
import java.io.*;
import java.math.BigInteger;
import java.util.Arrays;


public class Uber {
  
    public static void main(String[] args) throws NumberFormatException, Exception  {
    	
      BigInteger B1, B2, B3,B4, mult, mult2;		
	  int tamano, res;		
	  int[] list;	
	  String [] str;
	  String num="";
	  BufferedReader linea=new BufferedReader (new InputStreamReader (System.in));
	
	  //System.out.println("Ingrese la cantidad de numeros que va ingresar: ");
	  tamano= Integer.parseInt(linea.readLine());
	  list= new int[tamano];			
	
      if(tamano<=10000 && tamano>1){
    	//System.out.println("digite los "+ tamano + " numeros separados por espacio");
		num=linea.readLine();
		
		str=num.split("\\s+");
		  for (int i = 0; i < list.length; i++) {
		    list[i] = Integer.parseInt(str[i]);
		    if(list[i]>1000000000 || list[i]<(-1000000000)){
		    	System.err.println("ha ingresado un numero no permitido");	
		    	System.exit(0);
		    }
		  }
	  }
      Arrays.sort(list);
	  B1 = new BigInteger(Integer.toString(list[list.length-1]));
	  B2 = new BigInteger(Integer.toString(list[list.length-2]));		
	  B3 = new BigInteger(Integer.toString(list[0]));
	  B4 = new BigInteger(Integer.toString(list[1]));
	  //System.out.println(B1 + "  " + B2 + "  "+ B3 + "  "+ B4);	
	  mult= B1.multiply(B2);
	  mult2=B3.multiply(B4);		
	  res=mult.compareTo(mult2);
	  if(res==1)
	    System.out.println(mult);
      else if(res==-1)
	    System.out.println(mult2);
	  else if(res==0)
	    System.out.println(mult);
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Booom {

	public static void main(String[] args) throws NumberFormatException, IOException {
	  int numCase,count=0, list[];
	  	
	  String message2, message = "";	
	  BufferedReader line=new BufferedReader (new InputStreamReader (System.in));      
	  numCase= Integer.parseInt(line.readLine());
	  list=new int[numCase];
		
	  if(0<numCase&& numCase<11){		
		for (int i = 0; i <numCase; i++) {	     
		  message=line.readLine();
		  message2=mayus(message);
  	      //System.out.println("message analizada:" +message2);			 
		 		    
		  while(message2.contains("B")){
			
		      if(message2.contains("WWBWW")){
			    count+=4;
			    message2=message2.replaceFirst("WWBWW", "XXXXX");	
			    continue;
			  }
				
			  if(message2.contains("WBWW")){
		        count+=3;
			    message2=message2.replaceFirst("WBWW", "XXXX");	
			    continue;
			  }
				
			  if(message2.contains("WWBW")){
			    count+=3;
			    message2=message2.replaceFirst("WWBW", "XXX");	
			    continue;
			  }
				
			  if(message2.contains("BWW")){
			    count+=2;
			    message2=message2.replaceFirst("BWW", "XXX");
			    continue;
			  }
			  if(message2.contains("WWB")){
			    count+=2;
			    message2=message2.replaceFirst("WWB", "XXX");
			    continue;
			  }
			  if(message2.contains("WBW")){
				 count+=2;
				 message2=message2.replaceFirst("WBW", "XXX");
				 continue;
			  }
			  if(message2.contains("WB")){
		        count+=1;
		        message2=message2.replaceFirst("WB", "XX");	
		        continue;
			  }
			  if(message2.contains("BW")){
			    count+=1;
			    message2=message2.replaceFirst("BW", "XX");	
			    continue;
			  }	
			  else{
				count+=0;
				break;
			  }	
			}
		  
		  list[i]=count;
		  message2="";
		  message="";
		  count=0;
		  }
		
		for (int j = 0; j < list.length; j++) {
		  System.out.println(list[j]);
		}	
	    }
      }
	 
  private static String mayus (String s){
	  String str;
	  str=s.toUpperCase();
	  return str;	  
  }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class RoySub{    

  public static void main( String[] args ) throws NumberFormatException, IOException{
	BufferedReader line= new BufferedReader(new InputStreamReader(System.in) );
    int numCase,tamano,acum,answer,list[];
    String str;
    numCase=Integer.parseInt(line.readLine());
    list=new int[numCase];
    for (int j = 0; j < list.length; j++) {		
	
      tamano = Integer.parseInt(line.readLine());
      str =line.readLine();
      answer = tamano;
      acum = 0;
      for( int i = 0; i < tamano-1; i++ )
        if(str.charAt(i) <= str.charAt(i+1))
          acum++;
        else{
          answer+=sumatoria(acum);
          acum=0;
        }
        answer+= sumatoria(acum);
        list[j]=answer;
    }
    for (int i = 0; i < list.length; i++) {
	  System.out.println(list[i]);
    }
  }
  public static int sumatoria(int n){
    return (n*(n+1))/2;
  }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Choco {
  
  static BufferedReader line= new BufferedReader (new InputStreamReader (System.in));
  static int  count, sum,sum2;
  static  int [] list;

	public static void main(String[] args) throws NumberFormatException, IOException {
	  int tamano,numCase;
	  boolean flag, flag2=true;
      char [][] choco;
      String [] out;
      //System.out.println("ingrese el numero de casos");
	  numCase=Integer.parseInt(line.readLine());
	  out=new String[numCase];
	  
	  for (int i = 0; i < numCase; i++) {
		//System.out.println("tamano del chocolate ");
		tamano=Integer.parseInt(line.readLine());
        choco= new char [tamano][tamano];
		fill( choco,tamano);	
        flag=cutRow(choco,tamano);
        flag2=cutCol(choco,tamano);
        if(flag==true||flag2==true)
          out[i]="YES";
        else
        	out[i]="NO";
	   }
	   for (int i = 0; i < out.length; i++) 
		 System.out.println(out[i]);
	
	}
	
	public static char[][] fill(char a[][],int n) throws IOException{	 
	  for (int i = 0; i <n; i++) {
	    a[i]=line.readLine().toCharArray();		  
	  }
	  return  a;
	}
        
     public static boolean cutRow (char a[][], int n) throws IOException{    	 
       list=new int[n]; 
       boolean flag=true;
	   for (int i = 0; i <n; i++) {
	     count=0;  
	     for (int j = 0; j < n; j++) {
           if(a[i][j]=='#'){
             count++;
           }
         }
         list[i]=count;    
	   }
       for (int i = 0; i <list.length; i++) {
         sum+=list[i];
       }
       for (int i = 0; i < list.length; i++) {
         sum2+=list[i];
           if(sum2==sum-sum2){           
             flag=true;
             break;
           }              
        }
        if(sum2!=sum-sum2){         
          flag=false;
        }
        sum=0;
        sum2=0;
        return flag;
    }   
     
     public static boolean cutCol (char a[][], int n) throws IOException{    	 
       list=new int[n]; 
       boolean flag= true;
  	   for (int i = 0; i <n; i++) {
  	     count=0;  
  	     for (int j = 0; j < n; j++) {
             if(a[j][i]=='#'){
               count++;
             }
         }
         list[i]=count;    
  	   }
         for (int i = 0; i <list.length; i++) {
           sum+=list[i];
         }
         for (int i = 0; i < list.length; i++) {
           sum2+=list[i];
             if(sum2==sum-sum2){               
               flag = true;
               break;
             }              
          }
          if(sum2!=sum-sum2){            
            flag=false;
          }
          sum=0;
          sum2=0;
          return flag;
      } 
     
   
}      
	
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Booom {

	public static void main(String[] args) throws NumberFormatException, IOException {
	  int numCase,count=0, list[];
	  	
	  String message2, message = "";	
	  BufferedReader line=new BufferedReader (new InputStreamReader (System.in));      
	  numCase= Integer.parseInt(line.readLine());
	  list=new int[numCase];
		
	  	
		for (int i = 0; i <numCase; i++) {	     
		  message=line.readLine();
		  message2=mayus(message);
  	       
		 		    
		  while(message2.contains("B")){
			
		      if(message2.contains("WWBWW")){
			    count+=4;
			    message2=message2.replaceFirst("WWBWW", "XXXXX");	
			    continue;
			  }
				
			  if(message2.contains("WBWW")){
		        count+=3;
			    message2=message2.replaceFirst("WBWW", "XXXX");	
			    continue;
			  }
				
			  if(message2.contains("WWBW")){
			    count+=3;
			    message2=message2.replaceFirst("WWBW", "XXX");	
			    continue;
			  }
				
			  if(message2.contains("BWW")){
			    count+=2;
			    message2=message2.replaceFirst("BWW", "XXX");
			    continue;
			  }
			  if(message2.contains("WWB")){
			    count+=2;
			    message2=message2.replaceFirst("WWB", "XXX");
			    continue;
			  }
			  if(message2.contains("WBW")){
				 count+=2;
				 message2=message2.replaceFirst("WBW", "XXX");
				 continue;
			  }
			  if(message2.contains("WB")){
		        count+=1;
		        message2=message2.replaceFirst("WB", "XX");	
		        continue;
			  }
			  if(message2.contains("BW")){
			    count+=1;
			    message2=message2.replaceFirst("BW", "XX");	
			    continue;
			  }	
			  else{
				count+=0;
				break;
			  }	
			}
		  
		  list[i]=count;
		  message2="";
		  message="";
		  count=0;
		  }
		
		for (int j = 0; j < list.length; j++) {
		  System.out.println(list[j]);
		}	
	    
      }
	 
  private static String mayus (String s){
	  String str;
	  str=s.toUpperCase();
	  return str;	  
  }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Booom {

	public static void main(String[] args) throws NumberFormatException, IOException {
	  int numCase,count=0, list[];
	  	
	  String message;	
	  BufferedReader line=new BufferedReader (new InputStreamReader (System.in));      
	  numCase= Integer.parseInt(line.readLine());
	  list=new int[numCase];
		
	  	
		for (int i = 0; i <numCase; i++) {	     
		  message=line.readLine();
		  
  	       
		 		    
		  while(message.contains("B")){
			
		      if(message.contains("WWBWW")){
			    count+=4;
			    message=message.replaceFirst("WWBWW", "XXXXX");	
			    continue;
			  }
				
			  if(message.contains("WBWW")){
		        count+=3;
			    message=message.replaceFirst("WBWW", "XXXX");	
			    continue;
			  }
				
			  if(message.contains("WWBW")){
			    count+=3;
			    message=message.replaceFirst("WWBW", "XXX");	
			    continue;
			  }
				
			  if(message.contains("BWW")){
			    count+=2;
			    message=message.replaceFirst("BWW", "XXX");
			    continue;
			  }
			  if(message.contains("WWB")){
			    count+=2;
			    message=message.replaceFirst("WWB", "XXX");
			    continue;
			  }
			  if(message.contains("WBW")){
				 count+=2;
				 message=message.replaceFirst("WBW", "XXX");
				 continue;
			  }
			  if(message.contains("WB")){
		        count+=1;
		        message=message.replaceFirst("WB", "XX");	
		        continue;
			  }
			  if(message.contains("BW")){
			    count+=1;
			    message=message.replaceFirst("BW", "XX");	
			    continue;
			  }	
			  else{
				count+=0;
				break;
			  }	
			}
		  
		  list[i]=count;
		  message="";
		  
		  count=0;
		  }
		
		for (int j = 0; j < list.length; j++) {
		  System.out.println(list[j]);
		}	
	    
      }
	 
  
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Choco {
  
  static BufferedReader line= new BufferedReader (new InputStreamReader (System.in));
  static int  count, sum,sum2,C,D;
  static  int [] list;

	public static void main(String[] args) throws NumberFormatException, IOException {
	  int tamano,numCase, a ,b;
	  
      char [][] choco;
      int []out;
      int [] out2;
      
      //System.out.println("ingrese el numero de casos");
	  numCase=Integer.parseInt(line.readLine());
	  out=new int[numCase];
	  out2=new int[numCase];
	  for (int i = 0; i < numCase; i++) {
		//System.out.println("tamano del chocolate ");
		tamano=Integer.parseInt(line.readLine());
        choco= new char [tamano][tamano];
		fill( choco,tamano);	
        a=cutRow(choco,tamano);
        b=cutCol(choco,tamano);
        if(a>=0||b>=0){
          out[i]=a;
          out2[i]=b;
        }  
        
        if(a>1&&b>1){
        	out[i]=1;
        	out2[i]=1;
        }
     
        }
	   for (int i = 0; i < out.length; i++){
		 System.out.println(out[i]+" "+ out2[i]);
		}
	
	}
	
	public static char[][] fill(char a[][],int n) throws IOException{	 
	  for (int i = 0; i <n; i++) {
	    a[i]=line.readLine().toCharArray();		  
	  }
	  return  a;
	}
        
     public static int cutRow (char a[][], int n) throws IOException{    	 
       list=new int[n];     
	   for (int i = 0; i <n; i++) {
	     count=0;  
	     for (int j = 0; j < n; j++) {
           if(a[i][j]=='#'){
             count++;
           }
         }
         list[i]=count;    
	   }
       for (int i = 0; i <list.length; i++) {
         sum+=list[i];
       }
       for (int i = 0; i < list.length; i++) {
         sum2+=list[i];
           if(sum2==sum-sum2){           
             C=i+1;
             break;
           }              
        }
        if(sum2!=sum-sum2){
          C=0;
          
        }
        sum=0;
        sum2=0;
        return C;
    }   
     
     public static int  cutCol (char a[][], int n) throws IOException{    	 
       list=new int[n]; 
       for (int i = 0; i <n; i++) {
  	     count=0;  
  	     for (int j = 0; j < n; j++) {
             if(a[j][i]=='#'){
               count++;
             }
         }
         list[i]=count;    
  	   }
         for (int i = 0; i <list.length; i++) {
           sum+=list[i];
         }
         for (int i = 0; i < list.length; i++) {
           sum2+=list[i];
             if(sum2==sum-sum2){ 
               D=i+1;
               break;
             }              
          }
          if(sum2!=sum-sum2){  
        	D=0;
          }
          sum=0;
          sum2=0;
          return D;
      } 
     
   
}      
	
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Choco {
  
  static BufferedReader line= new BufferedReader (new InputStreamReader (System.in));
  static int  count, sum,sum2,C,D;
  static  int [] list;

	public static void main(String[] args) throws NumberFormatException, IOException {
	  int tamano,numCase, a ,b;
	  
      char [][] choco;
      int []out;
      int [] out2;
      
      //System.out.println("ingrese el numero de casos");
	  numCase=Integer.parseInt(line.readLine());
	  out=new int[numCase];
	  out2=new int[numCase];
	  for (int i = 0; i < numCase; i++) {
		//System.out.println("tamano del chocolate ");
		tamano=Integer.parseInt(line.readLine());
        choco= new char [tamano][tamano];
		fill( choco,tamano);	
        a=cutRow(choco,tamano);
        b=cutCol(choco,tamano);
        if(a>=0){
          out[i]=a;
          out2[i]=0;
          break;
        }  
        if(b>=0){
            out[i]=0;
            out2[i]=b;
            break;
         } 
        
        
        if(a>1&&b>1){
        	out[i]=1;
        	out2[i]=1;
        }
     
        }
	   for (int i = 0; i < out.length; i++){
		 System.out.println(out[i]+" "+ out2[i]);
		}
	
	}
	
	public static char[][] fill(char a[][],int n) throws IOException{	 
	  for (int i = 0; i <n; i++) {
	    a[i]=line.readLine().toCharArray();		  
	  }
	  return  a;
	}
        
     public static int cutRow (char a[][], int n) throws IOException{    	 
       list=new int[n];     
	   for (int i = 0; i <n; i++) {
	     count=0;  
	     for (int j = 0; j < n; j++) {
           if(a[i][j]=='#'){
             count++;
           }
         }
         list[i]=count;    
	   }
       for (int i = 0; i <list.length; i++) {
         sum+=list[i];
       }
       for (int i = 0; i < list.length; i++) {
         sum2+=list[i];
           if(sum2==sum-sum2){           
             C=i+1;
             break;
           }              
        }
        if(sum2!=sum-sum2){
          C=0;
          
        }
        sum=0;
        sum2=0;
        return C;
    }   
     
     public static int  cutCol (char a[][], int n) throws IOException{    	 
       list=new int[n]; 
       for (int i = 0; i <n; i++) {
  	     count=0;  
  	     for (int j = 0; j < n; j++) {
             if(a[j][i]=='#'){
               count++;
             }
         }
         list[i]=count;    
  	   }
         for (int i = 0; i <list.length; i++) {
           sum+=list[i];
         }
         for (int i = 0; i < list.length; i++) {
           sum2+=list[i];
             if(sum2==sum-sum2){ 
               D=i+1;
               break;
             }              
          }
          if(sum2!=sum-sum2){  
        	D=0;
          }
          sum=0;
          sum2=0;
          return D;
      } 
     
   
}      
	
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Choco {
  
  static BufferedReader line= new BufferedReader (new InputStreamReader (System.in));
  static int  count, sum,sum2,C,D;
  static  int [] list;

	public static void main(String[] args) throws NumberFormatException, IOException {
	  int tamano,numCase, a ,b;
	  
      char [][] choco;
      int []out;
      int [] out2;
      
      //System.out.println("ingrese el numero de casos");
	  numCase=Integer.parseInt(line.readLine());
	  out=new int[numCase];
	  out2=new int[numCase];
	  for (int i = 0; i < numCase; i++) {
		//System.out.println("tamano del chocolate ");
		tamano=Integer.parseInt(line.readLine());
        choco= new char [tamano][tamano];
		fill( choco,tamano);	
        a=cutRow(choco,tamano);
        b=cutCol(choco,tamano);
        if(a>=0){
          out[i]=a;
          out2[i]=0;
          continue;
        }  
        else if(b>=0){
            out[i]=0;
            out2[i]=b;
            continue;
         } 
        
        
        else if(a>1&&b>1){
        	out[i]=1;
        	out2[i]=1;
        }
     
        }
	   for (int i = 0; i < out.length; i++){
		 System.out.println(out[i]+" "+ out2[i]);
		}
	
	}
	
	public static char[][] fill(char a[][],int n) throws IOException{	 
	  for (int i = 0; i <n; i++) {
	    a[i]=line.readLine().toCharArray();		  
	  }
	  return  a;
	}
        
     public static int cutRow (char a[][], int n) throws IOException{    	 
       list=new int[n];     
	   for (int i = 0; i <n; i++) {
	     count=0;  
	     for (int j = 0; j < n; j++) {
           if(a[i][j]=='#'){
             count++;
           }
         }
         list[i]=count;    
	   }
       for (int i = 0; i <list.length; i++) {
         sum+=list[i];
       }
       for (int i = 0; i < list.length; i++) {
         sum2+=list[i];
           if(sum2==sum-sum2){           
             C=i+1;
             break;
           }              
        }
        if(sum2!=sum-sum2){
          C=0;
          
        }
        sum=0;
        sum2=0;
        return C;
    }   
     
     public static int  cutCol (char a[][], int n) throws IOException{    	 
       list=new int[n]; 
       for (int i = 0; i <n; i++) {
  	     count=0;  
  	     for (int j = 0; j < n; j++) {
             if(a[j][i]=='#'){
               count++;
             }
         }
         list[i]=count;    
  	   }
         for (int i = 0; i <list.length; i++) {
           sum+=list[i];
         }
         for (int i = 0; i < list.length; i++) {
           sum2+=list[i];
             if(sum2==sum-sum2){ 
               D=i+1;
               break;
             }              
          }
          if(sum2!=sum-sum2){  
        	D=0;
          }
          sum=0;
          sum2=0;
          return D;
      } 
     
   
}      
	
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class PA {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	HashMap<Integer, HashMap<Integer, String>> map;
	MyArrayList<HashMap> arr;
	
	
	
	HashMap<Integer,String > internalMap; 
	HashMap<Integer,String > aux; 
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	int numCase, teams, sends, competitor, time=0,  work, pena, count=0, time2;
	String str, spl[],split[], cadena,status;
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
	  
	  
	  str=br.readLine();
	  spl=str.split(" ");
	  
	  teams= Integer.parseInt(spl[0]);
	  sends=Integer.parseInt(spl[1]);
	  
	  System.out.println("Caso #"+(i+1)+":");
	  
	  arr=new MyArrayList<>();
	 
	  
	  for (int j = 0; j < teams; j++) {
		 internalMap= new HashMap<>();
		  arr.add(internalMap);
	  }
			
	  
	  
	  for (int j = 0; j < sends; j++) {
				 
		 str=br.readLine();
		 spl=str.split(" ");
		 competitor=Integer.parseInt(spl[0]);//numro competidor
		 work= Integer.parseInt(spl[1]);		 
		 status=spl[3]; // C I T R
			 
		 aux=arr.get(competitor-1);// traigame el map de tal competidor
		
		
		 //para los competidors que no han enviando ese trabajo al juez
		 
		 if(aux.get(work)== null){		  
		   
		   if(!status.equals("C")){
			 aux.put(work, 20 + " "+ spl[3] );
			// System.out.println("if  tiempo"+20+" estado "+spl[3]);
			// System.out.println("aqui");
		   }
		   else{
			 aux.put(work, spl[2]+ " "+ "C" );	
			// System.out.println("time "+spl[2]);
			 
			 if(!aux.containsKey(0)){			   
			   aux.put(0, competitor+" "+1+" "+ spl[2]);				  
			  // System.out.println("else if cuenta: "+1+" time "+spl[2]);
			 }
			 else{
			   cadena=aux.get(0);
			   split=cadena.split("\\s+");
			   time2=Integer.parseInt(split[2]);
			   time2+=Integer.parseInt(spl[2]);
			   count=Integer.parseInt(split[1]);
			   count++;
			   aux.put(0,competitor+" "+ count+" "+time2);
			   //System.out.println("else else cuenta: "+count+" time2 "+time2);
			   
			 }
			   
		   }
		   arr.set((competitor-1), aux);
		 }
		 
		 //para competidores que ya tengan ese trabajo en el juez		 
		 else{
		   //aux contiene el map del concursante actual
		   cadena=aux.get(work); // traiga el valor de la llave de tal trabajo
		   //System.out.println("cadeena "+ cadena);
		   split=cadena.split(" ");
		   
		   time= Integer.parseInt(split[0]);
		   
		   //la nueva solucion sigue siendo incorrecta
		   if(!split[1].equals("C") && !status.equals("C")){
			 time+=20;
			 aux.put(work, time+ " "+ status);
			 cadena=aux.get(work);
			 //System.out.println("cadeena69 "+ cadena);
			 
		   }
		   
		   // la nueva solucion es correcta
		   else if(!split[1].equals("C") && status.equals("C")){
			 time+= Integer.parseInt(spl[2]);
			 aux.put(work, time+ " "+ "C");
			 cadena=aux.get(work);
			 count++;
			 
			//  System.out.println("cadeena00 "+ cadena);
			  
			 if(!aux.containsKey(0)){			   
			   aux.put(0,competitor+" "+1+" "+ time);
			  
			 }
			 else{
			   cadena=aux.get(0);
			   spl=cadena.split("\\s+");
			   time2=Integer.parseInt(spl[2]);
			   time2+=time;
			   count=Integer.parseInt(spl[1]);
			   count++;
			   aux.put(0,competitor+" "+ count+" "+time2);
			  // System.out.println("cuenta "+ count+" time " + time2);
			   
			 }
		   }
		   
		 }
	  }
	  
	 
	  
	  String cad;
	  Set<Integer> Set;	  
	  Iterator<HashMap> it = arr.iterator();
	  ArrayList<person> list= new ArrayList<>();
	  int c=0;
	  
	  while (it.hasNext()) {
		int t, cuenta, comp;
		String sp[];
		HashMap<Integer,String> se =  it.next();		
		if(se.containsKey(0)){
		  String x= se.get(0);
		  sp=x.split("\\s+");
		  //System.out.println("sp "+ x);
		  t=Integer.parseInt(sp[2]);
		  comp=Integer.parseInt(sp[0]);
		  cuenta=Integer.parseInt(sp[1]);
		  list.add(new person(comp,cuenta,t));
		 }
		else{
		  
		  if(arr.get(c).size()!=0){
			//System.out.println("el c "+ c+ " "+arr.get(c));
			list.add(new person((c+1),0,0));
		  }
		}
		c++;		
	  }  Collections.sort(list);	  
	
	  
	  Iterator<person> m = list.iterator();
	  
	  while (m.hasNext()) {
		person na = (person) m.next();
		System.out.println(na.equipo+ " " + na.solutions+ " " +na.time);
		
	  }

	  list.clear();

	  
	}
	
  }
  
  
  public static class person implements Comparable<person> {
	int  equipo;
	int solutions;
	int time;
	
	public person(int equipo, int solutions, int time) {
		this.equipo = equipo;
		this.solutions = solutions;
		this.time = time;
	}
	
	@Override
	public int compareTo(person o) {
		if (this.solutions > o.solutions)
			return -1;
		else if (solutions < o.solutions)
			return 1;
		else {
			if (time < o.time)
				return -1;
			else if (time > o.time)
				return 1;
			else{
			  if(equipo<o.equipo)
				return -1;
			  else if(equipo> o.time)
				return 1;
			}
		}
		return 0;
	}

	

	
  }
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;



public class pB {
  
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	

	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));	
	
	
	HashMap<Integer,Integer > map=new HashMap<>(); 
	MyArrayList<Integer> arr = new MyArrayList<>();
	
	int [] b;	
	int numCase, tamano, idx, value;
	String str,spl[];
	
	numCase=Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
	  
	  tamano=Integer.parseInt(br.readLine());
	  str=br.readLine();
	  spl=str.split("\\s+");
	  System.out.println("Caso #"+(i+1)+":");
	  		  
	  
	  for (int j = 0; j < spl.length; j++){ 
		
		int num=Integer.parseInt(spl[j]);
		if(map.containsKey(num)){		  
		  value=map.get(num);
		  map.put(num, ++value);		 
		}
		else{
		  map.put(num, 1);
		  arr.add(num);
		}		
	  }
	  
	  
	
	  
	  Iterator<Integer> it = arr.iterator();
	  while (it.hasNext()) {
		Integer e = it.next();
		System.out.println(e + " " + map.get(e));
	  }
	  
	  
	  map.clear();
	  arr.clear();
	  
	}	
	
	
  }
  



public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class PC {
  
  
  
  public static void main(String[] args) throws NumberFormatException, IOException {
		
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));	
	
	HashMap<String,HashSet<String> > map=new HashMap<>(); 
	HashSet<String> se;
	HashSet<String> s;
	
	
	int numCase, amistades, idx, value, value2;
	String friend1, friend2, str,spl[];
	
	numCase=Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
	  
	  amistades=Integer.parseInt(br.readLine());
	  
	  System.out.println("Caso #"+(i+1)+":");
	  
	 
	  
	  for (int j = 0; j < amistades; j++) {
		str=br.readLine();
		spl=str.split("\\s+");
		friend1=spl[0];
		friend2=spl[1];
		
		if(map.containsKey(friend1) && map.containsKey(friend2)){
		  s=map.get(friend1);		  
		  se=map.get(friend2);
		  
		  if(s.size()<se.size()){			
			se.addAll(s);
			
			 Iterator<String> iter = se.iterator();
			  while (iter.hasNext()) {
			     String st=iter.next();
			     if(map.containsKey(st)){
			       map.put(st, se);
			     }
			  }
			  
			  System.out.println(se.size());
			  
		  }
		  else{
			s.addAll(se);
			Iterator<String> iter = s.iterator();
			  while (iter.hasNext()) {
			     String st=iter.next();
			     if(map.containsKey(st)){
			       map.put(st, s);
			     }
			  }
			System.out.println(s.size());
		  }
		  
		  
		  
		}
		
		else if(map.containsKey(friend1)){		  
		  s=map.get(friend1);
		  s.add(friend2);
		  
		  Iterator<String> iter = s.iterator();
		  while (iter.hasNext()) {
		     String st=iter.next();
		     if(map.containsKey(st)){
		       map.put(st, s);
		     }
		  }
		  
		  map.put(friend1, s);
		  map.put(friend2, s);
		  System.out.println(s.size());
		  
		  
		}
		
		else if(map.containsKey(friend2)){		  
		  s=map.get(friend2);
		  s.add(friend1);
		  Iterator<String> iter = s.iterator();
		  while (iter.hasNext()) {
		     String st=iter.next();
		     if(map.containsKey(st)){
		       map.put(st, s);
		     }
		  }
		  
		  map.put(friend1, s);
		  map.put(friend2, s);
		  System.out.println(s.size());
		}		  
		
		else{
		  se=new HashSet<>();
		  se.add(friend1);
		  se.add(friend2);
		  map.put(friend1, se);		
		  map.put(friend2, se );
		  System.out.println(se.size());
		  
		}
		
	  }
	  
	  map.clear();	
	  
	  
	 
	  
	  
	}
	
	
	
	
	
	
	
  }
  
  


  
  
	public static class UnionFind {
		private int id[];
		private int rank[];
		private int cont;

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			rank = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				rank[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if (rank[a] < rank[b]) {
				id[a] = b;
			} else {
				id[b] = a;
				if (rank[a] == rank[b])
					rank[b]++;
			}
			cont--;
		}
	}


  
  

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class p7E {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	HashMap<Integer, HashMap<Integer, String>> map;
	MyArrayList<HashMap> arr;

	HashMap<String,Integer> results;
	
	
	HashMap<Integer,String > internalMap; 
	HashMap<Integer,String > aux; 
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	int numCase, teams, sends, competitor, time=0,  work, pena, count=0, time2;
	String str, spl[],split[], cadena,status;
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
	  
	  
	  str=br.readLine();
	  spl=str.split(" ");
	  
	  teams= Integer.parseInt(spl[0]);
	  sends=Integer.parseInt(spl[1]);
	  
	  System.out.println("Caso #"+(i+1)+":");
	  
	  arr=new MyArrayList<>();
	  results=new HashMap<>();
	 
	  
	  for (int j = 0; j < teams; j++) {
		 internalMap= new HashMap<>();
		  arr.add(internalMap);
	  }
			
	  
	  
	  for (int j = 0; j < sends; j++) {
				 
		 str=br.readLine();
		 spl=str.split(" ");
		 competitor=Integer.parseInt(spl[0]);//numro competidor
		 work= Integer.parseInt(spl[1]);		 
		 status=spl[3]; // C I T R
		 
		 if(!results.containsKey(status)){
			results.put(status, 1); 
		 }
		 else{
			 int value=results.get(status);
			 value++;
			 results.put(status, value);
		 }
		 	
		 aux=arr.get(competitor-1);// traigame el map de tal competidor
		
		
		 //para los competidors que no han enviando ese trabajo al juez
		 
		 if(aux.get(work)== null){		  
		   
		   if(!status.equals("C")){
			 aux.put(work, 20 + " "+ spl[3] );
			 
			// System.out.println("if  tiempo"+20+" estado "+spl[3]);
			// System.out.println("aqui");
		   }
		   else{
			 aux.put(work, spl[2]+ " "+ "C" );	
			 
			// System.out.println("time "+spl[2]);
			 
			 if(!aux.containsKey(0)){			   
			   aux.put(0, competitor+" "+1+" "+ spl[2]);				  
			  // System.out.println("else if cuenta: "+1+" time "+spl[2]);
			 }
			 else{
			   cadena=aux.get(0);
			   split=cadena.split("\\s+");
			   time2=Integer.parseInt(split[2]);
			   time2+=Integer.parseInt(spl[2]);
			   count=Integer.parseInt(split[1]);
			   count++;
			   aux.put(0,competitor+" "+ count+" "+time2);
			   //System.out.println("else else cuenta: "+count+" time2 "+time2);
			   
			 }
			   
		   }
		   arr.set((competitor-1), aux);
		 }
		 
		 //para competidores que ya tengan ese trabajo en el juez		 
		 else{
		   //aux contiene el map del concursante actual
		   cadena=aux.get(work); // traiga el valor de la llave de tal trabajo
		   //System.out.println("cadeena "+ cadena);
		   split=cadena.split(" ");
		   
		   time= Integer.parseInt(split[0]);
		   
		   //la nueva solucion sigue siendo incorrecta
		   if(!split[1].equals("C") && !status.equals("C")){
			 time+=20;
			 aux.put(work, time+ " "+ status);
			 cadena=aux.get(work);
			 //System.out.println("cadeena69 "+ cadena);
			 
		   }
		   
		   // la nueva solucion es correcta
		   else if(!split[1].equals("C") && status.equals("C")){
			 time+= Integer.parseInt(spl[2]);
			 aux.put(work, time+ " "+ "C");
			 cadena=aux.get(work);
			 count++;
			 
			//  System.out.println("cadeena00 "+ cadena);
			  
			 if(!aux.containsKey(0)){			   
			   aux.put(0,competitor+" "+1+" "+ time);
			  
			 }
			 else{
			   cadena=aux.get(0);
			   spl=cadena.split("\\s+");
			   time2=Integer.parseInt(spl[2]);
			   time2+=time;
			   count=Integer.parseInt(spl[1]);
			   count++;
			   aux.put(0,competitor+" "+ count+" "+time2);
			  // System.out.println("cuenta "+ count+" time " + time2);
			   
			 }
		   }
		   
		 }
	  }
	  
	 
	  
	  String cad;
	  Set<Integer> Set;	  
	  Iterator<HashMap> it = arr.iterator();
	  ArrayList<person> list= new ArrayList<>();
	  int c=0;
	  
	  while (it.hasNext()) {
		int t, cuenta, comp;
		String sp[];
		HashMap<Integer,String> se =  it.next();		
		if(se.containsKey(0)){
		  String x= se.get(0);
		  sp=x.split("\\s+");
		  //System.out.println("sp "+ x);
		  t=Integer.parseInt(sp[2]);
		  comp=Integer.parseInt(sp[0]);
		  cuenta=Integer.parseInt(sp[1]);
		  list.add(new person(comp,cuenta,t));
		 }
		else{
		  
		  if(arr.get(c).size()!=0){
			//System.out.println("el c "+ c+ " "+arr.get(c));
			list.add(new person((c+1),0,0));
		  }
		}
		c++;		
	  }  Collections.sort(list);	  
	
	  
	  Iterator<person> m = list.iterator();
	  
	  while (m.hasNext()) {
		person na = (person) m.next();
		System.out.println(na.equipo+ " " + na.solutions+ " " +na.time);
		
	  }
	  
	  //System.out.println(results);
	 System.out.println(results.get("C")+ " "+results.get("I")+ " "+ results.get("T")+ " "+results.get("R"));
	 results.clear();
	  list.clear();

	  
	}
	
  }
  
  
  public static class person implements Comparable<person> {
	int  equipo;
	int solutions;
	int time;
	
	public person(int equipo, int solutions, int time) {
		this.equipo = equipo;
		this.solutions = solutions;
		this.time = time;
	}
	
	@Override
	public int compareTo(person o) {
		if (this.solutions > o.solutions)
			return -1;
		else if (solutions < o.solutions)
			return 1;
		else {
			if (time < o.time)
				return -1;
			else if (time > o.time)
				return 1;
			else{
			  if(equipo<o.equipo)
				return -1;
			  else if(equipo> o.time)
				return 1;
			}
		}
		return 0;
	}

	

	
  }
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class p7E {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	HashMap<Integer, HashMap<Integer, String>> map;
	MyArrayList<HashMap> arr;

	HashMap<String,Integer> results;
	
	
	HashMap<Integer,String > internalMap; 
	HashMap<Integer,String > aux; 
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	int numCase, teams, sends, competitor, time=0,  work, pena, count=0, time2;
	String str, spl[],split[], cadena,status;
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
	  
	  
	  str=br.readLine();
	  spl=str.split(" ");
	  
	  teams= Integer.parseInt(spl[0]);
	  sends=Integer.parseInt(spl[1]);
	  
	  System.out.println("Caso #"+(i+1)+":");
	  
	  arr=new MyArrayList<>();
	  results=new HashMap<>();
	 
	  
	  for (int j = 0; j < teams; j++) {
		 internalMap= new HashMap<>();
		  arr.add(internalMap);
	  }
			
	  
	  
	  for (int j = 0; j < sends; j++) {
				 
		 str=br.readLine();
		 spl=str.split(" ");
		 competitor=Integer.parseInt(spl[0]);//numro competidor
		 work= Integer.parseInt(spl[1]);		 
		 status=spl[3]; // C I T R
		 
		 if(!results.containsKey(status)){
			results.put(status, 1); 
		 }
		 else{
			 int value=results.get(status);
			 
			 value++;
			 results.put(status, value);
		 }
		 	
		 aux=arr.get(competitor-1);// traigame el map de tal competidor
		
		
		 //para los competidors que no han enviando ese trabajo al juez
		 
		 if(aux.get(work)== null){		  
		   
		   if(!status.equals("C")){
			 aux.put(work, 20 + " "+ spl[3] );
			 
			// System.out.println("if  tiempo"+20+" estado "+spl[3]);
			// System.out.println("aqui");
		   }
		   else{
			 aux.put(work, spl[2]+ " "+ "C" );	
			 
			// System.out.println("time "+spl[2]);
			 
			 if(!aux.containsKey(0)){			   
			   aux.put(0, competitor+" "+1+" "+ spl[2]);				  
			  // System.out.println("else if cuenta: "+1+" time "+spl[2]);
			 }
			 else{
			   cadena=aux.get(0);
			   split=cadena.split("\\s+");
			   time2=Integer.parseInt(split[2]);
			   time2+=Integer.parseInt(spl[2]);
			   count=Integer.parseInt(split[1]);
			   count++;
			   aux.put(0,competitor+" "+ count+" "+time2);
			   //System.out.println("else else cuenta: "+count+" time2 "+time2);
			   
			 }
			   
		   }
		   arr.set((competitor-1), aux);
		 }
		 
		 //para competidores que ya tengan ese trabajo en el juez		 
		 else{
		   //aux contiene el map del concursante actual
		   cadena=aux.get(work); // traiga el valor de la llave de tal trabajo
		   //System.out.println("cadeena "+ cadena);
		   split=cadena.split(" ");
		   
		   time= Integer.parseInt(split[0]);
		   
		   //la nueva solucion sigue siendo incorrecta
		   if(!split[1].equals("C") && !status.equals("C")){
			 time+=20;
			 aux.put(work, time+ " "+ status);
			 cadena=aux.get(work);
			 //System.out.println("cadeena69 "+ cadena);
			 
		   }
		   
		   // la nueva solucion es correcta
		   else if(!split[1].equals("C") && status.equals("C")){
			 time+= Integer.parseInt(spl[2]);
			 aux.put(work, time+ " "+ "C");
			 cadena=aux.get(work);
			 count++;
			 
			//  System.out.println("cadeena00 "+ cadena);
			  
			 if(!aux.containsKey(0)){			   
			   aux.put(0,competitor+" "+1+" "+ time);
			  
			 }
			 else{
			   cadena=aux.get(0);
			   spl=cadena.split("\\s+");
			   time2=Integer.parseInt(spl[2]);
			   time2+=time;
			   count=Integer.parseInt(spl[1]);
			   count++;
			   aux.put(0,competitor+" "+ count+" "+time2);
			  // System.out.println("cuenta "+ count+" time " + time2);
			   
			 }
		   }
		   
		 }
	  }
	  
	 
	  
	  String cad;
	  Set<Integer> Set;	  
	  Iterator<HashMap> it = arr.iterator();
	  ArrayList<person> list= new ArrayList<>();
	  int c=0;
	  
	  while (it.hasNext()) {
		int t, cuenta, comp;
		String sp[];
		HashMap<Integer,String> se =  it.next();		
		if(se.containsKey(0)){
		  String x= se.get(0);
		  sp=x.split("\\s+");
		  //System.out.println("sp "+ x);
		  t=Integer.parseInt(sp[2]);
		  comp=Integer.parseInt(sp[0]);
		  cuenta=Integer.parseInt(sp[1]);
		  list.add(new person(comp,cuenta,t));
		 }
		else{
		  
		  if(arr.get(c).size()!=0){
			//System.out.println("el c "+ c+ " "+arr.get(c));
			list.add(new person((c+1),0,0));
		  }
		}
		c++;		
	  }  Collections.sort(list);	  
	
	  
	  Iterator<person> m = list.iterator();
	  
	  while (m.hasNext()) {
		person na = (person) m.next();
		System.out.println(na.equipo+ " " + na.solutions+ " " +na.time);
		
	  }
	  
	  //System.out.println(results);
	  
	  if(results.get("C")==null){
		  results.put("C", 0);
	  }
	  if(results.get("I")==null){
		  results.put("I", 0);
	  }
	  if(results.get("R")==null){
		  results.put("R", 0);
	  }
	  if(results.get("T")==null){
		  results.put("T", 0);
	  }
	 System.out.println(results.get("C")+ " "+results.get("I")+ " "+ results.get("T")+ " "+results.get("R"));
	 results.clear();
	  list.clear();

	  
	}
	
  }
  
  
  public static class person implements Comparable<person> {
	int  equipo;
	int solutions;
	int time;
	
	public person(int equipo, int solutions, int time) {
		this.equipo = equipo;
		this.solutions = solutions;
		this.time = time;
	}
	
	@Override
	public int compareTo(person o) {
		if (this.solutions > o.solutions)
			return -1;
		else if (solutions < o.solutions)
			return 1;
		else {
			if (time < o.time)
				return -1;
			else if (time > o.time)
				return 1;
			else{
			  if(equipo<o.equipo)
				return -1;
			  else if(equipo> o.time)
				return 1;
			}
		}
		return 0;
	}

	

	
  }
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;





public class PD7 {
  
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	BufferedReader br= new BufferedReader (new InputStreamReader(System.in));
	
	UnionFind friends;
	UnionFind enemies;
	UnionFind aux, aux2, aux3, aux4;
	
	HashMap<Integer, UnionFind> list;
	
	int numCase, numPerson, numOp, op, person1, person2,num, num2;
	String str, spl[];
	
	numCase = Integer.parseInt(br.readLine());
	
	
	for (int i = 0; i < numCase; i++) {	
	  str=br.readLine();
	  spl=str.split("\\s+");
	  numPerson= Integer.parseInt(spl[0]);
	  numOp=Integer.parseInt(spl[1]);	  
	  
	  System.out.println("Caso #"+ (i+1)+":");
	  
	  friends = new UnionFind(numPerson);
	  list= new HashMap<Integer, UnionFind>();
	  
	  for (int j = 0; j < numOp; j++) {
		str=br.readLine();
		spl=str.split("\\s+");
		op=Integer.parseInt(spl[0]);
		
//		if(list.containsKey(0)){
//		  aux=list.get(0);
//		  num=aux.find(0);
//		  
//		  ArrayList<Integer> ar=new ArrayList<>();
//		 for (int k = 0; k <numPerson; k++) {
//		   if(num==aux.find(k)){
//			 ar.add(k);
//		   }
//		  }
//		 	System.out.println(ar);
//		 	System.out.println("a " +j);
//		}
//		else
//     	  System.out.println("el j "+j);
		
	
		
		
		switch (op){
		
		  case (1):
			person1=Integer.parseInt(spl[1]);
		  	person2=Integer.parseInt(spl[2]);
		  	
		  	if(person1==person2){
		  	  break;
		  	}
		  	//no se tiene en cuenta todos los casos
		  	if(list.containsKey(person1)&&list.containsKey(person2)){		  	  
		  	  aux=list.get(person1);
		  	  aux2=list.get(person2);
		  	  if((aux.find(person1)==aux.find(person2))||(aux2.find(person1)==aux2.find(person2))){
		  		System.out.println(-1);
		  		break;
		  	  }	
		  	  else{		
		  		//System.out.println("B A");
		  		friends.union(person1, person2);
		  		aux=list.get(person1);
			  	aux2=list.get(person2);
			  	
			  	num=aux.find(person1);
			  	num2=aux2.find(person2);
			  	
			  	for (int j2 = 0; j2 < numPerson; j2++) {
			  	  if(num==aux.find(j2)){
			  		  
			  		  if(j2!=person1){
			  	
			  			  aux2.union(person2, j2); 
			  		  	list.put(person2, aux2);
			  		  }
			  		
			  		
			  		if(list.containsKey(j2)){
			  			aux3=list.get(j2);
			  			aux3.union(j2, person2);
			  			list.put(j2, aux3);
			  			}
			  		else{
			  			enemies=new UnionFind(numPerson);
			  			enemies.union(j2, person2);
			  			list.put(j2, enemies);			  		  
			  		}
			  	  }
				}
			  	
			  	for (int j2 = 0; j2 < numPerson; j2++) {
			  	  if(num2==aux2.find(j2)){
			  		  if(j2!=person2){
			  		
			  			aux.union(person1, j2); 
			  		  	list.put(person1, aux);
			  		  }
			  		
			  	  
			  		if(list.containsKey(j2)){
			  		  aux4=list.get(j2);
			  		  aux4.union(j2, person1);
			  		  list.put(j2, aux4);
			  		 // System.out.println("cual es j2 "+j2);
			  		}			  	

			  		else{
			  		  enemies=new UnionFind(numPerson);
			  		  enemies.union(j2, person1);
			  		  list.put(j2, enemies);			  		  
			  		}
			  	  }
				}
			  	break;
		  	  }
		  	  
		  	  
		  	}
		  	
		  	else if(list.containsKey(person1)){
		  	  
		  	  friends.union(person1, person2);
		  	
		  	  aux=list.get(person1);
		  	  enemies=new UnionFind(numPerson);
		  	
		  	
		  	  num=aux.find(person1);
		  	
		  	  for (int j2 = 0; j2 < numPerson; j2++) {
		  		if(num==aux.find(j2)){
		  			if(j2!=person1){
		  		 		  		  
		  			enemies.union(person2, j2);
  		  		  	list.put(person2, enemies);
		  			}

		  			if(list.containsKey(j2)){
		  			  aux3=list.get(j2);
		  			  aux3.union(j2, person2);
		  			  list.put(j2, aux3);
		  			}
		  			else{
		  			  enemies=new UnionFind(numPerson);
		  			  enemies.union(j2, person2);
		  			  list.put(j2, enemies);			  		  
		  			}
		  		}
			  
		  	  }
		  	  break;
		  	  
		  	}
		  	
		  	else if(list.containsKey(person2)){
		  	  
		  	  friends.union(person1, person2);
		  	
		  	  aux2=list.get(person2);
		  	  enemies=new UnionFind(numPerson);
		  	
		  	
		  	  num2=aux2.find(person2);
		  	
		  	  for (int j2 = 0; j2 < numPerson; j2++) {
		  		if(num2==aux2.find(j2)){
		  			if((j2!=person1)){
		  		 	enemies.union(person1, j2);
  		  		  	list.put(person1, enemies);
		  			}
		  			if(list.containsKey(j2)){
		  			  aux3=list.get(j2);
		  			  aux3.union(j2, person1);
		  			  list.put(j2, aux3);
		  			}
		  			else{
		  			  enemies=new UnionFind(numPerson);
		  			  enemies.union(j2, person1);
		  			  list.put(j2, enemies);			  		  
		  			}
		  		}
			  
		  	  }
		  	  break;
		  	  
		  	}
		  	else{
		  	  friends.union(person1, person2);
		  	  
		  	}
		  	break;
		  	
		  	
		  	
		  case (2):			
			person1=Integer.parseInt(spl[1]);
		  	person2=Integer.parseInt(spl[2]);
		  	
		  	if(person1==person2){
		  	  System.out.println(-1);
		  	  break;
		  	}
		  	
			if(friends.find(person1)==friends.find(person2)){
		  	  System.out.println(-1);
		  	  break;
		  	}
			
			else{
			  
			  if(list.containsKey(person1)&&list.containsKey(person2)){
				//System.out.println("bloque A");
				aux=list.get(person1);
				aux2=list.get(person2);
				
				
				int ax=aux.find(person2);
				num=aux.find(person1);
				
				
				if(ax==num){
				  break;
				}
				
				
				
				aux.union(person1, person2);
				aux2.union(person2, person1);
				
				num=friends.find(person1);
				num2=friends.find(person2);
				
				for (int j2 = 0; j2 < numPerson; j2++) {
				  if(num==friends.find(j2)){
					aux2.union(person2, j2);
					list.put(person2, aux2);
					
					if(list.containsKey(j2)){
					  aux3=list.get(j2);
					  aux3.union(j2, person2);
					  list.put(j2, aux3);
					  
					}
					else{
					  enemies=new UnionFind(numPerson);
					  enemies.union(j2, person2);
					  list.put(j2, enemies);
					}
				  }
				  
				  if(num2==friends.find(j2)){
					aux.union(person1, j2);
					list.put(person1, aux);
					
					if(list.containsKey(j2)){
					  aux3=list.get(j2);
					  aux3.union(j2, person1);		
					  list.put(j2, aux3);
					}
					else{
					  enemies=new UnionFind(numPerson);
					  enemies.union(j2, person1);
					  list.put(j2, enemies);
					}
				  }
				}
				break;
					
			  }
			  else if(list.containsKey(person1)){
				
				//System.out.println("bloque B");
				aux=list.get(person1);
				num=friends.find(person1);
				num2=friends.find(person2);
				
				enemies=new UnionFind(numPerson);
				enemies.union(person2, person1);
				list.put(person2, enemies);
				
				aux.union(person1, person2);
				list.put(person1, aux);
				
				
				for (int j2 = 0; j2 < numPerson; j2++) {
				  
				  aux=list.get(person1);
				  aux2=list.get(person2);
					
				  
				  if(num==friends.find(j2)){
					aux2.union(person2, j2);
					list.put(person2, aux2);
					
					if(list.containsKey(j2)){
					  aux3=list.get(j2);
					  aux3.union(j2, person2);	
					  list.put(j2, aux3);
					}
					else{
					  enemies=new UnionFind(numPerson);
					  enemies.union(j2, person2);
					  list.put(j2, enemies);
					}
				  }
				  
				  if(num2==friends.find(j2)){
					  aux.union(person1, j2);
					  list.put(person1, aux);
					  
					if(list.containsKey(j2)){
					 aux3=list.get(j2);
					 aux3.union(j2, person1);	
					 list.put(j2, aux3);
					}
					else{
					 enemies=new UnionFind(numPerson);
					 enemies.union(j2, person1);
					 list.put(j2, enemies);
					}
				  }
				  
				  
				}	
				break;
			  }
			  
			  
			  else if(list.containsKey(person2)){
				//System.out.println("bloque C");
				aux2=list.get(person2);
				aux2.union(person2, person1);
				list.put(person2, aux2);
				
				num=friends.find(person1);
				num2=friends.find(person2);
				
				enemies=new UnionFind(numPerson);
				enemies.union(person1, person2);
				list.put(person1, enemies);
				
				
				for (int j2 = 0; j2 < numPerson; j2++) {
				
				  aux=list.get(person1);
				  aux2=list.get(person2);
				
				  
				  if(num2==friends.find(j2)){
					//System.out.println(num2+" "+j2+" "+friends.find(j2));
					aux.union(person1, j2);
					list.put(person1, aux);
					
					if(list.containsKey(j2)){
					  //System.out.println("j2 "+j2);
					  aux3=list.get(j2);
					  aux3.union(j2, person1);	
					  list.put(j2, aux3);
					}
					else{
					  //System.out.println("entro  ");
					  enemies=new UnionFind(numPerson);
					  enemies.union(j2, person1);
					  list.put(j2, enemies);
					}
									
					
				  }
				  
				  if(num==friends.find(j2)){
					
					  aux2.union(person2, j2);
					  list.put(person2, aux2);
					  
					if(list.containsKey(j2)){
					//  System.out.println("2 if "+num+" "+j2+" "+friends.find(j2)+" " + person2);
					 aux3=list.get(j2);
					 aux3.union(j2, person2);	
					 list.put(j2, aux3);
					}
					else{
					  //System.out.println("NUNCAAAAA");
					 enemies=new UnionFind(numPerson);
					 enemies.union(j2, person2);
					 list.put(j2, enemies);
					}
				  }
				  
				}
			
				
				break;
			  }
			  
			  else{
			
				//System.out.println("bloque D");
				
				enemies=new UnionFind(numPerson);
				enemies.union(person1, person2);
				list.put(person1, enemies);
				
				UnionFind uf =new UnionFind(numPerson);
				uf.union(person2, person1);
				list.put(person2, uf);	

				num=friends.find(person1);
				num2=friends.find(person2);
				
				//System.out.println(num+" "+num2);
				
				for (int j2 = 0; j2 < numPerson; j2++) {				 			  
				 
				  aux2=list.get(person2);
				  

				  if(num==friends.find(j2)){
					aux2.union(person2, j2);
					list.put(person2, aux2);
					
					
					if(list.containsKey(j2)){
					  aux3=list.get(j2);
					  aux3.union(j2, person2);
					  list.put(j2, aux3);
					//  System.out.println("j20 "+j2+" "+person2);
					 
					  
					}
					else{
					  enemies=new UnionFind(numPerson);
					  enemies.union(j2, person2);
					  list.put(j2, enemies);
					//  System.out.println("j20 "+j2+" "+person2);
					 
					}
				  }	
				  else{
					list.put(person2, aux2);
				  }
				}
				
				for (int j2 = 0; j2 < numPerson; j2++) {
				  aux=list.get(person1);
				  
				//  System.out.println(num2+" "+j2+" "+friends.find(j2));
				  
				  if(num2==friends.find(j2)){
					aux.union(person1, j2);
					list.put(person1, aux);
					//System.out.println(j2);
					
					
					if(list.containsKey(j2)){
					  aux4=list.get(j2);
					  aux4.union(j2, person1);		
					  list.put(j2, aux4);
					 
					}
					else{
					  enemies=new UnionFind(numPerson);
					  enemies.union(j2, person1);
					  list.put(j2, enemies);
					  
					}
					
				  }
				  else{
					list.put(person1, aux);
				  }
				}
				
				break;
				
			  }
			  
			  
			  
			}
			
		  case(3): 
			
			person1=Integer.parseInt(spl[1]);
		  	person2=Integer.parseInt(spl[2]);
		  	
		  	if(friends.find(person1)==friends.find(person2)){
		  	  System.out.println(1);		  	
		  	  break;		  	  
		  	}
		  	
		  	else{
		  	  System.out.println(0);
		  	  break;
		  	}
		  	
		  case (4):
			person1=Integer.parseInt(spl[1]);
		  	person2=Integer.parseInt(spl[2]);
		  	
		  	if(person1==person2){
		  	  System.out.println(0);
		  	  break;
		  	}
		  	
		  	//System.out.println(list.keySet());
		  	if(!list.containsKey(person1)||!list.containsKey(person2)){
		  	  System.out.println(0);
		  	  break;		  	  
		  	}
		  	else{
		  	  aux=list.get(person1);
		  	  aux2=list.get(person2);
		  	  
		  	  num=aux.find(person1);
		  	  int numAux=aux.find(person2);
		  	  
		  	  if(num==numAux){
		  		System.out.println(1);
		  		break;
		  	  }
		  	  else{
		  		System.out.println(0);
		  		break;
		  	  }
		  	}
			
		}
		
	  }
	  
	  list.clear();
	}
	
	
	
  }
  
  
  

  
	public static class UnionFind {
		private int id[];
		private int rank[];
		private int cont;

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			rank = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				rank[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if (rank[a] < rank[b]) {
				id[a] = b;
			} else {
				id[b] = a;
				if (rank[a] == rank[b])
					rank[b]++;
			}
			cont--;
		}
	}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


public class p7E {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	
	MyQueue<Integer> fila =new MyQueue<>();
	HashSet<Integer> par;
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	
	
	int numCase, numComand;
	String op, spl[], operation;
	
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
			
		numComand=Integer.parseInt(br.readLine());
		par=new HashSet<>();
		System.out.println("Caso #"+(i+1)+":");
		for (int j = 0; j < numComand; j++) {
			op=br.readLine();
			spl=op.split("\\s+");
			operation=spl[0];
			
		
			//System.out.println(par);
			switch (operation){
		
				case("agregar"):
					int id=Integer.parseInt(spl[1]);
					fila.offer(id);	
					//System.out.println(id);
					break;
				
				
				case ("atender"):
					if(!fila.isEmpty()){
						int cliente=fila.poll();
						//System.out.println(cliente);
						par.add(cliente);					
					}
				break;
			
				case("existe"):
					int ident=Integer.parseInt(spl[1]);
					boolean a;
					a=par.contains(ident);
					if(a==false){
						System.out.println("NO");
					}
					else
						System.out.println("SI");
					break;
				
			}
		}
	  
	  
	  
	}
  }
  
  
  


public static class MyQueue<AnyType> 
{
  public static <E> void enderezar (MyQueue<E> s)
	{	 
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.poll ();	
		MyQueue.<E>enderezar (s);
		s.offer (elem);	
		
	  }
	}
	
	
	public static <E> void print (MyQueue<E> s)
	{
	  E elem;
	 
	  
	  if (!s.isEmpty ()) {
		elem = s.poll ();		
		System.out.println (elem);			
		MyQueue.<E>print (s);
		s.offer (elem);		
	  }
	}
  
  
   public MyQueue( )
   {
       doClear( );
   }
   
   public void doClear( )
   {
       beginMarker = new Node<>( null,null );         
       theSize = 0;
       modCount++;
   }
   
  
   public int size( )
   {
       return theSize;
   }
   
   public boolean isEmpty( )
   {
       return size( ) == 0;
   }
   
  
   public boolean offer( AnyType x )
   {        
       add( size( ), x );   
       return true;         
   }
   
   
   private void add( int idx, AnyType x )
   {
       addBefore( getNodeAnt( idx, 0, size( ) ), x );
   }
   
   
   private void addBefore( Node<AnyType> p, AnyType x )
   {
   	Node<AnyType> aux=p.next;    	
       Node<AnyType> newNode = new Node<>( x, aux );
       newNode.next=aux;  
       p.next=newNode;        
       theSize++;
       modCount++;
   }   
   
   
   public AnyType peek(  )
   {
       return getNode( 0 ).data;
   }
       
  
   
 
   private Node<AnyType> getNode( int idx )
   {
       return getNode( idx, 0, size( ) - 1 );
   }

  
   private Node<AnyType> getNode( int idx, int lower, int upper )
   {
       Node<AnyType> p;  
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
   	Node<AnyType> aux;
   	aux=beginMarker;
       p = beginMarker.next;
       for( int i = 0; i < idx; i++ ){
         p = p.next;
         aux=aux.next;
         
       }                        
       return p;
   }
   
   

   private Node<AnyType> getNodeAnt( int idx )
   {
       return getNodeAnt( idx, 0, size( ) - 1 );
   }
   
   private Node<AnyType> getNodeAnt(int idx, int lower, int upper)
   {

         
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
       Node<AnyType> aux;
   	   aux=beginMarker;
       
       for( int i = 0; i < idx; i++ ){        
         aux=aux.next;
       }                        
       return aux;
   
   }
   
   
   
     public AnyType poll(  )
   {
       return remove( getNodeAnt( 0 ) );
   }
   
   
   private AnyType remove( Node<AnyType> p )
   {   Node<AnyType>b;
   	b=p.next;
       p.next = b.next;        
       theSize--;
       modCount++;        
       return b.data;
   }
   

  
   private class Node <AnyType>
   {
       public Node( AnyType d, Node<AnyType> n )
       {
           data = d; next = n;
       }
       
       public AnyType data;       
       public Node<AnyType>   next;
   }
   
   private int theSize;
   private int modCount = 0;
   private Node<AnyType> beginMarker;
  
}

  
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


public class p7E {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	
	MyQueue<Integer> fila;
	HashSet<Integer> par;
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	
	
	int numCase, numComand;
	String op, spl[], operation;
	
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
			
		numComand=Integer.parseInt(br.readLine());
		par=new HashSet<>();
		 fila=new MyQueue<>();
		System.out.println("Caso #"+(i+1)+":");
		for (int j = 0; j < numComand; j++) {
			op=br.readLine();
			spl=op.split("\\s+");
			operation=spl[0];
			
		
			//System.out.println(par);
			switch (operation){
		
				case("agregar"):
					int id=Integer.parseInt(spl[1]);
					fila.offer(id);	
					//System.out.println(id);
					break;
				
				
				case ("atender"):
					if(!fila.isEmpty()){
						int cliente=fila.poll();
						//System.out.println(cliente);
						par.add(cliente);					
					}
				break;
			
				case("existe"):
					int ident=Integer.parseInt(spl[1]);
					boolean a;
					a=par.contains(ident);
					if(a==false){
						System.out.println("NO");
					}
					else
						System.out.println("SI");
					break;
				
			}
		}
		fila.doClear();
	  
	  
	  
	}
  }
  
  
  


public static class MyQueue<AnyType> 
{
  public static <E> void enderezar (MyQueue<E> s)
	{	 
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.poll ();	
		MyQueue.<E>enderezar (s);
		s.offer (elem);	
		
	  }
	}
	
	
	public static <E> void print (MyQueue<E> s)
	{
	  E elem;
	 
	  
	  if (!s.isEmpty ()) {
		elem = s.poll ();		
		System.out.println (elem);			
		MyQueue.<E>print (s);
		s.offer (elem);		
	  }
	}
  
  
   public MyQueue( )
   {
       doClear( );
   }
   
   public void doClear( )
   {
       beginMarker = new Node<>( null,null );         
       theSize = 0;
       modCount++;
   }
   
  
   public int size( )
   {
       return theSize;
   }
   
   public boolean isEmpty( )
   {
       return size( ) == 0;
   }
   
  
   public boolean offer( AnyType x )
   {        
       add( size( ), x );   
       return true;         
   }
   
   
   private void add( int idx, AnyType x )
   {
       addBefore( getNodeAnt( idx, 0, size( ) ), x );
   }
   
   
   private void addBefore( Node<AnyType> p, AnyType x )
   {
   	Node<AnyType> aux=p.next;    	
       Node<AnyType> newNode = new Node<>( x, aux );
       newNode.next=aux;  
       p.next=newNode;        
       theSize++;
       modCount++;
   }   
   
   
   public AnyType peek(  )
   {
       return getNode( 0 ).data;
   }
       
  
   
 
   private Node<AnyType> getNode( int idx )
   {
       return getNode( idx, 0, size( ) - 1 );
   }

  
   private Node<AnyType> getNode( int idx, int lower, int upper )
   {
       Node<AnyType> p;  
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
   	Node<AnyType> aux;
   	aux=beginMarker;
       p = beginMarker.next;
       for( int i = 0; i < idx; i++ ){
         p = p.next;
         aux=aux.next;
         
       }                        
       return p;
   }
   
   

   private Node<AnyType> getNodeAnt( int idx )
   {
       return getNodeAnt( idx, 0, size( ) - 1 );
   }
   
   private Node<AnyType> getNodeAnt(int idx, int lower, int upper)
   {

         
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
       Node<AnyType> aux;
   	   aux=beginMarker;
       
       for( int i = 0; i < idx; i++ ){        
         aux=aux.next;
       }                        
       return aux;
   
   }
   
   
   
     public AnyType poll(  )
   {
       return remove( getNodeAnt( 0 ) );
   }
   
   
   private AnyType remove( Node<AnyType> p )
   {   Node<AnyType>b;
   	b=p.next;
       p.next = b.next;        
       theSize--;
       modCount++;        
       return b.data;
   }
   

  
   private class Node <AnyType>
   {
       public Node( AnyType d, Node<AnyType> n )
       {
           data = d; next = n;
       }
       
       public AnyType data;       
       public Node<AnyType>   next;
   }
   
   private int theSize;
   private int modCount = 0;
   private Node<AnyType> beginMarker;
  
}

  
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;



public class p7E {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	
	MyQueue<Integer> fila =new MyQueue<>();
	HashSet<Integer> par;
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	
	
	int numCase, numComand, id, cliente;
	String op, spl[], operation;
	boolean a;
	
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
			
		numComand=Integer.parseInt(br.readLine());
		par=new HashSet<>();
		System.out.println("Caso #"+(i+1)+":");
		
		for (int j = 0; j < numComand; j++) {
			op=br.readLine();
			spl=op.split("\\s+");
			operation=spl[0];
			
		
			//System.out.println(par);
			switch (operation){
		
				case("agregar"):
					id=Integer.parseInt(spl[1]);
					fila.offer(id);	
					//System.out.println(id);
					break;
				
				
				case ("atender"):
					if(!fila.isEmpty()){
						cliente=fila.poll();
						//System.out.println(cliente);
						par.add(cliente);					
					}
				break;
			
				case("existe"):
					int ident=Integer.parseInt(spl[1]);
					
					a=par.contains(ident);
					if(a==false){
						System.out.println("NO");
					}
					else
						System.out.println("SI");
					break;
				
			}
		}
		fila.doClear();
	  
	  
	  
	}
  }
  
  
  


public static class MyQueue<AnyType> 
{
  public static <E> void enderezar (MyQueue<E> s)
	{	 
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.poll ();	
		MyQueue.<E>enderezar (s);
		s.offer (elem);	
		
	  }
	}
	
	
	public static <E> void print (MyQueue<E> s)
	{
	  E elem;
	 
	  
	  if (!s.isEmpty ()) {
		elem = s.poll ();		
		System.out.println (elem);			
		MyQueue.<E>print (s);
		s.offer (elem);		
	  }
	}
  
  
   public MyQueue( )
   {
       doClear( );
   }
   
   public void doClear( )
   {
       beginMarker = new Node<>( null,null );         
       theSize = 0;
       modCount++;
   }
   
  
   public int size( )
   {
       return theSize;
   }
   
   public boolean isEmpty( )
   {
       return size( ) == 0;
   }
   
  
   public boolean offer( AnyType x )
   {        
       add( size( ), x );   
       return true;         
   }
   
   
   private void add( int idx, AnyType x )
   {
       addBefore( getNodeAnt( idx, 0, size( ) ), x );
   }
   
   
   private void addBefore( Node<AnyType> p, AnyType x )
   {
   	Node<AnyType> aux=p.next;    	
       Node<AnyType> newNode = new Node<>( x, aux );
       newNode.next=aux;  
       p.next=newNode;        
       theSize++;
       modCount++;
   }   
   
   
   public AnyType peek(  )
   {
       return getNode( 0 ).data;
   }
       
  
   
 
   private Node<AnyType> getNode( int idx )
   {
       return getNode( idx, 0, size( ) - 1 );
   }

  
   private Node<AnyType> getNode( int idx, int lower, int upper )
   {
       Node<AnyType> p;  
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
   	Node<AnyType> aux;
   	aux=beginMarker;
       p = beginMarker.next;
       for( int i = 0; i < idx; i++ ){
         p = p.next;
         aux=aux.next;
         
       }                        
       return p;
   }
   
   

   private Node<AnyType> getNodeAnt( int idx )
   {
       return getNodeAnt( idx, 0, size( ) - 1 );
   }
   
   private Node<AnyType> getNodeAnt(int idx, int lower, int upper)
   {

         
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
       Node<AnyType> aux;
   	   aux=beginMarker;
       
       for( int i = 0; i < idx; i++ ){        
         aux=aux.next;
       }                        
       return aux;
   
   }
   
   
   
     public AnyType poll(  )
   {
       return remove( getNodeAnt( 0 ) );
   }
   
   
   private AnyType remove( Node<AnyType> p )
   {   Node<AnyType>b;
   	b=p.next;
       p.next = b.next;        
       theSize--;
       modCount++;        
       return b.data;
   }
   

  
   private class Node <AnyType>
   {
       public Node( AnyType d, Node<AnyType> n )
       {
           data = d; next = n;
       }
       
       public AnyType data;       
       public Node<AnyType>   next;
   }
   
   private int theSize;
   private int modCount = 0;
   private Node<AnyType> beginMarker;
  
}

  
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;



public class p7E {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	
	MyQueue<Integer> fila =new MyQueue<>();
	HashSet<Integer> par=new HashSet<>();
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	
	
	int numCase, numComand, id, cliente;
	String op, spl[], operation;
	boolean a;
	
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
			
		numComand=Integer.parseInt(br.readLine());
	
		System.out.println("Caso #"+(i+1)+":");
		
		for (int j = 0; j < numComand; j++) {
			op=br.readLine();
			spl=op.split("\\s+");
			operation=spl[0];
			
		
			//System.out.println(par);
			switch (operation){
		
				case("agregar"):
					id=Integer.parseInt(spl[1]);
					fila.offer(id);	
					//System.out.println(id);
					break;
				
				
				case ("atender"):
					
						cliente=fila.poll();						
						par.add(cliente);					
					
				break;
			
				case("existe"):
					int ident=Integer.parseInt(spl[1]);
					
					a=par.contains(ident);
					if(a==false){
						System.out.println("NO");
					}
					else
						System.out.println("SI");
					break;
				
			}
		}
		fila.doClear();
		par.clear();
	  
	  
	  
	}
  }
  
  
  


public static class MyQueue<AnyType> 
{
  public static <E> void enderezar (MyQueue<E> s)
	{	 
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.poll ();	
		MyQueue.<E>enderezar (s);
		s.offer (elem);	
		
	  }
	}
	
	
	public static <E> void print (MyQueue<E> s)
	{
	  E elem;
	 
	  
	  if (!s.isEmpty ()) {
		elem = s.poll ();		
		System.out.println (elem);			
		MyQueue.<E>print (s);
		s.offer (elem);		
	  }
	}
  
  
   public MyQueue( )
   {
       doClear( );
   }
   
   public void doClear( )
   {
       beginMarker = new Node<>( null,null );         
       theSize = 0;
       modCount++;
   }
   
  
   public int size( )
   {
       return theSize;
   }
   
   public boolean isEmpty( )
   {
       return size( ) == 0;
   }
   
  
   public boolean offer( AnyType x )
   {        
       add( size( ), x );   
       return true;         
   }
   
   
   private void add( int idx, AnyType x )
   {
       addBefore( getNodeAnt( idx, 0, size( ) ), x );
   }
   
   
   private void addBefore( Node<AnyType> p, AnyType x )
   {
   	Node<AnyType> aux=p.next;    	
       Node<AnyType> newNode = new Node<>( x, aux );
       newNode.next=aux;  
       p.next=newNode;        
       theSize++;
       modCount++;
   }   
   
   
   public AnyType peek(  )
   {
       return getNode( 0 ).data;
   }
       
  
   
 
   private Node<AnyType> getNode( int idx )
   {
       return getNode( idx, 0, size( ) - 1 );
   }

  
   private Node<AnyType> getNode( int idx, int lower, int upper )
   {
       Node<AnyType> p;  
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
   	Node<AnyType> aux;
   	aux=beginMarker;
       p = beginMarker.next;
       for( int i = 0; i < idx; i++ ){
         p = p.next;
         aux=aux.next;
         
       }                        
       return p;
   }
   
   

   private Node<AnyType> getNodeAnt( int idx )
   {
       return getNodeAnt( idx, 0, size( ) - 1 );
   }
   
   private Node<AnyType> getNodeAnt(int idx, int lower, int upper)
   {

         
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
       Node<AnyType> aux;
   	   aux=beginMarker;
       
       for( int i = 0; i < idx; i++ ){        
         aux=aux.next;
       }                        
       return aux;
   
   }
   
   
   
     public AnyType poll(  )
   {
       return remove( getNodeAnt( 0 ) );
   }
   
   
   private AnyType remove( Node<AnyType> p )
   {   Node<AnyType>b;
   	b=p.next;
       p.next = b.next;        
       theSize--;
       modCount++;        
       return b.data;
   }
   

  
   private class Node <AnyType>
   {
       public Node( AnyType d, Node<AnyType> n )
       {
           data = d; next = n;
       }
       
       public AnyType data;       
       public Node<AnyType>   next;
   }
   
   private int theSize;
   private int modCount = 0;
   private Node<AnyType> beginMarker;
  
}

  
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;




public class practicaA {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	
	MyQueue<Integer> fila =new MyQueue<>();

	HashSet<Integer> par=new HashSet<>();
	HashMap<Integer, Integer> map = new HashMap<>();
	
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	
	
	int numCase, numComand, id, cliente, numPuesto;
	String str, op, spl[],sp[], operation;
	boolean a;
	
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
		str=br.readLine();
		sp=str.split("\\s+");
		
		numComand=Integer.parseInt(sp[0]);
		numPuesto=Integer.parseInt(sp[1]);
		
		for (int j = 0; j < numPuesto; j++) {
			map.put(j, null);
			
		}
	
		System.out.println("Caso #"+(i+1)+":");
		
		for (int j = 0; j < numComand; j++) {
			op=br.readLine();
			spl=op.split("\\s+");
			operation=spl[0];
			
		
			//System.out.println(par);
			switch (operation){
		
				case("agregar"):
					id=Integer.parseInt(spl[1]);
					fila.offer(id);	
					//System.out.println(id);
					break;
				
				
				case ("atender"):
					
						cliente=fila.poll();						
						par.add(cliente);
						for (int j2 = 0; j2 < numPuesto; j2++) {
							if(map.get(j2)==null){
								map.put(j2,cliente);
								break;
							}
							
						}
					
				break;
			
				case("existe"):
					int ident=Integer.parseInt(spl[1]);					
					a=par.contains(ident);
					if(a==false){
						System.out.println("NO");
					}
					else{
						System.out.print("SI ");
						for (int k = 0; k < numPuesto; k++) {
							if(map.get(k)==ident){
								System.out.println(k);
								break;
							}
							
						}
						
					}
					break;
					
				case("salir"):
					id=Integer.parseInt(spl[2]);
					par.remove(id);
					for (int j2 = 0; j2 < numPuesto; j2++) {
						if(map.get(j2)==id){
							map.put(j2, null);
							break;
						}
						
					}
					
					
			}
		}
		fila.doClear();
		par.clear();
		map.clear();
	  
	  
	  
	}
  }
  
  
  


public static class MyQueue<AnyType> 
{
  public static <E> void enderezar (MyQueue<E> s)
	{	 
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.poll ();	
		MyQueue.<E>enderezar (s);
		s.offer (elem);	
		
	  }
	}
	
	
	public static <E> void print (MyQueue<E> s)
	{
	  E elem;
	 
	  
	  if (!s.isEmpty ()) {
		elem = s.poll ();		
		System.out.println (elem);			
		MyQueue.<E>print (s);
		s.offer (elem);		
	  }
	}
  
  
   public MyQueue( )
   {
       doClear( );
   }
   
   public void doClear( )
   {
       beginMarker = new Node<>( null,null );         
       theSize = 0;
       modCount++;
   }
   
  
   public int size( )
   {
       return theSize;
   }
   
   public boolean isEmpty( )
   {
       return size( ) == 0;
   }
   
  
   public boolean offer( AnyType x )
   {        
       add( size( ), x );   
       return true;         
   }
   
   
   private void add( int idx, AnyType x )
   {
       addBefore( getNodeAnt( idx, 0, size( ) ), x );
   }
   
   
   private void addBefore( Node<AnyType> p, AnyType x )
   {
   	Node<AnyType> aux=p.next;    	
       Node<AnyType> newNode = new Node<>( x, aux );
       newNode.next=aux;  
       p.next=newNode;        
       theSize++;
       modCount++;
   }   
   
   
   public AnyType peek(  )
   {
       return getNode( 0 ).data;
   }
       
  
   
 
   private Node<AnyType> getNode( int idx )
   {
       return getNode( idx, 0, size( ) - 1 );
   }

  
   private Node<AnyType> getNode( int idx, int lower, int upper )
   {
       Node<AnyType> p;  
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
   	Node<AnyType> aux;
   	aux=beginMarker;
       p = beginMarker.next;
       for( int i = 0; i < idx; i++ ){
         p = p.next;
         aux=aux.next;
         
       }                        
       return p;
   }
   
   

   private Node<AnyType> getNodeAnt( int idx )
   {
       return getNodeAnt( idx, 0, size( ) - 1 );
   }
   
   private Node<AnyType> getNodeAnt(int idx, int lower, int upper)
   {

         
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
       Node<AnyType> aux;
   	   aux=beginMarker;
       
       for( int i = 0; i < idx; i++ ){        
         aux=aux.next;
       }                        
       return aux;
   
   }
   
   
   
     public AnyType poll(  )
   {
       return remove( getNodeAnt( 0 ) );
   }
   
   
   private AnyType remove( Node<AnyType> p )
   {   Node<AnyType>b;
   	b=p.next;
       p.next = b.next;        
       theSize--;
       modCount++;        
       return b.data;
   }
   

  
   private class Node <AnyType>
   {
       public Node( AnyType d, Node<AnyType> n )
       {
           data = d; next = n;
       }
       
       public AnyType data;       
       public Node<AnyType>   next;
   }
   
   private int theSize;
   private int modCount = 0;
   private Node<AnyType> beginMarker;
  
}

  
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map.Entry;




public class practicaA {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	
	MyQueue<Integer> fila =new MyQueue<>();

	HashSet<Integer> par=new HashSet<>();
	HashMap<Integer, Integer> map = new HashMap<>();
	
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	
	
	int numCase, numComand, id, cliente, numPuesto;
	String str, op, spl[],sp[], operation;
	boolean a;
	
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
		str=br.readLine();
		sp=str.split("\\s+");
		
		numComand=Integer.parseInt(sp[0]);
		numPuesto=Integer.parseInt(sp[1]);
		
		for (int j = 0; j < numPuesto; j++) {
			map.put(j, null);
			
		}
	
		System.out.println("Caso #"+(i+1)+":");
		
		for (int j = 0; j < numComand; j++) {
			op=br.readLine();
			spl=op.split("\\s+");
			operation=spl[0];
			
		
			//System.out.println(par);
			switch (operation){
		
				case("agregar"):
					id=Integer.parseInt(spl[1]);
					fila.offer(id);	
					//System.out.println(id);
					break;
				
				
				case ("atender"):
					
						cliente=fila.poll();						
						par.add(cliente);
						for (int j2 = 0; j2 < numPuesto; j2++) {
							if(map.get(j2)==null){
								map.put(j2,cliente);
								break;
							}
							
						}
					
				break;
			
				case("existe"):
					int ident=Integer.parseInt(spl[1]);					
					a=par.contains(ident);
					if(a==false){
						System.out.println("NO");
					}
					else{
						System.out.print("SI ");
						for (int k = 0; k < numPuesto; k++) {
							if(map.get(k)==ident){
								System.out.println(k);
								break;
							}
							
						}
						
					}
					break;
					
				case("salir"):
					id=Integer.parseInt(spl[1]);
					par.remove(id);
					for (int j2 = 0; j2 < numPuesto; j2++) {
						if(map.get(j2)==id){
							map.put(j2, null);
							break;
						}
						
					}
					
					
			}
		}
		fila.doClear();
		par.clear();
		map.clear();
	  
	  
	  
	}
  }
  
  
  


public static class MyQueue<AnyType> 
{
  public static <E> void enderezar (MyQueue<E> s)
	{	 
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.poll ();	
		MyQueue.<E>enderezar (s);
		s.offer (elem);	
		
	  }
	}
	
	
	public static <E> void print (MyQueue<E> s)
	{
	  E elem;
	 
	  
	  if (!s.isEmpty ()) {
		elem = s.poll ();		
		System.out.println (elem);			
		MyQueue.<E>print (s);
		s.offer (elem);		
	  }
	}
  
  
   public MyQueue( )
   {
       doClear( );
   }
   
   public void doClear( )
   {
       beginMarker = new Node<>( null,null );         
       theSize = 0;
       modCount++;
   }
   
  
   public int size( )
   {
       return theSize;
   }
   
   public boolean isEmpty( )
   {
       return size( ) == 0;
   }
   
  
   public boolean offer( AnyType x )
   {        
       add( size( ), x );   
       return true;         
   }
   
   
   private void add( int idx, AnyType x )
   {
       addBefore( getNodeAnt( idx, 0, size( ) ), x );
   }
   
   
   private void addBefore( Node<AnyType> p, AnyType x )
   {
   	Node<AnyType> aux=p.next;    	
       Node<AnyType> newNode = new Node<>( x, aux );
       newNode.next=aux;  
       p.next=newNode;        
       theSize++;
       modCount++;
   }   
   
   
   public AnyType peek(  )
   {
       return getNode( 0 ).data;
   }
       
  
   
 
   private Node<AnyType> getNode( int idx )
   {
       return getNode( idx, 0, size( ) - 1 );
   }

  
   private Node<AnyType> getNode( int idx, int lower, int upper )
   {
       Node<AnyType> p;  
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
   	Node<AnyType> aux;
   	aux=beginMarker;
       p = beginMarker.next;
       for( int i = 0; i < idx; i++ ){
         p = p.next;
         aux=aux.next;
         
       }                        
       return p;
   }
   
   

   private Node<AnyType> getNodeAnt( int idx )
   {
       return getNodeAnt( idx, 0, size( ) - 1 );
   }
   
   private Node<AnyType> getNodeAnt(int idx, int lower, int upper)
   {

         
       if( idx < lower || idx > upper )
           throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
       
       Node<AnyType> aux;
   	   aux=beginMarker;
       
       for( int i = 0; i < idx; i++ ){        
         aux=aux.next;
       }                        
       return aux;
   
   }
   
   
   
     public AnyType poll(  )
   {
       return remove( getNodeAnt( 0 ) );
   }
   
   
   private AnyType remove( Node<AnyType> p )
   {   Node<AnyType>b;
   	b=p.next;
       p.next = b.next;        
       theSize--;
       modCount++;        
       return b.data;
   }
   

  
   private class Node <AnyType>
   {
       public Node( AnyType d, Node<AnyType> n )
       {
           data = d; next = n;
       }
       
       public AnyType data;       
       public Node<AnyType>   next;
   }
   
   private int theSize;
   private int modCount = 0;
   private Node<AnyType> beginMarker;
  
}

  
  


public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    
    public MyArrayList( )
    {
        doClear( );
    }
    
   
    public int size( )
    {
        return theSize;
    }
    
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
  
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
  
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
  
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
  
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
   
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
  
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
  
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class gB {

  public static void main(String[] args) throws IOException {


	Graph g ;
	Vertex[] vertices;

	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	int numCase, conex, pc,A, B;
	String str, spl[], cadena, arr[];


	numCase= Integer.parseInt(br.readLine());

	for (int i = 0; i < numCase; i++) {
	  System.out.println("Caso #" + (i+1)+":");

	  g= new Graph();

	  str=br.readLine();
	  spl=str.split("\\s+");
	  conex=Integer.parseInt(spl[1]);
	  pc=Integer.parseInt(spl[0]);
	  vertices = new Vertex[pc];

	  for (int j = 0; j < vertices.length; j++) {
		vertices[j] = new Vertex(j + "");
		g.addVertex(vertices[j], true);
	  }

	  Edge[] edges = new Edge[conex];

	  for (int j = 0; j < conex; j++) {
		cadena=br.readLine();
		arr=cadena.split("\\s+");
		A=Integer.parseInt(arr[0]);
		B=Integer.parseInt(arr[1]);
		edges[j] = new Edge(vertices[A], vertices[B], Integer.parseInt(arr[2]));
	  }

	  for(Edge e: edges){
		g.addEdge(e.getOne(), e.getTwo(), e.getWeight());
	  }


	  if(conex==0){
		System.out.println("inalcanzable");
	  }
	  else{
		Dijkstra dijkstra = new Dijkstra(g, vertices[Integer.parseInt(spl[2])].getLabel());
		System.out.println(dijkstra.getDistanceTo(spl[3]));
	  }



	}




//	Graph graph = new Graph();
//	Vertex[] vertices = new Vertex[6];
//
//	for(int i = 0; i < vertices.length; i++){
//		vertices[i] = new Vertex(i + "");
//        graph.addVertex(vertices[i], true);
//
//		        }
//
//		        Edge[] edges = new Edge[9];
//		        edges[0] = new Edge(vertices[0], vertices[1], 7);
//		        edges[1] = new Edge(vertices[0], vertices[2], 9);
//		        edges[2] = new Edge(vertices[0], vertices[5], 14);
//		        edges[3] = new Edge(vertices[1], vertices[2], 10);
//		        edges[4] = new Edge(vertices[1], vertices[3], 15);
//		        edges[5] = new Edge(vertices[2], vertices[3], 11);
//		        edges[6] = new Edge(vertices[2], vertices[5], 2);
//		        edges[7] = new Edge(vertices[3], vertices[4], 6);
//		        edges[8] = new Edge(vertices[4], vertices[5], 9);
//
//
//		        for(Edge e: edges){
//		            graph.addEdge(e.getOne(), e.getTwo(), e.getWeight());
//		        }
//
//		        Dijkstra dijkstra = new Dijkstra(graph, vertices[0].getLabel());
//
//		        System.out.println(dijkstra.getDistanceTo("5"));
//		        System.out.println(dijkstra.getPathTo("5"));
  }




  public static class Vertex {

		    private ArrayList<Edge> neighborhood;
		    private String label;
		    /*
		      * @param label The unique label associated with this Vertex
		     */

		    public Vertex(String label){
		        this.label = label;
		        this.neighborhood = new ArrayList<Edge>();
		    }

		    /*
		     * This method adds an Edge to the incidence neighborhood of this graph iff
		     * the edge is not already present.
		     * @param edge The edge to add
		     */

		    public void addNeighbor(Edge edge){
			        if(this.neighborhood.contains(edge)){
		            return;
		        }

		        this.neighborhood.add(edge);
		    }

		    /*
		     * @param other The edge for which to search
		     * @return true iff other is contained in this.neighborhood
		     */

		    public boolean containsNeighbor(Edge other){
		        return this.neighborhood.contains(other);
		    }

		    /*
		     * @param index The index of the Edge to retrieve
		     * @return Edge The Edge at the specified index in this.neighborhood
		     */

		    public Edge getNeighbor(int index){
		        return this.neighborhood.get(index);
		    }



		    /*
		     * @param e The Edge to remove from this.neighborhood
		     */

		    public void removeNeighbor(Edge e){
		        this.neighborhood.remove(e);
		      }

		    /*
		     * @return int The number of neighbors of this Vertex
		     */

		    public int getNeighborCount(){
		        return this.neighborhood.size();
		    }

		    /*
		     * @return String The label of this Vertex
		     */

		    public String getLabel(){
		        return this.label;
		    }


		    /*
		     * @return ArrayList<Edge> A copy of this.neighborhood. Modifying the returned
		     * ArrayList will not affect the neighborhood of this Vertex
		     */

		    public ArrayList<Edge> getNeighbors(){
		        return new ArrayList<Edge>(this.neighborhood);
		    }

	}




  public static class Edge implements Comparable<Edge> {
		    private Vertex one, two;
		    private int weight;

		    /*
		     * @param one The first vertex in the Edge
		     * @param two The second vertex in the Edge
		     */

		    public Edge(Vertex one, Vertex two){
		        this(one, two, 1);
		    }



		    /*
		     * @param one The first vertex in the Edge
		     * @param two The second vertex of the Edge
		     * @param weight The weight of this Edge
		     */

		    public Edge(Vertex one, Vertex two, int weight){
		        this.one = (one.getLabel().compareTo(two.getLabel()) <= 0) ? one : two;
		        this.two = (this.one == one) ? two : one;
		        this.weight = weight;
		    }

		    /*
		     * @param current
		     * @return The neighbor of current along this Edge
		     */

		    public Vertex getNeighbor(Vertex current){
		        if(!(current.equals(one) || current.equals(two))){

		            return null;
		        }

		        return (current.equals(one)) ? two : one;
		    }


		    /*
		     * @return Vertex this.one
		     */

		    public Vertex getOne(){
		        return this.one;
		    }

		    /*
		     * @return Vertex this.two
		     */

		    public Vertex getTwo(){
		        return this.two;
		    }
		    /*
		     * @return int The weight of this Edge

		     */

		    public int getWeight(){
		        return this.weight;
		    }


		    /*
		     * @param weight The new weight of this Edge
		     */

		    public void setWeight(int weight){
		        this.weight = weight;
		    }

		    /*
		     * Note that the compareTo() method deviates from

		     * the specifications in the Comparable interface. A

		     * return value of 0 does not indicate that this.equals(other).

		     * The equals() method checks the Vertex endpoints, while the

		     * compareTo() is used to compare Edge weights

		     * @param other The Edge to compare against this

		     * @return int this.weight - other.weight

		     */

		    public int compareTo(Edge other){
		        return this.weight - other.weight;
		    }

		    /*
		     * @return String A String representation of this Edge
		     */

		    public String toString(){
		        return "({" + one + ", " + two + "}, " + weight + ")";
		    }


		    /*
		     * @return int The hash code for this Edge
		     */

		    public int hashCode(){
		        return (one.getLabel() + two.getLabel()).hashCode();
		    }


		    /*
		     * @param other The Object to compare against this

		     * @return ture iff other is an Edge with the same Vertices as this
	    */

		    public boolean equals(Object other){
		        if(!(other instanceof Edge)){
		            return false;
		        }

		        Edge e = (Edge)other;

		        return e.one.equals(this.one) && e.two.equals(this.two);
		    }

		}



  public static class Graph {
			private HashMap<String, Vertex> vertices;

		    private HashMap<Integer, Edge> edges;

		    public Graph(){

		        this.vertices = new HashMap<String, Vertex>();

		        this.edges = new HashMap<Integer, Edge>();
		    }

		    /*
		     * This constructor accepts an ArrayList<Vertex> and populates
		     * this.vertices. If multiple Vertex objects have the same label,
		     * then the last Vertex with the given label is used.
		     *
		     * @param vertices The initial Vertices to populate this Graph
		     */

		    public Graph(ArrayList<Vertex> vertices){
		        this.vertices = new HashMap<String, Vertex>();
		        this.edges = new HashMap<Integer, Edge>();

		        for(Vertex v: vertices){
		            this.vertices.put(v.getLabel(), v);
		        }
		    }

		    /*
		     * This method adds am edge between Vertices one and two

		     * of weight 1, if no Edge between these Vertices already

		     * exists in the Graph.
		     * @param one The first vertex to add
		     * @param two The second vertex to add
		     * @return true iff no Edge relating one and two exists in the Graph
		     */

		    public boolean addEdge(Vertex one, Vertex two){
		        return addEdge(one, two, 1);
		    }

		    /*
		     * Accepts two vertices and a weight, and adds the edge
		     * ({one, two}, weight) iff no Edge relating one and two
		     * exists in the Graph.

		     * @param one The first Vertex of the Edge
		     * @param two The second Vertex of the Edge
		     * @param weight The weight of the Edge
		     * @return true iff no Edge already exists in the Graph
		     */

		    public boolean addEdge(Vertex one, Vertex two, int weight){
		        if(one.equals(two)){
		            return false;
		        }

		        //ensures the Edge is not in the Graph
		        Edge e = new Edge(one, two, weight);
		        if(edges.containsKey(e.hashCode())){
		            return false;
		        }

		        //and that the Edge isn't already incident to one of the vertices

		        else if(one.containsNeighbor(e) || two.containsNeighbor(e)){
		            return false;
		        }

		        edges.put(e.hashCode(), e);
		        one.addNeighbor(e);
		        two.addNeighbor(e);
		        return true;
		    }

		    /*
		     * @param e The Edge to look up
		     * @return true iff this Graph contains the Edge e
		     */

		    public boolean containsEdge(Edge e){
		        if(e.getOne() == null || e.getTwo() == null){
		            return false;
			        }

		        return this.edges.containsKey(e.hashCode());
		    }


		    /*
		     * This method removes the specified Edge from the Graph,
		     * including as each vertex's incidence neighborhood.
		     * @param e The Edge to remove from the Graph
		     * @return Edge The Edge removed from the Graph
		     */

		    public Edge removeEdge(Edge e){
		       e.getOne().removeNeighbor(e);
		       e.getTwo().removeNeighbor(e);
		       return this.edges.remove(e.hashCode());
		    }

		    /*
		     * @param vertex The Vertex to look up
		     * @return true iff this Graph contains vertex
		     */

		    public boolean containsVertex(Vertex vertex){
		        return this.vertices.get(vertex.getLabel()) != null;
		    }

		    /*
		     * @param label The specified Vertex label
		     * @return Vertex The Vertex with the specified label
		     */

		    public Vertex getVertex(String label){
		        return vertices.get(label);
		    }

		    /*
		     * This method adds a Vertex to the graph. If a Vertex with the same label
		     * as the parameter exists in the Graph, the existing Vertex is overwritten
		     * only if overwriteExisting is true. If the existing Vertex is overwritten,
		     * the Edges incident to it are all removed from the Graph.
		     * @param vertex
		     * @param overwriteExisting
		     * @return true iff vertex was added to the Graph
		     */

		    public boolean addVertex(Vertex vertex, boolean overwriteExisting){
		        Vertex current = this.vertices.get(vertex.getLabel());
		        if(current != null){
		            if(!overwriteExisting){
		                return false;
		            }

		            while(current.getNeighborCount() > 0){
		                this.removeEdge(current.getNeighbor(0));
		            }
		        }

		        vertices.put(vertex.getLabel(), vertex);
		        return true;

		    }

		    /*
		     * @param label The label of the Vertex to remove
		     * @return Vertex The removed Vertex object
		     */

		    public Vertex removeVertex(String label){
		        Vertex v = vertices.remove(label);
		        while(v.getNeighborCount() > 0){
		            this.removeEdge(v.getNeighbor((0)));
		        }
	     return v;

		    }

		    /*
		     * @return Set<String> The unique labels of the Graph's Vertex objects
		     */

		    public Set<String> vertexKeys(){
		        return this.vertices.keySet();
		    }

		    /*
		     * @return Set<Edge> The Edges of this graph
		     */

		    public Set<Edge> getEdges(){
		        return new HashSet<Edge>(this.edges.values());
		    }
		}




  public static class Dijkstra {


		    private Graph graph;
		    private String initialVertexLabel;
		    private HashMap<String, String> predecessors;
		    private HashMap<String, Integer> distances;
		    private PriorityQueue<Vertex> availableVertices;
		    private HashSet<Vertex> visitedVertices;

		    /**
		     * This constructor initializes this Dijkstra object and executes
		     * Dijkstra's algorithm on the graph given the specified initialVertexLabel.
		     * After the algorithm terminates, the shortest a-b paths and the corresponding
		     * distances will be available for all vertices b in the graph.
		     *

		     * @param graph The Graph to traverse
		     * @param initialVertexLabel The starting Vertex label
		     * @throws IllegalArgumentException If the specified initial vertex is not in the Graph
		     */

		    public Dijkstra(Graph graph, String initialVertexLabel){

		        this.graph = graph;

		        Set<String> vertexKeys = this.graph.vertexKeys();

		        if(!vertexKeys.contains(initialVertexLabel)){
		            throw new IllegalArgumentException("The graph must contain the initial vertex.");
		        }

		        this.initialVertexLabel = initialVertexLabel;
		        this.predecessors = new HashMap<String, String>();
		        this.distances = new HashMap<String, Integer>();
		        this.availableVertices = new PriorityQueue<Vertex>(vertexKeys.size(), new Comparator<Vertex>(){



		            public int compare(Vertex one, Vertex two){

		                int weightOne = Dijkstra.this.distances.get(one.getLabel());

		                int weightTwo = Dijkstra.this.distances.get(two.getLabel());

		                return weightOne - weightTwo;

		            }

		        });


		        this.visitedVertices = new HashSet<Vertex>();



		        //for each Vertex in the graph

		        //assume it has distance infinity denoted by Integer.MAX_VALUE

		        for(String key: vertexKeys){

		            this.predecessors.put(key, null);

		            this.distances.put(key, Integer.MAX_VALUE);

		        }


		        //the distance from the initial vertex to itself is 0

		        this.distances.put(initialVertexLabel, 0);

		        //and seed initialVertex's neighbors

		        Vertex initialVertex = this.graph.getVertex(initialVertexLabel);

		        ArrayList<Edge> initialVertexNeighbors = initialVertex.getNeighbors();

		        for(Edge e : initialVertexNeighbors){

		            Vertex other = e.getNeighbor(initialVertex);

		            this.predecessors.put(other.getLabel(), initialVertexLabel);

		            this.distances.put(other.getLabel(), e.getWeight());

		            this.availableVertices.add(other);

		        }

		        this.visitedVertices.add(initialVertex);

		        //now apply Dijkstra's algorithm to the Graph

		        processGraph();

		    }



		    /*
		     * This method applies Dijkstra's algorithm to the graph using the Vertex
		     * specified by initialVertexLabel as the starting point.
		     *
		     * @post The shortest a-b paths as specified by Dijkstra's algorithm and
		     *       their distances are available

		     */

		    private void processGraph(){



		        //as long as there are Edges to process

		        while(this.availableVertices.size() > 0){
		          //pick the cheapest vertex

		            Vertex next = this.availableVertices.poll();

		            int distanceToNext = this.distances.get(next.getLabel());


		            //and for each available neighbor of the chosen vertex

		            List<Edge> nextNeighbors = next.getNeighbors();

		            for(Edge e: nextNeighbors){

		                Vertex other = e.getNeighbor(next);

		                if(this.visitedVertices.contains(other)){

		                    continue;

		                }



		                //we check if a shorter path exists

		                //and update to indicate a new shortest found path

		                //in the graph

		                int currentWeight = this.distances.get(other.getLabel());

		                int newWeight = distanceToNext + e.getWeight();

		                if(newWeight < currentWeight){

		                    this.predecessors.put(other.getLabel(), next.getLabel());

		                    this.distances.put(other.getLabel(), newWeight);

		                    this.availableVertices.remove(other);

		                    this.availableVertices.add(other);

		                }

		            }


		            // finally, mark the selected vertex as visited

		            // so we don't revisit it

		            this.visitedVertices.add(next);

		        }

		    }

		    /*
		     * @param destinationLabel The Vertex whose shortest path from the initial Vertex is desired
		     * @return LinkedList<Vertex> A sequence of Vertex objects starting at the
		     *         initial Vertex and terminating at the Vertex specified by destinationLabel.
		     *         The path is the shortest path specified by Dijkstra's algorithm.
		     */

		    public List<Vertex> getPathTo(String destinationLabel){

		        LinkedList<Vertex> path = new LinkedList<Vertex>();
		        path.add(graph.getVertex(destinationLabel));
		        while(!destinationLabel.equals(this.initialVertexLabel)){

		            Vertex predecessor = graph.getVertex(this.predecessors.get(destinationLabel));
		            destinationLabel = predecessor.getLabel();
		            path.add(0, predecessor);

		        }

		        return path;
		    }


		    /*
		     * @param destinationLabel The Vertex to determine the distance from the initial Vertex

		     * @return int The distance from the initial Vertex to the Vertex specified by destinationLabel

		     */

		    public int getDistanceTo(String destinationLabel){

		        return this.distances.get(destinationLabel);

		    }


		}



}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class gB {

  public static void main(String[] args) throws IOException {


	Graph g ;
	Vertex[] vertices;

	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	int numCase, conex, pc,A, B;
	String str, spl[], cadena, arr[];


	numCase= Integer.parseInt(br.readLine());

	for (int i = 0; i < numCase; i++) {
	  System.out.println("Caso #" + (i+1)+":");

	  g= new Graph();

	  str=br.readLine();
	  spl=str.split("\\s+");
	  conex=Integer.parseInt(spl[1]);
	  pc=Integer.parseInt(spl[0]);
	  vertices = new Vertex[pc];

	  for (int j = 0; j < vertices.length; j++) {
		vertices[j] = new Vertex(j + "");
		g.addVertex(vertices[j], true);
	  }

	  Edge[] edges = new Edge[conex];

	  for (int j = 0; j < conex; j++) {
		cadena=br.readLine();
		arr=cadena.split("\\s+");
		A=Integer.parseInt(arr[0]);
		B=Integer.parseInt(arr[1]);
		edges[j] = new Edge(vertices[A], vertices[B], Integer.parseInt(arr[2]));
	  }

	  for(Edge e: edges){
		g.addEdge(e.getOne(), e.getTwo(), e.getWeight());
	  }


	  if(conex==0){
		System.out.println("inalcanzable");
	  }
	  else{
		Dijkstra dijkstra = new Dijkstra(g, vertices[Integer.parseInt(spl[2])].getLabel());
		System.out.println(dijkstra.getDistanceTo(spl[3]));
	  }



	}




//	Graph graph = new Graph();
//	Vertex[] vertices = new Vertex[6];
//
//	for(int i = 0; i < vertices.length; i++){
//		vertices[i] = new Vertex(i + "");
//        graph.addVertex(vertices[i], true);
//
//		        }
//
//		        Edge[] edges = new Edge[9];
//		        edges[0] = new Edge(vertices[0], vertices[1], 7);
//		        edges[1] = new Edge(vertices[0], vertices[2], 9);
//		        edges[2] = new Edge(vertices[0], vertices[5], 14);
//		        edges[3] = new Edge(vertices[1], vertices[2], 10);
//		        edges[4] = new Edge(vertices[1], vertices[3], 15);
//		        edges[5] = new Edge(vertices[2], vertices[3], 11);
//		        edges[6] = new Edge(vertices[2], vertices[5], 2);
//		        edges[7] = new Edge(vertices[3], vertices[4], 6);
//		        edges[8] = new Edge(vertices[4], vertices[5], 9);
//
//
//		        for(Edge e: edges){
//		            graph.addEdge(e.getOne(), e.getTwo(), e.getWeight());
//		        }
//
//		        Dijkstra dijkstra = new Dijkstra(graph, vertices[0].getLabel());
//
//		        System.out.println(dijkstra.getDistanceTo("5"));
//		        System.out.println(dijkstra.getPathTo("5"));
  }




  public static class Vertex {

		    private ArrayList<Edge> neighborhood;
		    private String label;
		    /*
		      * @param label The unique label associated with this Vertex
		     */

		    public Vertex(String label){
		        this.label = label;
		        this.neighborhood = new ArrayList<Edge>();
		    }

		    /*
		     * This method adds an Edge to the incidence neighborhood of this graph iff
		     * the edge is not already present.
		     * @param edge The edge to add
		     */

		    public void addNeighbor(Edge edge){
			        if(this.neighborhood.contains(edge)){
		            return;
		        }

		        this.neighborhood.add(edge);
		    }

		    /*
		     * @param other The edge for which to search
		     * @return true iff other is contained in this.neighborhood
		     */

		    public boolean containsNeighbor(Edge other){
		        return this.neighborhood.contains(other);
		    }

		    /*
		     * @param index The index of the Edge to retrieve
		     * @return Edge The Edge at the specified index in this.neighborhood
		     */

		    public Edge getNeighbor(int index){
		        return this.neighborhood.get(index);
		    }



		    /*
		     * @param e The Edge to remove from this.neighborhood
		     */

		    public void removeNeighbor(Edge e){
		        this.neighborhood.remove(e);
		      }

		    /*
		     * @return int The number of neighbors of this Vertex
		     */

		    public int getNeighborCount(){
		        return this.neighborhood.size();
		    }

		    /*
		     * @return String The label of this Vertex
		     */

		    public String getLabel(){
		        return this.label;
		    }


		    /*
		     * @return ArrayList<Edge> A copy of this.neighborhood. Modifying the returned
		     * ArrayList will not affect the neighborhood of this Vertex
		     */

		    public ArrayList<Edge> getNeighbors(){
		        return new ArrayList<Edge>(this.neighborhood);
		    }

	}




  public static class Edge implements Comparable<Edge> {
		    private Vertex one, two;
		    private int weight;

		    /*
		     * @param one The first vertex in the Edge
		     * @param two The second vertex in the Edge
		     */

		    public Edge(Vertex one, Vertex two){
		        this(one, two, 1);
		    }



		    /*
		     * @param one The first vertex in the Edge
		     * @param two The second vertex of the Edge
		     * @param weight The weight of this Edge
		     */

		    public Edge(Vertex one, Vertex two, int weight){
		        this.one = (one.getLabel().compareTo(two.getLabel()) <= 0) ? one : two;
		        this.two = (this.one == one) ? two : one;
		        this.weight = weight;
		    }

		    /*
		     * @param current
		     * @return The neighbor of current along this Edge
		     */

		    public Vertex getNeighbor(Vertex current){
		        if(!(current.equals(one) || current.equals(two))){

		            return null;
		        }

		        return (current.equals(one)) ? two : one;
		    }


		    /*
		     * @return Vertex this.one
		     */

		    public Vertex getOne(){
		        return this.one;
		    }

		    /*
		     * @return Vertex this.two
		     */

		    public Vertex getTwo(){
		        return this.two;
		    }
		    /*
		     * @return int The weight of this Edge

		     */

		    public int getWeight(){
		        return this.weight;
		    }


		    /*
		     * @param weight The new weight of this Edge
		     */

		    public void setWeight(int weight){
		        this.weight = weight;
		    }

		    /*
		     * Note that the compareTo() method deviates from

		     * the specifications in the Comparable interface. A

		     * return value of 0 does not indicate that this.equals(other).

		     * The equals() method checks the Vertex endpoints, while the

		     * compareTo() is used to compare Edge weights

		     * @param other The Edge to compare against this

		     * @return int this.weight - other.weight

		     */

		    public int compareTo(Edge other){
		        return this.weight - other.weight;
		    }

		    /*
		     * @return String A String representation of this Edge
		     */

		    public String toString(){
		        return "({" + one + ", " + two + "}, " + weight + ")";
		    }


		    /*
		     * @return int The hash code for this Edge
		     */

		    public int hashCode(){
		        return (one.getLabel() + two.getLabel()).hashCode();
		    }


		    /*
		     * @param other The Object to compare against this

		     * @return ture iff other is an Edge with the same Vertices as this
	    */

		    public boolean equals(Object other){
		        if(!(other instanceof Edge)){
		            return false;
		        }

		        Edge e = (Edge)other;

		        return e.one.equals(this.one) && e.two.equals(this.two);
		    }

		}



  public static class Graph {
			private HashMap<String, Vertex> vertices;

		    private HashMap<Integer, Edge> edges;

		    public Graph(){

		        this.vertices = new HashMap<String, Vertex>();

		        this.edges = new HashMap<Integer, Edge>();
		    }

		    /*
		     * This constructor accepts an ArrayList<Vertex> and populates
		     * this.vertices. If multiple Vertex objects have the same label,
		     * then the last Vertex with the given label is used.
		     *
		     * @param vertices The initial Vertices to populate this Graph
		     */

		    public Graph(ArrayList<Vertex> vertices){
		        this.vertices = new HashMap<String, Vertex>();
		        this.edges = new HashMap<Integer, Edge>();

		        for(Vertex v: vertices){
		            this.vertices.put(v.getLabel(), v);
		        }
		    }

		    /*
		     * This method adds am edge between Vertices one and two

		     * of weight 1, if no Edge between these Vertices already

		     * exists in the Graph.
		     * @param one The first vertex to add
		     * @param two The second vertex to add
		     * @return true iff no Edge relating one and two exists in the Graph
		     */

		    public boolean addEdge(Vertex one, Vertex two){
		        return addEdge(one, two, 1);
		    }

		    /*
		     * Accepts two vertices and a weight, and adds the edge
		     * ({one, two}, weight) iff no Edge relating one and two
		     * exists in the Graph.

		     * @param one The first Vertex of the Edge
		     * @param two The second Vertex of the Edge
		     * @param weight The weight of the Edge
		     * @return true iff no Edge already exists in the Graph
		     */

		    public boolean addEdge(Vertex one, Vertex two, int weight){
		        if(one.equals(two)){
		            return false;
		        }

		        //ensures the Edge is not in the Graph
		        Edge e = new Edge(one, two, weight);
		        if(edges.containsKey(e.hashCode())){
		            return false;
		        }

		        //and that the Edge isn't already incident to one of the vertices

		        else if(one.containsNeighbor(e) || two.containsNeighbor(e)){
		            return false;
		        }

		        edges.put(e.hashCode(), e);
		        one.addNeighbor(e);
		        two.addNeighbor(e);
		        return true;
		    }

		    /*
		     * @param e The Edge to look up
		     * @return true iff this Graph contains the Edge e
		     */

		    public boolean containsEdge(Edge e){
		        if(e.getOne() == null || e.getTwo() == null){
		            return false;
			        }

		        return this.edges.containsKey(e.hashCode());
		    }


		    /*
		     * This method removes the specified Edge from the Graph,
		     * including as each vertex's incidence neighborhood.
		     * @param e The Edge to remove from the Graph
		     * @return Edge The Edge removed from the Graph
		     */

		    public Edge removeEdge(Edge e){
		       e.getOne().removeNeighbor(e);
		       e.getTwo().removeNeighbor(e);
		       return this.edges.remove(e.hashCode());
		    }

		    /*
		     * @param vertex The Vertex to look up
		     * @return true iff this Graph contains vertex
		     */

		    public boolean containsVertex(Vertex vertex){
		        return this.vertices.get(vertex.getLabel()) != null;
		    }

		    /*
		     * @param label The specified Vertex label
		     * @return Vertex The Vertex with the specified label
		     */

		    public Vertex getVertex(String label){
		        return vertices.get(label);
		    }

		    /*
		     * This method adds a Vertex to the graph. If a Vertex with the same label
		     * as the parameter exists in the Graph, the existing Vertex is overwritten
		     * only if overwriteExisting is true. If the existing Vertex is overwritten,
		     * the Edges incident to it are all removed from the Graph.
		     * @param vertex
		     * @param overwriteExisting
		     * @return true iff vertex was added to the Graph
		     */

		    public boolean addVertex(Vertex vertex, boolean overwriteExisting){
		        Vertex current = this.vertices.get(vertex.getLabel());
		        if(current != null){
		            if(!overwriteExisting){
		                return false;
		            }

		            while(current.getNeighborCount() > 0){
		                this.removeEdge(current.getNeighbor(0));
		            }
		        }

		        vertices.put(vertex.getLabel(), vertex);
		        return true;

		    }

		    /*
		     * @param label The label of the Vertex to remove
		     * @return Vertex The removed Vertex object
		     */

		    public Vertex removeVertex(String label){
		        Vertex v = vertices.remove(label);
		        while(v.getNeighborCount() > 0){
		            this.removeEdge(v.getNeighbor((0)));
		        }
	     return v;

		    }

		    /*
		     * @return Set<String> The unique labels of the Graph's Vertex objects
		     */

		    public Set<String> vertexKeys(){
		        return this.vertices.keySet();
		    }

		    /*
		     * @return Set<Edge> The Edges of this graph
		     */

		    public Set<Edge> getEdges(){
		        return new HashSet<Edge>(this.edges.values());
		    }
		}




  public static class Dijkstra {


		    private Graph graph;
		    private String initialVertexLabel;
		    private HashMap<String, String> predecessors;
		    private HashMap<String, Integer> distances;
		    private PriorityQueue<Vertex> availableVertices;
		    private HashSet<Vertex> visitedVertices;

		    /**
		     * This constructor initializes this Dijkstra object and executes
		     * Dijkstra's algorithm on the graph given the specified initialVertexLabel.
		     * After the algorithm terminates, the shortest a-b paths and the corresponding
		     * distances will be available for all vertices b in the graph.
		     *

		     * @param graph The Graph to traverse
		     * @param initialVertexLabel The starting Vertex label
		     * @throws IllegalArgumentException If the specified initial vertex is not in the Graph
		     */

		    public Dijkstra(Graph graph, String initialVertexLabel){

		        this.graph = graph;

		        Set<String> vertexKeys = this.graph.vertexKeys();

		        if(!vertexKeys.contains(initialVertexLabel)){
		            throw new IllegalArgumentException("The graph must contain the initial vertex.");
		        }

		        this.initialVertexLabel = initialVertexLabel;
		        this.predecessors = new HashMap<String, String>();
		        this.distances = new HashMap<String, Integer>();
		        this.availableVertices = new PriorityQueue<Vertex>(vertexKeys.size(), new Comparator<Vertex>(){



		            public int compare(Vertex one, Vertex two){

		                int weightOne = Dijkstra.this.distances.get(one.getLabel());

		                int weightTwo = Dijkstra.this.distances.get(two.getLabel());

		                return weightOne - weightTwo;

		            }

		        });


		        this.visitedVertices = new HashSet<Vertex>();



		        //for each Vertex in the graph

		        //assume it has distance infinity denoted by Integer.MAX_VALUE

		        for(String key: vertexKeys){

		            this.predecessors.put(key, null);

		            this.distances.put(key, Integer.MAX_VALUE);

		        }


		        //the distance from the initial vertex to itself is 0

		        this.distances.put(initialVertexLabel, 0);

		        //and seed initialVertex's neighbors

		        Vertex initialVertex = this.graph.getVertex(initialVertexLabel);

		        ArrayList<Edge> initialVertexNeighbors = initialVertex.getNeighbors();

		        for(Edge e : initialVertexNeighbors){

		            Vertex other = e.getNeighbor(initialVertex);

		            this.predecessors.put(other.getLabel(), initialVertexLabel);

		            this.distances.put(other.getLabel(), e.getWeight());

		            this.availableVertices.add(other);

		        }

		        this.visitedVertices.add(initialVertex);

		        //now apply Dijkstra's algorithm to the Graph

		        processGraph();

		    }



		    /*
		     * This method applies Dijkstra's algorithm to the graph using the Vertex
		     * specified by initialVertexLabel as the starting point.
		     *
		     * @post The shortest a-b paths as specified by Dijkstra's algorithm and
		     *       their distances are available

		     */

		    private void processGraph(){



		        //as long as there are Edges to process

		        while(this.availableVertices.size() > 0){
		          //pick the cheapest vertex

		            Vertex next = this.availableVertices.poll();

		            int distanceToNext = this.distances.get(next.getLabel());


		            //and for each available neighbor of the chosen vertex

		            List<Edge> nextNeighbors = next.getNeighbors();

		            for(Edge e: nextNeighbors){

		                Vertex other = e.getNeighbor(next);

		                if(this.visitedVertices.contains(other)){

		                    continue;

		                }



		                //we check if a shorter path exists

		                //and update to indicate a new shortest found path

		                //in the graph

		                int currentWeight = this.distances.get(other.getLabel());

		                int newWeight = distanceToNext + e.getWeight();

		                if(newWeight < currentWeight){

		                    this.predecessors.put(other.getLabel(), next.getLabel());

		                    this.distances.put(other.getLabel(), newWeight);

		                    this.availableVertices.remove(other);

		                    this.availableVertices.add(other);

		                }

		            }


		            // finally, mark the selected vertex as visited

		            // so we don't revisit it

		            this.visitedVertices.add(next);

		        }

		    }

		    /*
		     * @param destinationLabel The Vertex whose shortest path from the initial Vertex is desired
		     * @return LinkedList<Vertex> A sequence of Vertex objects starting at the
		     *         initial Vertex and terminating at the Vertex specified by destinationLabel.
		     *         The path is the shortest path specified by Dijkstra's algorithm.
		     */

		    public List<Vertex> getPathTo(String destinationLabel){

		        LinkedList<Vertex> path = new LinkedList<Vertex>();
		        path.add(graph.getVertex(destinationLabel));
		        while(!destinationLabel.equals(this.initialVertexLabel)){

		            Vertex predecessor = graph.getVertex(this.predecessors.get(destinationLabel));
		            destinationLabel = predecessor.getLabel();
		            path.add(0, predecessor);

		        }

		        return path;
		    }


		    /*
		     * @param destinationLabel The Vertex to determine the distance from the initial Vertex

		     * @return int The distance from the initial Vertex to the Vertex specified by destinationLabel

		     */

		    public int getDistanceTo(String destinationLabel){

		        return this.distances.get(destinationLabel);

		    }


		}



}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class gB {

  public static void main(String[] args) throws IOException {


	Graph g ;
	Vertex[] vertices;

	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	int numCase, conex, pc,A, B;
	String str, spl[], cadena, arr[];


	numCase= Integer.parseInt(br.readLine());

	for (int i = 0; i < numCase; i++) {
	  System.out.println("Caso #" + (i+1)+":");

	  g= new Graph();

	  str=br.readLine();
	  spl=str.split("\\s+");
	  conex=Integer.parseInt(spl[1]);
	  pc=Integer.parseInt(spl[0]);
	  vertices = new Vertex[pc];

	  for (int j = 0; j < vertices.length; j++) {
		vertices[j] = new Vertex(j + "");
		g.addVertex(vertices[j], true);
	  }

	  Edge[] edges = new Edge[conex];

	  for (int j = 0; j < conex; j++) {
		cadena=br.readLine();
		arr=cadena.split("\\s+");
		A=Integer.parseInt(arr[0]);
		B=Integer.parseInt(arr[1]);
		edges[j] = new Edge(vertices[A], vertices[B], Integer.parseInt(arr[2]));
	  }

	  for(Edge e: edges){
		g.addEdge(e.getOne(), e.getTwo(), e.getWeight());
	  }


	  if(conex==0){
		System.out.println("inalcanzable");
	  }
	  else{
		Dijkstra dijkstra = new Dijkstra(g, vertices[Integer.parseInt(spl[2])].getLabel());
		System.out.println(dijkstra.getDistanceTo(spl[3]));
	  }



	}




//	Graph graph = new Graph();
//	Vertex[] vertices = new Vertex[6];
//
//	for(int i = 0; i < vertices.length; i++){
//		vertices[i] = new Vertex(i + "");
//        graph.addVertex(vertices[i], true);
//
//		        }
//
//		        Edge[] edges = new Edge[9];
//		        edges[0] = new Edge(vertices[0], vertices[1], 7);
//		        edges[1] = new Edge(vertices[0], vertices[2], 9);
//		        edges[2] = new Edge(vertices[0], vertices[5], 14);
//		        edges[3] = new Edge(vertices[1], vertices[2], 10);
//		        edges[4] = new Edge(vertices[1], vertices[3], 15);
//		        edges[5] = new Edge(vertices[2], vertices[3], 11);
//		        edges[6] = new Edge(vertices[2], vertices[5], 2);
//		        edges[7] = new Edge(vertices[3], vertices[4], 6);
//		        edges[8] = new Edge(vertices[4], vertices[5], 9);
//
//
//		        for(Edge e: edges){
//		            graph.addEdge(e.getOne(), e.getTwo(), e.getWeight());
//		        }
//
//		        Dijkstra dijkstra = new Dijkstra(graph, vertices[0].getLabel());
//
//		        System.out.println(dijkstra.getDistanceTo("5"));
//		        System.out.println(dijkstra.getPathTo("5"));
  }




  public static class Vertex {

		    private ArrayList<Edge> neighborhood;
		    private String label;
		    /*
		      * @param label The unique label associated with this Vertex
		     */

		    public Vertex(String label){
		        this.label = label;
		        this.neighborhood = new ArrayList<Edge>();
		    }

		    /*
		     * This method adds an Edge to the incidence neighborhood of this graph iff
		     * the edge is not already present.
		     * @param edge The edge to add
		     */

		    public void addNeighbor(Edge edge){
			        if(this.neighborhood.contains(edge)){
		            return;
		        }

		        this.neighborhood.add(edge);
		    }

		    /*
		     * @param other The edge for which to search
		     * @return true iff other is contained in this.neighborhood
		     */

		    public boolean containsNeighbor(Edge other){
		        return this.neighborhood.contains(other);
		    }

		    /*
		     * @param index The index of the Edge to retrieve
		     * @return Edge The Edge at the specified index in this.neighborhood
		     */

		    public Edge getNeighbor(int index){
		        return this.neighborhood.get(index);
		    }



		    /*
		     * @param e The Edge to remove from this.neighborhood
		     */

		    public void removeNeighbor(Edge e){
		        this.neighborhood.remove(e);
		      }

		    /*
		     * @return int The number of neighbors of this Vertex
		     */

		    public int getNeighborCount(){
		        return this.neighborhood.size();
		    }

		    /*
		     * @return String The label of this Vertex
		     */

		    public String getLabel(){
		        return this.label;
		    }


		    /*
		     * @return ArrayList<Edge> A copy of this.neighborhood. Modifying the returned
		     * ArrayList will not affect the neighborhood of this Vertex
		     */

		    public ArrayList<Edge> getNeighbors(){
		        return new ArrayList<Edge>(this.neighborhood);
		    }

	}




  public static class Edge implements Comparable<Edge> {
		    private Vertex one, two;
		    private int weight;

		    /*
		     * @param one The first vertex in the Edge
		     * @param two The second vertex in the Edge
		     */

		    public Edge(Vertex one, Vertex two){
		        this(one, two, 1);
		    }



		    /*
		     * @param one The first vertex in the Edge
		     * @param two The second vertex of the Edge
		     * @param weight The weight of this Edge
		     */

		    public Edge(Vertex one, Vertex two, int weight){
		        this.one = (one.getLabel().compareTo(two.getLabel()) <= 0) ? one : two;
		        this.two = (this.one == one) ? two : one;
		        this.weight = weight;
		    }

		    /*
		     * @param current
		     * @return The neighbor of current along this Edge
		     */

		    public Vertex getNeighbor(Vertex current){
		        if(!(current.equals(one) || current.equals(two))){

		            return null;
		        }

		        return (current.equals(one)) ? two : one;
		    }


		    /*
		     * @return Vertex this.one
		     */

		    public Vertex getOne(){
		        return this.one;
		    }

		    /*
		     * @return Vertex this.two
		     */

		    public Vertex getTwo(){
		        return this.two;
		    }
		    /*
		     * @return int The weight of this Edge

		     */

		    public int getWeight(){
		        return this.weight;
		    }


		    /*
		     * @param weight The new weight of this Edge
		     */

		    public void setWeight(int weight){
		        this.weight = weight;
		    }

		    /*
		     * Note that the compareTo() method deviates from

		     * the specifications in the Comparable interface. A

		     * return value of 0 does not indicate that this.equals(other).

		     * The equals() method checks the Vertex endpoints, while the

		     * compareTo() is used to compare Edge weights

		     * @param other The Edge to compare against this

		     * @return int this.weight - other.weight

		     */

		    public int compareTo(Edge other){
		        return this.weight - other.weight;
		    }

		    /*
		     * @return String A String representation of this Edge
		     */

		    public String toString(){
		        return "({" + one + ", " + two + "}, " + weight + ")";
		    }


		    /*
		     * @return int The hash code for this Edge
		     */

		    public int hashCode(){
		        return (one.getLabel() + two.getLabel()).hashCode();
		    }


		    /*
		     * @param other The Object to compare against this

		     * @return ture iff other is an Edge with the same Vertices as this
	    */

		    public boolean equals(Object other){
		        if(!(other instanceof Edge)){
		            return false;
		        }

		        Edge e = (Edge)other;

		        return e.one.equals(this.one) && e.two.equals(this.two);
		    }

		}



  public static class Graph {
			private HashMap<String, Vertex> vertices;

		    private HashMap<Integer, Edge> edges;

		    public Graph(){

		        this.vertices = new HashMap<String, Vertex>();

		        this.edges = new HashMap<Integer, Edge>();
		    }

		    /*
		     * This constructor accepts an ArrayList<Vertex> and populates
		     * this.vertices. If multiple Vertex objects have the same label,
		     * then the last Vertex with the given label is used.
		     *
		     * @param vertices The initial Vertices to populate this Graph
		     */

		    public Graph(ArrayList<Vertex> vertices){
		        this.vertices = new HashMap<String, Vertex>();
		        this.edges = new HashMap<Integer, Edge>();

		        for(Vertex v: vertices){
		            this.vertices.put(v.getLabel(), v);
		        }
		    }

		    /*
		     * This method adds am edge between Vertices one and two

		     * of weight 1, if no Edge between these Vertices already

		     * exists in the Graph.
		     * @param one The first vertex to add
		     * @param two The second vertex to add
		     * @return true iff no Edge relating one and two exists in the Graph
		     */

		    public boolean addEdge(Vertex one, Vertex two){
		        return addEdge(one, two, 1);
		    }

		    /*
		     * Accepts two vertices and a weight, and adds the edge
		     * ({one, two}, weight) iff no Edge relating one and two
		     * exists in the Graph.

		     * @param one The first Vertex of the Edge
		     * @param two The second Vertex of the Edge
		     * @param weight The weight of the Edge
		     * @return true iff no Edge already exists in the Graph
		     */

		    public boolean addEdge(Vertex one, Vertex two, int weight){
		        if(one.equals(two)){
		            return false;
		        }

		        //ensures the Edge is not in the Graph
		        Edge e = new Edge(one, two, weight);
		        if(edges.containsKey(e.hashCode())){
		            return false;
		        }

		        //and that the Edge isn't already incident to one of the vertices

		        else if(one.containsNeighbor(e) || two.containsNeighbor(e)){
		            return false;
		        }

		        edges.put(e.hashCode(), e);
		        one.addNeighbor(e);
		        two.addNeighbor(e);
		        return true;
		    }

		    /*
		     * @param e The Edge to look up
		     * @return true iff this Graph contains the Edge e
		     */

		    public boolean containsEdge(Edge e){
		        if(e.getOne() == null || e.getTwo() == null){
		            return false;
			        }

		        return this.edges.containsKey(e.hashCode());
		    }


		    /*
		     * This method removes the specified Edge from the Graph,
		     * including as each vertex's incidence neighborhood.
		     * @param e The Edge to remove from the Graph
		     * @return Edge The Edge removed from the Graph
		     */

		    public Edge removeEdge(Edge e){
		       e.getOne().removeNeighbor(e);
		       e.getTwo().removeNeighbor(e);
		       return this.edges.remove(e.hashCode());
		    }

		    /*
		     * @param vertex The Vertex to look up
		     * @return true iff this Graph contains vertex
		     */

		    public boolean containsVertex(Vertex vertex){
		        return this.vertices.get(vertex.getLabel()) != null;
		    }

		    /*
		     * @param label The specified Vertex label
		     * @return Vertex The Vertex with the specified label
		     */

		    public Vertex getVertex(String label){
		        return vertices.get(label);
		    }

		    /*
		     * This method adds a Vertex to the graph. If a Vertex with the same label
		     * as the parameter exists in the Graph, the existing Vertex is overwritten
		     * only if overwriteExisting is true. If the existing Vertex is overwritten,
		     * the Edges incident to it are all removed from the Graph.
		     * @param vertex
		     * @param overwriteExisting
		     * @return true iff vertex was added to the Graph
		     */

		    public boolean addVertex(Vertex vertex, boolean overwriteExisting){
		        Vertex current = this.vertices.get(vertex.getLabel());
		        if(current != null){
		            if(!overwriteExisting){
		                return false;
		            }

		            while(current.getNeighborCount() > 0){
		                this.removeEdge(current.getNeighbor(0));
		            }
		        }

		        vertices.put(vertex.getLabel(), vertex);
		        return true;

		    }

		    /*
		     * @param label The label of the Vertex to remove
		     * @return Vertex The removed Vertex object
		     */

		    public Vertex removeVertex(String label){
		        Vertex v = vertices.remove(label);
		        while(v.getNeighborCount() > 0){
		            this.removeEdge(v.getNeighbor((0)));
		        }
	     return v;

		    }

		    /*
		     * @return Set<String> The unique labels of the Graph's Vertex objects
		     */

		    public Set<String> vertexKeys(){
		        return this.vertices.keySet();
		    }

		    /*
		     * @return Set<Edge> The Edges of this graph
		     */

		    public Set<Edge> getEdges(){
		        return new HashSet<Edge>(this.edges.values());
		    }
		}




  public static class Dijkstra {


		    private Graph graph;
		    private String initialVertexLabel;
		    private HashMap<String, String> predecessors;
		    private HashMap<String, Integer> distances;
		    private PriorityQueue<Vertex> availableVertices;
		    private HashSet<Vertex> visitedVertices;

		    /**
		     * This constructor initializes this Dijkstra object and executes
		     * Dijkstra's algorithm on the graph given the specified initialVertexLabel.
		     * After the algorithm terminates, the shortest a-b paths and the corresponding
		     * distances will be available for all vertices b in the graph.
		     *

		     * @param graph The Graph to traverse
		     * @param initialVertexLabel The starting Vertex label
		     * @throws IllegalArgumentException If the specified initial vertex is not in the Graph
		     */

		    public Dijkstra(Graph graph, String initialVertexLabel){

		        this.graph = graph;

		        Set<String> vertexKeys = this.graph.vertexKeys();

		        if(!vertexKeys.contains(initialVertexLabel)){
		            throw new IllegalArgumentException("The graph must contain the initial vertex.");
		        }

		        this.initialVertexLabel = initialVertexLabel;
		        this.predecessors = new HashMap<String, String>();
		        this.distances = new HashMap<String, Integer>();
		        this.availableVertices = new PriorityQueue<Vertex>(vertexKeys.size(), new Comparator<Vertex>(){



		            public int compare(Vertex one, Vertex two){

		                int weightOne = Dijkstra.this.distances.get(one.getLabel());

		                int weightTwo = Dijkstra.this.distances.get(two.getLabel());

		                return weightOne - weightTwo;

		            }

		        });


		        this.visitedVertices = new HashSet<Vertex>();



		        //for each Vertex in the graph

		        //assume it has distance infinity denoted by Integer.MAX_VALUE

		        for(String key: vertexKeys){

		            this.predecessors.put(key, null);

		            this.distances.put(key, Integer.MAX_VALUE);

		        }


		        //the distance from the initial vertex to itself is 0

		        this.distances.put(initialVertexLabel, 0);

		        //and seed initialVertex's neighbors

		        Vertex initialVertex = this.graph.getVertex(initialVertexLabel);

		        ArrayList<Edge> initialVertexNeighbors = initialVertex.getNeighbors();

		        for(Edge e : initialVertexNeighbors){

		            Vertex other = e.getNeighbor(initialVertex);

		            this.predecessors.put(other.getLabel(), initialVertexLabel);

		            this.distances.put(other.getLabel(), e.getWeight());

		            this.availableVertices.add(other);

		        }

		        this.visitedVertices.add(initialVertex);

		        //now apply Dijkstra's algorithm to the Graph

		        processGraph();

		    }



		    /*
		     * This method applies Dijkstra's algorithm to the graph using the Vertex
		     * specified by initialVertexLabel as the starting point.
		     *
		     * @post The shortest a-b paths as specified by Dijkstra's algorithm and
		     *       their distances are available

		     */

		    private void processGraph(){



		        //as long as there are Edges to process

		        while(this.availableVertices.size() > 0){
		          //pick the cheapest vertex

		            Vertex next = this.availableVertices.poll();

		            int distanceToNext = this.distances.get(next.getLabel());


		            //and for each available neighbor of the chosen vertex

		            List<Edge> nextNeighbors = next.getNeighbors();

		            for(Edge e: nextNeighbors){

		                Vertex other = e.getNeighbor(next);

		                if(this.visitedVertices.contains(other)){

		                    continue;

		                }



		                //we check if a shorter path exists

		                //and update to indicate a new shortest found path

		                //in the graph

		                int currentWeight = this.distances.get(other.getLabel());

		                int newWeight = distanceToNext + e.getWeight();

		                if(newWeight < currentWeight){

		                    this.predecessors.put(other.getLabel(), next.getLabel());

		                    this.distances.put(other.getLabel(), newWeight);

		                    this.availableVertices.remove(other);

		                    this.availableVertices.add(other);

		                }

		            }


		            // finally, mark the selected vertex as visited

		            // so we don't revisit it

		            this.visitedVertices.add(next);

		        }

		    }

		    /*
		     * @param destinationLabel The Vertex whose shortest path from the initial Vertex is desired
		     * @return LinkedList<Vertex> A sequence of Vertex objects starting at the
		     *         initial Vertex and terminating at the Vertex specified by destinationLabel.
		     *         The path is the shortest path specified by Dijkstra's algorithm.
		     */

		    public List<Vertex> getPathTo(String destinationLabel){

		        LinkedList<Vertex> path = new LinkedList<Vertex>();
		        path.add(graph.getVertex(destinationLabel));
		        while(!destinationLabel.equals(this.initialVertexLabel)){

		            Vertex predecessor = graph.getVertex(this.predecessors.get(destinationLabel));
		            destinationLabel = predecessor.getLabel();
		            path.add(0, predecessor);

		        }

		        return path;
		    }


		    /*
		     * @param destinationLabel The Vertex to determine the distance from the initial Vertex

		     * @return int The distance from the initial Vertex to the Vertex specified by destinationLabel

		     */

		    public int getDistanceTo(String destinationLabel){

		        return this.distances.get(destinationLabel);

		    }


		}



}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class gB {

  public static void main(String[] args) throws IOException {


	Graph g ;
	Vertex[] vertices;

	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	int numCase, conex, pc,A, B;
	String str, spl[], cadena, arr[];


	numCase= Integer.parseInt(br.readLine());

	for (int i = 0; i < numCase; i++) {
	  System.out.println("Caso #" + (i+1)+":");

	  g= new Graph();

	  str=br.readLine();
	  spl=str.split("\\s+");
	  conex=Integer.parseInt(spl[1]);
	  pc=Integer.parseInt(spl[0]);
	  vertices = new Vertex[pc];

	  for (int j = 0; j < vertices.length; j++) {
		vertices[j] = new Vertex(j + "");
		g.addVertex(vertices[j], true);
	  }

	  Edge[] edges = new Edge[conex];

	  for (int j = 0; j < conex; j++) {
		cadena=br.readLine();
		arr=cadena.split("\\s+");
		A=Integer.parseInt(arr[0]);
		B=Integer.parseInt(arr[1]);
		edges[j] = new Edge(vertices[A], vertices[B], Integer.parseInt(arr[2]));
	  }

	  for(Edge e: edges){
		g.addEdge(e.getOne(), e.getTwo(), e.getWeight());
	  }

	 
	Dijkstra dijkstra = new Dijkstra(g, vertices[Integer.parseInt(spl[2])].getLabel());
	int camino= dijkstra.getDistanceTo(spl[3]);
        if(camino>1000000){
            System.out.println("inalcanzable");
               
        }
        else{
            System.out.println(camino);
        }
            
	  
	}
  }




  public static class Vertex {

		    private ArrayList<Edge> neighborhood;
		    private String label;
		    /*
		      * @param label The unique label associated with this Vertex
		     */

		    public Vertex(String label){
		        this.label = label;
		        this.neighborhood = new ArrayList<Edge>();
		    }

		
		    public void addNeighbor(Edge edge){
			        if(this.neighborhood.contains(edge)){
		            return;
		        }

		        this.neighborhood.add(edge);
		    }

		

		    public boolean containsNeighbor(Edge other){
		        return this.neighborhood.contains(other);
		    }

	
		    public Edge getNeighbor(int index){
		        return this.neighborhood.get(index);
		    }




		    public void removeNeighbor(Edge e){
		        this.neighborhood.remove(e);
		      }

		    /*
		     * @return int The number of neighbors of this Vertex
		     */

		    public int getNeighborCount(){
		        return this.neighborhood.size();
		    }

		    /*
		     * @return String The label of this Vertex
		     */

		    public String getLabel(){
		        return this.label;
		    }


		    /*
		     * @return ArrayList<Edge> A copy of this.neighborhood. Modifying the returned
		     * ArrayList will not affect the neighborhood of this Vertex
		     */

		    public ArrayList<Edge> getNeighbors(){
		        return new ArrayList<Edge>(this.neighborhood);
		    }

	}




  public static class Edge implements Comparable<Edge> {
		    private Vertex one, two;
		    private int weight;

		    /*
		     * @param one The first vertex in the Edge
		     * @param two The second vertex in the Edge
		     */

		    public Edge(Vertex one, Vertex two){
		        this(one, two, 1);
		    }



		    /*
		     * @param one The first vertex in the Edge
		     * @param two The second vertex of the Edge
		     * @param weight The weight of this Edge
		     */

		    public Edge(Vertex one, Vertex two, int weight){
		        this.one = (one.getLabel().compareTo(two.getLabel()) <= 0) ? one : two;
		        this.two = (this.one == one) ? two : one;
		        this.weight = weight;
		    }

		    /*
		     * @param current
		     * @return The neighbor of current along this Edge
		     */

		    public Vertex getNeighbor(Vertex current){
		        if(!(current.equals(one) || current.equals(two))){

		            return null;
		        }

		        return (current.equals(one)) ? two : one;
		    }


		    /*
		     * @return Vertex this.one
		     */

		    public Vertex getOne(){
		        return this.one;
		    }

		    /*
		     * @return Vertex this.two
		     */

		    public Vertex getTwo(){
		        return this.two;
		    }
		    /*
		     * @return int The weight of this Edge

		     */

		    public int getWeight(){
		        return this.weight;
		    }


		    /*
		     * @param weight The new weight of this Edge
		     */

		    public void setWeight(int weight){
		        this.weight = weight;
		    }

	

		    public int compareTo(Edge other){
		        return this.weight - other.weight;
		    }

		    /*
		     * @return String A String representation of this Edge
		     */

		    public String toString(){
		        return "({" + one + ", " + two + "}, " + weight + ")";
		    }


		    /*
		     * @return int The hash code for this Edge
		     */

		    public int hashCode(){
		        return (one.getLabel() + two.getLabel()).hashCode();
		    }


		    public boolean equals(Object other){
		        if(!(other instanceof Edge)){
		            return false;
		        }

		        Edge e = (Edge)other;

		        return e.one.equals(this.one) && e.two.equals(this.two);
		    }

		}



  public static class Graph {
			private HashMap<String, Vertex> vertices;

		    private HashMap<Integer, Edge> edges;

		    public Graph(){

		        this.vertices = new HashMap<String, Vertex>();

		        this.edges = new HashMap<Integer, Edge>();
		    }

		    /*
		     * This constructor accepts an ArrayList<Vertex> and populates
		     * this.vertices. If multiple Vertex objects have the same label,
		     * then the last Vertex with the given label is used.
		     *
		     * @param vertices The initial Vertices to populate this Graph
		     */

		    public Graph(ArrayList<Vertex> vertices){
		        this.vertices = new HashMap<String, Vertex>();
		        this.edges = new HashMap<Integer, Edge>();

		        for(Vertex v: vertices){
		            this.vertices.put(v.getLabel(), v);
		        }
		    }

		    /*
		     * This method adds am edge between Vertices one and two

		     * of weight 1, if no Edge between these Vertices already

		     * exists in the Graph.
		     * @param one The first vertex to add
		     * @param two The second vertex to add
		     * @return true iff no Edge relating one and two exists in the Graph
		     */

		    public boolean addEdge(Vertex one, Vertex two){
		        return addEdge(one, two, 1);
		    }

		    /*
		     * Accepts two vertices and a weight, and adds the edge
		     * ({one, two}, weight) iff no Edge relating one and two
		     * exists in the Graph.

		     * @param one The first Vertex of the Edge
		     * @param two The second Vertex of the Edge
		     * @param weight The weight of the Edge
		     * @return true iff no Edge already exists in the Graph
		     */

		    public boolean addEdge(Vertex one, Vertex two, int weight){
		        if(one.equals(two)){
		            return false;
		        }

		        //ensures the Edge is not in the Graph
		        Edge e = new Edge(one, two, weight);
		        if(edges.containsKey(e.hashCode())){
		            return false;
		        }

		        //and that the Edge isn't already incident to one of the vertices

		        else if(one.containsNeighbor(e) || two.containsNeighbor(e)){
		            return false;
		        }

		        edges.put(e.hashCode(), e);
		        one.addNeighbor(e);
		        two.addNeighbor(e);
		        return true;
		    }

		    /*
		     * @param e The Edge to look up
		     * @return true iff this Graph contains the Edge e
		     */

		    public boolean containsEdge(Edge e){
		        if(e.getOne() == null || e.getTwo() == null){
		            return false;
			        }

		        return this.edges.containsKey(e.hashCode());
		    }


		    /*
		     * This method removes the specified Edge from the Graph,
		     * including as each vertex's incidence neighborhood.
		     * @param e The Edge to remove from the Graph
		     * @return Edge The Edge removed from the Graph
		     */

		    public Edge removeEdge(Edge e){
		       e.getOne().removeNeighbor(e);
		       e.getTwo().removeNeighbor(e);
		       return this.edges.remove(e.hashCode());
		    }

		    /*
		     * @param vertex The Vertex to look up
		     * @return true iff this Graph contains vertex
		     */

		    public boolean containsVertex(Vertex vertex){
		        return this.vertices.get(vertex.getLabel()) != null;
		    }

		    /*
		     * @param label The specified Vertex label
		     * @return Vertex The Vertex with the specified label
		     */

		    public Vertex getVertex(String label){
		        return vertices.get(label);
		    }

		    /*
		     * This method adds a Vertex to the graph. If a Vertex with the same label
		     * as the parameter exists in the Graph, the existing Vertex is overwritten
		     * only if overwriteExisting is true. If the existing Vertex is overwritten,
		     * the Edges incident to it are all removed from the Graph.
		     * @param vertex
		     * @param overwriteExisting
		     * @return true iff vertex was added to the Graph
		     */

		    public boolean addVertex(Vertex vertex, boolean overwriteExisting){
		        Vertex current = this.vertices.get(vertex.getLabel());
		        if(current != null){
		            if(!overwriteExisting){
		                return false;
		            }

		            while(current.getNeighborCount() > 0){
		                this.removeEdge(current.getNeighbor(0));
		            }
		        }

		        vertices.put(vertex.getLabel(), vertex);
		        return true;

		    }

		    /*
		     * @param label The label of the Vertex to remove
		     * @return Vertex The removed Vertex object
		     */

		    public Vertex removeVertex(String label){
		        Vertex v = vertices.remove(label);
		        while(v.getNeighborCount() > 0){
		            this.removeEdge(v.getNeighbor((0)));
		        }
	     return v;

		    }

		    /*
		     * @return Set<String> The unique labels of the Graph's Vertex objects
		     */

		    public Set<String> vertexKeys(){
		        return this.vertices.keySet();
		    }

		    /*
		     * @return Set<Edge> The Edges of this graph
		     */

		    public Set<Edge> getEdges(){
		        return new HashSet<Edge>(this.edges.values());
		    }
		}




  public static class Dijkstra {


		    private Graph graph;
		    private String initialVertexLabel;
		    private HashMap<String, String> predecessors;
		    private HashMap<String, Integer> distances;
		    private PriorityQueue<Vertex> availableVertices;
		    private HashSet<Vertex> visitedVertices;

		

		    public Dijkstra(Graph graph, String initialVertexLabel){

		        this.graph = graph;

		        Set<String> vertexKeys = this.graph.vertexKeys();

		        if(!vertexKeys.contains(initialVertexLabel)){
		            throw new IllegalArgumentException("The graph must contain the initial vertex.");
		        }

		        this.initialVertexLabel = initialVertexLabel;
		        this.predecessors = new HashMap<String, String>();
		        this.distances = new HashMap<String, Integer>();
		        this.availableVertices = new PriorityQueue<Vertex>(vertexKeys.size(), new Comparator<Vertex>(){



		            public int compare(Vertex one, Vertex two){

		                int weightOne = Dijkstra.this.distances.get(one.getLabel());

		                int weightTwo = Dijkstra.this.distances.get(two.getLabel());

		                return weightOne - weightTwo;

		            }

		        });


		        this.visitedVertices = new HashSet<Vertex>();



		        //for each Vertex in the graph

		        //assume it has distance infinity denoted by Integer.MAX_VALUE

		        for(String key: vertexKeys){

		            this.predecessors.put(key, null);

		            this.distances.put(key, Integer.MAX_VALUE);

		        }


		        //the distance from the initial vertex to itself is 0

		        this.distances.put(initialVertexLabel, 0);

		        //and seed initialVertex's neighbors

		        Vertex initialVertex = this.graph.getVertex(initialVertexLabel);

		        ArrayList<Edge> initialVertexNeighbors = initialVertex.getNeighbors();

		        for(Edge e : initialVertexNeighbors){

		            Vertex other = e.getNeighbor(initialVertex);

		            this.predecessors.put(other.getLabel(), initialVertexLabel);

		            this.distances.put(other.getLabel(), e.getWeight());

		            this.availableVertices.add(other);

		        }

		        this.visitedVertices.add(initialVertex);

		        //now apply Dijkstra's algorithm to the Graph

		        processGraph();

		    }



		    /*
		     * This method applies Dijkstra's algorithm to the graph using the Vertex
		     * specified by initialVertexLabel as the starting point.
		     *
		     * @post The shortest a-b paths as specified by Dijkstra's algorithm and
		     *       their distances are available

		     */

		    private void processGraph(){



		        //as long as there are Edges to process

		        while(this.availableVertices.size() > 0){
		          //pick the cheapest vertex

		            Vertex next = this.availableVertices.poll();

		            int distanceToNext = this.distances.get(next.getLabel());


		            //and for each available neighbor of the chosen vertex

		            List<Edge> nextNeighbors = next.getNeighbors();

		            for(Edge e: nextNeighbors){

		                Vertex other = e.getNeighbor(next);

		                if(this.visitedVertices.contains(other)){

		                    continue;

		                }



		                //we check if a shorter path exists

		                //and update to indicate a new shortest found path

		                //in the graph

		                int currentWeight = this.distances.get(other.getLabel());

		                int newWeight = distanceToNext + e.getWeight();

		                if(newWeight < currentWeight){

		                    this.predecessors.put(other.getLabel(), next.getLabel());

		                    this.distances.put(other.getLabel(), newWeight);

		                    this.availableVertices.remove(other);

		                    this.availableVertices.add(other);

		                }

		            }


		            // finally, mark the selected vertex as visited

		            // so we don't revisit it

		            this.visitedVertices.add(next);

		        }

		    }

		    /*
		     * @param destinationLabel The Vertex whose shortest path from the initial Vertex is desired
		     * @return LinkedList<Vertex> A sequence of Vertex objects starting at the
		     *         initial Vertex and terminating at the Vertex specified by destinationLabel.
		     *         The path is the shortest path specified by Dijkstra's algorithm.
		     */

		    public List<Vertex> getPathTo(String destinationLabel){

		        LinkedList<Vertex> path = new LinkedList<Vertex>();
		        path.add(graph.getVertex(destinationLabel));
		        while(!destinationLabel.equals(this.initialVertexLabel)){

		            Vertex predecessor = graph.getVertex(this.predecessors.get(destinationLabel));
		            destinationLabel = predecessor.getLabel();
		            path.add(0, predecessor);

		        }

		        return path;
		    }


		    /*
		     * @param destinationLabel The Vertex to determine the distance from the initial Vertex

		     * @return int The distance from the initial Vertex to the Vertex specified by destinationLabel

		     */

		    public int getDistanceTo(String destinationLabel){

		        return this.distances.get(destinationLabel);

		    }


		}



}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


public class gA {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	MyLinkedList<Character> lista;
	MyLinkedList<Integer> li= new MyLinkedList<>();
	int numCase, num,aux=0, aux2=0, count;
	String str, spl[],cadena, split[];
	char A, B, op;
	
	 boolean x=true,y=true;
	HashMap<Integer, Character> map;
	HashMap<Integer, Character> map2;
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
	  System.out.println("Caso #"+(i+1)+":");
	  num=Integer.parseInt(br.readLine());
	  Graph g = new Graph(num);
	  str=br.readLine();
	  spl=str.split("\\s+");
	  map=new HashMap<>();
	  map2=new HashMap<>();
	  count=0;
	  lista= new MyLinkedList<>();
	  
	  for (String st : spl) {
		lista.add(st.charAt(0));	
		map.put(count, st.charAt(0));
		map2.put(count, st.charAt(0));
		count++;
	  }
	  cadena=br.readLine();
	  split=cadena.split("\\s+");
	  
	  for (String st : split) {
		A=st.charAt(0);	
		op=st.charAt(1);
		B=st.charAt(2);
		
	
		if(op=='<'){
		  for (int j = 0; j < lista.size(); j++) {
			if(A==lista.get(j)){			  
			  aux=j;	
			  map.remove(j);
			}
			
			if(B==lista.get(j)){
			  aux2=j;	
			  map.remove(j);
			}
		  }
		 
		  x=g.addEdge(aux, aux2);
		 
		}
		else{
		  for (int j = 0; j < lista.size(); j++) {
			if(A==lista.get(j))			  
			  aux=j;
			
			if(B==lista.get(j))
			  aux2=j;
		  }
		 		  
		  y=g.addEdge(aux2, aux);
		  
		}
		
	  }
	  
	  if(x==false || y==false){
		System.out.println("NO");
		continue;
	  }
	  	
	  li=g.topologicalSort();
	 
	 
	 
	  HashSet<Integer> set= new HashSet <>(); 
	  
	  Object b []=map.keySet().toArray();

	  
	  for (int j = 0; j < b.length; j++) {;
		int r = (int) b[j];		
		Iterator<Integer> k = li.iterator();
		while (k.hasNext()) {
		  Integer inte = (Integer) k.next();		  
		  if(inte==r){			
			li.remove(j);
			break;
		  }		 		  
		}	
	  }
	  
	  //System.out.println(li);
	  
	  Iterator<Integer> k = li.iterator();
	  while (k.hasNext()) {
		Integer integer = (Integer) k.next();
		System.out.print(map2.get(integer)+ " ");
		map2.remove(integer);

	  }
	  
	  Object e[]=map2.keySet().toArray();
	 for (int j = 0; j < e.length; j++) {
	   int r= (int) e[j];
	   System.out.println(map2.get(r)+" ");
	   
	  
	 }
	  
	}
	li.doClear();
	
  }
  

  public static class Graph
  {
      private int V;   // # of vertices
      private MyLinkedList<Integer> adj[]; // Adjacency List
      private MyLinkedList<Integer> l;
   
      //Constructor
      Graph(int v)
      {
          V = v;
          adj = new MyLinkedList[v];
          for (int i=0; i<v; ++i)
              adj[i] = new MyLinkedList();
      }
   
      // Function to add an edge into the graph
      boolean addEdge(int v,int w) { 
    	if(adj[w].size() >0){
    	for (int i = 0; i < adj[w].size(); i++) {
    	  if(adj[w].get(i)==v)
    		return false;		  
		}
    	}
    	
    	adj[v].add(w);
    	return true;
      }
   
      // A recursive function used by topologicalSort
      void topologicalSortUtil(int v, Boolean visited[],MyStack stack)
      {
          // Mark the current node as visited.
          visited[v] = true;
          Integer i;
   
          // Recur for all the vertices adjacent to this vertex
          Iterator<Integer> it = adj[v].iterator();
          while (it.hasNext())
          {
              i = it.next();
              if (!visited[i])
                  topologicalSortUtil(i, visited, stack);
          }
   
          // Push current vertex to stack which stores result
          stack.push(new Integer(v));
      }
   
      // The function to do Topological Sort. It uses recursive
      // topologicalSortUtil()
      
      MyLinkedList<Integer> topologicalSort()
      {
    	
    		l=new MyLinkedList<>();
          MyStack <Integer> stack= new MyStack<>();
   
          // Mark all the vertices as not visited
          Boolean visited[] = new Boolean[V];
          for (int i = 0; i < V; i++)
              visited[i] = false;
   
          // Call the recursive helper function to store Topological
          // Sort starting from all vertices one by one
          for (int i = 0; i < V; i++)
              if (visited[i] == false)
                  topologicalSortUtil(i, visited, stack);
   
          // Print contents of stack
          while (stack.isEmpty()==false)
             l.add(stack.pop());
          
          return l;
      }
   
  }
  public static class MyLinkedList<AnyType> implements Iterable<AnyType>
  {

    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    
    
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    
    
   /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private  class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;

  }
  

  
  public static class MyStack <AnyType> 
  {
	public static <E> void print (MyStack<E> s)
	{
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();
		System.out.println (elem);
		MyStack.<E>print (s);
		s.push (elem);
	  }
	}
	
	public static <E> int countElements(MyStack<E> s)
	{
	  c=0;
	  return MyStack.<E> numElements(s);
	}
	
	private static <E> int numElements (MyStack<E> s)
	{
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();
		c++;
		MyStack.<E> numElements(s);
		s.push (elem);
	  }
	  return c;
	}
	
	
	public static <E> MyStack<E> doble (MyStack<E> s, MyStack<E> t){
	  
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();		
		MyStack.<E> doble(s,t);
		t.push(elem);
		s.push (elem);
	  }
	  return t;
	  
	}
	
	
	public boolean contains (AnyType x){
	  for (int i = (size()-1); i >=0; i--) 
		if(theItems[i]==x)
		  return true;	
	  return false;
		
	  
	}
	
	
	
	public MyStack( )
	{
      doClear( );
	}
  
	public void clear( )
	{
	 doClear( );
	}
	  
	private void doClear( )
	{
	  theSize = 0;
	  ensureCapacity( DEFAULT_CAPACITY );
	}
 
	public int size( ) 
	{
      return theSize;
	}
	
	
 
	public boolean isEmpty( )
	{
      return size( ) == 0;
	}
  
  
  public AnyType top( )
  {
      return theItems[ size()-1 ];    
  }
      
 

  @SuppressWarnings("unchecked")
  public void ensureCapacity( int newCapacity )
  {
      if( newCapacity < theSize )
          return;

      AnyType [ ] old = theItems;
      theItems = (AnyType []) new Object[ newCapacity ];
      for( int i = 0; i < size( ); i++ )
          theItems[ i ] = old[ i ];
  }
  

  public boolean push( AnyType x )
  {
	add( size( ), x );
      return true;            
  }

  public void add( int idx, AnyType x )
  {
      if( theItems.length == size( ) )
          ensureCapacity( size( ) * 2 + 1 );

      for( int i = theSize; i > idx; i-- )
          theItems[ i ] = theItems[ i - 1 ];

      theItems[ idx ] = x;
      theSize++;  
  }
    
 
  public AnyType pop(  )
  {
      AnyType removedItem = theItems[ size()-1 ];      
      theSize--;          
      return removedItem;
  }
  
  
  private static final int DEFAULT_CAPACITY = 10;
  
  private AnyType [ ] theItems;  
  private int theSize;
  private static int c;
} 

  
  
  
  
  
  

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


public class gA {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	MyLinkedList<Character> lista;
	MyLinkedList<Integer> li= new MyLinkedList<>();
	int numCase, num,aux=0, aux2=0, count;
	String str, spl[],cadena, split[];
	char A, B, op;
	
	 boolean x=true,y=true;
	HashMap<Integer, Character> map;
	HashMap<Integer, Character> map2;
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
	  System.out.println("Caso #"+(i+1)+":");
	  num=Integer.parseInt(br.readLine());
	  Graph g = new Graph(num);
	  str=br.readLine();
	  spl=str.split("\\s+");
	  map=new HashMap<>();
	  map2=new HashMap<>();
	  count=0;
	  lista= new MyLinkedList<>();
	  
	  for (String st : spl) {
		lista.add(st.charAt(0));	
		map.put(count, st.charAt(0));
		map2.put(count, st.charAt(0));
		count++;
	  }
	  cadena=br.readLine();
	  split=cadena.split("\\s+");
	  
	  for (String st : split) {
		A=st.charAt(0);	
		op=st.charAt(1);
		B=st.charAt(2);
		
	
		if(op=='<'){
		  for (int j = 0; j < lista.size(); j++) {
			if(A==lista.get(j)){			  
			  aux=j;	
			  map.remove(j);
			}
			
			if(B==lista.get(j)){
			  aux2=j;	
			  map.remove(j);
			}
		  }
		 
		  x=g.addEdge(aux, aux2);
		 
		}
		else{
		  for (int j = 0; j < lista.size(); j++) {
			if(A==lista.get(j))			  
			  aux=j;
			
			if(B==lista.get(j))
			  aux2=j;
		  }
		 		  
		  y=g.addEdge(aux2, aux);
		  
		}
		
	  }
	  
	  if(x==false || y==false){
		System.out.println("NO");
		continue;
	  }
	  	
	  li=g.topologicalSort();
	 
	 
	 
	  HashSet<Integer> set= new HashSet <>(); 
	  
	  Object b []=map.keySet().toArray();

	  
	  for (int j = 0; j < b.length; j++) {;
		int r = (int) b[j];		
		Iterator<Integer> k = li.iterator();
		while (k.hasNext()) {
		  Integer inte = (Integer) k.next();		  
		  if(inte==r){			
			li.remove(j);
			break;
		  }		 		  
		}	
	  }
	  
	  //System.out.println(li);
	  
	  Iterator<Integer> k = li.iterator();
	  while (k.hasNext()) {
		Integer integer = (Integer) k.next();
		System.out.print(map2.get(integer)+ " ");
		map2.remove(integer);

	  }
	  
	  Object e[]=map2.keySet().toArray();
	 for (int j = 0; j < e.length; j++) {
	   int r= (int) e[j];
	   System.out.println(map2.get(r)+" ");
	   
	  
	 }
	  
	}
	li.doClear();
	
  }

  public static class Graph
  {
      private int V;   // # of vertices
      private MyLinkedList<Integer> adj[]; // Adjacency List
      private MyLinkedList<Integer> l;
   
      //Constructor
      Graph(int v)
      {
          V = v;
          adj = new MyLinkedList[v];
          for (int i=0; i<v; ++i)
              adj[i] = new MyLinkedList();
      }
   
      // Function to add an edge into the graph
      boolean addEdge(int v,int w) { 
    	if(adj[w].size() >0){
    	for (int i = 0; i < adj[w].size(); i++) {
    	  if(adj[w].get(i)==v)
    		return false;		  
		}
    	}
    	
    	adj[v].add(w);
    	return true;
      }
   
      // A recursive function used by topologicalSort
      void topologicalSortUtil(int v, Boolean visited[],MyStack stack)
      {
          // Mark the current node as visited.
          visited[v] = true;
          Integer i;
   
          // Recur for all the vertices adjacent to this vertex
          Iterator<Integer> it = adj[v].iterator();
          while (it.hasNext())
          {
              i = it.next();
              if (!visited[i])
                  topologicalSortUtil(i, visited, stack);
          }
   
          // Push current vertex to stack which stores result
          stack.push(new Integer(v));
      }
   
      // The function to do Topological Sort. It uses recursive
      // topologicalSortUtil()
      
      MyLinkedList<Integer> topologicalSort()
      {
    	
    		l=new MyLinkedList<>();
          MyStack <Integer> stack= new MyStack<>();
   
          // Mark all the vertices as not visited
          Boolean visited[] = new Boolean[V];
          for (int i = 0; i < V; i++)
              visited[i] = false;
   
          // Call the recursive helper function to store Topological
          // Sort starting from all vertices one by one
          for (int i = 0; i < V; i++)
              if (visited[i] == false)
                  topologicalSortUtil(i, visited, stack);
   
          // Print contents of stack
          while (stack.isEmpty()==false)
             l.add(stack.pop());
          
          return l;
      }
   
  }
  public static class MyLinkedList<AnyType> implements Iterable<AnyType>
  {

    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    
    
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    
    
   /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private  class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;

  }
  

  
  public static class MyStack <AnyType> 
  {
	public static <E> void print (MyStack<E> s)
	{
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();
		System.out.println (elem);
		MyStack.<E>print (s);
		s.push (elem);
	  }
	}
	
	public static <E> int countElements(MyStack<E> s)
	{
	  c=0;
	  return MyStack.<E> numElements(s);
	}
	
	private static <E> int numElements (MyStack<E> s)
	{
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();
		c++;
		MyStack.<E> numElements(s);
		s.push (elem);
	  }
	  return c;
	}
	
	
	public static <E> MyStack<E> doble (MyStack<E> s, MyStack<E> t){
	  
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();		
		MyStack.<E> doble(s,t);
		t.push(elem);
		s.push (elem);
	  }
	  return t;
	  
	}
	
	
	public boolean contains (AnyType x){
	  for (int i = (size()-1); i >=0; i--) 
		if(theItems[i]==x)
		  return true;	
	  return false;
		
	  
	}
	
	
	
	public MyStack( )
	{
      doClear( );
	}
  
	public void clear( )
	{
	 doClear( );
	}
	  
	private void doClear( )
	{
	  theSize = 0;
	  ensureCapacity( DEFAULT_CAPACITY );
	}
 
	public int size( ) 
	{
      return theSize;
	}
	
	
 
	public boolean isEmpty( )
	{
      return size( ) == 0;
	}
  
  
  public AnyType top( )
  {
      return theItems[ size()-1 ];    
  }
      
 

  @SuppressWarnings("unchecked")
  public void ensureCapacity( int newCapacity )
  {
      if( newCapacity < theSize )
          return;

      AnyType [ ] old = theItems;
      theItems = (AnyType []) new Object[ newCapacity ];
      for( int i = 0; i < size( ); i++ )
          theItems[ i ] = old[ i ];
  }
  

  public boolean push( AnyType x )
  {
	add( size( ), x );
      return true;            
  }

  public void add( int idx, AnyType x )
  {
      if( theItems.length == size( ) )
          ensureCapacity( size( ) * 2 + 1 );

      for( int i = theSize; i > idx; i-- )
          theItems[ i ] = theItems[ i - 1 ];

      theItems[ idx ] = x;
      theSize++;  
  }
    
 
  public AnyType pop(  )
  {
      AnyType removedItem = theItems[ size()-1 ];      
      theSize--;          
      return removedItem;
  }
  
  
  private static final int DEFAULT_CAPACITY = 10;
  
  private AnyType [ ] theItems;  
  private int theSize;
  private static int c;
} 

  
  
  
  
  
  

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


public class gA {
  
  public static void main(String[] args) throws NumberFormatException, IOException {
	
	BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
	MyLinkedList<Character> lista;
	MyLinkedList<Integer> li= new MyLinkedList<>();
	int numCase, num,aux=0, aux2=0, count;
	String str, spl[],cadena, split[];
	char A, B, op;
	
	 boolean x=true,y=true;
	HashMap<Integer, Character> map;
	HashMap<Integer, Character> map2;
	
	numCase= Integer.parseInt(br.readLine());
	
	for (int i = 0; i < numCase; i++) {
	  System.out.println("Caso #"+(i+1)+":");
	  num=Integer.parseInt(br.readLine());
	  Graph g = new Graph(num);
	  str=br.readLine();
	  spl=str.split("\\s+");
	  map=new HashMap<>();
	  map2=new HashMap<>();
	  count=0;
	  lista= new MyLinkedList<>();
	  
	  for (String st : spl) {
		lista.add(st.charAt(0));	
		map.put(count, st.charAt(0));
		map2.put(count, st.charAt(0));
		count++;
	  }
	  cadena=br.readLine();
	  split=cadena.split("\\s+");
	  
	  for (String st : split) {
		A=st.charAt(0);	
		op=st.charAt(1);
		B=st.charAt(2);
		
	
		if(op=='<'){
		  for (int j = 0; j < lista.size(); j++) {
			if(A==lista.get(j)){			  
			  aux=j;	
			  map.remove(j);
			}
			
			if(B==lista.get(j)){
			  aux2=j;	
			  map.remove(j);
			}
		  }
		 
		  x=g.addEdge(aux, aux2);
		 
		}
		else{
		  for (int j = 0; j < lista.size(); j++) {
			if(A==lista.get(j)){			  
			  aux=j;
                         map.remove(j);
                        }
			
			if(B==lista.get(j)){
			  aux2=j;
                          map.remove(j);
                          
                        }
		  }
		 		  
		  y=g.addEdge(aux2, aux);
		  
		}
		
	  }
	  
	  if(x==false || y==false){
		System.out.println("NO");
		continue;
	  }
	  	
	  li=g.topologicalSort();
	 
	 
	 
	  HashSet<Integer> set= new HashSet <>(); 
	  
	  Object b []=map.keySet().toArray();

	  
	  for (int j = 0; j < b.length; j++) {;
		int r = (int) b[j];		
		Iterator<Integer> k = li.iterator();
		while (k.hasNext()) {
		  Integer inte = (Integer) k.next();		  
		  if(inte==r){			
			li.remove(j);
			break;
		  }		 		  
		}	
	  }
           
	  
	  //System.out.println(li);
	  
	  Iterator<Integer> k = li.iterator();
	  while (k.hasNext()) {
		Integer integer = (Integer) k.next();
		System.out.print(map2.get(integer)+ " ");
		map2.remove(integer);

	  }
	  
	  Object e[]=map2.keySet().toArray();
	 for (int j = 0; j < e.length; j++) {
	   int r= (int) e[j];
	   System.out.println(map2.get(r)+" ");
	 }
         
         
	  
	}
	li.doClear();
	
  }

  public static class Graph
  {
      private int V;   // # of vertices
      private MyLinkedList<Integer> adj[]; // Adjacency List
      private MyLinkedList<Integer> l;
   
      //Constructor
      Graph(int v)
      {
          V = v;
          adj = new MyLinkedList[v];
          for (int i=0; i<v; ++i)
              adj[i] = new MyLinkedList();
      }
   
      // Function to add an edge into the graph
      boolean addEdge(int v,int w) { 
    	if(adj[w].size() >0){
    	for (int i = 0; i < adj[w].size(); i++) {
    	  if(adj[w].get(i)==v)
    		return false;		  
		}
    	}
    	
    	adj[v].add(w);
    	return true;
      }
      
      boolean conex (int v, int w){
          for (int i = 0; i < adj[w].size(); i++) {
              if(adj[v].get(i)==w){
                  return true;
                  
              }
          }
          return false;          
         
      }
   
      // A recursive function used by topologicalSort
      void topologicalSortUtil(int v, Boolean visited[],MyStack stack)
      {
          // Mark the current node as visited.
          visited[v] = true;
          Integer i;
   
          // Recur for all the vertices adjacent to this vertex
          Iterator<Integer> it = adj[v].iterator();
          while (it.hasNext())
          {
              i = it.next();
              if (!visited[i])
                  topologicalSortUtil(i, visited, stack);
          }
   
          // Push current vertex to stack which stores result
          stack.push(new Integer(v));
      }
   
      // The function to do Topological Sort. It uses recursive
      // topologicalSortUtil()
      
      MyLinkedList<Integer> topologicalSort()
      {
    	
    		l=new MyLinkedList<>();
          MyStack <Integer> stack= new MyStack<>();
   
          // Mark all the vertices as not visited
          Boolean visited[] = new Boolean[V];
          for (int i = 0; i < V; i++)
              visited[i] = false;
   
          // Call the recursive helper function to store Topological
          // Sort starting from all vertices one by one
          for (int i = 0; i < V; i++)
              if (visited[i] == false)
                  topologicalSortUtil(i, visited, stack);
   
          // Print contents of stack
          while (stack.isEmpty()==false)
             l.add(stack.pop());
          
          return l;
      }
   
  }
  public static class MyLinkedList<AnyType> implements Iterable<AnyType>
  {

    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    
    
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    
    
   /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private  class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;

  }
  

  
  public static class MyStack <AnyType> 
  {
	public static <E> void print (MyStack<E> s)
	{
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();
		System.out.println (elem);
		MyStack.<E>print (s);
		s.push (elem);
	  }
	}
	
	public static <E> int countElements(MyStack<E> s)
	{
	  c=0;
	  return MyStack.<E> numElements(s);
	}
	
	private static <E> int numElements (MyStack<E> s)
	{
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();
		c++;
		MyStack.<E> numElements(s);
		s.push (elem);
	  }
	  return c;
	}
	
	
	public static <E> MyStack<E> doble (MyStack<E> s, MyStack<E> t){
	  
	  E elem;
	  if (!s.isEmpty ()) {
		elem = s.pop ();		
		MyStack.<E> doble(s,t);
		t.push(elem);
		s.push (elem);
	  }
	  return t;
	  
	}
	
	
	public boolean contains (AnyType x){
	  for (int i = (size()-1); i >=0; i--) 
		if(theItems[i]==x)
		  return true;	
	  return false;
		
	  
	}
	
	
	
	public MyStack( )
	{
      doClear( );
	}
  
	public void clear( )
	{
	 doClear( );
	}
	  
	private void doClear( )
	{
	  theSize = 0;
	  ensureCapacity( DEFAULT_CAPACITY );
	}
 
	public int size( ) 
	{
      return theSize;
	}
	
	
 
	public boolean isEmpty( )
	{
      return size( ) == 0;
	}
  
  
  public AnyType top( )
  {
      return theItems[ size()-1 ];    
  }
      
 

  @SuppressWarnings("unchecked")
  public void ensureCapacity( int newCapacity )
  {
      if( newCapacity < theSize )
          return;

      AnyType [ ] old = theItems;
      theItems = (AnyType []) new Object[ newCapacity ];
      for( int i = 0; i < size( ); i++ )
          theItems[ i ] = old[ i ];
  }
  

  public boolean push( AnyType x )
  {
	add( size( ), x );
      return true;            
  }

  public void add( int idx, AnyType x )
  {
      if( theItems.length == size( ) )
          ensureCapacity( size( ) * 2 + 1 );

      for( int i = theSize; i > idx; i-- )
          theItems[ i ] = theItems[ i - 1 ];

      theItems[ idx ] = x;
      theSize++;  
  }
    
 
  public AnyType pop(  )
  {
      AnyType removedItem = theItems[ size()-1 ];      
      theSize--;          
      return removedItem;
  }
  
  
  private static final int DEFAULT_CAPACITY = 10;
  
  private AnyType [ ] theItems;  
  private int theSize;
  private static int c;
} 

  
  
  
  
  
  

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
