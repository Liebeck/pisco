import java.util.Scanner;

public class ProblemaA {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);

		int n = Integer.parseInt(scan.nextLine());
		long arr[] = readInts(scan.nextLine());

	
		int hasNeg = 0;
		long maxA, maxB;
		//catching numbers
		for(int i = 0; i < n; ++i) 
			if(arr[i] < 0)
				++hasNeg;		
		
		//sorting array of catched numbers
		for(int i = 0; i < n; ++i)
			for(int j = i; j < n; ++j)
				if(arr[j] <= arr[i]) {
					long tmp = arr[i];
					arr[i] = arr[j];
					arr[j] = tmp;
				}

	
		//searching for biggest multiplication
		if(hasNeg >= 2) {
			maxA = arr[n-1]*arr[n-2];
			maxB = arr[0]*arr[1];
			System.out.println(Math.max(maxA, maxB));
		} else {
			maxA = arr[n-1]*arr[n-2];
			System.out.println(maxA);	
		}
		scan.close();
		
	}
	
	public static long[] readInts(String cad) {
		String lines[] = cad.split(" ");
		long arr[] = new long[lines.length];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = Integer.parseInt(lines[i]);
		}
		return arr;
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class ProblemaB {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int t = Integer.parseInt(scan.nextLine()); //number of messages sended
		
		String[] messages = new String[t];
		int[] destroyedWalls = new int[t];
	
		for(int i = 0; i < t; i++){
			String temp = scan.nextLine();
			messages[i] = temp;
			int[] data = new int[3];
			data = ProblemaB.bombsWallsCounter(messages[i]);
			
			if(data[0] != 0) {
				int[] distances = new int[messages[i].length() + 1];
				distances = ProblemaB.distanceBetweenBombs(messages[i]);
				
				int standingWalls = ProblemaB.standingWallsCounter(distances);
				destroyedWalls[i] = data[1] - standingWalls;
			} else 
				destroyedWalls[i] = 0;
				
		}
		
		for(int i = 0; i < t; i++)
			System.out.println(destroyedWalls[i]);
		
		scan.close();
	}
	
	/*
	 * distanceBetweenBombs method generates an array of length n + 2, where
	 * n indicates the number of bombs in the message. The two additional en-
	 * tries measures the distances between first element of message and fir-
	 * st bomb and the distance between last element of message and last enc-
	 * ountered bomb.
	 */
	public static int[] distanceBetweenBombs(String line) {
		line.toUpperCase();
		
		char[] chars = new char[line.length()];
		line.getChars(0, line.length(), chars, 0);
		
		int countBs = 0;
		for(int i = 0; i < line.length(); ++i)
			if(chars[i] == 'B')
				countBs++;
		
		int[] bombsLocation = new int[countBs]; 
		int index = 0;	
		for(int i = 0; i < chars.length; ++i)
				if(chars[i] == 'B') {
					bombsLocation[index] = i;
					++index;
				} 
		/*
		System.out.println("bombs location");
		for(int i = 0; i < bombsLocation.length; ++i)
			System.out.print( bombsLocation[i] + " ");
		System.out.println();
		*/
		int[] distances = new int[bombsLocation.length + 1];
		distances[0] = bombsLocation[0];
		for(int i = 1; i < bombsLocation.length; ++i)
			distances[i] = bombsLocation[i] - bombsLocation[i-1] - 1;
		distances[bombsLocation.length] = line.length() - bombsLocation[bombsLocation.length -  1] - 1;
		/*
		System.out.println("distances");
		for(int i = 0; i < distances.length; ++i)
			System.out.print(distances[i] + " ");
		System.out.println();
		*/
		return distances;
	}
	
	public static int[] bombsWallsCounter(String line) {
		line.toUpperCase();
		char[] chars = new char[line.length()];
		line.getChars(0, line.length(), chars, 0);
		
		int countBs = 0;
		int countWs = 0;
		for(int i = 0; i < line.length(); ++i)
			if(chars[i] == 'B')
				++countBs;
			else
				++countWs;
		int[] data = {countBs, countWs, line.length()};
		/*
		 * data[0] = number of bombs
		 * data[1] = number of walls
		 * data[2] = message length
		 * Remember that last entry in bombsLocation array indicates position of last
		 *  wall
		 */
		return data;
	}
	
	public static int standingWallsCounter(int[] distances) {
		final int POWER = 4;
		int standingWalls = 0;
		for(int i = 1; i < distances.length-1; ++i)
			if(distances[i] > POWER)
				standingWalls += distances[i] - POWER;
		if(distances[0] > POWER/2)
			standingWalls += distances[0] - POWER/2;
		if(distances[distances.length-1] > POWER/2)
			standingWalls += distances[distances.length-1] - POWER/2;
		return standingWalls;
	}
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaC {
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader in;
		File f = new File("in.txt");
		if (f.exists()) {
			in = new BufferedReader(new FileReader(f));
		} else {
			in = new BufferedReader(new InputStreamReader(System.in));
		}
		
		
		int t = Integer.parseInt(in.readLine());
		String[] toProcess = new String[t];
		int subStrings[] = new int[t]; //here, number of substrings are recorder...
		for (int test = 0; test < t; test++) {
			int n = Integer.parseInt(in.readLine());
			String s = in.readLine();// cadena
			toProcess[test] = s;
			subStrings[test] = ProblemaC.parser(s);
		}
		
		for(int i = 0; i < t; i++)
			System.out.println(subStrings[i]);
	}

		
	public static int parser(String s) {
		
		char[] chars = new char[s.length()];
		int[] charsToInt = new int[s.length()];
		s.getChars(0, s.length(), chars, 0);
		
		for(int i = 0; i < s.length(); ++i)
			charsToInt[i] = chars[i];
		
		/*
		for(int i = 0; i < chars.length; ++i) {
			System.out.print(chars[i] + " ");
			System.out.println(charsToInt[i]);
		}
		*/
		
		int orderedSubstrings = 0;
		
		for(int i = 0; i < s.length(); ++i) 
			for(int j = i; j < s.length(); ++j) {
				int test = 0;
				for(int k = i;k < j ; ++k) {
					if(i == j) {
						orderedSubstrings++;
						//System.out.println("test :" + test);
						continue;
					}
					//System.out.println("i: " + i + " j: " + j + " k: " + k + " rest: " + (charsToInt[k] - charsToInt[k]));
					if(charsToInt[k+1] - charsToInt[k] >= 0) {
						test++;
						//System.out.println("test :" + test);
					}
				}
				//System.out.println("i: " + i + " j: " + j + " cond: " + (j-i+1));
				if(test == j-i) {
				
					//System.out.println("number subs :" + orderedSubstrings);
					++orderedSubstrings;
				}
			}
		return orderedSubstrings;
	}
}
 



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

public class ProblemaD {
	public static void main(String[] args) throws IOException {
		BufferedReader in;
		File f = new File("entradaD.txt");
		if (f.exists()) {
			in = new BufferedReader(new FileReader(f));
		} else {
			in = new BufferedReader(new InputStreamReader(System.in));
		}
		String line = in.readLine();
		int N = Integer.parseInt(line);
		
		String[] answers = new String[N];
		for (int t = 0; t < N; t++) {
			int s = Integer.parseInt(in.readLine());
			char array[][] = new char[s][s];
			for (int i = 0; i < s; i++)
				array[i] = in.readLine().toCharArray();// lee una fila completa
			if(ProblemaD.hasEvenCherry(array, s)) {
				if(ProblemaD.cutterChecker(array, s, true))
					answers[t] = "YES";
				else if(ProblemaD.cutterChecker(array, s, false))
					answers[t] = "YES";
				else
					answers[t] = "NO";
			} else {
				answers[t] = "NO";
			}			
		}
		
		for(int i = 0; i < N; i++)
			System.out.println(answers[i]);
	}
	
	public static boolean hasEvenCherry(char[][] array, int sideLength) {
		boolean flag = true;
		if(ProblemaD.cherryCounter(array,sideLength,sideLength)%2 == 0)
			return flag;
		else
			return flag = false;
	}
	
	public static int cherryCounter(char[][] array, int sideV, int sideH) {
		int counter = 0;
		for(int i = 0; i < sideV; i++)
			for(int j = 0; j < sideH; j++)
				if(array[i][j] == '#')
					counter++;
		return counter;
	}
	
	public static boolean cutterChecker(char[][] array, int sideLength, boolean isHorizontal) {
		if(isHorizontal) {
			int cherries = 0;
			boolean flag = false;
			for(int k = 0; k < sideLength; k++)	{
				cherries = ProblemaD.cherryCounter(array, sideLength, k);
				if(cherries == ProblemaD.cherryCounter(array, sideLength, sideLength)/2) {
					flag = true;
					break;
				}
			}
			return flag;
		} else {
			int cherries = 0;
			boolean flag = false;
			for(int k = 0; k < sideLength; k++)	{
				cherries = ProblemaD.cherryCounter(array, k, sideLength);
				if(cherries == ProblemaD.cherryCounter(array, sideLength, sideLength)/2) {
					flag = true;
					break;
				}
			}
			return flag;
		}	
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

public class ProblemaE {
	public static void main(String[] args) throws IOException {
		BufferedReader in;
		File f = new File("entradaD.txt");
		if (f.exists()) {
			in = new BufferedReader(new FileReader(f));
		} else {
			in = new BufferedReader(new InputStreamReader(System.in));
		}
		String line = in.readLine();
		int N = Integer.parseInt(line);
		
		String[] answers = new String[N];
		for (int t = 0; t < N; t++) {
			int s = Integer.parseInt(in.readLine());
			char array[][] = new char[s][s];
			for (int i = 0; i < s; i++)
				array[i] = in.readLine().toCharArray();// lee una fila completa
			
		}
                
                int[] myData = new int[2];
		/*
		for(int i = 0; i < N; i++)
			System.out.println(answers[i]);
		*/
		
		
	}
	
	public static boolean hasEvenCherry(char[][] array, int sideLength) {
		boolean flag = true;
		if(ProblemaE.cherryCounter(array,sideLength,sideLength)%2 == 0)
			return flag;
		else
			return flag = false;
	}
	
	public static int cherryCounter(char[][] array, int sideV, int sideH) {
		int counter = 0;
		for(int i = 0; i < sideV; i++)
			for(int j = 0; j < sideH; j++)
				if(array[i][j] == '#')
					counter++;
		return counter;
	}
	
	public static int[] cutterChecker(char[][] array, int sideLength, boolean isHorizontal) {
		int cuts[] = new int[2];
		if(isHorizontal) {
			int cherries = 0;
			int cutterV = 0;
			for(int k = 0; k < sideLength; k++)	{
				cherries = ProblemaE.cherryCounter(array, sideLength, k);
				if(cherries == ProblemaE.cherryCounter(array, sideLength, sideLength)/2) {
					cutterV = k;
				}
				
			}
			cuts[0] = cutterV;
		} else {
			int cherries = 0;
			int cutterH = 0;
			boolean flag = false;
			for(int k = 0; k < sideLength; k++)	{
				cherries = ProblemaE.cherryCounter(array, k, sideLength);
				if(cherries == ProblemaE.cherryCounter(array, sideLength, sideLength)/2) {	
					cutterH = k;
				}
			}
			cuts[1] = cutterH;

		}
		return cuts;
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemAv1 {
	public static void main(String[] args) throws Exception {
		Scanner in = new Scanner(System.in);
		int T = Integer.parseInt(in.nextLine()); //number of cases
		for(int testCase = 1; testCase <= T; testCase++) {
			System.out.println("Caso #" + testCase + ":");
			int[] params = parseInts(in.nextLine()); //N K
			
			ContestantStatus[] scoreBoard = initScoreBoard(params[0]); //array that contains partial scoreboards
			SeparateChainingHashTable<Submit> submits = new SeparateChainingHashTable<>(); //see hash of Submit class to details to store
			
			LinkedList<Submit> problemTeamSubs; //list containing submits of same problem of a contestant/team. Is retrieved from a hash table
			
			for(int i = 0; i < params[1]; i++) {
				Submit tmp = parseToSubmit(in.nextLine());
				submits.insert(tmp);
//				System.out.println("tmpSubmit: " + tmp);
				
				if(tmp.state == 'C') {
					problemTeamSubs = submits.getListOf(tmp);

					//Check if contents of linked list is trusted
					//===============================================
//					for(Submit item : problemTeamSubs) {
//						System.out.println("item tmp to cmp is:\n\t" + item + "\n");
//						if(item.contestant != tmp.contestant )
//							System.out.println("!!!!crash on contestant: " + item.contestant);
//						if(item.problem != tmp.problem )
//							System.out.println("!!!!crash on problem: " + item.problem);
//					}
					
					//===============================================
					
					int partialTime = PenaltyTimeProblem(problemTeamSubs);
					
					scoreBoard[tmp.contestant-1].addPenaltyTime(partialTime);
					scoreBoard[tmp.contestant-1].addSolution();
				}
			}	
			BinaryHeap<ContestantStatus> order = new BinaryHeap<>(scoreBoard);
			System.out.print(printScoreBoard(order));
		}
		in.close();
	}
	
	public static String printScoreBoard(BinaryHeap<ContestantStatus> order) throws Exception {
		StringBuilder sb = new StringBuilder();
		while(! order.isEmpty() ) {
			String tmp = order.deleteMin().toString();
			sb.append(tmp + "\n");
		}
		return new String(sb);
	}
	
	public static ContestantStatus[] initScoreBoard(int length) {
		ContestantStatus[] scoreBoard = new ContestantStatus[length];
		for(int i = 0; i < length; i++)
			scoreBoard[i] = new ContestantStatus(i+1, 0, 0);
		return scoreBoard;
	}
	
	public static int PenaltyTimeProblem(LinkedList<Submit> lst) {
		int numberSubmits = lst.size();
		Submit lastSubmit = lst.getLast();
		int penaltyTime = (numberSubmits-1)*20 + lastSubmit.time;
		return penaltyTime;
	}
	
	public static void printArr(ContestantStatus[] x) {
		for(int i = 0; i < x.length; i++)
			System.out.println(x[i]);
		System.out.println();
	}
	
	public static Submit parseToSubmit(String s) {
		String[] split = s.split(" ");
		int a = Integer.parseInt(split[0]);
		int b = Integer.parseInt(split[1]);
		int c = Integer.parseInt(split[2]);
		char d = split[3].charAt(0);
		Submit foo = new Submit(a, b, c, d);
		return foo;
		
	}
	
	public static int[] parseInts(String s) {
		String[] sp = s.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static class Submit{
		int contestant, problem, time;
		char state;
		
		public Submit() {
			this(0, 0, 0, ' ');
		}
		
		public Submit(int c, int p, int t, char s) {
			contestant = c; problem = p; time = t; state = s;
		}
		
		public String toString() {
			return "contestant: " + contestant +
					"\nproblem: " + problem + 
					"\ntime: " + time + 
					"\nstate: " + state;
		}
		
		public int hashCode() { //this hash makes that occur a collision for thus store same problem submits for a contestant
			return powInt(contestant*31, 2) + powInt(problem*31, 1);
//			return powInt(2, contestant)*powInt(3,problem); //(8 crashes)
//			return problem*problem + contestant; //(4 crashes)
//			return (int) Math.pow(2, contestant)*(int) Math.pow(3, contestant); //using Arithmetic Fundamental Theorem principle (24 crashes)
//			return (contestant*(contestant-1) + problem*(problem+1));

		}
		
		/**
		 * @return x^y
		 */
		public static int powInt(int x, int y) {
			int prod = 1;
			for(int i = 0; i < y; i++)
				prod *= x;
			return prod;
		}
	}
	
	
	public static class ContestantStatus implements Comparable<ContestantStatus> {
		private int contestantNumber,  problemsSolved, penaltyTime;
		
		public ContestantStatus() { this(0, 0, 0); }
		public ContestantStatus(int cN, int pS, int pT) {
			contestantNumber = cN; problemsSolved = pS; penaltyTime = pT;
		}
		
		public void addSolution() { problemsSolved++; }
		public void addPenaltyTime(int penalty) { penaltyTime += penalty; }
		
		public int getContestantNumber() {
			return contestantNumber;
		}
		
		public int compareTo(ContestantStatus x) {
			if(this.problemsSolved > x.problemsSolved)
				return 1;
			else if(this.problemsSolved < x.problemsSolved)
				return -1;
			else if(this.penaltyTime > x.penaltyTime)
				return -1;
			else if(this.penaltyTime < x.penaltyTime)
				return 1;
			else if(this.contestantNumber > x.contestantNumber)
				return -1;
			else if(this.contestantNumber < x.contestantNumber)
				return 1;
			else 
				return 0;
		}
		
		public String toStringAlt() {
			return "contestantNumber: " + contestantNumber + 
					"\nproblemsSolved: " + problemsSolved + 
					"\npenaltyTime: " + penaltyTime;
		}
		
		public String toString() {
			return contestantNumber + " " + problemsSolved + " " + penaltyTime;
		}
	}
	

	// SeparateChaining Hash table class
	//
	// CONSTRUCTION: an approximate initial size or default of 101
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// void remove( x )       --> Remove x
	// boolean contains( x )  --> Return true if x is present
	// void makeEmpty( )      --> Remove all items
	/**
	 * Separate chaining table implementation of hash tables.
	 * Note that all "matching" is based on the equals method.
	 * @param <AnyType>
	 */
	public static class SeparateChainingHashTable<AnyType>
	{
	    /**
	     * Construct the hash table.
	     */
	    public SeparateChainingHashTable( )
	    {
	        this( DEFAULT_TABLE_SIZE );
	    }
	
	    /**
	     * Construct the hash table.
	     * @param size approximate table size.
	     */
	    public SeparateChainingHashTable( int size )
	    {
	        theLists = new LinkedList[ nextPrime( size ) ];
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ] = new LinkedList<>( );
	    }
	    
	    /**
	     * @param x
	     * @return a list containing all collisions referred to element x
	     */
	    public LinkedList<AnyType> getListOf(AnyType x) {
	    	LinkedList<AnyType> whichList = (LinkedList<AnyType>) theLists[ myhash( x )];
	    	return whichList;
	    }
	
	    /**
	     * Insert into the hash table. If the item is
	     * already present, then do nothing.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
//	    	System.out.println(myhash(x));
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( !whichList.contains( x ) )
	        {
	            whichList.add( x );
	
	                // Rehash; see Section 5.5
	            if( ++currentSize > theLists.length )
	                rehash( );
	        }
	    }
	
	    /**
	     * Remove from the hash table.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( whichList.contains( x ) )
	    {
	        whichList.remove( x );
	            currentSize--;
	    }
	    }
	
	    /**
	     * Find an item in the hash table.
	     * @param x the item to search for.
	     * @return true if x is found.
	     */
	    public boolean contains( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        return whichList.contains( x );
	    }
	
	    /**
	     * Make the hash table logically empty.
	     */
	    public void makeEmpty( )
	    {
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ].clear( );
	        currentSize = 0;  
	    }
	
	    /**
	     * A hash routine for String objects.
	     * @param key the String to hash.
	     * @param tableSize the size of the hash table.
	     * @return the hash value.
	     */
	    public static int hash( String key, int tableSize )
	    {
	        int hashVal = 0;
	
	        for( int i = 0; i < key.length( ); i++ )
	            hashVal = 37 * hashVal + key.charAt( i );
	
	        hashVal %= tableSize;
	        if( hashVal < 0 )
	            hashVal += tableSize;
	
	        return hashVal;
	    }
	
	    private void rehash( )
	    {
	        List<AnyType> [ ]  oldLists = theLists;
	
	            // Create new double-sized, empty table
	        theLists = new List[ nextPrime( 2 * theLists.length ) ];
	        for( int j = 0; j < theLists.length; j++ )
	            theLists[ j ] = new LinkedList<>( );
	
	            // Copy table over
	        currentSize = 0;
	        for( List<AnyType> list : oldLists )
	            for( AnyType item : list )
	                insert( item );
	    }
	
	    private int myhash( AnyType x )
	    {
	        int hashVal = x.hashCode( );
	        hashVal %= theLists.length;
	        if( hashVal < 0 )
	            hashVal += theLists.length;
	        return hashVal;
	    }
	    
	    private static final int DEFAULT_TABLE_SIZE = 101;
	
	        /** The array of Lists. */
	    private List<AnyType> [ ] theLists; 
	    private int currentSize;
	
	    /**
	     * Internal method to find a prime number at least as large as n.
	     * @param n the starting number (must be positive).
	     * @return a prime number larger than or equal to n.
	     */
	    @SuppressWarnings("empty-statement")
	    private static int nextPrime( int n )
	    {
	        if( n % 2 == 0 )
	            n++;
	
	        for( ; !isPrime( n ); n += 2 )
	            ;
	
	        return n;
	    }
	
	    /**
	     * Internal method to test if a number is prime.
	     * Not an efficient algorithm.
	     * @param n the number to test.
	     * @return the result of the test.
	     */
	    private static boolean isPrime( int n )
	    {
	        if( n == 2 || n == 3 )
	            return true;
	
	        if( n == 1 || n % 2 == 0 )
	            return false;
	
	        for( int i = 3; i * i <= n; i += 2 )
	            if( n % i == 0 )
	                return false;
	
	        return true;
	    }
	}


	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}
		
		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( AnyType [ ] items )
		{
				currentSize = items.length;
				array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

				int i = 1;
				for( AnyType item : items )
					array[ i++ ] = item;
				buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

				// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		@SuppressWarnings("unchecked")
		private void enlargeArray( int newSize )
		{
				AnyType [] old = array;
				array = (AnyType []) new Comparable[ newSize ];
				for( int i = 0; i < old.length; i++ )
					array[ i ] = old[ i ];        
		}
		
		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) > 0 )
					child++;
				if( array[ child ].compareTo( tmp ) > 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
		
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");
			for(int i = 0; i < array.length; i++)
				sb.append(array[i] + " ");
			sb.append("] \n" );
			return new String(sb);
		}
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemBv1 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		int t = Integer.parseInt(in.nextLine());
		for(int testCase = 1; testCase <= t; testCase++) {
			System.out.println("Caso #" + testCase + ":");

			int n = Integer.parseInt(in.nextLine());
			int[] numbers = getNumbers(in.nextLine());
			
			SeparateChainingHashTable<KeyNumber> hashTable = new SeparateChainingHashTable<>();
			KeyNumber kn;
			boolean collision;
			LinkedList<KeyNumber> keys = new LinkedList<>();
			
			
			for(int i = 0; i < numbers.length; i++) {
				kn = new KeyNumber(numbers[i], i);
				collision = hashTable.insert(kn);
				if(!collision)
					keys.add(kn);
			}
			
			LinkedList<KeyNumber> collisionList;
			StringBuilder sb = new StringBuilder();
			for(KeyNumber item : keys) {
				collisionList = hashTable.getList(item);
				sb.append(collisionList.getFirst().number + " " + collisionList.size() + "\n");
			}
			System.out.print(sb);
		}
		in.close();
	}
	
	
	public static int[] getNumbers(String str) {
		String[] split = str.split(" ");
		int[] nums = new int[split.length];
		for(int i = 0; i < split.length; i++) 
			nums[i] = Integer.parseInt(split[i]);
		return nums;
	}
	
	/**
	 * Class KeyNumber.
	 * Stores the idea of entry position given by a counter, a long number
	 * 
	 * Also represents the idea of anything that you want depending of signify of entryNumber field
	 */
	public static class KeyNumber{
		int number;
		int entryNumber; 
		 
		public KeyNumber(int n, int eN) {
			number = n;
			entryNumber = eN;
		}
		
		public int hashCode() {
			return number;	
		}
		
		public String toString() {
			return number + " " + entryNumber;
		}
	}
	
	

	// SeparateChaining Hash table class
	//
	// CONSTRUCTION: an approximate initial size or default of 101
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x						EDIT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	// void remove( x )       --> Remove x
	// boolean contains( x )  --> Return true if x is present
	// void makeEmpty( )      --> Remove all items

	/**
	 * Separate chaining table implementation of hash tables.
	 * Note that all "matching" is based on the equals method.
	 * @param <AnyType>
	 */
	public static class SeparateChainingHashTable<AnyType>
	{
	    /**
	     * Construct the hash table.
	     */
	    public SeparateChainingHashTable( )
	    {
	        this( DEFAULT_TABLE_SIZE );
	    }

	    /**
	     * Construct the hash table.
	     * @param size approximate table size.
	     */
	    public SeparateChainingHashTable( int size )
	    {
	        theLists = new LinkedList[ nextPrime( size ) ];
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ] = new LinkedList<>( );
	    }
	    
	    
	    
	    /**
	     * @param x common collision factor
	     * @return a list containing items that collided given a hash function
	     */
	    public LinkedList<AnyType> getList(AnyType x) {
	    	LinkedList<AnyType> list = (LinkedList<AnyType>) theLists[ myhash(x) ];
	    	return list;
	    }
	    

	    /**
	     * Insert into the hash table. If the item is
	     * already present, then do nothing.
	     * @param x the item to insert.
	     * RETURNS TRUE IF EXISTS A COLLISION
	     */
	    public boolean insert( AnyType x )
	    {
	    	boolean flag = false;
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        
	        if(!whichList.isEmpty())
	        	flag = true;
	        
	        if( !whichList.contains( x ) )
	        {
	            whichList.add( x );

	                // Rehash; see Section 5.5
	            if( ++currentSize > theLists.length )
	                rehash( );
	        }
	        
	        return flag;
	    }

	    /**
	     * Remove from the hash table.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( whichList.contains( x ) )
	    {
	        whichList.remove( x );
	            currentSize--;
	    }
	    }

	    /**
	     * Find an item in the hash table.
	     * @param x the item to search for.
	     * @return true if x is found.
	     */
	    public boolean contains( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        return whichList.contains( x );
	    }

	    /**
	     * Make the hash table logically empty.
	     */
	    public void makeEmpty( )
	    {
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ].clear( );
	        currentSize = 0;  
	    }

	    /**
	     * A hash routine for String objects.
	     * @param key the String to hash.
	     * @param tableSize the size of the hash table.
	     * @return the hash value.
	     */
	    public static int hash( String key, int tableSize )
	    {
	        int hashVal = 0;

	        for( int i = 0; i < key.length( ); i++ )
	            hashVal = 37 * hashVal + key.charAt( i );

	        hashVal %= tableSize;
	        if( hashVal < 0 )
	            hashVal += tableSize;

	        return hashVal;
	    }

	    private void rehash( )
	    {
	        List<AnyType> [ ]  oldLists = theLists;

	            // Create new double-sized, empty table
	        theLists = new List[ nextPrime( 2 * theLists.length ) ];
	        for( int j = 0; j < theLists.length; j++ )
	            theLists[ j ] = new LinkedList<>( );

	            // Copy table over
	        currentSize = 0;
	        for( List<AnyType> list : oldLists )
	            for( AnyType item : list )
	                insert( item );
	    }

	    private int myhash( AnyType x )
	    {
	        int hashVal = x.hashCode( );

	        hashVal %= theLists.length;
	        if( hashVal < 0 )
	            hashVal += theLists.length;

	        return hashVal;
	    }
	    
	    private static final int DEFAULT_TABLE_SIZE = 101;

	        /** The array of Lists. */
	    private List<AnyType> [ ] theLists; 
	    private int currentSize;

	    /**
	     * Internal method to find a prime number at least as large as n.
	     * @param n the starting number (must be positive).
	     * @return a prime number larger than or equal to n.
	     */
	    @SuppressWarnings("empty-statement")
	    private static int nextPrime( int n )
	    {
	        if( n % 2 == 0 )
	            n++;

	        for( ; !isPrime( n ); n += 2 )
	            ;

	        return n;
	    }

	    /**
	     * Internal method to test if a number is prime.
	     * Not an efficient algorithm.
	     * @param n the number to test.
	     * @return the result of the test.
	     */
	    private static boolean isPrime( int n )
	    {
	        if( n == 2 || n == 3 )
	            return true;

	        if( n == 1 || n % 2 == 0 )
	            return false;

	        for( int i = 3; i * i <= n; i += 2 )
	            if( n % i == 0 )
	                return false;

	        return true;
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.HashSet;
import java.util.HashMap;
import java.util.Scanner;

public class ProblemCv1 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		int t = Integer.parseInt(in.nextLine());
		
		for(int testCase = 1; testCase <= t; testCase++) {
			StringBuilder sb = new StringBuilder("Caso #" + testCase + ":");
			int n = Integer.parseInt(in.nextLine());
			
			UnionFind net = new UnionFind(2*n);
			HashSet<String> buildSet = new HashSet<>();
			HashMap<String, Integer> keySet = new HashMap<>();
			
			
			int counterKey = 0; //(internal) adds one to make a new key for new objects
			
			for(int i = 0; i < n; i++) { //Names of new friendships are taken
				String[] names = getNames(in.nextLine());
				
				for(int idx = 0; idx < 2; idx++) { //Here we parse both names to get their keys, seeing first if have already passed in buildSet hash table
					boolean flag = buildSet.add(names[idx]);
//					System.out.println("hash of Str[" + idx + "]: " + names[idx].hashCode());
//					System.out.println("flag " + idx + " " + flag);
					if(flag) {
						keySet.put(names[idx], new Integer(counterKey++));
					}
				}
				
				int parentSet = net.union( keySet.get(names[0]).intValue(), keySet.get(names[1]).intValue() ); //Make a union between two mentioned people in 'names' string
				
//				System.out.println("key " + names[0] + " " + keySet.get(names[0]).intValue());
//				System.out.println("key " + names[1] + " " + keySet.get(names[1]).intValue());
//				System.out.println(parentSet);
//				System.out.println(net.getSizeOfSet(parentSet));
				
				sb.append("\n" + net.getSizeOfSet(parentSet));				
			}
			System.out.println(sb);
		}
		in.close();
	}
	
	public static String[] getNames(String str) {
		String[] names = str.split(" ");
		return names;
	}
	
	public static class Key {
		String name;
		int key;
		
		public Key(String n, int k) {
			name = n; key = k;
		}
	}
	
	/**
	 * This class was modified to support measures of sets. Every set is distinguished 
	 * by his unique parent, this if you want fetch the size of a given set do you must 
	 * now his parent.
	 * 
	 * Also, was modified for return a index of new parent when we perform a union.
	 */
	
	public static class UnionFind {
		private int id[];
		private int sz[];
		private int cont;
		
		public int getSizeOfSet(int i) {
			return sz[i];
		}

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			sz = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				sz[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}
		
		
		/**
		 * @param x a element to union
		 * @param y a element to union
		 * @return new parent index, for size calculus proposals. Return -1 if 
		 * x and y are already members of a same set.
		 */
		public int union(int x, int y) {
			int a = find(x);
			int b = find(y);
			int newParent;
			if (a == b)
				return a;
			if (sz[a] < sz[b]) {
				id[a] = b;
				sz[b] += sz[a];	
				newParent = b;
			} else {
				id[b] = a;
				sz[a] += sz[b];	
				newParent = a;
			}
			cont--;
			return newParent;
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemAv1 {
	public static void main(String[] args) throws Exception {
		Scanner in = new Scanner(System.in);
		int T = Integer.parseInt(in.nextLine()); //number of cases
		for(int testCase = 1; testCase <= T; testCase++) {
			System.out.println("Caso #" + testCase + ":");
			int[] params = parseInts(in.nextLine()); //N K
			
			ContestantStatus[] scoreBoard = initScoreBoard(params[0]); //array that contains partial scoreboards
			SeparateChainingHashTable<Submit> submits = new SeparateChainingHashTable<>(); //see hash of Submit class to details to store
			
			LinkedList<Submit> problemTeamSubs; //list containing submits of same problem of a contestant/team. Is retrieved from a hash table
			
			for(int i = 0; i < params[1]; i++) {
				Submit tmp = parseToSubmit(in.nextLine());
				submits.insert(tmp);
//				System.out.println("tmpSubmit: " + tmp);
				
				if(tmp.state == 'C') {
					problemTeamSubs = submits.getListOf(tmp);

					//Check if contents of linked list is trusted
					//===============================================
//					for(Submit item : problemTeamSubs) {
//						System.out.println("item tmp to cmp is:\n\t" + item + "\n");
//						if(item.contestant != tmp.contestant )
//							System.out.println("!!!!crash on contestant: " + item.contestant);
//						if(item.problem != tmp.problem )
//							System.out.println("!!!!crash on problem: " + item.problem);
//					}
					
					//===============================================
					
					int partialTime = PenaltyTimeProblem(problemTeamSubs);
					
					scoreBoard[tmp.contestant-1].addPenaltyTime(partialTime);
					scoreBoard[tmp.contestant-1].addSolution();
				}
			}	
			BinaryHeap<ContestantStatus> order = new BinaryHeap<>(scoreBoard);
			System.out.print(printScoreBoard(order));
		}
		in.close();
	}
	
	public static String printScoreBoard(BinaryHeap<ContestantStatus> order) throws Exception {
		StringBuilder sb = new StringBuilder();
		while(! order.isEmpty() ) {
			String tmp = order.deleteMin().toString();
			sb.append(tmp + "\n");
		}
		return new String(sb);
	}
	
	public static ContestantStatus[] initScoreBoard(int length) {
		ContestantStatus[] scoreBoard = new ContestantStatus[length];
		for(int i = 0; i < length; i++)
			scoreBoard[i] = new ContestantStatus(i+1, 0, 0);
		return scoreBoard;
	}
	
	public static int PenaltyTimeProblem(LinkedList<Submit> lst) {
		int numberSubmits = lst.size();
		Submit lastSubmit = lst.getLast();
		int penaltyTime = (numberSubmits-1)*20 + lastSubmit.time;
		return penaltyTime;
	}
	
	public static void printArr(ContestantStatus[] x) {
		for(int i = 0; i < x.length; i++)
			System.out.println(x[i]);
		System.out.println();
	}
	
	public static Submit parseToSubmit(String s) {
		String[] split = s.split(" ");
		int a = Integer.parseInt(split[0]);
		int b = Integer.parseInt(split[1]);
		int c = Integer.parseInt(split[2]);
		char d = split[3].charAt(0);
		Submit foo = new Submit(a, b, c, d);
		return foo;
		
	}
	
	public static int[] parseInts(String s) {
		String[] sp = s.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static class Submit{
		int contestant, problem, time;
		char state;
		
		public Submit() {
			this(0, 0, 0, ' ');
		}
		
		public Submit(int c, int p, int t, char s) {
			contestant = c; problem = p; time = t; state = s;
		}
		
		public String toString() {
			return "contestant: " + contestant +
					"\nproblem: " + problem + 
					"\ntime: " + time + 
					"\nstate: " + state;
		}
		
		public int hashCode() { //this hash makes that occur a collision for thus store same problem submits for a contestant
//			return powInt(contestant*31, 2) + powInt(problem*31, 1);
//			return powInt(2, contestant)*powInt(3,problem); //(8 crashes)
			return problem*problem + contestant; //(4 crashes)
//			return (int) Math.pow(2, contestant)*(int) Math.pow(3, contestant); //using Arithmetic Fundamental Theorem principle (24 crashes)
//			return (contestant*(contestant-1) + problem*(problem+1));

		}
		
		/**
		 * @return x^y
		 */
		public static int powInt(int x, int y) {
			int prod = 1;
			for(int i = 0; i < y; i++)
				prod *= x;
			return prod;
		}
	}
	
	
	public static class ContestantStatus implements Comparable<ContestantStatus> {
		private int contestantNumber,  problemsSolved, penaltyTime;
		
		public ContestantStatus() { this(0, 0, 0); }
		public ContestantStatus(int cN, int pS, int pT) {
			contestantNumber = cN; problemsSolved = pS; penaltyTime = pT;
		}
		
		public void addSolution() { problemsSolved++; }
		public void addPenaltyTime(int penalty) { penaltyTime += penalty; }
		
		public int getContestantNumber() {
			return contestantNumber;
		}
		
		public int compareTo(ContestantStatus x) {
			if(this.problemsSolved > x.problemsSolved)
				return 1;
			else if(this.problemsSolved < x.problemsSolved)
				return -1;
			else if(this.penaltyTime > x.penaltyTime)
				return -1;
			else if(this.penaltyTime < x.penaltyTime)
				return 1;
			else if(this.contestantNumber > x.contestantNumber)
				return -1;
			else if(this.contestantNumber < x.contestantNumber)
				return 1;
			else 
				return 0;
		}
		
		public String toStringAlt() {
			return "contestantNumber: " + contestantNumber + 
					"\nproblemsSolved: " + problemsSolved + 
					"\npenaltyTime: " + penaltyTime;
		}
		
		public String toString() {
			return contestantNumber + " " + problemsSolved + " " + penaltyTime;
		}
	}
	

	// SeparateChaining Hash table class
	//
	// CONSTRUCTION: an approximate initial size or default of 101
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// void remove( x )       --> Remove x
	// boolean contains( x )  --> Return true if x is present
	// void makeEmpty( )      --> Remove all items
	/**
	 * Separate chaining table implementation of hash tables.
	 * Note that all "matching" is based on the equals method.
	 * @param <AnyType>
	 */
	public static class SeparateChainingHashTable<AnyType>
	{
	    /**
	     * Construct the hash table.
	     */
	    public SeparateChainingHashTable( )
	    {
	        this( DEFAULT_TABLE_SIZE );
	    }
	
	    /**
	     * Construct the hash table.
	     * @param size approximate table size.
	     */
	    public SeparateChainingHashTable( int size )
	    {
	        theLists = new LinkedList[ nextPrime( size ) ];
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ] = new LinkedList<>( );
	    }
	    
	    /**
	     * @param x
	     * @return a list containing all collisions referred to element x
	     */
	    public LinkedList<AnyType> getListOf(AnyType x) {
	    	LinkedList<AnyType> whichList = (LinkedList<AnyType>) theLists[ myhash( x )];
	    	return whichList;
	    }
	
	    /**
	     * Insert into the hash table. If the item is
	     * already present, then do nothing.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
//	    	System.out.println(myhash(x));
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( !whichList.contains( x ) )
	        {
	            whichList.add( x );
	
	                // Rehash; see Section 5.5
	            if( ++currentSize > theLists.length )
	                rehash( );
	        }
	    }
	
	    /**
	     * Remove from the hash table.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( whichList.contains( x ) )
	    {
	        whichList.remove( x );
	            currentSize--;
	    }
	    }
	
	    /**
	     * Find an item in the hash table.
	     * @param x the item to search for.
	     * @return true if x is found.
	     */
	    public boolean contains( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        return whichList.contains( x );
	    }
	
	    /**
	     * Make the hash table logically empty.
	     */
	    public void makeEmpty( )
	    {
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ].clear( );
	        currentSize = 0;  
	    }
	
	    /**
	     * A hash routine for String objects.
	     * @param key the String to hash.
	     * @param tableSize the size of the hash table.
	     * @return the hash value.
	     */
	    public static int hash( String key, int tableSize )
	    {
	        int hashVal = 0;
	
	        for( int i = 0; i < key.length( ); i++ )
	            hashVal = 37 * hashVal + key.charAt( i );
	
	        hashVal %= tableSize;
	        if( hashVal < 0 )
	            hashVal += tableSize;
	
	        return hashVal;
	    }
	
	    private void rehash( )
	    {
	        List<AnyType> [ ]  oldLists = theLists;
	
	            // Create new double-sized, empty table
	        theLists = new List[ nextPrime( 2 * theLists.length ) ];
	        for( int j = 0; j < theLists.length; j++ )
	            theLists[ j ] = new LinkedList<>( );
	
	            // Copy table over
	        currentSize = 0;
	        for( List<AnyType> list : oldLists )
	            for( AnyType item : list )
	                insert( item );
	    }
	
	    private int myhash( AnyType x )
	    {
	        int hashVal = x.hashCode( );
	        hashVal %= theLists.length;
	        if( hashVal < 0 )
	            hashVal += theLists.length;
	        return hashVal;
	    }
	    
	    private static final int DEFAULT_TABLE_SIZE = 101;
	
	        /** The array of Lists. */
	    private List<AnyType> [ ] theLists; 
	    private int currentSize;
	
	    /**
	     * Internal method to find a prime number at least as large as n.
	     * @param n the starting number (must be positive).
	     * @return a prime number larger than or equal to n.
	     */
	    @SuppressWarnings("empty-statement")
	    private static int nextPrime( int n )
	    {
	        if( n % 2 == 0 )
	            n++;
	
	        for( ; !isPrime( n ); n += 2 )
	            ;
	
	        return n;
	    }
	
	    /**
	     * Internal method to test if a number is prime.
	     * Not an efficient algorithm.
	     * @param n the number to test.
	     * @return the result of the test.
	     */
	    private static boolean isPrime( int n )
	    {
	        if( n == 2 || n == 3 )
	            return true;
	
	        if( n == 1 || n % 2 == 0 )
	            return false;
	
	        for( int i = 3; i * i <= n; i += 2 )
	            if( n % i == 0 )
	                return false;
	
	        return true;
	    }
	}


	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}
		
		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( AnyType [ ] items )
		{
				currentSize = items.length;
				array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

				int i = 1;
				for( AnyType item : items )
					array[ i++ ] = item;
				buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

				// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		@SuppressWarnings("unchecked")
		private void enlargeArray( int newSize )
		{
				AnyType [] old = array;
				array = (AnyType []) new Comparable[ newSize ];
				for( int i = 0; i < old.length; i++ )
					array[ i ] = old[ i ];        
		}
		
		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) > 0 )
					child++;
				if( array[ child ].compareTo( tmp ) > 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
		
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");
			for(int i = 0; i < array.length; i++)
				sb.append(array[i] + " ");
			sb.append("] \n" );
			return new String(sb);
		}
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemAv1 {
	public static void main(String[] args) throws Exception {
		Scanner in = new Scanner(System.in);
		int T = Integer.parseInt(in.nextLine()); //number of cases
		for(int testCase = 1; testCase <= T; testCase++) {
			System.out.println("Caso #" + testCase + ":");
			int[] params = parseInts(in.nextLine()); //N K
			
			ContestantStatus[] scoreBoard = initScoreBoard(params[0]); //array that contains partial scoreboards
			SeparateChainingHashTable<Submit> submits = new SeparateChainingHashTable<>(); //see hash of Submit class to details to store
			
			LinkedList<Submit> problemTeamSubs; //list containing submits of same problem of a contestant/team. Is retrieved from a hash table
			
			for(int i = 0; i < params[1]; i++) {
				Submit tmp = parseToSubmit(in.nextLine());
				submits.insert(tmp);
//				System.out.println("tmpSubmit: " + tmp);
				
				if(tmp.state == 'C') {
					problemTeamSubs = submits.getListOf(tmp);

					//Check if contents of linked list is trusted
					//===============================================
//					for(Submit item : problemTeamSubs) {
//						System.out.println("item tmp to cmp is:\n\t" + item + "\n");
//						if(item.contestant != tmp.contestant )
//							System.out.println("!!!!crash on contestant: " + item.contestant);
//						if(item.problem != tmp.problem )
//							System.out.println("!!!!crash on problem: " + item.problem);
//					}
					
					//===============================================
					
					int partialTime = PenaltyTimeProblem(problemTeamSubs);
					
					scoreBoard[tmp.contestant-1].addPenaltyTime(partialTime);
					scoreBoard[tmp.contestant-1].addSolution();
				}
			}	
			BinaryHeap<ContestantStatus> order = new BinaryHeap<>(scoreBoard);
			System.out.print(printScoreBoard(order));
		}
		in.close();
	}
	
	public static String printScoreBoard(BinaryHeap<ContestantStatus> order) throws Exception {
		StringBuilder sb = new StringBuilder();
		while(! order.isEmpty() ) {
			String tmp = order.deleteMin().toString();
			sb.append(tmp + "\n");
		}
		return new String(sb);
	}
	
	public static ContestantStatus[] initScoreBoard(int length) {
		ContestantStatus[] scoreBoard = new ContestantStatus[length];
		for(int i = 0; i < length; i++)
			scoreBoard[i] = new ContestantStatus(i+1, 0, 0);
		return scoreBoard;
	}
	
	public static int PenaltyTimeProblem(LinkedList<Submit> lst) {
		int numberSubmits = lst.size();
		Submit lastSubmit = lst.getLast();
		int penaltyTime = (numberSubmits-1)*20 + lastSubmit.time;
		return penaltyTime;
	}
	
	public static void printArr(ContestantStatus[] x) {
		for(int i = 0; i < x.length; i++)
			System.out.println(x[i]);
		System.out.println();
	}
	
	public static Submit parseToSubmit(String s) {
		String[] split = s.split(" ");
		int a = Integer.parseInt(split[0]);
		int b = Integer.parseInt(split[1]);
		int c = Integer.parseInt(split[2]);
		char d = split[3].charAt(0);
		Submit foo = new Submit(a, b, c, d);
		return foo;
		
	}
	
	public static int[] parseInts(String s) {
		String[] sp = s.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static class Submit{
		int contestant, problem, time;
		char state;
		
		public Submit() {
			this(0, 0, 0, ' ');
		}
		
		public Submit(int c, int p, int t, char s) {
			contestant = c; problem = p; time = t; state = s;
		}
		
		public String toString() {
			return "contestant: " + contestant +
					"\nproblem: " + problem + 
					"\ntime: " + time + 
					"\nstate: " + state;
		}
		
		public int hashCode() {
//			return powInt(contestant*31, 13) + powInt(problem*31, 11); //(2 crashes)

			return powInt(contestant*31, 11) + powInt(problem*31, 7); //(1 crashes)
//			return powInt(contestant*31, 7) + powInt(problem*31, 5); //(3 crashes)
//			return powInt(2, contestant)*powInt(3,problem); //(8 crashes)
//			return problem*problem + contestant; //(4 crashes)
//			return (int) Math.pow(2, contestant)*(int) Math.pow(3, contestant); //using Arithmetic Fundamental Theorem principle (24 crashes)
//			return (contestant*(contestant-1) + problem*(problem+1));

		}
		
		/**
		 * @return x^y
		 */
		public static int powInt(int x, int y) {
			int prod = 1;
			for(int i = 0; i < y; i++)
				prod *= x;
			return prod;
		}
	}
	
	
	public static class ContestantStatus implements Comparable<ContestantStatus> {
		private int contestantNumber,  problemsSolved, penaltyTime;
		
		public ContestantStatus() { this(0, 0, 0); }
		public ContestantStatus(int cN, int pS, int pT) {
			contestantNumber = cN; problemsSolved = pS; penaltyTime = pT;
		}
		
		public void addSolution() { problemsSolved++; }
		public void addPenaltyTime(int penalty) { penaltyTime += penalty; }
		
		public int getContestantNumber() {
			return contestantNumber;
		}
		
		public int compareTo(ContestantStatus x) {
			if(this.problemsSolved > x.problemsSolved)
				return 1;
			else if(this.problemsSolved < x.problemsSolved)
				return -1;
			else if(this.penaltyTime > x.penaltyTime)
				return -1;
			else if(this.penaltyTime < x.penaltyTime)
				return 1;
			else if(this.contestantNumber > x.contestantNumber)
				return -1;
			else if(this.contestantNumber < x.contestantNumber)
				return 1;
			else 
				return 0;
		}
		
		public String toStringAlt() {
			return "contestantNumber: " + contestantNumber + 
					"\nproblemsSolved: " + problemsSolved + 
					"\npenaltyTime: " + penaltyTime;
		}
		
		public String toString() {
			return contestantNumber + " " + problemsSolved + " " + penaltyTime;
		}
	}
	

	// SeparateChaining Hash table class
	//
	// CONSTRUCTION: an approximate initial size or default of 101
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// void remove( x )       --> Remove x
	// boolean contains( x )  --> Return true if x is present
	// void makeEmpty( )      --> Remove all items
	/**
	 * Separate chaining table implementation of hash tables.
	 * Note that all "matching" is based on the equals method.
	 * @param <AnyType>
	 */
	public static class SeparateChainingHashTable<AnyType>
	{
	    /**
	     * Construct the hash table.
	     */
	    public SeparateChainingHashTable( )
	    {
	        this( DEFAULT_TABLE_SIZE );
	    }
	
	    /**
	     * Construct the hash table.
	     * @param size approximate table size.
	     */
	    public SeparateChainingHashTable( int size )
	    {
	        theLists = new LinkedList[ nextPrime( size ) ];
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ] = new LinkedList<>( );
	    }
	    
	    /**
	     * @param x
	     * @return a list containing all collisions referred to element x
	     */
	    public LinkedList<AnyType> getListOf(AnyType x) {
	    	LinkedList<AnyType> whichList = (LinkedList<AnyType>) theLists[ myhash( x )];
	    	return whichList;
	    }
	
	    /**
	     * Insert into the hash table. If the item is
	     * already present, then do nothing.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
//	    	System.out.println(myhash(x));
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( !whichList.contains( x ) )
	        {
	            whichList.add( x );
	
	                // Rehash; see Section 5.5
	            if( ++currentSize > theLists.length )
	                rehash( );
	        }
	    }
	
	    /**
	     * Remove from the hash table.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( whichList.contains( x ) )
	    {
	        whichList.remove( x );
	            currentSize--;
	    }
	    }
	
	    /**
	     * Find an item in the hash table.
	     * @param x the item to search for.
	     * @return true if x is found.
	     */
	    public boolean contains( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        return whichList.contains( x );
	    }
	
	    /**
	     * Make the hash table logically empty.
	     */
	    public void makeEmpty( )
	    {
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ].clear( );
	        currentSize = 0;  
	    }
	
	    /**
	     * A hash routine for String objects.
	     * @param key the String to hash.
	     * @param tableSize the size of the hash table.
	     * @return the hash value.
	     */
	    public static int hash( String key, int tableSize )
	    {
	        int hashVal = 0;
	
	        for( int i = 0; i < key.length( ); i++ )
	            hashVal = 37 * hashVal + key.charAt( i );
	
	        hashVal %= tableSize;
	        if( hashVal < 0 )
	            hashVal += tableSize;
	
	        return hashVal;
	    }
	
	    private void rehash( )
	    {
	        List<AnyType> [ ]  oldLists = theLists;
	
	            // Create new double-sized, empty table
	        theLists = new List[ nextPrime( 2 * theLists.length ) ];
	        for( int j = 0; j < theLists.length; j++ )
	            theLists[ j ] = new LinkedList<>( );
	
	            // Copy table over
	        currentSize = 0;
	        for( List<AnyType> list : oldLists )
	            for( AnyType item : list )
	                insert( item );
	    }
	
	    private int myhash( AnyType x )
	    {
	        int hashVal = x.hashCode( );
	        hashVal %= theLists.length;
	        if( hashVal < 0 )
	            hashVal += theLists.length;
	        return hashVal;
	    }
	    
	    private static final int DEFAULT_TABLE_SIZE = 101;
	
	        /** The array of Lists. */
	    private List<AnyType> [ ] theLists; 
	    private int currentSize;
	
	    /**
	     * Internal method to find a prime number at least as large as n.
	     * @param n the starting number (must be positive).
	     * @return a prime number larger than or equal to n.
	     */
	    @SuppressWarnings("empty-statement")
	    private static int nextPrime( int n )
	    {
	        if( n % 2 == 0 )
	            n++;
	
	        for( ; !isPrime( n ); n += 2 )
	            ;
	
	        return n;
	    }
	
	    /**
	     * Internal method to test if a number is prime.
	     * Not an efficient algorithm.
	     * @param n the number to test.
	     * @return the result of the test.
	     */
	    private static boolean isPrime( int n )
	    {
	        if( n == 2 || n == 3 )
	            return true;
	
	        if( n == 1 || n % 2 == 0 )
	            return false;
	
	        for( int i = 3; i * i <= n; i += 2 )
	            if( n % i == 0 )
	                return false;
	
	        return true;
	    }
	}


	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}
		
		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( AnyType [ ] items )
		{
				currentSize = items.length;
				array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

				int i = 1;
				for( AnyType item : items )
					array[ i++ ] = item;
				buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

				// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		@SuppressWarnings("unchecked")
		private void enlargeArray( int newSize )
		{
				AnyType [] old = array;
				array = (AnyType []) new Comparable[ newSize ];
				for( int i = 0; i < old.length; i++ )
					array[ i ] = old[ i ];        
		}
		
		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) > 0 )
					child++;
				if( array[ child ].compareTo( tmp ) > 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
		
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");
			for(int i = 0; i < array.length; i++)
				sb.append(array[i] + " ");
			sb.append("] \n" );
			return new String(sb);
		}
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemAv3 {
	public static void main(String[] args) throws Exception {
		Scanner in = new Scanner(System.in);
		int T = Integer.parseInt(in.nextLine()); //number of cases
		for(int testCase = 1; testCase <= T; testCase++) {
			System.out.println("Caso #" + testCase + ":");
			int[] params = parseInts(in.nextLine()); //N K
			
			ContestantStatus[] scoreBoard = initScoreBoard(params[0]); //array that contains partial scoreboards
			SeparateChainingHashTable<Submit> submits = new SeparateChainingHashTable<>(); //see hash of Submit class to details to store
			
			LinkedList<Submit> problemTeamSubs; //list containing submits of same problem of a contestant/team. Is retrieved from a hash table
			
			for(int i = 0; i < params[1]; i++) {
				Submit tmp = parseToSubmit(in.nextLine());
				submits.insert(tmp);
//				System.out.println("tmpSubmit: " + tmp);
				scoreBoard[tmp.contestant-1].active = true;
				if(tmp.state == 'C') {
					problemTeamSubs = submits.getListOf(tmp);

					//Check if contents of linked list is trusted
					//===============================================
//					for(Submit item : problemTeamSubs) {
//						System.out.println("item tmp to cmp is:\n\t" + item + "\n");
//						if(item.contestant != tmp.contestant )
//							System.out.println("!!!!crash on contestant: " + item.contestant);
//						if(item.problem != tmp.problem )
//							System.out.println("!!!!crash on problem: " + item.problem);
//					}
					
					//===============================================
					
					int partialTime = PenaltyTimeProblem(problemTeamSubs);
					
					scoreBoard[tmp.contestant-1].addPenaltyTime(partialTime);
					scoreBoard[tmp.contestant-1].addSolution();
					
				}
			}	
			BinaryHeap<ContestantStatus> order = fillHeap(scoreBoard);
			System.out.print(printScoreBoard(order));
		}
		in.close();
	}
	
	public static BinaryHeap<ContestantStatus> fillHeap(ContestantStatus[] x) {
		BinaryHeap<ContestantStatus> order = new BinaryHeap<>();
		for(int i = 0; i < x.length; i++)
			if(x[i].active)
				order.insert(x[i]);
		return order;
		
	}
	
	public static String printScoreBoard(BinaryHeap<ContestantStatus> order) throws Exception {
		StringBuilder sb = new StringBuilder();
		while(! order.isEmpty() ) {
			String tmp = order.deleteMin().toString();
			sb.append(tmp + "\n");
		}
		return new String(sb);
	}
	
	public static ContestantStatus[] initScoreBoard(int length) {
		ContestantStatus[] scoreBoard = new ContestantStatus[length];
		for(int i = 0; i < length; i++)
			scoreBoard[i] = new ContestantStatus(i+1, 0, 0);
		return scoreBoard;
	}
	
	public static int PenaltyTimeProblem(LinkedList<Submit> lst) {
		int numberSubmits = lst.size();
		Submit lastSubmit = lst.getLast();
		int penaltyTime = (numberSubmits-1)*20 + lastSubmit.time;
		return penaltyTime;
	}
	
	public static void printArr(ContestantStatus[] x) {
		for(int i = 0; i < x.length; i++)
			System.out.println(x[i]);
		System.out.println();
	}
	
	public static Submit parseToSubmit(String s) {
		String[] split = s.split(" ");
		int a = Integer.parseInt(split[0]);
		int b = Integer.parseInt(split[1]);
		int c = Integer.parseInt(split[2]);
		char d = split[3].charAt(0);
		Submit foo = new Submit(a, b, c, d);
		return foo;
		
	}
	
	public static int[] parseInts(String s) {
		String[] sp = s.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static class Submit{
		int contestant, problem, time;
		char state;
		
		public Submit() {
			this(0, 0, 0, ' ');
		}
		
		public Submit(int c, int p, int t, char s) {
			contestant = c; problem = p; time = t; state = s;
		}
		
		public String toString() {
			return "contestant: " + contestant +
					"\nproblem: " + problem + 
					"\ntime: " + time + 
					"\nstate: " + state;
		}
		
		public int hashCode() {
//			return powInt(contestant*31, 13) + powInt(problem*31, 11); //(2 crashes)

			return powInt(contestant*31, 11) + powInt(problem*31, 7); //(1 crashes)
//			return powInt(contestant*31, 7) + powInt(problem*31, 5); //(3 crashes)
//			return powInt(2, contestant)*powInt(3,problem); //(8 crashes)
//			return problem*problem + contestant; //(4 crashes)
//			return (int) Math.pow(2, contestant)*(int) Math.pow(3, contestant); //using Arithmetic Fundamental Theorem principle (24 crashes)
//			return (contestant*(contestant-1) + problem*(problem+1));

		}
		
		/**
		 * @return x^y
		 */
		public static int powInt(int x, int y) {
			int prod = 1;
			for(int i = 0; i < y; i++)
				prod *= x;
			return prod;
		}
	}
	
	
	public static class ContestantStatus implements Comparable<ContestantStatus> {
		private int contestantNumber,  problemsSolved, penaltyTime;
		boolean active;
		
		public ContestantStatus() { this(0, 0, 0); }
		public ContestantStatus(int cN, int pS, int pT) {
			contestantNumber = cN; problemsSolved = pS; penaltyTime = pT;
			active = false;
		}
		
		public void addSolution() { problemsSolved++; }
		public void addPenaltyTime(int penalty) { penaltyTime += penalty; }
		
		public int getContestantNumber() {
			return contestantNumber;
		}
		
		public int compareTo(ContestantStatus x) {
			if(this.problemsSolved > x.problemsSolved)
				return 1;
			else if(this.problemsSolved < x.problemsSolved)
				return -1;
			else if(this.penaltyTime > x.penaltyTime)
				return -1;
			else if(this.penaltyTime < x.penaltyTime)
				return 1;
			else if(this.contestantNumber > x.contestantNumber)
				return -1;
			else if(this.contestantNumber < x.contestantNumber)
				return 1;
			else 
				return 0;
		}
		
		public String toStringAlt() {
			return "contestantNumber: " + contestantNumber + 
					"\nproblemsSolved: " + problemsSolved + 
					"\npenaltyTime: " + penaltyTime;
		}
		
		public String toString() {
			return contestantNumber + " " + problemsSolved + " " + penaltyTime;
		}
	}
	

	// SeparateChaining Hash table class
	//
	// CONSTRUCTION: an approximate initial size or default of 101
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// void remove( x )       --> Remove x
	// boolean contains( x )  --> Return true if x is present
	// void makeEmpty( )      --> Remove all items
	/**
	 * Separate chaining table implementation of hash tables.
	 * Note that all "matching" is based on the equals method.
	 * @param <AnyType>
	 */
	public static class SeparateChainingHashTable<AnyType>
	{
	    /**
	     * Construct the hash table.
	     */
	    public SeparateChainingHashTable( )
	    {
	        this( DEFAULT_TABLE_SIZE );
	    }
	
	    /**
	     * Construct the hash table.
	     * @param size approximate table size.
	     */
	    public SeparateChainingHashTable( int size )
	    {
	        theLists = new LinkedList[ nextPrime( size ) ];
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ] = new LinkedList<>( );
	    }
	    
	    /**
	     * @param x
	     * @return a list containing all collisions referred to element x
	     */
	    public LinkedList<AnyType> getListOf(AnyType x) {
	    	LinkedList<AnyType> whichList = (LinkedList<AnyType>) theLists[ myhash( x )];
	    	return whichList;
	    }
	
	    /**
	     * Insert into the hash table. If the item is
	     * already present, then do nothing.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
//	    	System.out.println(myhash(x));
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( !whichList.contains( x ) )
	        {
	            whichList.add( x );
	
	                // Rehash; see Section 5.5
	            if( ++currentSize > theLists.length )
	                rehash( );
	        }
	    }
	
	    /**
	     * Remove from the hash table.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( whichList.contains( x ) )
	    {
	        whichList.remove( x );
	            currentSize--;
	    }
	    }
	
	    /**
	     * Find an item in the hash table.
	     * @param x the item to search for.
	     * @return true if x is found.
	     */
	    public boolean contains( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        return whichList.contains( x );
	    }
	
	    /**
	     * Make the hash table logically empty.
	     */
	    public void makeEmpty( )
	    {
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ].clear( );
	        currentSize = 0;  
	    }
	
	    /**
	     * A hash routine for String objects.
	     * @param key the String to hash.
	     * @param tableSize the size of the hash table.
	     * @return the hash value.
	     */
	    public static int hash( String key, int tableSize )
	    {
	        int hashVal = 0;
	
	        for( int i = 0; i < key.length( ); i++ )
	            hashVal = 37 * hashVal + key.charAt( i );
	
	        hashVal %= tableSize;
	        if( hashVal < 0 )
	            hashVal += tableSize;
	
	        return hashVal;
	    }
	
	    private void rehash( )
	    {
	        List<AnyType> [ ]  oldLists = theLists;
	
	            // Create new double-sized, empty table
	        theLists = new List[ nextPrime( 2 * theLists.length ) ];
	        for( int j = 0; j < theLists.length; j++ )
	            theLists[ j ] = new LinkedList<>( );
	
	            // Copy table over
	        currentSize = 0;
	        for( List<AnyType> list : oldLists )
	            for( AnyType item : list )
	                insert( item );
	    }
	
	    private int myhash( AnyType x )
	    {
	        int hashVal = x.hashCode( );
	        hashVal %= theLists.length;
	        if( hashVal < 0 )
	            hashVal += theLists.length;
	        return hashVal;
	    }
	    
	    private static final int DEFAULT_TABLE_SIZE = 101;
	
	        /** The array of Lists. */
	    private List<AnyType> [ ] theLists; 
	    private int currentSize;
	
	    /**
	     * Internal method to find a prime number at least as large as n.
	     * @param n the starting number (must be positive).
	     * @return a prime number larger than or equal to n.
	     */
	    @SuppressWarnings("empty-statement")
	    private static int nextPrime( int n )
	    {
	        if( n % 2 == 0 )
	            n++;
	
	        for( ; !isPrime( n ); n += 2 )
	            ;
	
	        return n;
	    }
	
	    /**
	     * Internal method to test if a number is prime.
	     * Not an efficient algorithm.
	     * @param n the number to test.
	     * @return the result of the test.
	     */
	    private static boolean isPrime( int n )
	    {
	        if( n == 2 || n == 3 )
	            return true;
	
	        if( n == 1 || n % 2 == 0 )
	            return false;
	
	        for( int i = 3; i * i <= n; i += 2 )
	            if( n % i == 0 )
	                return false;
	
	        return true;
	    }
	}


	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}
		
		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( AnyType [ ] items )
		{
				currentSize = items.length;
				array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

				int i = 1;
				for( AnyType item : items )
					array[ i++ ] = item;
				buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

				// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		@SuppressWarnings("unchecked")
		private void enlargeArray( int newSize )
		{
				AnyType [] old = array;
				array = (AnyType []) new Comparable[ newSize ];
				for( int i = 0; i < old.length; i++ )
					array[ i ] = old[ i ];        
		}
		
		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) > 0 )
					child++;
				if( array[ child ].compareTo( tmp ) > 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
		
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");
			for(int i = 0; i < array.length; i++)
				sb.append(array[i] + " ");
			sb.append("] \n" );
			return new String(sb);
		}
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;

public class ProblemDv1 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		int t = Integer.parseInt(in.nextLine());
		
		for(int testCase = 1; testCase <= t; testCase++) {
			StringBuilder sb = new StringBuilder("Caso #" + testCase + ":");
			int[] params = getInts(in.nextLine());
			
			UnionFind relations = new UnionFind(params[0]);
			int ans;
			for(int i = 0; i < params[1]; i++) { 
				int[] command = getInts(in.nextLine());
//				printArr(command);
				switch (command[0]) {
					case 1:
						if(getEnemies(relations, command) == 1) {
							System.out.println(-1);
							break;
						}
						relations.union(command[1], command[2]);
						break;
						
					case 2:
						if(getFriend(relations, command) == 1) {
							System.out.println(-1);
							break;
						}
						int a = relations.find(command[1]);
						int b = relations.find(command[2]);
						
						if(a == command[1]) { //a is its same parent?
							relations.union(command[2], relations.getLastJoined());
							break; 
						} else if(b == command[2]){ //b is its same parent? 
							relations.union(command[1], relations.getLastJoined());
							break;
						}
						break;
					case 3: 
						System.out.println(getFriend(relations, command));
						break;
						
					case 4: 
						System.out.println(getEnemies(relations, command));
						break;
					
					default: 
						break;
				}
			}
		}
		in.close();
	}
	
	public static void printArr(int[] arr) {
		for(int i = 0; i < arr.length; i++)
			System.out.print(arr[i] + " ");
		System.out.println();
	}
	
	public static int getFriend(UnionFind relations, int[] command) {
		int ans;
		if(relations.sameSet(command[1], command[2]))
			ans = 1;
		else 
			ans = 0;
		return ans;
	}
	
	public static int getEnemies(UnionFind relations, int[] command) {
		int x = relations.find(command[0]);
		int y = relations.find(command[1]);
//		System.out.println("p1: " + x + " p2: " + y);
		int ans;
		
		if(x == command[0] && y == command[1])
			ans = 0;
		else if( x == y)
			ans = 0;
		else
			ans = 1;
		
		return ans;
	}
	
	public static int[] getInts(String str) {
		String[] sp = str.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static class UnionFind {
		
		private int id[];
		private int rank[];
		private int cont;
		private int lastJoined;

		public int getCont() {
			return cont;
		}
		
		public void printSet() {
			for(int i = 0; i < id.length; i++)
				System.out.print(i + " ");
			System.out.println();
			for(int i = 0; i < id.length; i++)
				System.out.print(id[i] + " ");
			System.out.println();
			System.out.println();
			System.out.println();
		}
		
		public int getLastJoined() {
			return lastJoined;
		}

		public UnionFind(int n) {
			id = new int[n];
			rank = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				rank[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}
		
		public boolean sameSet(int x, int y) {
			boolean flag = false;
			int a = find(x);
			int b = find(y);
			if(a == b)
				flag = true;
			return flag;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			lastJoined = x;
			if (a == b) {
				return;
			}
			if (rank[a] < rank[b]) {
				id[a] = b;
			} else {
				id[b] = a;
				if (rank[a] == rank[b])
					rank[b]++;
			}
			cont--;
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;

public class ProblemDv2 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		int t = Integer.parseInt(in.nextLine());
		
		for(int testCase = 1; testCase <= t; testCase++) {
			StringBuilder sb = new StringBuilder("Caso #" + testCase + ":");
			int[] params = getInts(in.nextLine());
			
			UnionFind relations = new UnionFind(params[0]);
			int ans;
			for(int i = 0; i < params[1]; i++) { 
				int[] command = getInts(in.next());
				
				switch (command[0]) {
					case 1:
						relations.union(command[1], command[2]);
						break;
						
					case 2: 
						int a = relations.find(command[1]);
						int b = relations.find(command[2]);
						
						if(a == command[1]) { //a is its same parent?
							relations.union(a, relations.getMainParent());
							break; 
						} else if(b == command[2]){ //b is its same parent? 
							relations.union(b, relations.getMainParent());
							break;
						}
						break;
					case 3: 
						
						if(relations.sameSet(command[1], command[2]))
								ans = 1;
						else 
								ans = 0;
						System.out.println(ans);
						break;
						
					case 4: 
						int x = relations.find(command[0]);
						int y = relations.find(command[1]);
						
						if(x == command[0] && y == command[1])
							ans = 0;
						else if( x == y)
							ans = 0;
						else 
							ans = 1;
						
						System.out.println(ans);
						break;
					
					default: 
						break;
				}
			}
		}
		in.close();
	}
	
	public static int[] getInts(String str) {
		String[] sp = str.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static class UnionFind {
		
		private int id[];
		private int rank[];
		private int cont;
		private int mainParent;

		public int getCont() {
			return cont;
		}
		
		public int getMainParent() {
			return mainParent;
		}

		public UnionFind(int n) {
			id = new int[n];
			rank = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				rank[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}
		
		public boolean sameSet(int x, int y) {
			boolean flag = false;
			int a = find(x);
			int b = find(y);
			if(a == b)
				flag = true;
			return flag;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			
			if (a == b) {
				mainParent = a;
				return;
			}
			if (rank[a] < rank[b]) {
				id[a] = b;
				mainParent = b;
			} else {
				id[b] = a;
				mainParent = a;
				if (rank[a] == rank[b])
					rank[b]++;
			}
			cont--;
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;

public class ProblemDv1 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		int t = Integer.parseInt(in.nextLine());
		
		for(int testCase = 1; testCase <= t; testCase++) {
			StringBuilder sb = new StringBuilder("Caso #" + testCase + ":");
			int[] params = getInts(in.nextLine());
			
			UnionFind relations = new UnionFind(params[0]);
			int ans;
			for(int i = 0; i < params[1]; i++) { 
				int[] command = getInts(in.nextLine());
//				printArr(command);
				switch (command[0]) {
					case 1:
						if(getEnemies(relations, command) == 1) {
							System.out.println(-1);
							break;
						}
						relations.union(command[1], command[2]);
						break;
						
					case 2:
						if(getFriend(relations, command) == 1) {
							System.out.println(-1);
							break;
						}
						int a = relations.find(command[1]);
						int b = relations.find(command[2]);
						
						if(a == command[1]) { //a is its same parent?
							relations.union(command[2], relations.getLastJoined());
							break; 
						} else if(b == command[2]){ //b is its same parent? 
							relations.union(command[1], relations.getLastJoined());
							break;
						}
						break;
					case 3: 
						System.out.println(getFriend(relations, command));
						break;
						
					case 4: 
						System.out.println(getEnemies(relations, command));
						break;
					
					default: 
						break;
				}
			}
		}
		in.close();
	}
	
	public static void printArr(int[] arr) {
		for(int i = 0; i < arr.length; i++)
			System.out.print(arr[i] + " ");
		System.out.println();
	}
	
	public static int getFriend(UnionFind relations, int[] command) {
		int ans;
		if(relations.sameSet(command[1], command[2]))
			ans = 1;
		else 
			ans = 0;
		return ans;
	}
	
	public static int getEnemies(UnionFind relations, int[] command) {
		int x = relations.find(command[0]);
		int y = relations.find(command[1]);
//		System.out.println("p1: " + x + " p2: " + y);
		int ans;
		
		if(x == command[0] && y == command[1])
			ans = 0;
		else if( x == y)
			ans = 0;
		else
			ans = 1;
		
		return ans;
	}
	
	public static int[] getInts(String str) {
		String[] sp = str.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static class UnionFind {
		
		private int id[];
		private int rank[];
		private int cont;
		private int lastJoined;

		public int getCont() {
			return cont;
		}
		
		public void printSet() {
			for(int i = 0; i < id.length; i++)
				System.out.print(i + " ");
			System.out.println();
			for(int i = 0; i < id.length; i++)
				System.out.print(id[i] + " ");
			System.out.println();
			System.out.println();
			System.out.println();
		}
		
		public int getLastJoined() {
			return lastJoined;
		}

		public UnionFind(int n) {
			id = new int[n];
			rank = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				rank[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}
		
		public boolean sameSet(int x, int y) {
			boolean flag = false;
			int a = find(x);
			int b = find(y);
			if(a == b)
				flag = true;
			return flag;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			lastJoined = x;
			if (a == b) {
				return;
			}
			if (rank[a] < rank[b]) {
				id[a] = b;
			} else {
				id[b] = a;
				if (rank[a] == rank[b])
					rank[b]++;
			}
			cont--;
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemAv3 {
	public static void main(String[] args) throws Exception {
		Scanner in = new Scanner(System.in);
		int T = Integer.parseInt(in.nextLine()); //number of cases
		for(int testCase = 1; testCase <= T; testCase++) {
			System.out.println("Caso #" + testCase + ":");
			int[] params = parseInts(in.nextLine()); //N K
			
			ContestantStatus[] scoreBoard = initScoreBoard(params[0]); //array that contains partial scoreboards
			SeparateChainingHashTable<Submit> submits = new SeparateChainingHashTable<>(); //see hash of Submit class to details to store
			
			LinkedList<Submit> problemTeamSubs; //list containing submits of same problem of a contestant/team. Is retrieved from a hash table
			
			for(int i = 0; i < params[1]; i++) {
				Submit tmp = parseToSubmit(in.nextLine());
				submits.insert(tmp);
//				System.out.println("tmpSubmit: " + tmp);
				scoreBoard[tmp.contestant-1].active = true;
				if(tmp.state == 'C') {
					problemTeamSubs = submits.getListOf(tmp);

					//Check if contents of linked list is trusted
					//===============================================
//					for(Submit item : problemTeamSubs) {
//						System.out.println("item tmp to cmp is:\n\t" + item + "\n");
//						if(item.contestant != tmp.contestant )
//							System.out.println("!!!!crash on contestant: " + item.contestant);
//						if(item.problem != tmp.problem )
//							System.out.println("!!!!crash on problem: " + item.problem);
//					}
					
					//===============================================
					
					int partialTime = PenaltyTimeProblem(problemTeamSubs);
					
					scoreBoard[tmp.contestant-1].addPenaltyTime(partialTime);
					scoreBoard[tmp.contestant-1].addSolution();
					
				}
			}	
			BinaryHeap<ContestantStatus> order = fillHeap(scoreBoard);
			System.out.print(printScoreBoard(order));
		}
		in.close();
	}
	
	public static BinaryHeap<ContestantStatus> fillHeap(ContestantStatus[] x) {
		BinaryHeap<ContestantStatus> order = new BinaryHeap<>();
		for(int i = 0; i < x.length; i++)
			if(x[i].active)
				order.insert(x[i]);
		return order;
		
	}
	
	public static String printScoreBoard(BinaryHeap<ContestantStatus> order) throws Exception {
		StringBuilder sb = new StringBuilder();
		while(! order.isEmpty() ) {
			String tmp = order.deleteMin().toString();
			sb.append(tmp + "\n");
		}
		return new String(sb);
	}
	
	public static ContestantStatus[] initScoreBoard(int length) {
		ContestantStatus[] scoreBoard = new ContestantStatus[length];
		for(int i = 0; i < length; i++)
			scoreBoard[i] = new ContestantStatus(i+1, 0, 0);
		return scoreBoard;
	}
	
	public static int PenaltyTimeProblem(LinkedList<Submit> lst) {
		int numberSubmits = lst.size();
		Submit lastSubmit = lst.getLast();
		int penaltyTime = (numberSubmits-1)*20 + lastSubmit.time;
		return penaltyTime;
	}
	
	public static void printArr(ContestantStatus[] x) {
		for(int i = 0; i < x.length; i++)
			System.out.println(x[i]);
		System.out.println();
	}
	
	public static Submit parseToSubmit(String s) {
		String[] split = s.split(" ");
		int a = Integer.parseInt(split[0]);
		int b = Integer.parseInt(split[1]);
		int c = Integer.parseInt(split[2]);
		char d = split[3].charAt(0);
		Submit foo = new Submit(a, b, c, d);
		return foo;
		
	}
	
	public static int[] parseInts(String s) {
		String[] sp = s.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static class Submit{
		int contestant, problem, time;
		char state;
		
		public Submit() {
			this(0, 0, 0, ' ');
		}
		
		public Submit(int c, int p, int t, char s) {
			contestant = c; problem = p; time = t; state = s;
		}
		
		public String toString() {
			return "contestant: " + contestant +
					"\nproblem: " + problem + 
					"\ntime: " + time + 
					"\nstate: " + state;
		}
		
		public int hashCode() {
//			return powInt(contestant*7, 17) + powInt(problem*35, 13);
//			return powInt(contestant*31, 13) + powInt(problem*31, 11); //(2 crashes)

			return powInt(contestant*31, 11) + powInt(problem*31, 7); //(1 crashes)
			
//			return powInt(contestant*31, 7) + powInt(problem*31, 5); //(3 crashes)
//			return powInt(2, contestant)*powInt(3,problem); //(8 crashes)
//			return problem*problem + contestant; //(4 crashes)
//			return (int) Math.pow(2, contestant)*(int) Math.pow(3, contestant); //using Arithmetic Fundamental Theorem principle (24 crashes)
//			return (contestant*(contestant-1) + problem*(problem+1));

		}
		
		/**
		 * @return x^y
		 */
		public static int powInt(int x, int y) {
			int prod = 1;
			for(int i = 0; i < y; i++)
				prod *= x;
			return prod;
		}
	}
	
	
	public static class ContestantStatus implements Comparable<ContestantStatus> {
		private int contestantNumber,  problemsSolved, penaltyTime;
		boolean active;
		
		public ContestantStatus() { this(0, 0, 0); }
		public ContestantStatus(int cN, int pS, int pT) {
			contestantNumber = cN; problemsSolved = pS; penaltyTime = pT;
			active = false;
		}
		
		public void addSolution() { problemsSolved++; }
		public void addPenaltyTime(int penalty) { penaltyTime += penalty; }
		
		public int getContestantNumber() {
			return contestantNumber;
		}
		
		public int compareTo(ContestantStatus x) {
			if(this.problemsSolved > x.problemsSolved)
				return 1;
			else if(this.problemsSolved < x.problemsSolved)
				return -1;
			else if(this.penaltyTime > x.penaltyTime)
				return -1;
			else if(this.penaltyTime < x.penaltyTime)
				return 1;
			else if(this.contestantNumber > x.contestantNumber)
				return -1;
			else if(this.contestantNumber < x.contestantNumber)
				return 1;
			else 
				return 0;
		}
		
		public String toStringAlt() {
			return "contestantNumber: " + contestantNumber + 
					"\nproblemsSolved: " + problemsSolved + 
					"\npenaltyTime: " + penaltyTime;
		}
		
		public String toString() {
			return contestantNumber + " " + problemsSolved + " " + penaltyTime;
		}
	}
	

	// SeparateChaining Hash table class
	//
	// CONSTRUCTION: an approximate initial size or default of 101
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// void remove( x )       --> Remove x
	// boolean contains( x )  --> Return true if x is present
	// void makeEmpty( )      --> Remove all items
	/**
	 * Separate chaining table implementation of hash tables.
	 * Note that all "matching" is based on the equals method.
	 * @param <AnyType>
	 */
	public static class SeparateChainingHashTable<AnyType>
	{
	    /**
	     * Construct the hash table.
	     */
	    public SeparateChainingHashTable( )
	    {
	        this( DEFAULT_TABLE_SIZE );
	    }
	
	    /**
	     * Construct the hash table.
	     * @param size approximate table size.
	     */
	    public SeparateChainingHashTable( int size )
	    {
	        theLists = new LinkedList[ nextPrime( size ) ];
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ] = new LinkedList<>( );
	    }
	    
	    /**
	     * @param x
	     * @return a list containing all collisions referred to element x
	     */
	    public LinkedList<AnyType> getListOf(AnyType x) {
	    	LinkedList<AnyType> whichList = (LinkedList<AnyType>) theLists[ myhash( x )];
	    	return whichList;
	    }
	
	    /**
	     * Insert into the hash table. If the item is
	     * already present, then do nothing.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
//	    	System.out.println(myhash(x));
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( !whichList.contains( x ) )
	        {
	            whichList.add( x );
	
	                // Rehash; see Section 5.5
	            if( ++currentSize > theLists.length )
	                rehash( );
	        }
	    }
	
	    /**
	     * Remove from the hash table.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        if( whichList.contains( x ) )
	    {
	        whichList.remove( x );
	            currentSize--;
	    }
	    }
	
	    /**
	     * Find an item in the hash table.
	     * @param x the item to search for.
	     * @return true if x is found.
	     */
	    public boolean contains( AnyType x )
	    {
	        List<AnyType> whichList = theLists[ myhash( x ) ];
	        return whichList.contains( x );
	    }
	
	    /**
	     * Make the hash table logically empty.
	     */
	    public void makeEmpty( )
	    {
	        for( int i = 0; i < theLists.length; i++ )
	            theLists[ i ].clear( );
	        currentSize = 0;  
	    }
	
	    /**
	     * A hash routine for String objects.
	     * @param key the String to hash.
	     * @param tableSize the size of the hash table.
	     * @return the hash value.
	     */
	    public static int hash( String key, int tableSize )
	    {
	        int hashVal = 0;
	
	        for( int i = 0; i < key.length( ); i++ )
	            hashVal = 37 * hashVal + key.charAt( i );
	
	        hashVal %= tableSize;
	        if( hashVal < 0 )
	            hashVal += tableSize;
	
	        return hashVal;
	    }
	
	    private void rehash( )
	    {
	        List<AnyType> [ ]  oldLists = theLists;
	
	            // Create new double-sized, empty table
	        theLists = new List[ nextPrime( 2 * theLists.length ) ];
	        for( int j = 0; j < theLists.length; j++ )
	            theLists[ j ] = new LinkedList<>( );
	
	            // Copy table over
	        currentSize = 0;
	        for( List<AnyType> list : oldLists )
	            for( AnyType item : list )
	                insert( item );
	    }
	
	    private int myhash( AnyType x )
	    {
	        int hashVal = x.hashCode( );
	        hashVal %= theLists.length;
	        if( hashVal < 0 )
	            hashVal += theLists.length;
	        return hashVal;
	    }
	    
	    private static final int DEFAULT_TABLE_SIZE = 101;
	
	        /** The array of Lists. */
	    private List<AnyType> [ ] theLists; 
	    private int currentSize;
	
	    /**
	     * Internal method to find a prime number at least as large as n.
	     * @param n the starting number (must be positive).
	     * @return a prime number larger than or equal to n.
	     */
	    @SuppressWarnings("empty-statement")
	    private static int nextPrime( int n )
	    {
	        if( n % 2 == 0 )
	            n++;
	
	        for( ; !isPrime( n ); n += 2 )
	            ;
	
	        return n;
	    }
	
	    /**
	     * Internal method to test if a number is prime.
	     * Not an efficient algorithm.
	     * @param n the number to test.
	     * @return the result of the test.
	     */
	    private static boolean isPrime( int n )
	    {
	        if( n == 2 || n == 3 )
	            return true;
	
	        if( n == 1 || n % 2 == 0 )
	            return false;
	
	        for( int i = 3; i * i <= n; i += 2 )
	            if( n % i == 0 )
	                return false;
	
	        return true;
	    }
	}


	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}
		
		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( AnyType [ ] items )
		{
				currentSize = items.length;
				array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

				int i = 1;
				for( AnyType item : items )
					array[ i++ ] = item;
				buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

				// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		@SuppressWarnings("unchecked")
		private void enlargeArray( int newSize )
		{
				AnyType [] old = array;
				array = (AnyType []) new Comparable[ newSize ];
				for( int i = 0; i < old.length; i++ )
					array[ i ] = old[ i ];        
		}
		
		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) > 0 )
					child++;
				if( array[ child ].compareTo( tmp ) > 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
		
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");
			for(int i = 0; i < array.length; i++)
				sb.append(array[i] + " ");
			sb.append("] \n" );
			return new String(sb);
		}
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayDeque;
import java.util.HashSet;

public class ProblemaA {

	public static void main(String args[]) throws FileNotFoundException {
		Scanner scan;
		File f = new File("A_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 0; t < n; t++) {
			System.out.println("Caso #:" + t + ":");
			int Q = Integer.parseInt(scan.nextLine());// numero de consultas
			
			ArrayDeque<Integer> cola = new ArrayDeque<>();
			HashSet <Integer> parking = new HashSet<>();
			
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que
															// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					
					cola.offer(new Integer(line[1]));
					
				} else if (type.equals("atender")) {

					parking.add(cola.poll());
					
				} else if (type.equals("existe")) {
					
					boolean flag = parking.contains(new Integer(line[1]));
					if( flag )
						System.out.println("SI");
					else
						System.out.println("NO");

				}

			}
		}
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayDeque;
import java.util.HashSet;

public class ProblemaA {

	public static void main(String args[]) throws FileNotFoundException {
		Scanner scan;
		File f = new File("A_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 0; t < n; t++) {
			System.out.println("Caso #:" + t+1 + ":");
			int Q = Integer.parseInt(scan.nextLine());// numero de consultas
			
			ArrayDeque<Integer> cola = new ArrayDeque<>();
			HashSet <Integer> parking = new HashSet<>();
			
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que
															// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					
					cola.offer(new Integer(line[1]));
					
				} else if (type.equals("atender")) {

					parking.add(cola.poll());
					
				} else if (type.equals("existe")) {
					
					boolean flag = parking.contains(new Integer(line[1]));
					if( flag )
						System.out.println("SI");
					else
						System.out.println("NO");

				}

			}
		}
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayDeque;
import java.util.HashSet;

public class ProblemaA {

	public static void main(String args[]) throws FileNotFoundException {
		Scanner scan;
		File f = new File("A_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 1; t <= n; t++) {
			System.out.println("Caso #" + t + ":");
			int Q = Integer.parseInt(scan.nextLine());// numero de consultas
			
			ArrayDeque<Integer> cola = new ArrayDeque<>();
			HashSet <Integer> parking = new HashSet<>();
			
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que
															// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					
					cola.offer(new Integer(line[1]));
					
				} else if (type.equals("atender")) {

					parking.add(cola.poll());
					
				} else if (type.equals("existe")) {
					
					boolean flag = parking.contains(new Integer(line[1]));
					if( flag )
						System.out.println("SI");
					else
						System.out.println("NO");

				}

			}
		}
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayDeque;
import java.util.HashMap;

public class ProblemaB {

	public static void main(String args[]) throws Exception {
		Scanner scan;
		File f = new File("A_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 1; t <= n; t++) {
			System.out.println("Caso #" + t + ":");
			int[] params = getInts(scan.nextLine());// numero de consultas
			
			Integer[] initVals = makeArr(params[1]-1);
			
			ArrayDeque<Integer> cola = new ArrayDeque<>();
			HashMap <Integer, Integer> parking = new HashMap<>();
			BinaryHeap<Integer> prioridad = new BinaryHeap<>(initVals);
			
			for (int i = 0; i < params[0]; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que
															// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					
					cola.offer(new Integer(line[1]));
					
				} else if (type.equals("atender")) {

					parking.put(cola.poll(), prioridad.deleteMin() );
					
				} else if (type.equals("existe")) {
					
					boolean flag = parking.containsKey(new Integer(line[1]));
					Integer place = parking.get(new Integer(line[1]));
					if( flag )
						System.out.println("SI " + place);
					else
						System.out.println("NO");

				} else if (type.equals("salir")) {
					Integer tmp = parking.remove(new Integer(line[1]));
//					System.out.println("saliendo: " + tmp.intValue());
					prioridad.insert(tmp);
				}

			}
		}
		

	}
	
	public static int[] getInts(String str) {
		String[] sp = str.split(" ");
		int[] nums = new int[sp.length];
		for(int i = 0; i < sp.length; i++)
			nums[i] = Integer.parseInt(sp[i]);
		return nums;
	}
	
	public static Integer[] makeArr(int length) {
		Integer[] nums = new Integer[length];
		for(int i = 0; i < nums.length; i++)
			nums[i] = new Integer(i);
		return nums;
	}
	
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.*; // For HashMap

public class ProblemBv1 {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		
		int t = Integer.parseInt(input.nextLine());
		
		for(int testCase = 1; testCase <= t; testCase ++) {
			System.out.println("Case #" + testCase + ":");
			int[] params = getNums(input.nextLine()); //N(#PCs) M(#CNXs) A B
			
			DirectedGraph<Integer> graph = new DirectedGraph<>();
			
			for(int i = 0; i < params[0]; i++) //initialize graph with PCs IDs
				graph.addNode(new Integer(i));
			
			for(int i = 0; i < params[1]; i++) { //Receive conextion specification and make conections
				int[] conex = getNums(input.nextLine());
				graph.addEdge(conex[1], conex[0], conex[2]);
				graph.addEdge(conex[0], conex[1], conex[2]);	
			}
			
			HashMap<Integer, Double> paths = (HashMap<Integer, Double>) Dijkstra.shortestPaths(graph, new Integer(params[2]));
			Double desiredTime = paths.get(params[3]);
			if(desiredTime.isInfinite())
				System.out.println("Inalcanzable");
			else {
				int answer = (int) desiredTime.doubleValue();
				System.out.println(answer);
			}
		}
	}
	
	public static int[] getNums(String s) {
		String[] spl = s.split(" ");
		int[] ints = new int[spl.length];
		for(int i = 0; i < spl.length; i++)
			ints[i] = Integer.parseInt(spl[i]);
		return ints;
	}

	/**************************************************************************
	 * File: Dijkstra.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * An implementation of Dijkstra's single-source shortest path algorithm.
	 * The algorithm takes as input a directed graph with non-negative edge
	 * costs and a source node, then computes the shortest path from that node
	 * to each other node in the graph.
	 *
	 * The algorithm works by maintaining a priority queue of nodes whose
	 * priorities are the lengths of some path from the source node to the
	 * node in question.  At each step, the algortihm dequeues a node from
	 * this priority queue, records that node as being at the indicated
	 * distance from the source, and then updates the priorities of all nodes
	 * in the graph by considering all outgoing edges from the recently-
	 * dequeued node to those nodes.
	 *
	 * In the course of this algorithm, the code makes up to |E| calls to
	 * decrease-key on the heap (since in the worst case every edge from every
	 * node will yield a shorter path to some node than before) and |V| calls
	 * to dequeue-min (since each node is removed from the prioritiy queue
	 * at most once).  Using a Fibonacci heap, this gives a very good runtime
	 * guarantee of O(|E| + |V| lg |V|).
	 *
	 * This implementation relies on the existence of a FibonacciHeap class, also
	 * from the Archive of Interesting Code.  You can find it online at
	 *
	 *         http://keithschwarz.com/interesting/code/?dir=fibonacci-heap
	 */

	public static class Dijkstra {
	    /**
	     * Given a directed, weighted graph G and a source node s, produces the
	     * distances from s to each other node in the graph.  If any nodes in
	     * the graph are unreachable from s, they will be reported at distance
	     * +infinity.
	     *
	     * @param graph The graph upon which to run Dijkstra's algorithm.
	     * @param source The source node in the graph.
	     * @return A map from nodes in the graph to their distances from the source.
	     */
	    public static <T> Map<T, Double> shortestPaths(DirectedGraph<T> graph, T source) {
	        /* Create a Fibonacci heap storing the distances of unvisited nodes
	         * from the source node.
	         */
	        FibonacciHeap<T> pq = new FibonacciHeap<T>();

	        /* The Fibonacci heap uses an internal representation that hands back
	         * Entry objects for every stored element.  This map associates each
	         * node in the graph with its corresponding Entry.
	         */
	        Map<T, FibonacciHeap.Entry<T>> entries = new HashMap<T, FibonacciHeap.Entry<T>>();

	        /* Maintain a map from nodes to their distances.  Whenever we expand a
	         * node for the first time, we'll put it in here.
	         */
	        Map<T, Double> result = new HashMap<T, Double>();

	        /* Add each node to the Fibonacci heap at distance +infinity since
	         * initially all nodes are unreachable.
	         */
	        for (T node: graph)
	            entries.put(node, pq.enqueue(node, Double.POSITIVE_INFINITY));

	        /* Update the source so that it's at distance 0.0 from itself; after
	         * all, we can get there with a path of length zero!
	         */
	        pq.decreaseKey(entries.get(source), 0.0);

	        /* Keep processing the queue until no nodes remain. */
	        while (!pq.isEmpty()) {
	            /* Grab the current node.  The algorithm guarantees that we now
	             * have the shortest distance to it.
	             */
	            FibonacciHeap.Entry<T> curr = pq.dequeueMin();

	            /* Store this in the result table. */
	            result.put(curr.getValue(), curr.getPriority());

	            /* Update the priorities of all of its edges. */
	            for (Map.Entry<T, Double> arc : graph.edgesFrom(curr.getValue()).entrySet()) {
	                /* If we already know the shortest path from the source to
	                 * this node, don't add the edge.
	                 */
	                if (result.containsKey(arc.getKey())) continue;

	                /* Compute the cost of the path from the source to this node,
	                 * which is the cost of this node plus the cost of this edge.
	                 */
	                double pathCost = curr.getPriority() + arc.getValue();

	                /* If the length of the best-known path from the source to
	                 * this node is longer than this potential path cost, update
	                 * the cost of the shortest path.
	                 */
	                FibonacciHeap.Entry<T> dest = entries.get(arc.getKey());
	                if (pathCost < dest.getPriority())
	                    pq.decreaseKey(dest, pathCost);
	            }
	        }

	        /* Finally, report the distances we've found. */
	        return result;
	    }
	}
	
	
	
	/*****************************************************************************
	 * File: DirectedGraph.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * A class representing a directed graph where each edge has an associated 
	 * real-valued length.  Internally, the class is represented by an adjacency 
	 * list.
	 */

	public static class DirectedGraph<T> implements Iterable<T> {
	    /* A map from nodes in the graph to sets of outgoing edges.  Each
	     * set of edges is represented by a map from edges to doubles.
	     */
	    private final Map<T, Map<T, Double>> mGraph = new HashMap<T, Map<T, Double>>();

	    /**
	     * Adds a new node to the graph.  If the node already exists, this
	     * function is a no-op.
	     *
	     * @param node The node to add.
	     * @return Whether or not the node was added.
	     */
	    public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashMap<T, Double>());
	        return true;
	    }

	    /**
	     * Given a start node, destination, and length, adds an arc from the
	     * start node to the destination of the length.  If an arc already
	     * existed, the length is updated to the specified value.  If either
	     * endpoint does not exist in the graph, throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @param length The length of the edge.
	     * @throws NoSuchElementException If either the start or destination nodes
	     *                                do not exist.
	     */
	    public void addEdge(T start, T dest, double length) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        /* Add the edge. */
	        mGraph.get(start).put(dest, length);
	    }

	    /**
	     * Removes the edge from start to dest from the graph.  If the edge does
	     * not exist, this operation is a no-op.  If either endpoint does not
	     * exist, this throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @throws NoSuchElementException If either node is not in the graph.
	     */
	    public void removeEdge(T start, T dest) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        mGraph.get(start).remove(dest);
	    }

	    /**
	     * Given a node in the graph, returns an immutable view of the edges
	     * leaving that node, as a map from endpoints to costs.
	     *
	     * @param node The node whose edges should be queried.
	     * @return An immutable view of the edges leaving that node.
	     * @throws NoSuchElementException If the node does not exist.
	     */
	    public Map<T, Double> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Map<T, Double> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException("Source node does not exist.");

	        return Collections.unmodifiableMap(arcs);
	    }

	    /**
	     * Returns an iterator that can traverse the nodes in the graph.
	     *
	     * @return An iterator that traverses the nodes in the graph.
	     */
	    public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }
	}
	
	
	/***********************************************************************
	 * File: FibonacciHeap.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * An implementation of a priority queue backed by a Fibonacci heap,
	 * as described by Fredman and Tarjan.  Fibonacci heaps are interesting
	 * theoretically because they have asymptotically good runtime guarantees
	 * for many operations.  In particular, insert, peek, and decrease-key all
	 * run in amortized O(1) time.  dequeueMin and delete each run in amortized
	 * O(lg n) time.  This allows algorithms that rely heavily on decrease-key
	 * to gain significant performance boosts.  For example, Dijkstra's algorithm
	 * for single-source shortest paths can be shown to run in O(m + n lg n) using
	 * a Fibonacci heap, compared to O(m lg n) using a standard binary or binomial
	 * heap.
	 *
	 * Internally, a Fibonacci heap is represented as a circular, doubly-linked
	 * list of trees obeying the min-heap property.  Each node stores pointers
	 * to its parent (if any) and some arbitrary child.  Additionally, every
	 * node stores its degree (the number of children it has) and whether it
	 * is a "marked" node.  Finally, each Fibonacci heap stores a pointer to
	 * the tree with the minimum value.
	 *
	 * To insert a node into a Fibonacci heap, a singleton tree is created and
	 * merged into the rest of the trees.  The merge operation works by simply
	 * splicing together the doubly-linked lists of the two trees, then updating
	 * the min pointer to be the smaller of the minima of the two heaps.  Peeking
	 * at the smallest element can therefore be accomplished by just looking at
	 * the min element.  All of these operations complete in O(1) time.
	 *
	 * The tricky operations are dequeueMin and decreaseKey.  dequeueMin works
	 * by removing the root of the tree containing the smallest element, then
	 * merging its children with the topmost roots.  Then, the roots are scanned
	 * and merged so that there is only one tree of each degree in the root list.
	 * This works by maintaining a dynamic array of trees, each initially null,
	 * pointing to the roots of trees of each dimension.  The list is then scanned
	 * and this array is populated.  Whenever a conflict is discovered, the
	 * appropriate trees are merged together until no more conflicts exist.  The
	 * resulting trees are then put into the root list.  A clever analysis using
	 * the potential method can be used to show that the amortized cost of this
	 * operation is O(lg n), see "Introduction to Algorithms, Second Edition" by
	 * Cormen, Rivest, Leiserson, and Stein for more details.
	 *
	 * The other hard operation is decreaseKey, which works as follows.  First, we
	 * update the key of the node to be the new value.  If this leaves the node
	 * smaller than its parent, we're done.  Otherwise, we cut the node from its
	 * parent, add it as a root, and then mark its parent.  If the parent was
	 * already marked, we cut that node as well, recursively mark its parent,
	 * and continue this process.  This can be shown to run in O(1) amortized time
	 * using yet another clever potential function.  Finally, given this function,
	 * we can implement delete by decreasing a key to -\infty, then calling
	 * dequeueMin to extract it.
	 */

	/**
	 * A class representing a Fibonacci heap.
	 *
	 * @param T The type of elements to store in the heap.
	 */
	public static class FibonacciHeap<T> {
	    /* In order for all of the Fibonacci heap operations to complete in O(1),
	     * clients need to have O(1) access to any element in the heap.  We make
	     * this work by having each insertion operation produce a handle to the
	     * node in the tree.  In actuality, this handle is the node itself, but
	     * we guard against external modification by marking the internal fields
	     * private.
	     */
	    public static final class Entry<T> {
	        private int     mDegree = 0;       // Number of children
	        private boolean mIsMarked = false; // Whether this node is marked

	        private Entry<T> mNext;   // Next and previous elements in the list
	        private Entry<T> mPrev;

	        private Entry<T> mParent; // Parent in the tree, if any.

	        private Entry<T> mChild;  // Child node, if any.

	        private T      mElem;     // Element being stored here
	        private double mPriority; // Its priority

	        /**
	         * Returns the element represented by this heap entry.
	         *
	         * @return The element represented by this heap entry.
	         */
	        public T getValue() {
	            return mElem;
	        }
	        /**
	         * Sets the element associated with this heap entry.
	         *
	         * @param value The element to associate with this heap entry.
	         */
	        public void setValue(T value) {
	            mElem = value;
	        }

	        /**
	         * Returns the priority of this element.
	         *
	         * @return The priority of this element.
	         */
	        public double getPriority() {
	            return mPriority;
	        }

	        /**
	         * Constructs a new Entry that holds the given element with the indicated 
	         * priority.
	         *
	         * @param elem The element stored in this node.
	         * @param priority The priority of this element.
	         */
	        private Entry(T elem, double priority) {
	            mNext = mPrev = this;
	            mElem = elem;
	            mPriority = priority;
	        }
	    }

	    /* Pointer to the minimum element in the heap. */
	    private Entry<T> mMin = null;

	    /* Cached size of the heap, so we don't have to recompute this explicitly. */
	    private int mSize = 0;

	    /**
	     * Inserts the specified element into the Fibonacci heap with the specified
	     * priority.  Its priority must be a valid double, so you cannot set the
	     * priority to NaN.
	     *
	     * @param value The value to insert.
	     * @param priority Its priority, which must be valid.
	     * @return An Entry representing that element in the tree.
	     */
	    public Entry<T> enqueue(T value, double priority) {
	        checkPriority(priority);

	        /* Create the entry object, which is a circularly-linked list of length
	         * one.
	         */
	        Entry<T> result = new Entry<T>(value, priority);

	        /* Merge this singleton list with the tree list. */
	        mMin = mergeLists(mMin, result);

	        /* Increase the size of the heap; we just added something. */
	        ++mSize;

	        /* Return the reference to the new element. */
	        return result;
	    }

	    /**
	     * Returns an Entry object corresponding to the minimum element of the
	     * Fibonacci heap, throwing a NoSuchElementException if the heap is
	     * empty.
	     *
	     * @return The smallest element of the heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> min() {
	        if (isEmpty())
	            throw new NoSuchElementException("Heap is empty.");
	        return mMin;
	    }

	    /**
	     * Returns whether the heap is empty.
	     *
	     * @return Whether the heap is empty.
	     */
	    public boolean isEmpty() {
	        return mMin == null;
	    }

	    /**
	     * Returns the number of elements in the heap.
	     *
	     * @return The number of elements in the heap.
	     */
	    public int size() {
	        return mSize;
	    }

	    /**
	     * Given two Fibonacci heaps, returns a new Fibonacci heap that contains
	     * all of the elements of the two heaps.  Each of the input heaps is
	     * destructively modified by having all its elements removed.  You can
	     * continue to use those heaps, but be aware that they will be empty
	     * after this call completes.
	     *
	     * @param one The first Fibonacci heap to merge.
	     * @param two The second Fibonacci heap to merge.
	     * @return A new FibonacciHeap containing all of the elements of both
	     *         heaps.
	     */
	    public static <T> FibonacciHeap<T> merge(FibonacciHeap<T> one, FibonacciHeap<T> two) {
	        /* Create a new FibonacciHeap to hold the result. */
	        FibonacciHeap<T> result = new FibonacciHeap<T>();

	        /* Merge the two Fibonacci heap root lists together.  This helper function
	         * also computes the min of the two lists, so we can store the result in
	         * the mMin field of the new heap.
	         */
	        result.mMin = mergeLists(one.mMin, two.mMin);

	        /* The size of the new heap is the sum of the sizes of the input heaps. */
	        result.mSize = one.mSize + two.mSize;

	        /* Clear the old heaps. */
	        one.mSize = two.mSize = 0;
	        one.mMin  = null;
	        two.mMin  = null;

	        /* Return the newly-merged heap. */
	        return result;
	    }

	    /**
	     * Dequeues and returns the minimum element of the Fibonacci heap.  If the
	     * heap is empty, this throws a NoSuchElementException.
	     *
	     * @return The smallest element of the Fibonacci heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> dequeueMin() {
	        /* Check for whether we're empty. */
	        if (isEmpty())
	            throw new NoSuchElementException("Heap is empty.");

	        /* Otherwise, we're about to lose an element, so decrement the number of
	         * entries in this heap.
	         */
	        --mSize;

	        /* Grab the minimum element so we know what to return. */
	        Entry<T> minElem = mMin;

	        /* Now, we need to get rid of this element from the list of roots.  There
	         * are two cases to consider.  First, if this is the only element in the
	         * list of roots, we set the list of roots to be null by clearing mMin.
	         * Otherwise, if it's not null, then we write the elements next to the
	         * min element around the min element to remove it, then arbitrarily
	         * reassign the min.
	         */
	        if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }

	        /* Next, clear the parent fields of all of the min element's children,
	         * since they're about to become roots.  Because the elements are
	         * stored in a circular list, the traversal is a bit complex.
	         */
	        if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }

	        /* Next, splice the children of the root node into the topmost list, 
	         * then set mMin to point somewhere in that list.
	         */
	        mMin = mergeLists(mMin, minElem.mChild);

	        /* If there are no entries left, we're done. */
	        if (mMin == null) return minElem;

	        /* Next, we need to coalsce all of the roots so that there is only one
	         * tree of each degree.  To track trees of each size, we allocate an
	         * ArrayList where the entry at position i is either null or the 
	         * unique tree of degree i.
	         */
	        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();

	        /* We need to traverse the entire list, but since we're going to be
	         * messing around with it we have to be careful not to break our
	         * traversal order mid-stream.  One major challenge is how to detect
	         * whether we're visiting the same node twice.  To do this, we'll
	         * spent a bit of overhead adding all of the nodes to a list, and
	         * then will visit each element of this list in order.
	         */
	        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();

	        /* To add everything, we'll iterate across the elements until we
	         * find the first element twice.  We check this by looping while the
	         * list is empty or while the current element isn't the first element
	         * of that list.
	         */
	        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);

	        /* Traverse this list and perform the appropriate unioning steps. */
	        for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }
	        return minElem;
	    }

	    /**
	     * Decreases the key of the specified element to the new priority.  If the
	     * new priority is greater than the old priority, this function throws an
	     * IllegalArgumentException.  The new priority must be a finite double,
	     * so you cannot set the priority to be NaN, or +/- infinity.  Doing
	     * so also throws an IllegalArgumentException.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The element whose priority should be decreased.
	     * @param newPriority The new priority to associate with this entry.
	     * @throws IllegalArgumentException If the new priority exceeds the old
	     *         priority, or if the argument is not a finite double.
	     */
	    public void decreaseKey(Entry<T> entry, double newPriority) {
	        checkPriority(newPriority);
	        if (newPriority > entry.mPriority)
	            throw new IllegalArgumentException("New priority exceeds old.");

	        /* Forward this to a helper function. */
	        decreaseKeyUnchecked(entry, newPriority);
	    }
	    
	    /**
	     * Deletes this Entry from the Fibonacci heap that contains it.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The entry to delete.
	     */
	    public void delete(Entry<T> entry) {
	        /* Use decreaseKey to drop the entry's key to -infinity.  This will
	         * guarantee that the node is cut and set to the global minimum.
	         */
	        decreaseKeyUnchecked(entry, Double.NEGATIVE_INFINITY);

	        /* Call dequeueMin to remove it. */
	        dequeueMin();
	    }

	    /**
	     * Utility function which, given a user-specified priority, checks whether
	     * it's a valid double and throws an IllegalArgumentException otherwise.
	     *
	     * @param priority The user's specified priority.
	     * @throws IllegalArgumentException If it is not valid.
	     */
	    private void checkPriority(double priority) {
	        if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + " is invalid.");
	    }

	    /**
	     * Utility function which, given two pointers into disjoint circularly-
	     * linked lists, merges the two lists together into one circularly-linked
	     * list in O(1) time.  Because the lists may be empty, the return value
	     * is the only pointer that's guaranteed to be to an element of the
	     * resulting list.
	     *
	     * This function assumes that one and two are the minimum elements of the
	     * lists they are in, and returns a pointer to whichever is smaller.  If
	     * this condition does not hold, the return value is some arbitrary pointer
	     * into the doubly-linked list.
	     *
	     * @param one A pointer into one of the two linked lists.
	     * @param two A pointer into the other of the two linked lists.
	     * @return A pointer to the smallest element of the resulting list.
	     */
	    private static <T> Entry<T> mergeLists(Entry<T> one, Entry<T> two) {
	        /* There are four cases depending on whether the lists are null or not.
	         * We consider each separately.
	         */
	        if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }
	    }

	    /**
	     * Decreases the key of a node in the tree without doing any checking to ensure
	     * that the new priority is valid.
	     *
	     * @param entry The node whose key should be decreased.
	     * @param priority The node's new priority.
	     */
	    private void decreaseKeyUnchecked(Entry<T> entry, double priority) {
	        /* First, change the node's priority. */
	        entry.mPriority = priority;

	        /* If the node no longer has a higher priority than its parent, cut it.
	         * Note that this also means that if we try to run a delete operation
	         * that decreases the key to -infinity, it's guaranteed to cut the node
	         * from its parent.
	         */
	        if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);

	        /* If our new value is the new min, mark it as such.  Note that if we
	         * ended up decreasing the key in a way that ties the current minimum
	         * priority, this will change the min accordingly.
	         */
	        if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;
	    }

	    /**
	     * Cuts a node from its parent.  If the parent was already marked, recursively
	     * cuts that node from its parent as well.
	     *
	     * @param entry The node to cut from its parent.
	     */
	    private void cutNode(Entry<T> entry) {
	        /* Begin by clearing the node's mark, since we just cut it. */
	        entry.mIsMarked = false;

	        /* Base case: If the node has no parent, we're done. */
	        if (entry.mParent == null) return;

	        /* Rewire the node's siblings around it, if it has any siblings. */
	        if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }

	        /* If the node is the one identified by its parent as its child,
	         * we need to rewrite that pointer to point to some arbitrary other
	         * child.
	         */
	        if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }

	        /* Decrease the degree of the parent, since it just lost a child. */
	        --entry.mParent.mDegree;

	        /* Splice this tree into the root list by converting it to a singleton
	         * and invoking the merge subroutine.
	         */
	        entry.mPrev = entry.mNext = entry;
	        mMin = mergeLists(mMin, entry);

	        /* Mark the parent and recursively cut it if it's already been
	         * marked.
	         */
	        if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;

	        /* Clear the relocated node's parent; it's now a root. */
	        entry.mParent = null;
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.*; // For HashMap

public class ProblemBv1 {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		
		int t = Integer.parseInt(input.nextLine());
		
		for(int testCase = 1; testCase <= t; testCase ++) {
			System.out.println("Case #" + testCase + ":");
			int[] params = getNums(input.nextLine()); //N(#PCs) M(#CNXs) A B
			
			DirectedGraph<Integer> graph = new DirectedGraph<>();
			
			for(int i = 0; i < params[0]; i++) //initialize graph with PCs IDs
				graph.addNode(new Integer(i));
			
			for(int i = 0; i < params[1]; i++) { //Receive conextion specification and make conections
				int[] conex = getNums(input.nextLine());
				graph.addEdge(conex[1], conex[0], conex[2]);
				graph.addEdge(conex[0], conex[1], conex[2]);	
			}
			
			HashMap<Integer, Double> paths = (HashMap<Integer, Double>) Dijkstra.shortestPaths(graph, new Integer(params[2]));
			Double desiredTime = paths.get(params[3]);
			if(desiredTime.isInfinite())
				System.out.println("Inalcanzable");
			else {
				int answer = (int) desiredTime.doubleValue();
				System.out.println(answer);
			}
		}
	}
	
	public static int[] getNums(String s) {
		String[] spl = s.split(" ");
		int[] ints = new int[spl.length];
		for(int i = 0; i < spl.length; i++)
			ints[i] = Integer.parseInt(spl[i]);
		return ints;
	}

	/**************************************************************************
	 * File: Dijkstra.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * An implementation of Dijkstra's single-source shortest path algorithm.
	 * The algorithm takes as input a directed graph with non-negative edge
	 * costs and a source node, then computes the shortest path from that node
	 * to each other node in the graph.
	 *
	 * The algorithm works by maintaining a priority queue of nodes whose
	 * priorities are the lengths of some path from the source node to the
	 * node in question.  At each step, the algortihm dequeues a node from
	 * this priority queue, records that node as being at the indicated
	 * distance from the source, and then updates the priorities of all nodes
	 * in the graph by considering all outgoing edges from the recently-
	 * dequeued node to those nodes.
	 *
	 * In the course of this algorithm, the code makes up to |E| calls to
	 * decrease-key on the heap (since in the worst case every edge from every
	 * node will yield a shorter path to some node than before) and |V| calls
	 * to dequeue-min (since each node is removed from the prioritiy queue
	 * at most once).  Using a Fibonacci heap, this gives a very good runtime
	 * guarantee of O(|E| + |V| lg |V|).
	 *
	 * This implementation relies on the existence of a FibonacciHeap class, also
	 * from the Archive of Interesting Code.  You can find it online at
	 *
	 *         http://keithschwarz.com/interesting/code/?dir=fibonacci-heap
	 */

	public static class Dijkstra {
	    /**
	     * Given a directed, weighted graph G and a source node s, produces the
	     * distances from s to each other node in the graph.  If any nodes in
	     * the graph are unreachable from s, they will be reported at distance
	     * +infinity.
	     *
	     * @param graph The graph upon which to run Dijkstra's algorithm.
	     * @param source The source node in the graph.
	     * @return A map from nodes in the graph to their distances from the source.
	     */
	    public static <T> Map<T, Double> shortestPaths(DirectedGraph<T> graph, T source) {
	        /* Create a Fibonacci heap storing the distances of unvisited nodes
	         * from the source node.
	         */
	        FibonacciHeap<T> pq = new FibonacciHeap<T>();

	        /* The Fibonacci heap uses an internal representation that hands back
	         * Entry objects for every stored element.  This map associates each
	         * node in the graph with its corresponding Entry.
	         */
	        Map<T, FibonacciHeap.Entry<T>> entries = new HashMap<T, FibonacciHeap.Entry<T>>();

	        /* Maintain a map from nodes to their distances.  Whenever we expand a
	         * node for the first time, we'll put it in here.
	         */
	        Map<T, Double> result = new HashMap<T, Double>();

	        /* Add each node to the Fibonacci heap at distance +infinity since
	         * initially all nodes are unreachable.
	         */
	        for (T node: graph)
	            entries.put(node, pq.enqueue(node, Double.POSITIVE_INFINITY));

	        /* Update the source so that it's at distance 0.0 from itself; after
	         * all, we can get there with a path of length zero!
	         */
	        pq.decreaseKey(entries.get(source), 0.0);

	        /* Keep processing the queue until no nodes remain. */
	        while (!pq.isEmpty()) {
	            /* Grab the current node.  The algorithm guarantees that we now
	             * have the shortest distance to it.
	             */
	            FibonacciHeap.Entry<T> curr = pq.dequeueMin();

	            /* Store this in the result table. */
	            result.put(curr.getValue(), curr.getPriority());

	            /* Update the priorities of all of its edges. */
	            for (Map.Entry<T, Double> arc : graph.edgesFrom(curr.getValue()).entrySet()) {
	                /* If we already know the shortest path from the source to
	                 * this node, don't add the edge.
	                 */
	                if (result.containsKey(arc.getKey())) continue;

	                /* Compute the cost of the path from the source to this node,
	                 * which is the cost of this node plus the cost of this edge.
	                 */
	                double pathCost = curr.getPriority() + arc.getValue();

	                /* If the length of the best-known path from the source to
	                 * this node is longer than this potential path cost, update
	                 * the cost of the shortest path.
	                 */
	                FibonacciHeap.Entry<T> dest = entries.get(arc.getKey());
	                if (pathCost < dest.getPriority())
	                    pq.decreaseKey(dest, pathCost);
	            }
	        }

	        /* Finally, report the distances we've found. */
	        return result;
	    }
	}
	
	
	
	/*****************************************************************************
	 * File: DirectedGraph.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * A class representing a directed graph where each edge has an associated 
	 * real-valued length.  Internally, the class is represented by an adjacency 
	 * list.
	 */

	public static class DirectedGraph<T> implements Iterable<T> {
	    /* A map from nodes in the graph to sets of outgoing edges.  Each
	     * set of edges is represented by a map from edges to doubles.
	     */
	    private final Map<T, Map<T, Double>> mGraph = new HashMap<T, Map<T, Double>>();

	    /**
	     * Adds a new node to the graph.  If the node already exists, this
	     * function is a no-op.
	     *
	     * @param node The node to add.
	     * @return Whether or not the node was added.
	     */
	    public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashMap<T, Double>());
	        return true;
	    }

	    /**
	     * Given a start node, destination, and length, adds an arc from the
	     * start node to the destination of the length.  If an arc already
	     * existed, the length is updated to the specified value.  If either
	     * endpoint does not exist in the graph, throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @param length The length of the edge.
	     * @throws NoSuchElementException If either the start or destination nodes
	     *                                do not exist.
	     */
	    public void addEdge(T start, T dest, double length) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        /* Add the edge. */
	        mGraph.get(start).put(dest, length);
	    }

	    /**
	     * Removes the edge from start to dest from the graph.  If the edge does
	     * not exist, this operation is a no-op.  If either endpoint does not
	     * exist, this throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @throws NoSuchElementException If either node is not in the graph.
	     */
	    public void removeEdge(T start, T dest) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        mGraph.get(start).remove(dest);
	    }

	    /**
	     * Given a node in the graph, returns an immutable view of the edges
	     * leaving that node, as a map from endpoints to costs.
	     *
	     * @param node The node whose edges should be queried.
	     * @return An immutable view of the edges leaving that node.
	     * @throws NoSuchElementException If the node does not exist.
	     */
	    public Map<T, Double> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Map<T, Double> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException("Source node does not exist.");

	        return Collections.unmodifiableMap(arcs);
	    }

	    /**
	     * Returns an iterator that can traverse the nodes in the graph.
	     *
	     * @return An iterator that traverses the nodes in the graph.
	     */
	    public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }
	}
	
	
	/***********************************************************************
	 * File: FibonacciHeap.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * An implementation of a priority queue backed by a Fibonacci heap,
	 * as described by Fredman and Tarjan.  Fibonacci heaps are interesting
	 * theoretically because they have asymptotically good runtime guarantees
	 * for many operations.  In particular, insert, peek, and decrease-key all
	 * run in amortized O(1) time.  dequeueMin and delete each run in amortized
	 * O(lg n) time.  This allows algorithms that rely heavily on decrease-key
	 * to gain significant performance boosts.  For example, Dijkstra's algorithm
	 * for single-source shortest paths can be shown to run in O(m + n lg n) using
	 * a Fibonacci heap, compared to O(m lg n) using a standard binary or binomial
	 * heap.
	 *
	 * Internally, a Fibonacci heap is represented as a circular, doubly-linked
	 * list of trees obeying the min-heap property.  Each node stores pointers
	 * to its parent (if any) and some arbitrary child.  Additionally, every
	 * node stores its degree (the number of children it has) and whether it
	 * is a "marked" node.  Finally, each Fibonacci heap stores a pointer to
	 * the tree with the minimum value.
	 *
	 * To insert a node into a Fibonacci heap, a singleton tree is created and
	 * merged into the rest of the trees.  The merge operation works by simply
	 * splicing together the doubly-linked lists of the two trees, then updating
	 * the min pointer to be the smaller of the minima of the two heaps.  Peeking
	 * at the smallest element can therefore be accomplished by just looking at
	 * the min element.  All of these operations complete in O(1) time.
	 *
	 * The tricky operations are dequeueMin and decreaseKey.  dequeueMin works
	 * by removing the root of the tree containing the smallest element, then
	 * merging its children with the topmost roots.  Then, the roots are scanned
	 * and merged so that there is only one tree of each degree in the root list.
	 * This works by maintaining a dynamic array of trees, each initially null,
	 * pointing to the roots of trees of each dimension.  The list is then scanned
	 * and this array is populated.  Whenever a conflict is discovered, the
	 * appropriate trees are merged together until no more conflicts exist.  The
	 * resulting trees are then put into the root list.  A clever analysis using
	 * the potential method can be used to show that the amortized cost of this
	 * operation is O(lg n), see "Introduction to Algorithms, Second Edition" by
	 * Cormen, Rivest, Leiserson, and Stein for more details.
	 *
	 * The other hard operation is decreaseKey, which works as follows.  First, we
	 * update the key of the node to be the new value.  If this leaves the node
	 * smaller than its parent, we're done.  Otherwise, we cut the node from its
	 * parent, add it as a root, and then mark its parent.  If the parent was
	 * already marked, we cut that node as well, recursively mark its parent,
	 * and continue this process.  This can be shown to run in O(1) amortized time
	 * using yet another clever potential function.  Finally, given this function,
	 * we can implement delete by decreasing a key to -\infty, then calling
	 * dequeueMin to extract it.
	 */

	/**
	 * A class representing a Fibonacci heap.
	 *
	 * @param T The type of elements to store in the heap.
	 */
	public static class FibonacciHeap<T> {
	    /* In order for all of the Fibonacci heap operations to complete in O(1),
	     * clients need to have O(1) access to any element in the heap.  We make
	     * this work by having each insertion operation produce a handle to the
	     * node in the tree.  In actuality, this handle is the node itself, but
	     * we guard against external modification by marking the internal fields
	     * private.
	     */
	    public static final class Entry<T> {
	        private int     mDegree = 0;       // Number of children
	        private boolean mIsMarked = false; // Whether this node is marked

	        private Entry<T> mNext;   // Next and previous elements in the list
	        private Entry<T> mPrev;

	        private Entry<T> mParent; // Parent in the tree, if any.

	        private Entry<T> mChild;  // Child node, if any.

	        private T      mElem;     // Element being stored here
	        private double mPriority; // Its priority

	        /**
	         * Returns the element represented by this heap entry.
	         *
	         * @return The element represented by this heap entry.
	         */
	        public T getValue() {
	            return mElem;
	        }
	        /**
	         * Sets the element associated with this heap entry.
	         *
	         * @param value The element to associate with this heap entry.
	         */
	        public void setValue(T value) {
	            mElem = value;
	        }

	        /**
	         * Returns the priority of this element.
	         *
	         * @return The priority of this element.
	         */
	        public double getPriority() {
	            return mPriority;
	        }

	        /**
	         * Constructs a new Entry that holds the given element with the indicated 
	         * priority.
	         *
	         * @param elem The element stored in this node.
	         * @param priority The priority of this element.
	         */
	        private Entry(T elem, double priority) {
	            mNext = mPrev = this;
	            mElem = elem;
	            mPriority = priority;
	        }
	    }

	    /* Pointer to the minimum element in the heap. */
	    private Entry<T> mMin = null;

	    /* Cached size of the heap, so we don't have to recompute this explicitly. */
	    private int mSize = 0;

	    /**
	     * Inserts the specified element into the Fibonacci heap with the specified
	     * priority.  Its priority must be a valid double, so you cannot set the
	     * priority to NaN.
	     *
	     * @param value The value to insert.
	     * @param priority Its priority, which must be valid.
	     * @return An Entry representing that element in the tree.
	     */
	    public Entry<T> enqueue(T value, double priority) {
	        checkPriority(priority);

	        /* Create the entry object, which is a circularly-linked list of length
	         * one.
	         */
	        Entry<T> result = new Entry<T>(value, priority);

	        /* Merge this singleton list with the tree list. */
	        mMin = mergeLists(mMin, result);

	        /* Increase the size of the heap; we just added something. */
	        ++mSize;

	        /* Return the reference to the new element. */
	        return result;
	    }

	    /**
	     * Returns an Entry object corresponding to the minimum element of the
	     * Fibonacci heap, throwing a NoSuchElementException if the heap is
	     * empty.
	     *
	     * @return The smallest element of the heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> min() {
	        if (isEmpty())
	            throw new NoSuchElementException("Heap is empty.");
	        return mMin;
	    }

	    /**
	     * Returns whether the heap is empty.
	     *
	     * @return Whether the heap is empty.
	     */
	    public boolean isEmpty() {
	        return mMin == null;
	    }

	    /**
	     * Returns the number of elements in the heap.
	     *
	     * @return The number of elements in the heap.
	     */
	    public int size() {
	        return mSize;
	    }

	    /**
	     * Given two Fibonacci heaps, returns a new Fibonacci heap that contains
	     * all of the elements of the two heaps.  Each of the input heaps is
	     * destructively modified by having all its elements removed.  You can
	     * continue to use those heaps, but be aware that they will be empty
	     * after this call completes.
	     *
	     * @param one The first Fibonacci heap to merge.
	     * @param two The second Fibonacci heap to merge.
	     * @return A new FibonacciHeap containing all of the elements of both
	     *         heaps.
	     */
	    public static <T> FibonacciHeap<T> merge(FibonacciHeap<T> one, FibonacciHeap<T> two) {
	        /* Create a new FibonacciHeap to hold the result. */
	        FibonacciHeap<T> result = new FibonacciHeap<T>();

	        /* Merge the two Fibonacci heap root lists together.  This helper function
	         * also computes the min of the two lists, so we can store the result in
	         * the mMin field of the new heap.
	         */
	        result.mMin = mergeLists(one.mMin, two.mMin);

	        /* The size of the new heap is the sum of the sizes of the input heaps. */
	        result.mSize = one.mSize + two.mSize;

	        /* Clear the old heaps. */
	        one.mSize = two.mSize = 0;
	        one.mMin  = null;
	        two.mMin  = null;

	        /* Return the newly-merged heap. */
	        return result;
	    }

	    /**
	     * Dequeues and returns the minimum element of the Fibonacci heap.  If the
	     * heap is empty, this throws a NoSuchElementException.
	     *
	     * @return The smallest element of the Fibonacci heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> dequeueMin() {
	        /* Check for whether we're empty. */
	        if (isEmpty())
	            throw new NoSuchElementException("Heap is empty.");

	        /* Otherwise, we're about to lose an element, so decrement the number of
	         * entries in this heap.
	         */
	        --mSize;

	        /* Grab the minimum element so we know what to return. */
	        Entry<T> minElem = mMin;

	        /* Now, we need to get rid of this element from the list of roots.  There
	         * are two cases to consider.  First, if this is the only element in the
	         * list of roots, we set the list of roots to be null by clearing mMin.
	         * Otherwise, if it's not null, then we write the elements next to the
	         * min element around the min element to remove it, then arbitrarily
	         * reassign the min.
	         */
	        if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }

	        /* Next, clear the parent fields of all of the min element's children,
	         * since they're about to become roots.  Because the elements are
	         * stored in a circular list, the traversal is a bit complex.
	         */
	        if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }

	        /* Next, splice the children of the root node into the topmost list, 
	         * then set mMin to point somewhere in that list.
	         */
	        mMin = mergeLists(mMin, minElem.mChild);

	        /* If there are no entries left, we're done. */
	        if (mMin == null) return minElem;

	        /* Next, we need to coalsce all of the roots so that there is only one
	         * tree of each degree.  To track trees of each size, we allocate an
	         * ArrayList where the entry at position i is either null or the 
	         * unique tree of degree i.
	         */
	        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();

	        /* We need to traverse the entire list, but since we're going to be
	         * messing around with it we have to be careful not to break our
	         * traversal order mid-stream.  One major challenge is how to detect
	         * whether we're visiting the same node twice.  To do this, we'll
	         * spent a bit of overhead adding all of the nodes to a list, and
	         * then will visit each element of this list in order.
	         */
	        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();

	        /* To add everything, we'll iterate across the elements until we
	         * find the first element twice.  We check this by looping while the
	         * list is empty or while the current element isn't the first element
	         * of that list.
	         */
	        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);

	        /* Traverse this list and perform the appropriate unioning steps. */
	        for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }
	        return minElem;
	    }

	    /**
	     * Decreases the key of the specified element to the new priority.  If the
	     * new priority is greater than the old priority, this function throws an
	     * IllegalArgumentException.  The new priority must be a finite double,
	     * so you cannot set the priority to be NaN, or +/- infinity.  Doing
	     * so also throws an IllegalArgumentException.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The element whose priority should be decreased.
	     * @param newPriority The new priority to associate with this entry.
	     * @throws IllegalArgumentException If the new priority exceeds the old
	     *         priority, or if the argument is not a finite double.
	     */
	    public void decreaseKey(Entry<T> entry, double newPriority) {
	        checkPriority(newPriority);
	        if (newPriority > entry.mPriority)
	            throw new IllegalArgumentException("New priority exceeds old.");

	        /* Forward this to a helper function. */
	        decreaseKeyUnchecked(entry, newPriority);
	    }
	    
	    /**
	     * Deletes this Entry from the Fibonacci heap that contains it.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The entry to delete.
	     */
	    public void delete(Entry<T> entry) {
	        /* Use decreaseKey to drop the entry's key to -infinity.  This will
	         * guarantee that the node is cut and set to the global minimum.
	         */
	        decreaseKeyUnchecked(entry, Double.NEGATIVE_INFINITY);

	        /* Call dequeueMin to remove it. */
	        dequeueMin();
	    }

	    /**
	     * Utility function which, given a user-specified priority, checks whether
	     * it's a valid double and throws an IllegalArgumentException otherwise.
	     *
	     * @param priority The user's specified priority.
	     * @throws IllegalArgumentException If it is not valid.
	     */
	    private void checkPriority(double priority) {
	        if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + " is invalid.");
	    }

	    /**
	     * Utility function which, given two pointers into disjoint circularly-
	     * linked lists, merges the two lists together into one circularly-linked
	     * list in O(1) time.  Because the lists may be empty, the return value
	     * is the only pointer that's guaranteed to be to an element of the
	     * resulting list.
	     *
	     * This function assumes that one and two are the minimum elements of the
	     * lists they are in, and returns a pointer to whichever is smaller.  If
	     * this condition does not hold, the return value is some arbitrary pointer
	     * into the doubly-linked list.
	     *
	     * @param one A pointer into one of the two linked lists.
	     * @param two A pointer into the other of the two linked lists.
	     * @return A pointer to the smallest element of the resulting list.
	     */
	    private static <T> Entry<T> mergeLists(Entry<T> one, Entry<T> two) {
	        /* There are four cases depending on whether the lists are null or not.
	         * We consider each separately.
	         */
	        if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }
	    }

	    /**
	     * Decreases the key of a node in the tree without doing any checking to ensure
	     * that the new priority is valid.
	     *
	     * @param entry The node whose key should be decreased.
	     * @param priority The node's new priority.
	     */
	    private void decreaseKeyUnchecked(Entry<T> entry, double priority) {
	        /* First, change the node's priority. */
	        entry.mPriority = priority;

	        /* If the node no longer has a higher priority than its parent, cut it.
	         * Note that this also means that if we try to run a delete operation
	         * that decreases the key to -infinity, it's guaranteed to cut the node
	         * from its parent.
	         */
	        if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);

	        /* If our new value is the new min, mark it as such.  Note that if we
	         * ended up decreasing the key in a way that ties the current minimum
	         * priority, this will change the min accordingly.
	         */
	        if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;
	    }

	    /**
	     * Cuts a node from its parent.  If the parent was already marked, recursively
	     * cuts that node from its parent as well.
	     *
	     * @param entry The node to cut from its parent.
	     */
	    private void cutNode(Entry<T> entry) {
	        /* Begin by clearing the node's mark, since we just cut it. */
	        entry.mIsMarked = false;

	        /* Base case: If the node has no parent, we're done. */
	        if (entry.mParent == null) return;

	        /* Rewire the node's siblings around it, if it has any siblings. */
	        if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }

	        /* If the node is the one identified by its parent as its child,
	         * we need to rewrite that pointer to point to some arbitrary other
	         * child.
	         */
	        if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }

	        /* Decrease the degree of the parent, since it just lost a child. */
	        --entry.mParent.mDegree;

	        /* Splice this tree into the root list by converting it to a singleton
	         * and invoking the merge subroutine.
	         */
	        entry.mPrev = entry.mNext = entry;
	        mMin = mergeLists(mMin, entry);

	        /* Mark the parent and recursively cut it if it's already been
	         * marked.
	         */
	        if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;

	        /* Clear the relocated node's parent; it's now a root. */
	        entry.mParent = null;
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.*; // For HashMap

public class ProblemBv1 {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		
		int t = Integer.parseInt(input.nextLine());
		
		for(int testCase = 1; testCase <= t; testCase ++) {
			System.out.println("Caso #" + testCase + ":");
			int[] params = getNums(input.nextLine()); //N(#PCs) M(#CNXs) A B
			
			DirectedGraph<Integer> graph = new DirectedGraph<>();
			
			for(int i = 0; i < params[0]; i++) //initialize graph with PCs IDs
				graph.addNode(new Integer(i));
			
			for(int i = 0; i < params[1]; i++) { //Receive conextion specification and make conections
				int[] conex = getNums(input.nextLine());
				graph.addEdge(conex[1], conex[0], conex[2]);
				graph.addEdge(conex[0], conex[1], conex[2]);	
			}
			
			HashMap<Integer, Double> paths = (HashMap<Integer, Double>) Dijkstra.shortestPaths(graph, new Integer(params[2]));
			Double desiredTime = paths.get(params[3]);
			if(desiredTime.isInfinite())
				System.out.println("inalcanzable");
			else {
				int answer = (int) desiredTime.doubleValue();
				System.out.println(answer);
			}
		}
	}
	
	public static int[] getNums(String s) {
		String[] spl = s.split(" ");
		int[] ints = new int[spl.length];
		for(int i = 0; i < spl.length; i++)
			ints[i] = Integer.parseInt(spl[i]);
		return ints;
	}

	/**************************************************************************
	 * File: Dijkstra.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * An implementation of Dijkstra's single-source shortest path algorithm.
	 * The algorithm takes as input a directed graph with non-negative edge
	 * costs and a source node, then computes the shortest path from that node
	 * to each other node in the graph.
	 *
	 * The algorithm works by maintaining a priority queue of nodes whose
	 * priorities are the lengths of some path from the source node to the
	 * node in question.  At each step, the algortihm dequeues a node from
	 * this priority queue, records that node as being at the indicated
	 * distance from the source, and then updates the priorities of all nodes
	 * in the graph by considering all outgoing edges from the recently-
	 * dequeued node to those nodes.
	 *
	 * In the course of this algorithm, the code makes up to |E| calls to
	 * decrease-key on the heap (since in the worst case every edge from every
	 * node will yield a shorter path to some node than before) and |V| calls
	 * to dequeue-min (since each node is removed from the prioritiy queue
	 * at most once).  Using a Fibonacci heap, this gives a very good runtime
	 * guarantee of O(|E| + |V| lg |V|).
	 *
	 * This implementation relies on the existence of a FibonacciHeap class, also
	 * from the Archive of Interesting Code.  You can find it online at
	 *
	 *         http://keithschwarz.com/interesting/code/?dir=fibonacci-heap
	 */

	public static class Dijkstra {
	    /**
	     * Given a directed, weighted graph G and a source node s, produces the
	     * distances from s to each other node in the graph.  If any nodes in
	     * the graph are unreachable from s, they will be reported at distance
	     * +infinity.
	     *
	     * @param graph The graph upon which to run Dijkstra's algorithm.
	     * @param source The source node in the graph.
	     * @return A map from nodes in the graph to their distances from the source.
	     */
	    public static <T> Map<T, Double> shortestPaths(DirectedGraph<T> graph, T source) {
	        /* Create a Fibonacci heap storing the distances of unvisited nodes
	         * from the source node.
	         */
	        FibonacciHeap<T> pq = new FibonacciHeap<T>();

	        /* The Fibonacci heap uses an internal representation that hands back
	         * Entry objects for every stored element.  This map associates each
	         * node in the graph with its corresponding Entry.
	         */
	        Map<T, FibonacciHeap.Entry<T>> entries = new HashMap<T, FibonacciHeap.Entry<T>>();

	        /* Maintain a map from nodes to their distances.  Whenever we expand a
	         * node for the first time, we'll put it in here.
	         */
	        Map<T, Double> result = new HashMap<T, Double>();

	        /* Add each node to the Fibonacci heap at distance +infinity since
	         * initially all nodes are unreachable.
	         */
	        for (T node: graph)
	            entries.put(node, pq.enqueue(node, Double.POSITIVE_INFINITY));

	        /* Update the source so that it's at distance 0.0 from itself; after
	         * all, we can get there with a path of length zero!
	         */
	        pq.decreaseKey(entries.get(source), 0.0);

	        /* Keep processing the queue until no nodes remain. */
	        while (!pq.isEmpty()) {
	            /* Grab the current node.  The algorithm guarantees that we now
	             * have the shortest distance to it.
	             */
	            FibonacciHeap.Entry<T> curr = pq.dequeueMin();

	            /* Store this in the result table. */
	            result.put(curr.getValue(), curr.getPriority());

	            /* Update the priorities of all of its edges. */
	            for (Map.Entry<T, Double> arc : graph.edgesFrom(curr.getValue()).entrySet()) {
	                /* If we already know the shortest path from the source to
	                 * this node, don't add the edge.
	                 */
	                if (result.containsKey(arc.getKey())) continue;

	                /* Compute the cost of the path from the source to this node,
	                 * which is the cost of this node plus the cost of this edge.
	                 */
	                double pathCost = curr.getPriority() + arc.getValue();

	                /* If the length of the best-known path from the source to
	                 * this node is longer than this potential path cost, update
	                 * the cost of the shortest path.
	                 */
	                FibonacciHeap.Entry<T> dest = entries.get(arc.getKey());
	                if (pathCost < dest.getPriority())
	                    pq.decreaseKey(dest, pathCost);
	            }
	        }

	        /* Finally, report the distances we've found. */
	        return result;
	    }
	}
	
	
	
	/*****************************************************************************
	 * File: DirectedGraph.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * A class representing a directed graph where each edge has an associated 
	 * real-valued length.  Internally, the class is represented by an adjacency 
	 * list.
	 */

	public static class DirectedGraph<T> implements Iterable<T> {
	    /* A map from nodes in the graph to sets of outgoing edges.  Each
	     * set of edges is represented by a map from edges to doubles.
	     */
	    private final Map<T, Map<T, Double>> mGraph = new HashMap<T, Map<T, Double>>();

	    /**
	     * Adds a new node to the graph.  If the node already exists, this
	     * function is a no-op.
	     *
	     * @param node The node to add.
	     * @return Whether or not the node was added.
	     */
	    public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashMap<T, Double>());
	        return true;
	    }

	    /**
	     * Given a start node, destination, and length, adds an arc from the
	     * start node to the destination of the length.  If an arc already
	     * existed, the length is updated to the specified value.  If either
	     * endpoint does not exist in the graph, throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @param length The length of the edge.
	     * @throws NoSuchElementException If either the start or destination nodes
	     *                                do not exist.
	     */
	    public void addEdge(T start, T dest, double length) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        /* Add the edge. */
	        mGraph.get(start).put(dest, length);
	    }

	    /**
	     * Removes the edge from start to dest from the graph.  If the edge does
	     * not exist, this operation is a no-op.  If either endpoint does not
	     * exist, this throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @throws NoSuchElementException If either node is not in the graph.
	     */
	    public void removeEdge(T start, T dest) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        mGraph.get(start).remove(dest);
	    }

	    /**
	     * Given a node in the graph, returns an immutable view of the edges
	     * leaving that node, as a map from endpoints to costs.
	     *
	     * @param node The node whose edges should be queried.
	     * @return An immutable view of the edges leaving that node.
	     * @throws NoSuchElementException If the node does not exist.
	     */
	    public Map<T, Double> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Map<T, Double> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException("Source node does not exist.");

	        return Collections.unmodifiableMap(arcs);
	    }

	    /**
	     * Returns an iterator that can traverse the nodes in the graph.
	     *
	     * @return An iterator that traverses the nodes in the graph.
	     */
	    public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }
	}
	
	
	/***********************************************************************
	 * File: FibonacciHeap.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * An implementation of a priority queue backed by a Fibonacci heap,
	 * as described by Fredman and Tarjan.  Fibonacci heaps are interesting
	 * theoretically because they have asymptotically good runtime guarantees
	 * for many operations.  In particular, insert, peek, and decrease-key all
	 * run in amortized O(1) time.  dequeueMin and delete each run in amortized
	 * O(lg n) time.  This allows algorithms that rely heavily on decrease-key
	 * to gain significant performance boosts.  For example, Dijkstra's algorithm
	 * for single-source shortest paths can be shown to run in O(m + n lg n) using
	 * a Fibonacci heap, compared to O(m lg n) using a standard binary or binomial
	 * heap.
	 *
	 * Internally, a Fibonacci heap is represented as a circular, doubly-linked
	 * list of trees obeying the min-heap property.  Each node stores pointers
	 * to its parent (if any) and some arbitrary child.  Additionally, every
	 * node stores its degree (the number of children it has) and whether it
	 * is a "marked" node.  Finally, each Fibonacci heap stores a pointer to
	 * the tree with the minimum value.
	 *
	 * To insert a node into a Fibonacci heap, a singleton tree is created and
	 * merged into the rest of the trees.  The merge operation works by simply
	 * splicing together the doubly-linked lists of the two trees, then updating
	 * the min pointer to be the smaller of the minima of the two heaps.  Peeking
	 * at the smallest element can therefore be accomplished by just looking at
	 * the min element.  All of these operations complete in O(1) time.
	 *
	 * The tricky operations are dequeueMin and decreaseKey.  dequeueMin works
	 * by removing the root of the tree containing the smallest element, then
	 * merging its children with the topmost roots.  Then, the roots are scanned
	 * and merged so that there is only one tree of each degree in the root list.
	 * This works by maintaining a dynamic array of trees, each initially null,
	 * pointing to the roots of trees of each dimension.  The list is then scanned
	 * and this array is populated.  Whenever a conflict is discovered, the
	 * appropriate trees are merged together until no more conflicts exist.  The
	 * resulting trees are then put into the root list.  A clever analysis using
	 * the potential method can be used to show that the amortized cost of this
	 * operation is O(lg n), see "Introduction to Algorithms, Second Edition" by
	 * Cormen, Rivest, Leiserson, and Stein for more details.
	 *
	 * The other hard operation is decreaseKey, which works as follows.  First, we
	 * update the key of the node to be the new value.  If this leaves the node
	 * smaller than its parent, we're done.  Otherwise, we cut the node from its
	 * parent, add it as a root, and then mark its parent.  If the parent was
	 * already marked, we cut that node as well, recursively mark its parent,
	 * and continue this process.  This can be shown to run in O(1) amortized time
	 * using yet another clever potential function.  Finally, given this function,
	 * we can implement delete by decreasing a key to -\infty, then calling
	 * dequeueMin to extract it.
	 */

	/**
	 * A class representing a Fibonacci heap.
	 *
	 * @param T The type of elements to store in the heap.
	 */
	public static class FibonacciHeap<T> {
	    /* In order for all of the Fibonacci heap operations to complete in O(1),
	     * clients need to have O(1) access to any element in the heap.  We make
	     * this work by having each insertion operation produce a handle to the
	     * node in the tree.  In actuality, this handle is the node itself, but
	     * we guard against external modification by marking the internal fields
	     * private.
	     */
	    public static final class Entry<T> {
	        private int     mDegree = 0;       // Number of children
	        private boolean mIsMarked = false; // Whether this node is marked

	        private Entry<T> mNext;   // Next and previous elements in the list
	        private Entry<T> mPrev;

	        private Entry<T> mParent; // Parent in the tree, if any.

	        private Entry<T> mChild;  // Child node, if any.

	        private T      mElem;     // Element being stored here
	        private double mPriority; // Its priority

	        /**
	         * Returns the element represented by this heap entry.
	         *
	         * @return The element represented by this heap entry.
	         */
	        public T getValue() {
	            return mElem;
	        }
	        /**
	         * Sets the element associated with this heap entry.
	         *
	         * @param value The element to associate with this heap entry.
	         */
	        public void setValue(T value) {
	            mElem = value;
	        }

	        /**
	         * Returns the priority of this element.
	         *
	         * @return The priority of this element.
	         */
	        public double getPriority() {
	            return mPriority;
	        }

	        /**
	         * Constructs a new Entry that holds the given element with the indicated 
	         * priority.
	         *
	         * @param elem The element stored in this node.
	         * @param priority The priority of this element.
	         */
	        private Entry(T elem, double priority) {
	            mNext = mPrev = this;
	            mElem = elem;
	            mPriority = priority;
	        }
	    }

	    /* Pointer to the minimum element in the heap. */
	    private Entry<T> mMin = null;

	    /* Cached size of the heap, so we don't have to recompute this explicitly. */
	    private int mSize = 0;

	    /**
	     * Inserts the specified element into the Fibonacci heap with the specified
	     * priority.  Its priority must be a valid double, so you cannot set the
	     * priority to NaN.
	     *
	     * @param value The value to insert.
	     * @param priority Its priority, which must be valid.
	     * @return An Entry representing that element in the tree.
	     */
	    public Entry<T> enqueue(T value, double priority) {
	        checkPriority(priority);

	        /* Create the entry object, which is a circularly-linked list of length
	         * one.
	         */
	        Entry<T> result = new Entry<T>(value, priority);

	        /* Merge this singleton list with the tree list. */
	        mMin = mergeLists(mMin, result);

	        /* Increase the size of the heap; we just added something. */
	        ++mSize;

	        /* Return the reference to the new element. */
	        return result;
	    }

	    /**
	     * Returns an Entry object corresponding to the minimum element of the
	     * Fibonacci heap, throwing a NoSuchElementException if the heap is
	     * empty.
	     *
	     * @return The smallest element of the heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> min() {
	        if (isEmpty())
	            throw new NoSuchElementException("Heap is empty.");
	        return mMin;
	    }

	    /**
	     * Returns whether the heap is empty.
	     *
	     * @return Whether the heap is empty.
	     */
	    public boolean isEmpty() {
	        return mMin == null;
	    }

	    /**
	     * Returns the number of elements in the heap.
	     *
	     * @return The number of elements in the heap.
	     */
	    public int size() {
	        return mSize;
	    }

	    /**
	     * Given two Fibonacci heaps, returns a new Fibonacci heap that contains
	     * all of the elements of the two heaps.  Each of the input heaps is
	     * destructively modified by having all its elements removed.  You can
	     * continue to use those heaps, but be aware that they will be empty
	     * after this call completes.
	     *
	     * @param one The first Fibonacci heap to merge.
	     * @param two The second Fibonacci heap to merge.
	     * @return A new FibonacciHeap containing all of the elements of both
	     *         heaps.
	     */
	    public static <T> FibonacciHeap<T> merge(FibonacciHeap<T> one, FibonacciHeap<T> two) {
	        /* Create a new FibonacciHeap to hold the result. */
	        FibonacciHeap<T> result = new FibonacciHeap<T>();

	        /* Merge the two Fibonacci heap root lists together.  This helper function
	         * also computes the min of the two lists, so we can store the result in
	         * the mMin field of the new heap.
	         */
	        result.mMin = mergeLists(one.mMin, two.mMin);

	        /* The size of the new heap is the sum of the sizes of the input heaps. */
	        result.mSize = one.mSize + two.mSize;

	        /* Clear the old heaps. */
	        one.mSize = two.mSize = 0;
	        one.mMin  = null;
	        two.mMin  = null;

	        /* Return the newly-merged heap. */
	        return result;
	    }

	    /**
	     * Dequeues and returns the minimum element of the Fibonacci heap.  If the
	     * heap is empty, this throws a NoSuchElementException.
	     *
	     * @return The smallest element of the Fibonacci heap.
	     * @throws NoSuchElementException If the heap is empty.
	     */
	    public Entry<T> dequeueMin() {
	        /* Check for whether we're empty. */
	        if (isEmpty())
	            throw new NoSuchElementException("Heap is empty.");

	        /* Otherwise, we're about to lose an element, so decrement the number of
	         * entries in this heap.
	         */
	        --mSize;

	        /* Grab the minimum element so we know what to return. */
	        Entry<T> minElem = mMin;

	        /* Now, we need to get rid of this element from the list of roots.  There
	         * are two cases to consider.  First, if this is the only element in the
	         * list of roots, we set the list of roots to be null by clearing mMin.
	         * Otherwise, if it's not null, then we write the elements next to the
	         * min element around the min element to remove it, then arbitrarily
	         * reassign the min.
	         */
	        if (mMin.mNext == mMin) { // Case one
	            mMin = null;
	        }
	        else { // Case two
	            mMin.mPrev.mNext = mMin.mNext;
	            mMin.mNext.mPrev = mMin.mPrev;
	            mMin = mMin.mNext; // Arbitrary element of the root list.
	        }

	        /* Next, clear the parent fields of all of the min element's children,
	         * since they're about to become roots.  Because the elements are
	         * stored in a circular list, the traversal is a bit complex.
	         */
	        if (minElem.mChild != null) {
	            /* Keep track of the first visited node. */
	            Entry<?> curr = minElem.mChild;
	            do {
	                curr.mParent = null;

	                /* Walk to the next node, then stop if this is the node we
	                 * started at.
	                 */
	                curr = curr.mNext;
	            } while (curr != minElem.mChild);
	        }

	        /* Next, splice the children of the root node into the topmost list, 
	         * then set mMin to point somewhere in that list.
	         */
	        mMin = mergeLists(mMin, minElem.mChild);

	        /* If there are no entries left, we're done. */
	        if (mMin == null) return minElem;

	        /* Next, we need to coalsce all of the roots so that there is only one
	         * tree of each degree.  To track trees of each size, we allocate an
	         * ArrayList where the entry at position i is either null or the 
	         * unique tree of degree i.
	         */
	        List<Entry<T>> treeTable = new ArrayList<Entry<T>>();

	        /* We need to traverse the entire list, but since we're going to be
	         * messing around with it we have to be careful not to break our
	         * traversal order mid-stream.  One major challenge is how to detect
	         * whether we're visiting the same node twice.  To do this, we'll
	         * spent a bit of overhead adding all of the nodes to a list, and
	         * then will visit each element of this list in order.
	         */
	        List<Entry<T>> toVisit = new ArrayList<Entry<T>>();

	        /* To add everything, we'll iterate across the elements until we
	         * find the first element twice.  We check this by looping while the
	         * list is empty or while the current element isn't the first element
	         * of that list.
	         */
	        for (Entry<T> curr = mMin; toVisit.isEmpty() || toVisit.get(0) != curr; curr = curr.mNext)
	            toVisit.add(curr);

	        /* Traverse this list and perform the appropriate unioning steps. */
	        for (Entry<T> curr: toVisit) {
	            /* Keep merging until a match arises. */
	            while (true) {
	                /* Ensure that the list is long enough to hold an element of this
	                 * degree.
	                 */
	                while (curr.mDegree >= treeTable.size())
	                    treeTable.add(null);

	                /* If nothing's here, we're can record that this tree has this size
	                 * and are done processing.
	                 */
	                if (treeTable.get(curr.mDegree) == null) {
	                    treeTable.set(curr.mDegree, curr);
	                    break;
	                }

	                /* Otherwise, merge with what's there. */
	                Entry<T> other = treeTable.get(curr.mDegree);
	                treeTable.set(curr.mDegree, null); // Clear the slot

	                /* Determine which of the two trees has the smaller root, storing
	                 * the two tree accordingly.
	                 */
	                Entry<T> min = (other.mPriority < curr.mPriority)? other : curr;
	                Entry<T> max = (other.mPriority < curr.mPriority)? curr  : other;

	                /* Break max out of the root list, then merge it into min's child
	                 * list.
	                 */
	                max.mNext.mPrev = max.mPrev;
	                max.mPrev.mNext = max.mNext;

	                /* Make it a singleton so that we can merge it. */
	                max.mNext = max.mPrev = max;
	                min.mChild = mergeLists(min.mChild, max);
	                
	                /* Reparent max appropriately. */
	                max.mParent = min;

	                /* Clear max's mark, since it can now lose another child. */
	                max.mIsMarked = false;

	                /* Increase min's degree; it now has another child. */
	                ++min.mDegree;

	                /* Continue merging this tree. */
	                curr = min;
	            }

	            /* Update the global min based on this node.  Note that we compare
	             * for <= instead of < here.  That's because if we just did a
	             * reparent operation that merged two different trees of equal
	             * priority, we need to make sure that the min pointer points to
	             * the root-level one.
	             */
	            if (curr.mPriority <= mMin.mPriority) mMin = curr;
	        }
	        return minElem;
	    }

	    /**
	     * Decreases the key of the specified element to the new priority.  If the
	     * new priority is greater than the old priority, this function throws an
	     * IllegalArgumentException.  The new priority must be a finite double,
	     * so you cannot set the priority to be NaN, or +/- infinity.  Doing
	     * so also throws an IllegalArgumentException.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The element whose priority should be decreased.
	     * @param newPriority The new priority to associate with this entry.
	     * @throws IllegalArgumentException If the new priority exceeds the old
	     *         priority, or if the argument is not a finite double.
	     */
	    public void decreaseKey(Entry<T> entry, double newPriority) {
	        checkPriority(newPriority);
	        if (newPriority > entry.mPriority)
	            throw new IllegalArgumentException("New priority exceeds old.");

	        /* Forward this to a helper function. */
	        decreaseKeyUnchecked(entry, newPriority);
	    }
	    
	    /**
	     * Deletes this Entry from the Fibonacci heap that contains it.
	     *
	     * It is assumed that the entry belongs in this heap.  For efficiency
	     * reasons, this is not checked at runtime.
	     *
	     * @param entry The entry to delete.
	     */
	    public void delete(Entry<T> entry) {
	        /* Use decreaseKey to drop the entry's key to -infinity.  This will
	         * guarantee that the node is cut and set to the global minimum.
	         */
	        decreaseKeyUnchecked(entry, Double.NEGATIVE_INFINITY);

	        /* Call dequeueMin to remove it. */
	        dequeueMin();
	    }

	    /**
	     * Utility function which, given a user-specified priority, checks whether
	     * it's a valid double and throws an IllegalArgumentException otherwise.
	     *
	     * @param priority The user's specified priority.
	     * @throws IllegalArgumentException If it is not valid.
	     */
	    private void checkPriority(double priority) {
	        if (Double.isNaN(priority))
	            throw new IllegalArgumentException(priority + " is invalid.");
	    }

	    /**
	     * Utility function which, given two pointers into disjoint circularly-
	     * linked lists, merges the two lists together into one circularly-linked
	     * list in O(1) time.  Because the lists may be empty, the return value
	     * is the only pointer that's guaranteed to be to an element of the
	     * resulting list.
	     *
	     * This function assumes that one and two are the minimum elements of the
	     * lists they are in, and returns a pointer to whichever is smaller.  If
	     * this condition does not hold, the return value is some arbitrary pointer
	     * into the doubly-linked list.
	     *
	     * @param one A pointer into one of the two linked lists.
	     * @param two A pointer into the other of the two linked lists.
	     * @return A pointer to the smallest element of the resulting list.
	     */
	    private static <T> Entry<T> mergeLists(Entry<T> one, Entry<T> two) {
	        /* There are four cases depending on whether the lists are null or not.
	         * We consider each separately.
	         */
	        if (one == null && two == null) { // Both null, resulting list is null.
	            return null;
	        }
	        else if (one != null && two == null) { // Two is null, result is one.
	            return one;
	        }
	        else if (one == null && two != null) { // One is null, result is two.
	            return two;
	        }
	        else { // Both non-null; actually do the splice.
	            /* This is actually not as easy as it seems.  The idea is that we'll
	             * have two lists that look like this:
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|one |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             *
	             * +----+     +----+     +----+
	             * |    |--N->|two |--N->|    |
	             * |    |<-P--|    |<-P--|    |
	             * +----+     +----+     +----+
	             *
	             * And we want to relink everything to get
	             *
	             * +----+     +----+     +----+---+
	             * |    |--N->|one |     |    |   |
	             * |    |<-P--|    |     |    |<+ |
	             * +----+     +----+<-\  +----+ | |
	             *                  \  P        | |
	             *                   N  \       N |
	             * +----+     +----+  \->+----+ | |
	             * |    |--N->|two |     |    | | |
	             * |    |<-P--|    |     |    | | P
	             * +----+     +----+     +----+ | |
	             *              ^ |             | |
	             *              | +-------------+ |
	             *              +-----------------+
	             *
	             */
	            Entry<T> oneNext = one.mNext; // Cache this since we're about to overwrite it.
	            one.mNext = two.mNext;
	            one.mNext.mPrev = one;
	            two.mNext = oneNext;
	            two.mNext.mPrev = two;

	            /* Return a pointer to whichever's smaller. */
	            return one.mPriority < two.mPriority? one : two;
	        }
	    }

	    /**
	     * Decreases the key of a node in the tree without doing any checking to ensure
	     * that the new priority is valid.
	     *
	     * @param entry The node whose key should be decreased.
	     * @param priority The node's new priority.
	     */
	    private void decreaseKeyUnchecked(Entry<T> entry, double priority) {
	        /* First, change the node's priority. */
	        entry.mPriority = priority;

	        /* If the node no longer has a higher priority than its parent, cut it.
	         * Note that this also means that if we try to run a delete operation
	         * that decreases the key to -infinity, it's guaranteed to cut the node
	         * from its parent.
	         */
	        if (entry.mParent != null && entry.mPriority <= entry.mParent.mPriority)
	            cutNode(entry);

	        /* If our new value is the new min, mark it as such.  Note that if we
	         * ended up decreasing the key in a way that ties the current minimum
	         * priority, this will change the min accordingly.
	         */
	        if (entry.mPriority <= mMin.mPriority)
	            mMin = entry;
	    }

	    /**
	     * Cuts a node from its parent.  If the parent was already marked, recursively
	     * cuts that node from its parent as well.
	     *
	     * @param entry The node to cut from its parent.
	     */
	    private void cutNode(Entry<T> entry) {
	        /* Begin by clearing the node's mark, since we just cut it. */
	        entry.mIsMarked = false;

	        /* Base case: If the node has no parent, we're done. */
	        if (entry.mParent == null) return;

	        /* Rewire the node's siblings around it, if it has any siblings. */
	        if (entry.mNext != entry) { // Has siblings
	            entry.mNext.mPrev = entry.mPrev;
	            entry.mPrev.mNext = entry.mNext;
	        }

	        /* If the node is the one identified by its parent as its child,
	         * we need to rewrite that pointer to point to some arbitrary other
	         * child.
	         */
	        if (entry.mParent.mChild == entry) {
	            /* If there are any other children, pick one of them arbitrarily. */
	            if (entry.mNext != entry) {
	                entry.mParent.mChild = entry.mNext;
	            }
	            /* Otherwise, there aren't any children left and we should clear the
	             * pointer and drop the node's degree.
	             */
	            else {
	                entry.mParent.mChild = null;
	            }
	        }

	        /* Decrease the degree of the parent, since it just lost a child. */
	        --entry.mParent.mDegree;

	        /* Splice this tree into the root list by converting it to a singleton
	         * and invoking the merge subroutine.
	         */
	        entry.mPrev = entry.mNext = entry;
	        mMin = mergeLists(mMin, entry);

	        /* Mark the parent and recursively cut it if it's already been
	         * marked.
	         */
	        if (entry.mParent.mIsMarked)
	            cutNode(entry.mParent);
	        else
	            entry.mParent.mIsMarked = true;

	        /* Clear the relocated node's parent; it's now a root. */
	        entry.mParent = null;
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; // For HashMap, HashSet

public class ProblemAv1 {
	
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int t = Integer.parseInt(input.nextLine());
		
		
		
		for(int testCase = 1; testCase <= t; testCase++) {
			TopologicalSort topSort = new TopologicalSort();
			DirectedGraph<String> graph = new DirectedGraph<>();
			
			System.out.println("Caso #" + testCase + ":");
			
			int n = Integer.parseInt(input.nextLine());
			
			String[] letters = input.nextLine().split(" ");
			String[] tokens = input.nextLine().split(" ");
			
			for(int i = 0; i < letters.length; i++) {
				graph.addNode(letters[i]);
//				System.out.println(letters[i]);
			}
			
			for(int i = 0; i < tokens.length; i++){
				String tmp = tokens[i].charAt(0) + " " +
								  tokens[i].charAt(1) + " " +
								  tokens[i].charAt(2);
				
				String[] tmpToken = tmp.split(" ");
//				System.out.println(tmpToken[0] +" " + tmpToken[1] +" " + tmpToken[2]);

				if( tmpToken[1].equals("<"))
					graph.addEdge(tmpToken[0], tmpToken[2]);
				else if(tmpToken[1].equals(">"))
					graph.addEdge(tmpToken[2], tmpToken[0]);	
			}
			
			try {
				ArrayList<String> order = (ArrayList<String>) topSort.sort(graph);
				StringBuilder sb = new StringBuilder();
				sb.append(order.get(0));
				for(int i = 1; i < order.size(); i++)
					sb.append(" " + order.get(i));
				System.out.println(sb);
			} catch(java.lang.IllegalArgumentException E) {
				System.out.println("NO");
			}
		}
	}

	
	/******************************************************************************
	 * File: TopologicalSort.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * A linear-time algorithm for computing a topological sort of a directed
	 * acyclic graph.  A topological sort is an ordering of the nodes in a graph
	 * such that for each node v, all of the ancestors of v appear in the ordering
	 * before v itself.  Topological sorting is useful, for example, when computing
	 * some function on a DAG where each node's value depends on its ancestors.
	 * Running a topological sort and then visiting the nodes in the order
	 * specified by this sorted order ensures that the necessary values for each
	 * node are available before the node is visited.
	 *
	 * There are several algorithms for computing topological sorts.  The one used
	 * here was first described in "Edge-Disjoint Spanning Trees and Depth-First
	 * Search" by Robert Tarjan.  The algorithm is reminiscent of Kosaraju's SCC
	 * algorithm.  We begin by constructing the reverse graph G^{rev} from the
	 * source graph, then running a depth-first search from each node in the graph.
	 * Whenever we finish expanding a node, we add it to a list of visited nodes.
	 * The intution behind this algorithm is that a DFS in the reverse graph will
	 * visit every node that is an ancestor of the given node before it finishes
	 * expanding out any node.  Since those nodes will be added to the sorted order
	 * before the expanded node, we have the desired property of the topological
	 * sort.
	 *
	 * This process can be augmented to detect a cycle in the original graph.  As
	 * we do the search, we'll maintain a set of nodes that we have visited and a
	 * set of nodes that we have expanded.  If when doing the DFS we find a node
	 * that has been visited but not expanded, it means that we have encountered a
	 * cycle in the graph.  Moreover, if a cycle exists, we know that this will
	 * occur, since the first time any node in the cycle is visited the DFS will
	 * expand out the cycle.
	 */

	public final static class TopologicalSort {
	    /**
	     * Given a directed acyclic graph, returns a topological sorting of the
	     * nodes in the graph.  If the input graph is not a DAG, throws an
	     * IllegalArgumentException.
	     *
	     * @param g A directed acyclic graph.
	     * @return A topological sort of that graph.
	     * @throws IllegalArgumentException If the graph is not a DAG.
	     */
	    public static <T> List<T> sort(DirectedGraph<T> g) {
	        /* Construct the reverse graph from the input graph. */
	        DirectedGraph<T> gRev = reverseGraph(g);

	        /* Maintain two structures - a set of visited nodes (so that once we've
	         * added a node to the list, we don't label it again), and a list of
	         * nodes that actually holds the topological ordering.
	         */
	        List<T> result = new ArrayList<T>();
	        TreeSet<T> visited = new TreeSet<T>();

	        /* We'll also maintain a third set consisting of all nodes that have
	         * been fully expanded.  If the graph contains a cycle, then we can
	         * detect this by noting that a node has been explored but not fully
	         * expanded.
	         */
	        TreeSet<T> expanded = new TreeSet<T>();

	        /* Fire off a DFS from each node in the graph. */
	        for (T node: gRev)
	            explore(node, gRev, result, visited, expanded);

	        /* Hand back the resulting ordering. */
	        return result;
	    }


	    /**
	     * Recursively performs a DFS from the specified node, marking all nodes
	     * encountered by the search.
	     *
	     * @param node The node to begin the search from.
	     * @param g The graph in which to perform the search.
	     * @param ordering A list holding the topological sort of the graph.
	     * @param visited A set of nodes that have already been visited.
	     * @param expanded A set of nodes that have been fully expanded.
	     */
	    private static <T> void explore(T node, DirectedGraph<T> g,
	                                    List<T> ordering, TreeSet<T> visited,
	                                    TreeSet<T> expanded) {
	        /* Check whether we've been here before.  If so, we should stop the
	         * search.
	         */
	        if (visited.contains(node)) {
	            /* There are two cases to consider.  First, if this node has
	             * already been expanded, then it's already been assigned a
	             * position in the final topological sort and we don't need to
	             * explore it again.  However, if it hasn't been expanded, it means
	             * that we've just found a node that is currently being explored,
	             * and therefore is part of a cycle.  In that case, we should 
	             * report an error.
	             */
	            if (expanded.contains(node)) return;
	            throw new IllegalArgumentException("Graph contains a cycle.");
	        }
	        
	        /* Mark that we've been here */
	        visited.add(node);

	        /* Recursively explore all of the node's predecessors. */
	        for (T predecessor: g.edgesFrom(node))
	            explore(predecessor, g, ordering, visited, expanded);

	        /* Having explored all of the node's predecessors, we can now add this
	         * node to the sorted ordering.
	         */
	        ordering.add(node);

	        /* Similarly, mark that this node is done being expanded. */
	        expanded.add(node);
	    }

	    /**
	     * Returns the reverse of the input graph.
	     *
	     * @param g A graph to reverse.
	     * @return The reverse of that graph.
	     */
	    private static <T> DirectedGraph<T> reverseGraph(DirectedGraph<T> g) {
	        DirectedGraph<T> result = new DirectedGraph<T>();

	        /* Add all the nodes from the original graph. */
	        for (T node: g)
	            result.addNode(node);

	        /* Scan over all the edges in the graph, adding their reverse to the
	         * reverse graph.
	         */
	        for (T node: g)
	            for (T endpoint: g.edgesFrom(node))
	                result.addEdge(endpoint, node);

	        return result;
	    }
	}
	
	
	/*****************************************************************************
	 * File: DirectedGraph.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * A class representing a directed graph.  Internally, the class is represented
	 * by an adjacency list.
	 */


	public static class DirectedGraph<T> implements Iterable<T> {
	    /* A map from nodes in the graph to sets of outgoing edges.  Each
	     * set of edges is represented by a map from edges to doubles.
	     */
	    private final Map<T, Set<T>> mGraph = new HashMap<T, Set<T>>();

	    /**
	     * Adds a new node to the graph.  If the node already exists, this
	     * function is a no-op.
	     *
	     * @param node The node to add.
	     * @return Whether or not the node was added.
	     */
	    public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashSet<T>());
	        return true;
	    }

	    /**
	     * Given a start node, and a destination, adds an arc from the start node 
	     * to the destination.  If an arc already exists, this operation is a 
	     * no-op.  If either endpoint does not exist in the graph, throws a 
	     * NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @throws NoSuchElementException If either the start or destination nodes
	     *                                do not exist.
	     */
	    public void addEdge(T start, T dest) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        /* Add the edge. */
	        mGraph.get(start).add(dest);
	    }

	    /**
	     * Removes the edge from start to dest from the graph.  If the edge does
	     * not exist, this operation is a no-op.  If either endpoint does not
	     * exist, this throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @throws NoSuchElementException If either node is not in the graph.
	     */
	    public void removeEdge(T start, T dest) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        mGraph.get(start).remove(dest);
	    }

	    /**
	     * Given two nodes in the graph, returns whether there is an edge from the
	     * first node to the second node.  If either node does not exist in the
	     * graph, throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param end The destination node.
	     * @return Whether there is an edge from start to end.
	     * @throws NoSuchElementException If either endpoint does not exist.
	     */
	    public boolean edgeExists(T start, T end) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(end))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        return mGraph.get(start).contains(end);
	    }

	    /**
	     * Given a node in the graph, returns an immutable view of the edges
	     * leaving that node as a set of endpoints.
	     *
	     * @param node The node whose edges should be queried.
	     * @return An immutable view of the edges leaving that node.
	     * @throws NoSuchElementException If the node does not exist.
	     */
	    public Set<T> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Set<T> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException("Source node does not exist.");

	        return Collections.unmodifiableSet(arcs);
	    }

	    /**
	     * Returns an iterator that can traverse the nodes in the graph.
	     *
	     * @return An iterator that traverses the nodes in the graph.
	     */
	    public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }

	    /**
	     * Returns the number of nodes in the graph.
	     *
	     * @return The number of nodes in the graph.
	     */
	    public int size() {
	        return mGraph.size();
	    }

	    /**
	     * Returns whether the graph is empty.
	     *
	     * @return Whether the graph is empty.
	     */
	    public boolean isEmpty() {
	        return mGraph.isEmpty();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
// For HashMap, HashSet
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class ProblemAv2 {
	
	public static void main(String[] args) throws Exception {
		Scanner input = new Scanner(System.in);
		int t = Integer.parseInt(input.nextLine());
		
		for(int testCase = 1; testCase <= t; testCase++) {
			TopologicalSort topSort = new TopologicalSort();
			DirectedGraph<String> graph = new DirectedGraph<>();
			
			System.out.println("Caso #" + testCase + ":");
			
			int n = Integer.parseInt(input.nextLine());
			
			String[] letters = input.nextLine().split(" ");
			String[] tokens = input.nextLine().split(" ");
						
			for(int i = 0; i < letters.length; i++) {
				graph.addNode(letters[i]);
			}
			
			for(int i = 0; i < tokens.length; i++){
				String tmp = tokens[i].charAt(0) + " " +
								  tokens[i].charAt(1) + " " +
								  tokens[i].charAt(2);
				
				String[] tmpToken = tmp.split(" ");
//				System.out.println(tmpToken[0] +" " + tmpToken[1] +" " + tmpToken[2]);

				if( tmpToken[1].equals("<"))
					graph.addEdge(tmpToken[0], tmpToken[2]);
				else if(tmpToken[1].equals(">"))
					graph.addEdge(tmpToken[2], tmpToken[0]);	
			}
			
			
			
			try {
				ArrayList<String> order = (ArrayList<String>) topSort.sort(graph);
				StringBuilder sb = new StringBuilder();
				sb.append(order.get(0));
				for(int i = 1; i < order.size(); i++)
					sb.append(" " + order.get(i));
				System.out.println(sb);
			} catch(java.lang.IllegalArgumentException E) {
				System.out.println("NO");
			}
		}
	}

	
	/******************************************************************************
	 * File: TopologicalSort.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * A linear-time algorithm for computing a topological sort of a directed
	 * acyclic graph.  A topological sort is an ordering of the nodes in a graph
	 * such that for each node v, all of the ancestors of v appear in the ordering
	 * before v itself.  Topological sorting is useful, for example, when computing
	 * some function on a DAG where each node's value depends on its ancestors.
	 * Running a topological sort and then visiting the nodes in the order
	 * specified by this sorted order ensures that the necessary values for each
	 * node are available before the node is visited.
	 *
	 * There are several algorithms for computing topological sorts.  The one used
	 * here was first described in "Edge-Disjoint Spanning Trees and Depth-First
	 * Search" by Robert Tarjan.  The algorithm is reminiscent of Kosaraju's SCC
	 * algorithm.  We begin by constructing the reverse graph G^{rev} from the
	 * source graph, then running a depth-first search from each node in the graph.
	 * Whenever we finish expanding a node, we add it to a list of visited nodes.
	 * The intution behind this algorithm is that a DFS in the reverse graph will
	 * visit every node that is an ancestor of the given node before it finishes
	 * expanding out any node.  Since those nodes will be added to the sorted order
	 * before the expanded node, we have the desired property of the topological
	 * sort.
	 *
	 * This process can be augmented to detect a cycle in the original graph.  As
	 * we do the search, we'll maintain a set of nodes that we have visited and a
	 * set of nodes that we have expanded.  If when doing the DFS we find a node
	 * that has been visited but not expanded, it means that we have encountered a
	 * cycle in the graph.  Moreover, if a cycle exists, we know that this will
	 * occur, since the first time any node in the cycle is visited the DFS will
	 * expand out the cycle.
	 */

	public static class TopologicalSort {
	    /**
	     * Given a directed acyclic graph, returns a topological sorting of the
	     * nodes in the graph.  If the input graph is not a DAG, throws an
	     * IllegalArgumentException.
	     *
	     * @param g A directed acyclic graph.
	     * @return A topological sort of that graph.
	     * @throws IllegalArgumentException If the graph is not a DAG.
	     */
	    public static <T> List<T> sort(DirectedGraph<T> g) {
	        /* Construct the reverse graph from the input graph. */
	        DirectedGraph<T> gRev = reverseGraph(g);

	        /* Maintain two structures - a set of visited nodes (so that once we've
	         * added a node to the list, we don't label it again), and a list of
	         * nodes that actually holds the topological ordering.
	         */
	        List<T> result = new ArrayList<T>();
	        Set<T> visited = new HashSet<T>();

	        /* We'll also maintain a third set consisting of all nodes that have
	         * been fully expanded.  If the graph contains a cycle, then we can
	         * detect this by noting that a node has been explored but not fully
	         * expanded.
	         */
	        Set<T> expanded = new HashSet<T>();

	        /* Fire off a DFS from each node in the graph. */
	        for (T node: gRev)
	            explore(node, gRev, result, visited, expanded);

	        /* Hand back the resulting ordering. */
	        return result;
	    }


	    /**
	     * Recursively performs a DFS from the specified node, marking all nodes
	     * encountered by the search.
	     *
	     * @param node The node to begin the search from.
	     * @param g The graph in which to perform the search.
	     * @param ordering A list holding the topological sort of the graph.
	     * @param visited A set of nodes that have already been visited.
	     * @param expanded A set of nodes that have been fully expanded.
	     */
	    private static <T> void explore(T node, DirectedGraph<T> g,
	                                    List<T> ordering, Set<T> visited,
	                                    Set<T> expanded) {
	        /* Check whether we've been here before.  If so, we should stop the
	         * search.
	         */
	        if (visited.contains(node)) {
	            /* There are two cases to consider.  First, if this node has
	             * already been expanded, then it's already been assigned a
	             * position in the final topological sort and we don't need to
	             * explore it again.  However, if it hasn't been expanded, it means
	             * that we've just found a node that is currently being explored,
	             * and therefore is part of a cycle.  In that case, we should 
	             * report an error.
	             */
	            if (expanded.contains(node)) return;
	            throw new IllegalArgumentException("Graph contains a cycle.");
	        }
	        
	        /* Mark that we've been here */
	        visited.add(node);

	        /* Recursively explore all of the node's predecessors. */
	        for (T predecessor: g.edgesFrom(node))
	            explore(predecessor, g, ordering, visited, expanded);

	        /* Having explored all of the node's predecessors, we can now add this
	         * node to the sorted ordering.
	         */
	        ordering.add(node);

	        /* Similarly, mark that this node is done being expanded. */
	        expanded.add(node);
	    }

	    /**
	     * Returns the reverse of the input graph.
	     *
	     * @param g A graph to reverse.
	     * @return The reverse of that graph.
	     */
	    private static <T> DirectedGraph<T> reverseGraph(DirectedGraph<T> g) {
	        DirectedGraph<T> result = new DirectedGraph<T>();

	        /* Add all the nodes from the original graph. */
	        for (T node: g)
	            result.addNode(node);

	        /* Scan over all the edges in the graph, adding their reverse to the
	         * reverse graph.
	         */
	        for (T node: g)
	            for (T endpoint: g.edgesFrom(node))
	                result.addEdge(endpoint, node);

	        return result;
	    }
	}
	
	
	/*****************************************************************************
	 * File: DirectedGraph.java
	 * Author: Keith Schwarz (htiek@cs.stanford.edu)
	 *
	 * A class representing a directed graph.  Internally, the class is represented
	 * by an adjacency list.
	 */


	public static class DirectedGraph<T> implements Iterable<T> {
	    /* A map from nodes in the graph to sets of outgoing edges.  Each
	     * set of edges is represented by a map from edges to doubles.
	     */
	    private final Map<T, Set<T>> mGraph = new HashMap<T, Set<T>>();

	    /**
	     * Adds a new node to the graph.  If the node already exists, this
	     * function is a no-op.
	     *
	     * @param node The node to add.
	     * @return Whether or not the node was added.
	     */
	    public boolean addNode(T node) {
	        /* If the node already exists, don't do anything. */
	        if (mGraph.containsKey(node))
	            return false;

	        /* Otherwise, add the node with an empty set of outgoing edges. */
	        mGraph.put(node, new HashSet<T>());
	        return true;
	    }

	    /**
	     * Given a start node, and a destination, adds an arc from the start node 
	     * to the destination.  If an arc already exists, this operation is a 
	     * no-op.  If either endpoint does not exist in the graph, throws a 
	     * NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @throws NoSuchElementException If either the start or destination nodes
	     *                                do not exist.
	     */
	    public void addEdge(T start, T dest) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        /* Add the edge. */
	        mGraph.get(start).add(dest);
	    }

	    /**
	     * Removes the edge from start to dest from the graph.  If the edge does
	     * not exist, this operation is a no-op.  If either endpoint does not
	     * exist, this throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param dest The destination node.
	     * @throws NoSuchElementException If either node is not in the graph.
	     */
	    public void removeEdge(T start, T dest) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(dest))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        mGraph.get(start).remove(dest);
	    }

	    /**
	     * Given two nodes in the graph, returns whether there is an edge from the
	     * first node to the second node.  If either node does not exist in the
	     * graph, throws a NoSuchElementException.
	     *
	     * @param start The start node.
	     * @param end The destination node.
	     * @return Whether there is an edge from start to end.
	     * @throws NoSuchElementException If either endpoint does not exist.
	     */
	    public boolean edgeExists(T start, T end) {
	        /* Confirm both endpoints exist. */
	        if (!mGraph.containsKey(start) || !mGraph.containsKey(end))
	            throw new NoSuchElementException("Both nodes must be in the graph.");

	        return mGraph.get(start).contains(end);
	    }

	    /**
	     * Given a node in the graph, returns an immutable view of the edges
	     * leaving that node as a set of endpoints.
	     *
	     * @param node The node whose edges should be queried.
	     * @return An immutable view of the edges leaving that node.
	     * @throws NoSuchElementException If the node does not exist.
	     */
	    public Set<T> edgesFrom(T node) {
	        /* Check that the node exists. */
	        Set<T> arcs = mGraph.get(node);
	        if (arcs == null)
	            throw new NoSuchElementException("Source node does not exist.");

	        return Collections.unmodifiableSet(arcs);
	    }

	    /**
	     * Returns an iterator that can traverse the nodes in the graph.
	     *
	     * @return An iterator that traverses the nodes in the graph.
	     */
	    public Iterator<T> iterator() {
	        return mGraph.keySet().iterator();
	    }

	    /**
	     * Returns the number of nodes in the graph.
	     *
	     * @return The number of nodes in the graph.
	     */
	    public int size() {
	        return mGraph.size();
	    }

	    /**
	     * Returns whether the graph is empty.
	     *
	     * @return Whether the graph is empty.
	     */
	    public boolean isEmpty() {
	        return mGraph.isEmpty();
	    }
	}
	
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}
		
		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		@SuppressWarnings("unchecked")
		public BinaryHeap( AnyType [ ] items )
		{
				currentSize = items.length;
				array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

				int i = 1;
				for( AnyType item : items )
					array[ i++ ] = item;
				buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

				// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		@SuppressWarnings("unchecked")
		private void enlargeArray( int newSize )
		{
				AnyType [] old = array;
				array = (AnyType []) new Comparable[ newSize ];
				for( int i = 0; i < old.length; i++ )
					array[ i ] = old[ i ];        
		}
		
		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) < 0 )
					child++;
				if( array[ child ].compareTo( tmp ) < 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
		
		public String toString() {
			StringBuilder sb = new StringBuilder("{{ ");
			for(int i = 0; i < array.length; i++)
				sb.append(array[i] + " ");
			sb.append("}}");
			return new String(sb);
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
