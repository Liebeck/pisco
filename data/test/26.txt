import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaAa {
	public static void main (String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaA.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		//Obtener informacion
		int n = Integer.parseInt(br.readLine());
		int[] numeros = separarNumeros(n, br.readLine());
		
		//Calcular el producto mayor
		int mayor = 0;
		for(int i=0; i<numeros.length-1; i++){
			for(int j=i+1; j<numeros.length; j++){
				if(numeros[i]*numeros[j] > mayor){
					mayor = numeros[i]*numeros[j];
				}
			}
		}
		
		//Mostrar el producto mayor
		System.out.println(mayor);
		
		//Cerrar entrada
		br.close();
	}
	
	public static int[] separarNumeros(int n, String cadena){
		int[] numeros = new int[n];
		for(int i=0; i<n; i++){
			numeros[i] = (i!=n-1)? Integer.parseInt(cadena.substring(0, cadena.indexOf(' '))) : Integer.parseInt(cadena);
			cadena = cadena.substring(cadena.indexOf(' ')+1, cadena.length());
		}
		return numeros;
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaB {
	public static void main(String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaB.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int nCasos = Integer.parseInt(br.readLine());
		
		for(int i=0; i<nCasos; i++){
			String cadena = br.readLine();
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'B'){
					int inicio = j-2, fin = j+2;
					while(inicio < 0){inicio++;}
					while(fin > cadena.length()){fin--;}
					for(int k=inicio; k <= fin; k++){
						if(k<cadena.length() && cadena.charAt(k) == 'W'){
							cadena = cadena.substring(0, k) + 'X' + cadena.substring(k+1, cadena.length());
						}
					}
				}
			}
			//Contar explosiones
			int cantExplosiones = 0;
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'X'){
					cantExplosiones++;
				}
			}
			System.out.println(cantExplosiones);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaC {
	public static void main(String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaC.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int nCasos = Integer.parseInt(br.readLine());
		for(int i=0; i<nCasos; i++){
			int cantSubCadenas = Integer.parseInt(br.readLine());
			String cadena = br.readLine();
			for(int j=0; j<cadena.length()-1; j++){
				for(int k=j+2; k<=cadena.length(); k++){
					if(estaOrdenada(cadena.substring(j, k))){
						cantSubCadenas++;
					}else{
						//Para que salga del siclo
						k=cadena.length();
					}
				}
				
			}
			System.out.println(cantSubCadenas);
		}
	}

	private static boolean estaOrdenada(String cadena) {
		for(int i=0; i<cadena.length()-1; i++){
			if(cadena.charAt(i) > cadena.charAt(i+1)){
				return false;
			}
		}
		return true;
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaD {
	public static void main(String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaD.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		int nCasos = Integer.parseInt(br.readLine());
		for(int i=0; i<nCasos; i++){
			int tamanio = Integer.parseInt(br.readLine());
			int cantCerezas =0;
			char[][] chocolate = new char[tamanio][tamanio];
			for(int j=0; j<tamanio; j++){
				chocolate[j] = br.readLine().toCharArray();
				for(int k=0; k<tamanio; k++){
					if(chocolate[j][k] == '#'){
						cantCerezas++;
					}
				}
			}
			
			//Valor por defecto
			boolean puede = false;
			if(cantCerezas%2 == 0){
				//mirar horizontal y verticalmente
				int cantCerezasArriba = 0;
				int cantCerezasIzquierda = 0;
				for(int j=0; !puede && j<tamanio; j++){
					for(int k=0; !puede && k<tamanio; k++){
						if(chocolate[j][k] == '#'){cantCerezasArriba++;}
						if(chocolate[k][j] == '#'){cantCerezasIzquierda++;}
					}
					if(cantCerezasArriba*2 == cantCerezas || cantCerezasIzquierda*2 == cantCerezas){
						puede = true;
					}
				}
			}
			
			//Evaluacion
			if(puede){
				System.out.println("YES");
			}else{
				System.out.println("NO");
			}
		}
	}	
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.IOException;
import java.util.Scanner;

public class ProblemaA {
	public static void main (String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		Scanner s = new Scanner(new File("EntradaA.txt"));
		
		//Obtener informacion
		int n = s.nextInt();
		int[] numeros = new int[n];
		for(int i=0; i<n; i++){
			numeros[i] = s.nextInt();
		}
		
		//Calcular el producto mayor
		int mayor = 0;
		for(int i=0; i<numeros.length-1; i++){
			for(int j=i+1; j<numeros.length; j++){
				if(numeros[i]*numeros[j] > mayor){
					mayor = numeros[i]*numeros[j];
				}
			}
		}
		
		//Mostrar el producto mayor
		System.out.println(mayor);
		
		//Cerrar entrada
		s.close();
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaAa {
	public static void main (String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaA.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		//Obtener informacion
		int n = Integer.parseInt(br.readLine());
		int[] numeros = separarNumeros(n, br.readLine());
		
		//Calcular el producto mayor
		int mayor = 0;
		for(int i=0; i<numeros.length-1; i++){
			for(int j=i+1; j<numeros.length; j++){
				if(numeros[i]*numeros[j] > mayor){
					mayor = numeros[i]*numeros[j];
				}
			}
		}
		
		//Mostrar el producto mayor
		System.out.println(mayor);
		
		//Cerrar entrada
		br.close();
	}
	
	public static int[] separarNumeros(int n, String cadena){
		int[] numeros = new int[n];
		for(int i=0; i<n; i++){
			numeros[i] = (i!=n-1)? Integer.parseInt(cadena.substring(0, cadena.indexOf(' '))) : Integer.parseInt(cadena);
			cadena = cadena.substring(cadena.indexOf(' ')+1, cadena.length());
		}
		return numeros;
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaB {
	public static void main(String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaB.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int nCasos = Integer.parseInt(br.readLine());
		
		for(int i=0; i<nCasos; i++){
			String cadena = br.readLine();
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'B'){
					int inicio = j-2, fin = j+2;
					while(inicio < 0){inicio++;}
					while(fin > cadena.length()){fin--;}
					for(int k=inicio; k <= fin; k++){
						if(k<cadena.length() && cadena.charAt(k) == 'W'){
							cadena = cadena.substring(0, k) + 'X' + cadena.substring(k+1, cadena.length());
						}
					}
				}
			}
			//Contar explosiones
			int cantExplosiones = 0;
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'X'){
					cantExplosiones++;
				}
			}
			System.out.println(cantExplosiones);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaAa {
	public static void main (String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaA.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		//Obtener informacion
		int n = Integer.parseInt(br.readLine());
		int[] numeros = separarNumeros(n, br.readLine());
		
		//Calcular el producto mayor
		int mayor = 0;
		for(int i=0; i<numeros.length-1; i++){
			for(int j=i+1; j<numeros.length; j++){
				if(numeros[i]*numeros[j] > mayor){
					mayor = numeros[i]*numeros[j];
				}
			}
		}
		
		//Mostrar el producto mayor
		System.out.println(mayor);
		
		//Cerrar entrada
		br.close();
	}
	
	public static int[] separarNumeros(int n, String cadena){
		int[] numeros = new int[n];
		for(int i=0; i<n; i++){
			numeros[i] = (i!=n-1)? Integer.parseInt(cadena.substring(0, cadena.indexOf(' '))) : Integer.parseInt(cadena);
			cadena = cadena.substring(cadena.indexOf(' ')+1, cadena.length());
		}
		return numeros;
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaAa {
	public static void main (String[] args) throws NumberFormatException, IOException{
		File f = new File("EntradaA.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		//br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		String cadena = br.readLine();
		int[] numeros = new int[n];
		for(int i=0; i<n; i++){
			numeros[i] = (i!=n-1)? Integer.parseInt(cadena.substring(0, cadena.indexOf(' '))) : Integer.parseInt(cadena);
			cadena = cadena.substring(cadena.indexOf(' ')+1, cadena.length());
		}
		
		int mayor = 0;
		for(int i=0; i<numeros.length-1; i++){
			for(int j=i+1; j<numeros.length; j++){
				if(numeros[i]*numeros[j] > mayor){
					mayor = numeros[i]*numeros[j];
				}
			}
		}
		
		System.out.println(mayor);
		
		br.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaAa {
	public static void main (String[] args) throws NumberFormatException, IOException{
		File f = new File("EntradaA.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		//br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		String cadena = br.readLine();
		long[] numeros = new long[n];
		for(int i=0; i<n; i++){
			numeros[i] = (i!=n-1)? Integer.parseInt(cadena.substring(0, cadena.indexOf(' '))) : Integer.parseInt(cadena);
			cadena = cadena.substring(cadena.indexOf(' ')+1, cadena.length());
		}
		
		long mayor = 0;
		for(int i=0; i<numeros.length-1; i++){
			for(int j=i+1; j<numeros.length; j++){
				long a = numeros[i]*numeros[j];
				if(a > mayor){
					mayor = a;
				}
			}
		}
		
		System.out.println(mayor);
		
		br.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaB {
	public static void main(String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaB.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int nCasos = Integer.parseInt(br.readLine());
		
		for(int i=0; i<nCasos; i++){
			String cadena = br.readLine();
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'B'){
					int inicio = j-2, fin = j+2;
					if(inicio < 0){inicio = 0;}
					if (inicio < 0){fin = cadena.length();}
					for(int k=inicio; k <= fin; k++){
						if(k<cadena.length() && cadena.charAt(k) == 'W'){
							cadena = cadena.substring(0, k) + 'X' + cadena.substring(k+1, cadena.length());
						}
					}
				}
			}
			//Contar explosiones
			int cantExplosiones = 0;
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'X'){
					cantExplosiones++;
				}
			}
			System.out.println(cantExplosiones);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaB {
	public static void main(String[] args) throws NumberFormatException, IOException{
		File f = new File("EntradaB.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		int nCasos = Integer.parseInt(br.readLine());
		for(int i=0; i<nCasos; i++){
			String cadena = br.readLine();
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'B'){
					int inicio = j-2, fin = j+2, largo = cadena.length();
					if(inicio < 0){inicio = 0;}
					if (inicio < 0){fin = largo;}
					for(int k=inicio; k <= fin; k++){
						if(k<largo && cadena.charAt(k) == 'W'){
							cadena = cadena.substring(0, k) + 'X' + cadena.substring(k+1, largo);
						}
					}
				}
			}
			int cantExplosiones = 0;
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'X'){
					cantExplosiones++;
				}
			}
			System.out.println(cantExplosiones);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaB {
	public static void main(String[] args) throws NumberFormatException, IOException{
		File f = new File("EntradaB.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		int nCasos = Integer.parseInt(br.readLine());
		for(int i=0; i<nCasos; i++){
			String cadena = br.readLine();
			char[] arreglo = cadena.toCharArray();
			for(int j=0; j<arreglo.length; j++){
				if(arreglo[j] == 'B'){
					int inicio = j-2, fin = j+2;
					if(inicio < 0){inicio = 0;}
					if (inicio < 0){fin = arreglo.length;}
					for(int k=inicio; k <= fin; k++){
						if(k<arreglo.length && arreglo[k] == 'W'){
							arreglo[k] = 'X';
						}
					}
				}
			}
			int cantExplosiones = 0;
			for(int j=0; j<cadena.length(); j++){
				if(cadena.charAt(j) == 'X'){
					cantExplosiones++;
				}
			}
			System.out.println(cantExplosiones);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaB {
	public static void main(String[] args) throws NumberFormatException, IOException{
		File f = new File("EntradaB.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		int nCasos = Integer.parseInt(br.readLine());
		for(int i=0; i<nCasos; i++){
			String cadena = br.readLine();
			char[] arreglo = cadena.toCharArray();
			for(int j=0; j<arreglo.length; j++){
				if(arreglo[j] == 'B'){
					int inicio = j-2, fin = j+2;
					if(inicio < 0){inicio = 0;}
					if (inicio < 0){fin = arreglo.length;}
					for(int k=inicio; k <= fin; k++){
						if(k<arreglo.length && arreglo[k] == 'W'){
							arreglo[k] = 'X';
						}
					}
				}
			}
			int cantExplosiones = 0;
			for(int j=0; j<arreglo.length; j++){
				if(arreglo[j] == 'X'){
					cantExplosiones++;
				}
			}
			System.out.println(cantExplosiones);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemaD {
	public static void main(String[] args) throws NumberFormatException, IOException{
		//Abrir entrada
		File f = new File("EntradaD.txt");
		BufferedReader br = null;
		if(f.exists()){
			br = new BufferedReader(new FileReader(f));
		} else {
			br = new BufferedReader(new InputStreamReader(System.in));
		}

		int nCasos = Integer.parseInt(br.readLine());
		for(int i=0; i<nCasos; i++){
			int tamanio = Integer.parseInt(br.readLine());
			int cantCerezas =0;
			char[][] chocolate = new char[tamanio][tamanio];
			for(int j=0; j<tamanio; j++){
				chocolate[j] = br.readLine().toCharArray();
				for(int k=0; k<tamanio; k++){
					if(chocolate[j][k] == '#'){
						cantCerezas++;
					}
				}
			}
			
			//Valor por defecto
			int puedeFil = 0, puedeCol = 0;
			if(cantCerezas%2 == 0){
				//mirar horizontal y verticalmente
				int cantCerezasArriba = 0;
				int cantCerezasIzquierda = 0;
				for(int j=0; j<tamanio; j++){
					for(int k=0; k<tamanio; k++){
						if(chocolate[j][k] == '#'){cantCerezasArriba++;}
						if(chocolate[k][j] == '#'){cantCerezasIzquierda++;}
					}
					if(cantCerezasArriba*2 == cantCerezas){
						puedeFil++;
					}
					if(cantCerezasIzquierda*2 == cantCerezas){
						puedeCol++;
					}
				}
			}
			System.out.println(puedeFil+" "+puedeCol);
		}
	}	
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Scanner;



public class ProblemaD_viejo {
	public static MyArrayList<MyArrayList<String[]>> cubiculos = new MyArrayList<MyArrayList<String[]>>();
	public static int[] casillerosOcupadosCubiculo = null;

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		File f = new File("DEntrada2.txt");
		BufferedReader br = null;
		Scanner s = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("DSalida2.txt")));
		} else {
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		
		int cantCasos = Integer.parseInt(br.readLine());
		int cantCubiculos = 0;
		int[] cantCasillerosCubiculo = null;
		MyArrayList<String[]> cubiculo = new MyArrayList<String[]>();
		
		for(int t=0; t<cantCasos; t++){
			System.out.println("Caso #"+(t+1)+":");
			//Inicializada
			cubiculos.clear();
			cantCubiculos = Integer.parseInt(br.readLine());
			cantCasillerosCubiculo = separarNumeros(br.readLine(), cantCubiculos);
			casillerosOcupadosCubiculo = new int[cantCubiculos];
			for(int n=0; n<cantCubiculos; n++){
				cubiculo = new MyArrayList<String[]>();
				for(int k=0; k<cantCasillerosCubiculo[n]; k++){
					cubiculo.add(new String[3]);
				}
				cubiculos.add(cubiculo);
			}
			
			
			int cantComandos = Integer.parseInt(br.readLine());
			for(int p=0; p<cantComandos; p++){
				ejecutarComando(br.readLine());
			}
		}
	}
	public static int[] separarNumeros(String cadena, int cantNumeros){
		String[] cadenas = cadena.split(" ");
		int[] numeros = new int[cantNumeros];
		for(int i=0; i<cantNumeros; i++){
			numeros[i] = Integer.parseInt(cadenas[i]);
		}
		return numeros;
	}
	
	public static void ejecutarComando(String cadena){
		String comando = cadena.substring(0, cadena.indexOf(' '));
		
		if(comando.equalsIgnoreCase("ingresar")){
			String[] persona = separarCadenas(cadena.substring(cadena.indexOf(' ')+1, cadena.length()));
			int cubiculoUsar = cubiculoAUsar();
			if(cubiculoUsar == -1){
				System.out.println("limite alcanzado");
			}else{
				MyArrayList<String[]> cubiculo = cubiculos.get(cubiculoUsar);
				for(int i=0; i<cubiculo.size(); i++){
					if(cubiculo.get(i)[0] == null){
						cubiculo.set(i, persona);
						casillerosOcupadosCubiculo[cubiculoUsar]++;
						System.out.println((cubiculoUsar+1)+" "+(i+1));
						i=cubiculo.size();
					}
				}
			}
		}else if(comando.equalsIgnoreCase("salir")){
			String cedula = cadena.substring(cadena.indexOf(' ')+1, cadena.length());
			int i = 0;
			int j =0;
			boolean encontro = false;
			for(MyArrayList<String[]> x : cubiculos){
				j=0;
				for(String[] y : x){
					if(cedula.equals(y[2])){
						System.out.println(y[0]);
						//y = new String[3];
						encontro = true;
						break;
					}
					j++;
				}
				if(encontro){
					break;
				}
				i++;
			}
			cubiculos.get(i).set(j, new String[3]);
			casillerosOcupadosCubiculo[i]--;
		}
	}
	public static String[] separarCadenas(String cadena){
		String[] cadenas = cadena.split(" ");
		String[] retorno = new String[3];
		for(int i=0; i<retorno.length; i++){
			retorno[i] = cadenas[i];
		}
		return retorno;
	}
	
	public static int cubiculoAUsar(){
		double menor = 1;
		int index = -1;	//	Retrona -1 en caso de que no exista ningun cubiculo disponible
		//por cada uno de los cubiculos
		for(int i=0; i<casillerosOcupadosCubiculo.length; i++){
			if((double)casillerosOcupadosCubiculo[i] / (double)cubiculos.get(i).size() < menor){
				menor = (double)casillerosOcupadosCubiculo[i] / (double)cubiculos.get(i).size();
				index=i;
			}
		}
		return index;
	}
	
	
	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    public int size( )
	    {
	        return theSize;
	    }
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder( "[ " );

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.append( "]" );

	            return new String( sb );
	    }
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( );
	            
	            okToRemove = true;
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ProblemaA {
	public static void main(String[] args) throws Exception {
		File f = new File("AEntrada2.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("ASalida2.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int numEquipos, numEnvios;
		HashMap<Integer, Concursante> memoria = new HashMap<>();
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			memoria.clear();
			
			entrada = br.readLine().split(" ");
			numEquipos = Integer.parseInt(entrada[0]);
			numEnvios = Integer.parseInt(entrada[1]);
			
			for(int i=0; i<numEnvios; i++){
				
				entrada = br.readLine().split(" ");
				valores = new int[3];
				for(int j=0; j<3; j++)
					valores[j] = Integer.parseInt(entrada[j]);
				
				
				//	Si el concurrsante no ha subido nada
				if(!memoria.containsKey(valores[0])){
					memoria.put(valores[0], new Concursante(valores[0]));
				}
				Concursante actual = memoria.get(valores[0]);
				
				//	Si el envio fue correcto
				if(entrada[3].equalsIgnoreCase("C")){
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						//	Si no se ha completado
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(
									valores[1], new Integer[]{1, valores[2] + actual.getPenalizacionesParciales().get(valores[1])[1]});
							actual.sumarProblemasResueltos(1);
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2]} );
						actual.sumarProblemasResueltos(1);
					}
					actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
					
				//	Si el envio fue incorrecto
				}else{
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						actual.getPenalizacionesParciales().put(
								valores[1], new Integer[]{0, 20 + actual.getPenalizacionesParciales().get(valores[1])[1]});
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{0, 20});
					}
				}
			}
			
			
			MyBinaryHeap<Concursante> BinH = new MyBinaryHeap<>("BinH", true);
			//	Agregar los concursantes a la cola de prioridad
			Iterator it = memoria.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				//System.out.println(e.getKey() + " " + e.getValue());
				BinH.offer((Concursante) e.getValue());
			}
			
			Concursante aux;
			//System.out.println(BinH.size);
			while(!BinH.isEmpty()){
				aux = BinH.poll();
				System.out.println(aux.getId()+" "+aux.getProblemasResueltos()+" "+aux.getTiempoPenalizado());
			}
		}
	}
	
	public static class Concursante implements Comparable<Concursante>{
		private int id;
		private int problemasResueltos;
		private int tiempoPenalizado;	//Tiempo de penalizacion total acumulados
		private HashMap<Integer, Integer[]> penalizacionesParciales;

		public Concursante(int id) {
			super();
			this.id = id;
			this.problemasResueltos = 0;
			this.tiempoPenalizado = 0;
			this.penalizacionesParciales = new HashMap<>();
		}

		public int getId() {
			return this.id;
		}
		public int getProblemasResueltos() {
			return this.problemasResueltos;
		}
		public int getTiempoPenalizado() {
			return this.tiempoPenalizado;
		}
		public HashMap<Integer, Integer[]> getPenalizacionesParciales(){
			return this.penalizacionesParciales;
		}
		
		public void setId(int id) {
			this.id = id;
		}
		public void setProblemasResueltos(int problemasResueltos) {
			this.problemasResueltos = problemasResueltos;
		}
		public void setTiempoPenalizado(int tiempoPenalizado) {
			this.tiempoPenalizado = tiempoPenalizado;
		}
		public void setPenalizacionesParciales(HashMap<Integer, Integer[]> penalizacionesParciales){
			this.penalizacionesParciales = penalizacionesParciales;
		}

		public void sumarProblemasResueltos(int cantidad){
			this.problemasResueltos += cantidad;
		}
		public void sumarTiempoPenalizado(int cantidad){
			this.tiempoPenalizado += cantidad;
		}
		
		@Override
		public int compareTo(Concursante o) {
			// TODO Auto-generated method stub
			if(this.problemasResueltos > o.problemasResueltos)
				return 1;
			else if(this.problemasResueltos < o.problemasResueltos)
				return -1;
			
			//	Else this.problemasResueltos == o.problemasResueltos
			if(this.tiempoPenalizado < o.tiempoPenalizado)
				return 1;
			else if(this.tiempoPenalizado > o.tiempoPenalizado)
				return -1;
			
			//	Else this.tiempoPenalizado == o.tiempoPenalizado
			if(this.id < o.id)
				return 1;
			else if(this.id > o.id)
				return -1;
			
			//	Else this.id == o.id
			return 0;
		}
		
	}

	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind) {
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;


public class ProblemaB {
		public static void main(String[] args) throws NumberFormatException, IOException{
		File f = new File("BEntrada2.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("BSalida2.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		int N;
		HashMap<Integer, Integer> ocurrencias = new HashMap<>();
		MyQueueSingleLinkedList<Integer> memoria = new MyQueueSingleLinkedList<>();
		String[] entrada;
		int[] numeros;
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			ocurrencias.clear();
			memoria.clear();
			
			N = Integer.parseInt(br.readLine().split(" ")[0]);
			numeros = new int[N];
			entrada = br.readLine().split(" ");
			for(int i=0; i<N; i++)
				numeros[i] = Integer.parseInt(entrada[i]);
			
			for(int i=0; i<N; i++){
				if(ocurrencias.containsKey(numeros[i]))
					ocurrencias.put(numeros[i], ocurrencias.get(numeros[i])+1);
				else{
					ocurrencias.put(numeros[i], 1);
					memoria.enqueue(numeros[i]);
				}
			}
			
			int auxiliar;
			while(!memoria.isEmpty()){
				auxiliar = memoria.dequeue();
				System.out.println(auxiliar+" "+ocurrencias.get(auxiliar));
			}
			
		}
	}
		
	public static class MyQueueSingleLinkedList<AnyType>{
	    public MyQueueSingleLinkedList( )
	    {
	        clear( );
	    }
	    
	    public void clear( )
	    {
	        beginMarker = new Node<>( null, null );
	        endNode = beginMarker;
	        theSize = 0;
	    }
	    
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    public boolean enqueue (AnyType x){
	        Node<AnyType> newNode = new Node<>( x, null );
	        endNode.next = newNode;
	        endNode = newNode;
	        theSize++;
	        return true;
	    }
	    
	    public AnyType dequeue (){
	    	if(beginMarker.next == endNode){ 
	    		endNode = beginMarker;
	    	}
	    	AnyType data = beginMarker.next.data;
	    	beginMarker.next = beginMarker.next.next;
	        theSize--;
	        
	        return data;
	    }
	    
	    public AnyType peek(){
	    	return beginMarker.next.data;
	    }
	    
	    public void print(){
	    	for(int i=0; i<theSize; i++){
	    		AnyType item = dequeue();
	    		System.out.println(item);
	    		enqueue(item);
	    	}
	    }
	    
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> n )
	        {
	            data = d; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType> next;
	    }
	    
	    private int theSize;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endNode;
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;

public class ProblemaC {
	public static void main(String[] args) throws NumberFormatException, IOException{
		File f = new File("CEntrada2.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("CSalida2.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		MyUnionFind grupos;
		HashMap<String, Integer> index = new HashMap();
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		int N;
		String[] entrada;
		String[][] memoria;
		int idx;
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			
			N = Integer.parseInt(br.readLine().split(" ")[0]);
			memoria = new String[N][];
			index.clear();
			idx = 0;
			for(int i=0; i<N; i++){
				entrada = br.readLine().split(" ");
				memoria[i] = new String[2];
				memoria[i][0] = entrada[0];
				memoria[i][1] = entrada[1];
				
				for(int j=0; j<2; j++){
					if(!index.containsKey(entrada[j])){
						index.put(entrada[j], idx);
						idx++;
					}
				}
			}
			
			/*
			Iterator it = index.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				System.out.println(e.getKey() + " " + e.getValue());
			}*/
			
			
			//System.out.println(index.size());
			grupos = new MyUnionFind(index.size());
			for(int i=0; i<N; i++){
				grupos.union(index.get(memoria[i][0]), index.get(memoria[i][1]));
				System.out.println(grupos.sizeOfSet(index.get(memoria[i][0])));
			}
			
			
		}
	}
	
	
	public static class MyUnionFind {
		int[] ancestor;		//Array of roots y rank; ???
		int[] sizeSet;		//# elements in the Set[i];
		int sets;			//# sets;
		
		public MyUnionFind(int size){
			this.ancestor = new int[size];
			this.sizeSet = new int[size];
			
			Arrays.fill(this.ancestor, -1);
			Arrays.fill(this.sizeSet, 1);
			this.sets = size;
		}
		
		public int sets(){
			return this.sets;
		}
		
		public boolean atSameSet(int element1, int element2){
			return this.findSet(element1) == findSet(element2);
		}
		
		public int sizeOfSet(int element1){
			return this.sizeSet[findSet(element1)];
		}
		
		public int findSet(int element){
			if(this.ancestor[element] < 0)
				return element;
			else
				return this.ancestor[element] = findSet(this.ancestor[element]);
		}
		
		public void union(int element1, int element2){
			if(!this.atSameSet(element1, element2)){
				this.sets--;
				int root_element1 = findSet(element1);
				int root_element2 = findSet(element2);
				
				if(this.ancestor[root_element1] < this.ancestor[root_element2]){
					this.ancestor[root_element2] = root_element1;
					this.sizeSet[root_element1] += this.sizeSet[root_element2];
				}else{
					if(this.ancestor[root_element1] == this.ancestor[root_element2])
						this.ancestor[root_element2]--;
					
					this.ancestor[root_element1] = root_element2;
					this.sizeSet[root_element2] += this.sizeSet[root_element1];
				}
				
			}
		}
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ProblemaA {
	public static void main(String[] args) throws Exception {
		File f = new File("AEntrada3.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("ASalida3.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int numEquipos, numEnvios;
		HashMap<Integer, Concursante> memoria = new HashMap<>();
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			memoria.clear();
			
			entrada = br.readLine().split(" ");
			numEquipos = Integer.parseInt(entrada[0]);
			numEnvios = Integer.parseInt(entrada[1]);
			
			for(int i=0; i<numEnvios; i++){
				
				entrada = br.readLine().split(" ");
				valores = new int[3];
				System.err.print(t+" "+i+"\t"+entrada.length+"\t");
				for(int j=0; j<entrada.length; j++)
					System.err.print(entrada[j]+" ");
				System.err.println();
				for(int j=0; j<3; j++)
					valores[j] = Integer.parseInt(entrada[j]);
				
				
				//	Si el concurrsante no ha subido nada
				if(!memoria.containsKey(valores[0])){
					memoria.put(valores[0], new Concursante(valores[0]));
				}
				Concursante actual = memoria.get(valores[0]);
				
				//	Si el envio fue correcto
				if(entrada[3].equalsIgnoreCase("C")){
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						//	Si no se ha completado
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(
									valores[1], new Integer[]{1, valores[2] + actual.getPenalizacionesParciales().get(valores[1])[1]});
							actual.sumarProblemasResueltos(1);
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2]} );
						actual.sumarProblemasResueltos(1);
					}
					actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
					
				//	Si el envio fue incorrecto
				}else{
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
						actual.getPenalizacionesParciales().put(
								valores[1], new Integer[]{0, 20 + actual.getPenalizacionesParciales().get(valores[1])[1]});
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{0, 20});
					}
				}
			}
			
			
			MyBinaryHeap<Concursante> BinH = new MyBinaryHeap<>("BinH", true);
			//	Agregar los concursantes a la cola de prioridad
			Iterator it = memoria.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				//System.out.println(e.getKey() + " " + e.getValue());
				BinH.offer((Concursante) e.getValue());
			}
			
			Concursante aux;
			//System.out.println(BinH.size);
			while(!BinH.isEmpty()){
				aux = BinH.poll();
				System.out.println(aux.getId()+" "+aux.getProblemasResueltos()+" "+aux.getTiempoPenalizado());
			}
		}
	}
	
	public static class Concursante implements Comparable<Concursante>{
		private int id;
		private int problemasResueltos;
		private int tiempoPenalizado;	//Tiempo de penalizacion total acumulados
		private HashMap<Integer, Integer[]> penalizacionesParciales;

		public Concursante(int id) {
			super();
			this.id = id;
			this.problemasResueltos = 0;
			this.tiempoPenalizado = 0;
			this.penalizacionesParciales = new HashMap<>();
		}

		public int getId() {
			return this.id;
		}
		public int getProblemasResueltos() {
			return this.problemasResueltos;
		}
		public int getTiempoPenalizado() {
			return this.tiempoPenalizado;
		}
		public HashMap<Integer, Integer[]> getPenalizacionesParciales(){
			return this.penalizacionesParciales;
		}
		
		public void setId(int id) {
			this.id = id;
		}
		public void setProblemasResueltos(int problemasResueltos) {
			this.problemasResueltos = problemasResueltos;
		}
		public void setTiempoPenalizado(int tiempoPenalizado) {
			this.tiempoPenalizado = tiempoPenalizado;
		}
		public void setPenalizacionesParciales(HashMap<Integer, Integer[]> penalizacionesParciales){
			this.penalizacionesParciales = penalizacionesParciales;
		}

		public void sumarProblemasResueltos(int cantidad){
			this.problemasResueltos += cantidad;
		}
		public void sumarTiempoPenalizado(int cantidad){
			this.tiempoPenalizado += cantidad;
		}
		
		@Override
		public int compareTo(Concursante o) {
			if(this.problemasResueltos > o.problemasResueltos)
				return 1;
			else if(this.problemasResueltos < o.problemasResueltos)
				return -1;
			
			//	Else this.problemasResueltos == o.problemasResueltos
			if(this.tiempoPenalizado < o.tiempoPenalizado)
				return 1;
			else if(this.tiempoPenalizado > o.tiempoPenalizado)
				return -1;
			
			//	Else this.tiempoPenalizado == o.tiempoPenalizado
			if(this.id < o.id)
				return 1;
			else if(this.id > o.id)
				return -1;
			
			//	Else this.id == o.id
			return 0;
		}
		
	}

	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind) {
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ProblemaA {
	public static void main(String[] args) throws Exception {
		File f = new File("AEntrada3.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("ASalida3.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int numEquipos, numEnvios;
		HashMap<Integer, Concursante> memoria = new HashMap<>();
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			memoria.clear();
			
			entrada = br.readLine().split(" ");
			numEquipos = Integer.parseInt(entrada[0]);
			numEnvios = Integer.parseInt(entrada[1]);
			
			for(int i=0; i<numEnvios; i++){
				
				entrada = br.readLine().split(" ");
				valores = new int[3];
				System.err.print(t+" "+i+"\t"+entrada.length+"\t");
				for(int j=0; j<entrada.length; j++)
					System.err.print(entrada[j]+" ");
				System.err.println();
				for(int j=0; j<3; j++)
					valores[j] = Integer.parseInt(entrada[j]);
				
				
				//	Si el concurrsante no ha subido nada
				if(!memoria.containsKey(valores[0])){
					memoria.put(valores[0], new Concursante(valores[0]));
				}
				Concursante actual = memoria.get(valores[0]);
				
				//	Si el envio fue correcto
				if(entrada[3].equalsIgnoreCase("C")){
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						//	Si no se ha completado
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2] + actual.getPenalizacionesParciales().get(valores[1])[1]});
							actual.sumarProblemasResueltos(1);
							actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2]} );
						actual.sumarProblemasResueltos(1);
						actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
					}
					
				//	Si el envio fue incorrecto
				}else{
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(
									valores[1], new Integer[]{0, 20 + actual.getPenalizacionesParciales().get(valores[1])[1]});
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{0, 20});
					}
				}
			}
			
			
			MyBinaryHeap<Concursante> BinH = new MyBinaryHeap<>("BinH", true);
			//	Agregar los concursantes a la cola de prioridad
			Iterator it = memoria.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				//System.out.println(e.getKey() + " " + e.getValue());
				BinH.offer((Concursante) e.getValue());
			}
			
			Concursante aux;
			//System.out.println(BinH.size);
			while(!BinH.isEmpty()){
				aux = BinH.poll();
				System.out.println(aux.getId()+" "+aux.getProblemasResueltos()+" "+aux.getTiempoPenalizado());
			}
		}
	}
	
	public static class Concursante implements Comparable<Concursante>{
		private int id;
		private int problemasResueltos;
		private int tiempoPenalizado;	//Tiempo de penalizacion total acumulados
		private HashMap<Integer, Integer[]> penalizacionesParciales;

		public Concursante(int id) {
			super();
			this.id = id;
			this.problemasResueltos = 0;
			this.tiempoPenalizado = 0;
			this.penalizacionesParciales = new HashMap<>();
		}

		public int getId() {
			return this.id;
		}
		public int getProblemasResueltos() {
			return this.problemasResueltos;
		}
		public int getTiempoPenalizado() {
			return this.tiempoPenalizado;
		}
		public HashMap<Integer, Integer[]> getPenalizacionesParciales(){
			return this.penalizacionesParciales;
		}
		
		public void setId(int id) {
			this.id = id;
		}
		public void setProblemasResueltos(int problemasResueltos) {
			this.problemasResueltos = problemasResueltos;
		}
		public void setTiempoPenalizado(int tiempoPenalizado) {
			this.tiempoPenalizado = tiempoPenalizado;
		}
		public void setPenalizacionesParciales(HashMap<Integer, Integer[]> penalizacionesParciales){
			this.penalizacionesParciales = penalizacionesParciales;
		}

		public void sumarProblemasResueltos(int cantidad){
			this.problemasResueltos += cantidad;
		}
		public void sumarTiempoPenalizado(int cantidad){
			this.tiempoPenalizado += cantidad;
		}
		
		@Override
		public int compareTo(Concursante o) {
			if(this.problemasResueltos > o.problemasResueltos)
				return 1;
			else if(this.problemasResueltos < o.problemasResueltos)
				return -1;
			
			//	Else this.problemasResueltos == o.problemasResueltos
			if(this.tiempoPenalizado < o.tiempoPenalizado)
				return 1;
			else if(this.tiempoPenalizado > o.tiempoPenalizado)
				return -1;
			
			//	Else this.tiempoPenalizado == o.tiempoPenalizado
			if(this.id < o.id)
				return 1;
			else if(this.id > o.id)
				return -1;
			
			//	Else this.id == o.id
			return 0;
		}
		
	}

	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind) {
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ProblemaA {
	public static void main(String[] args) throws Exception {
		File f = new File("AEntrada1.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("ASalida1.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int numEquipos, numEnvios;
		HashMap<Integer, Concursante> memoria = new HashMap<>();
		int[] CITR = new int[4];
		Arrays.fill(CITR, 0);
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			memoria.clear();
			
			entrada = br.readLine().split(" ");
			numEquipos = Integer.parseInt(entrada[0]);
			numEnvios = Integer.parseInt(entrada[1]);
			
			for(int i=0; i<numEnvios; i++){
				
				entrada = br.readLine().split(" ");
				valores = new int[3];
				for(int j=0; j<3; j++)
					valores[j] = Integer.parseInt(entrada[j]);
				
				
				//	Si el concurrsante no ha subido nada
				if(!memoria.containsKey(valores[0])){
					memoria.put(valores[0], new Concursante(valores[0]));
				}
				Concursante actual = memoria.get(valores[0]);
				
				//	Si el envio fue correcto
				if(entrada[3].equalsIgnoreCase("C")){
					CITR[0]++;
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						//	Si no se ha completado
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2] + actual.getPenalizacionesParciales().get(valores[1])[1]});
							actual.sumarProblemasResueltos(1);
							actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2]} );
						actual.sumarProblemasResueltos(1);
						actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
					}
					
				//	Si el envio fue incorrecto
				}else{
					switch (entrada[3]) {
					case "I":
						CITR[1]++;
						break;
					case "T":
						CITR[2]++;
						break;
					case "R":
						CITR[3]++;
						break;

					default:
						break;
					}
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(
									valores[1], new Integer[]{0, 20 + actual.getPenalizacionesParciales().get(valores[1])[1]});
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{0, 20});
					}
				}
			}
			
			
			MyBinaryHeap<Concursante> BinH = new MyBinaryHeap<>("BinH", true);
			//	Agregar los concursantes a la cola de prioridad
			Iterator it = memoria.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				//System.out.println(e.getKey() + " " + e.getValue());
				BinH.offer((Concursante) e.getValue());
			}
			
			Concursante aux;
			//System.out.println(BinH.size);
			while(!BinH.isEmpty()){
				aux = BinH.poll();
				System.out.println(aux.getId()+" "+aux.getProblemasResueltos()+" "+aux.getTiempoPenalizado());
			}
			
			for(int i=0; i<4; i++){
				if(i==0)
					System.out.print(CITR[i]);
				else
					System.out.print(" "+CITR[i]);
			}
		}
	}
	
	public static class Concursante implements Comparable<Concursante>{
		private int id;
		private int problemasResueltos;
		private int tiempoPenalizado;	//Tiempo de penalizacion total acumulados
		private HashMap<Integer, Integer[]> penalizacionesParciales;

		public Concursante(int id) {
			super();
			this.id = id;
			this.problemasResueltos = 0;
			this.tiempoPenalizado = 0;
			this.penalizacionesParciales = new HashMap<>();
		}

		public int getId() {
			return this.id;
		}
		public int getProblemasResueltos() {
			return this.problemasResueltos;
		}
		public int getTiempoPenalizado() {
			return this.tiempoPenalizado;
		}
		public HashMap<Integer, Integer[]> getPenalizacionesParciales(){
			return this.penalizacionesParciales;
		}
		
		public void setId(int id) {
			this.id = id;
		}
		public void setProblemasResueltos(int problemasResueltos) {
			this.problemasResueltos = problemasResueltos;
		}
		public void setTiempoPenalizado(int tiempoPenalizado) {
			this.tiempoPenalizado = tiempoPenalizado;
		}
		public void setPenalizacionesParciales(HashMap<Integer, Integer[]> penalizacionesParciales){
			this.penalizacionesParciales = penalizacionesParciales;
		}

		public void sumarProblemasResueltos(int cantidad){
			this.problemasResueltos += cantidad;
		}
		public void sumarTiempoPenalizado(int cantidad){
			this.tiempoPenalizado += cantidad;
		}
		
		@Override
		public int compareTo(Concursante o) {
			if(this.problemasResueltos > o.problemasResueltos)
				return 1;
			else if(this.problemasResueltos < o.problemasResueltos)
				return -1;
			
			//	Else this.problemasResueltos == o.problemasResueltos
			if(this.tiempoPenalizado < o.tiempoPenalizado)
				return 1;
			else if(this.tiempoPenalizado > o.tiempoPenalizado)
				return -1;
			
			//	Else this.tiempoPenalizado == o.tiempoPenalizado
			if(this.id < o.id)
				return 1;
			else if(this.id > o.id)
				return -1;
			
			//	Else this.id == o.id
			return 0;
		}
		
	}

	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind) {
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ProblemaA {
	public static void main(String[] args) throws Exception {
		File f = new File("AEntrada1.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("ASalida1.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int numEquipos, numEnvios;
		HashMap<Integer, Concursante> memoria = new HashMap<>();
		int[] CITR = new int[4];
		Arrays.fill(CITR, 0);
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			memoria.clear();
			
			entrada = br.readLine().split(" ");
			numEquipos = Integer.parseInt(entrada[0]);
			numEnvios = Integer.parseInt(entrada[1]);
			
			for(int i=0; i<numEnvios; i++){
				
				entrada = br.readLine().split(" ");
				valores = new int[3];
				for(int j=0; j<3; j++)
					valores[j] = Integer.parseInt(entrada[j]);
				
				switch (entrada[3]) {
				case "C":
					CITR[0]++;
					break;
				case "I":
					CITR[1]++;
					break;
				case "T":
					CITR[2]++;
					break;
				case "R":
					CITR[3]++;
					break;
				default:
					break;
				}
				
				//	Si el concurrsante no ha subido nada
				if(!memoria.containsKey(valores[0])){
					memoria.put(valores[0], new Concursante(valores[0]));
				}
				Concursante actual = memoria.get(valores[0]);
				
				//	Si el envio fue correcto
				if(entrada[3].equalsIgnoreCase("C")){
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						//	Si no se ha completado
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2] + actual.getPenalizacionesParciales().get(valores[1])[1]});
							actual.sumarProblemasResueltos(1);
							actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2]} );
						actual.sumarProblemasResueltos(1);
						actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
					}
					
				//	Si el envio fue incorrecto
				}else{
					
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(
									valores[1], new Integer[]{0, 20 + actual.getPenalizacionesParciales().get(valores[1])[1]});
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{0, 20});
					}
				}
			}
			
			
			MyBinaryHeap<Concursante> BinH = new MyBinaryHeap<>("BinH", true);
			//	Agregar los concursantes a la cola de prioridad
			Iterator it = memoria.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				//System.out.println(e.getKey() + " " + e.getValue());
				BinH.offer((Concursante) e.getValue());
			}
			
			Concursante aux;
			//System.out.println(BinH.size);
			while(!BinH.isEmpty()){
				aux = BinH.poll();
				System.out.println(aux.getId()+" "+aux.getProblemasResueltos()+" "+aux.getTiempoPenalizado());
			}
			
			for(int i=0; i<4; i++){
				if(i==0)
					System.out.print(CITR[i]);
				else
					System.out.print(" "+CITR[i]);
			}
		}
	}
	
	public static class Concursante implements Comparable<Concursante>{
		private int id;
		private int problemasResueltos;
		private int tiempoPenalizado;	//Tiempo de penalizacion total acumulados
		private HashMap<Integer, Integer[]> penalizacionesParciales;

		public Concursante(int id) {
			super();
			this.id = id;
			this.problemasResueltos = 0;
			this.tiempoPenalizado = 0;
			this.penalizacionesParciales = new HashMap<>();
		}

		public int getId() {
			return this.id;
		}
		public int getProblemasResueltos() {
			return this.problemasResueltos;
		}
		public int getTiempoPenalizado() {
			return this.tiempoPenalizado;
		}
		public HashMap<Integer, Integer[]> getPenalizacionesParciales(){
			return this.penalizacionesParciales;
		}
		
		public void setId(int id) {
			this.id = id;
		}
		public void setProblemasResueltos(int problemasResueltos) {
			this.problemasResueltos = problemasResueltos;
		}
		public void setTiempoPenalizado(int tiempoPenalizado) {
			this.tiempoPenalizado = tiempoPenalizado;
		}
		public void setPenalizacionesParciales(HashMap<Integer, Integer[]> penalizacionesParciales){
			this.penalizacionesParciales = penalizacionesParciales;
		}

		public void sumarProblemasResueltos(int cantidad){
			this.problemasResueltos += cantidad;
		}
		public void sumarTiempoPenalizado(int cantidad){
			this.tiempoPenalizado += cantidad;
		}
		
		@Override
		public int compareTo(Concursante o) {
			if(this.problemasResueltos > o.problemasResueltos)
				return 1;
			else if(this.problemasResueltos < o.problemasResueltos)
				return -1;
			
			//	Else this.problemasResueltos == o.problemasResueltos
			if(this.tiempoPenalizado < o.tiempoPenalizado)
				return 1;
			else if(this.tiempoPenalizado > o.tiempoPenalizado)
				return -1;
			
			//	Else this.tiempoPenalizado == o.tiempoPenalizado
			if(this.id < o.id)
				return 1;
			else if(this.id > o.id)
				return -1;
			
			//	Else this.id == o.id
			return 0;
		}
		
	}

	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind) {
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ProblemaA {
	public static void main(String[] args) throws Exception {
		File f = new File("AEntrada1.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("ASalida1.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int numEquipos, numEnvios;
		HashMap<Integer, Concursante> memoria = new HashMap<>();
		int[] CITR = new int[4];
		Arrays.fill(CITR, 0);
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			memoria.clear();
			
			entrada = br.readLine().split(" ");
			numEquipos = Integer.parseInt(entrada[0]);
			numEnvios = Integer.parseInt(entrada[1]);
			
			for(int i=0; i<numEnvios; i++){
				
				entrada = br.readLine().split(" ");
				valores = new int[3];
				for(int j=0; j<3; j++)
					valores[j] = Integer.parseInt(entrada[j]);
				
				switch (entrada[3]) {
				case "C":
					CITR[0]++;
					break;
				case "I":
					CITR[1]++;
					break;
				case "T":
					CITR[2]++;
					break;
				case "R":
					CITR[3]++;
					break;
				default:
					break;
				}
				
				//	Si el concurrsante no ha subido nada
				if(!memoria.containsKey(valores[0])){
					memoria.put(valores[0], new Concursante(valores[0]));
				}
				Concursante actual = memoria.get(valores[0]);
				
				//	Si el envio fue correcto
				if(entrada[3].equalsIgnoreCase("C")){
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						//	Si no se ha completado
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2] + actual.getPenalizacionesParciales().get(valores[1])[1]});
							actual.sumarProblemasResueltos(1);
							actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2]} );
						actual.sumarProblemasResueltos(1);
						actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
					}
					
				//	Si el envio fue incorrecto
				}else{
					
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(
									valores[1], new Integer[]{0, 20 + actual.getPenalizacionesParciales().get(valores[1])[1]});
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{0, 20});
					}
				}
			}
			
			
			MyBinaryHeap<Concursante> BinH = new MyBinaryHeap<>("BinH", true);
			//	Agregar los concursantes a la cola de prioridad
			Iterator it = memoria.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				//System.out.println(e.getKey() + " " + e.getValue());
				BinH.offer((Concursante) e.getValue());
			}
			
			Concursante aux;
			//System.out.println(BinH.size);
			while(!BinH.isEmpty()){
				aux = BinH.poll();
				System.out.println(aux.getId()+" "+aux.getProblemasResueltos()+" "+aux.getTiempoPenalizado());
			}
			
			for(int i=0; i<4; i++){
				if(i==0)
					System.out.print(CITR[i]);
				else
					System.out.print(" "+CITR[i]);
			}
			System.out.println();
		}
	}
	
	public static class Concursante implements Comparable<Concursante>{
		private int id;
		private int problemasResueltos;
		private int tiempoPenalizado;	//Tiempo de penalizacion total acumulados
		private HashMap<Integer, Integer[]> penalizacionesParciales;

		public Concursante(int id) {
			super();
			this.id = id;
			this.problemasResueltos = 0;
			this.tiempoPenalizado = 0;
			this.penalizacionesParciales = new HashMap<>();
		}

		public int getId() {
			return this.id;
		}
		public int getProblemasResueltos() {
			return this.problemasResueltos;
		}
		public int getTiempoPenalizado() {
			return this.tiempoPenalizado;
		}
		public HashMap<Integer, Integer[]> getPenalizacionesParciales(){
			return this.penalizacionesParciales;
		}
		
		public void setId(int id) {
			this.id = id;
		}
		public void setProblemasResueltos(int problemasResueltos) {
			this.problemasResueltos = problemasResueltos;
		}
		public void setTiempoPenalizado(int tiempoPenalizado) {
			this.tiempoPenalizado = tiempoPenalizado;
		}
		public void setPenalizacionesParciales(HashMap<Integer, Integer[]> penalizacionesParciales){
			this.penalizacionesParciales = penalizacionesParciales;
		}

		public void sumarProblemasResueltos(int cantidad){
			this.problemasResueltos += cantidad;
		}
		public void sumarTiempoPenalizado(int cantidad){
			this.tiempoPenalizado += cantidad;
		}
		
		@Override
		public int compareTo(Concursante o) {
			if(this.problemasResueltos > o.problemasResueltos)
				return 1;
			else if(this.problemasResueltos < o.problemasResueltos)
				return -1;
			
			//	Else this.problemasResueltos == o.problemasResueltos
			if(this.tiempoPenalizado < o.tiempoPenalizado)
				return 1;
			else if(this.tiempoPenalizado > o.tiempoPenalizado)
				return -1;
			
			//	Else this.tiempoPenalizado == o.tiempoPenalizado
			if(this.id < o.id)
				return 1;
			else if(this.id > o.id)
				return -1;
			
			//	Else this.id == o.id
			return 0;
		}
		
	}

	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind) {
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ProblemaA {
	public static void main(String[] args) throws Exception {
		File f = new File("AEntrada1.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("ASalida1.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int numEquipos, numEnvios;
		HashMap<Integer, Concursante> memoria = new HashMap<>();
		int[] CITR = new int[4];
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			memoria.clear();

			Arrays.fill(CITR, 0);
			
			entrada = br.readLine().split(" ");
			numEquipos = Integer.parseInt(entrada[0]);
			numEnvios = Integer.parseInt(entrada[1]);
			
			for(int i=0; i<numEnvios; i++){
				
				entrada = br.readLine().split(" ");
				valores = new int[3];
				for(int j=0; j<3; j++)
					valores[j] = Integer.parseInt(entrada[j]);
				
				switch (entrada[3]) {
				case "C":
					CITR[0]++;
					break;
				case "I":
					CITR[1]++;
					break;
				case "T":
					CITR[2]++;
					break;
				case "R":
					CITR[3]++;
					break;
				default:
					break;
				}
				
				//	Si el concurrsante no ha subido nada
				if(!memoria.containsKey(valores[0])){
					memoria.put(valores[0], new Concursante(valores[0]));
				}
				Concursante actual = memoria.get(valores[0]);
				
				//	Si el envio fue correcto
				if(entrada[3].equalsIgnoreCase("C")){
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						//	Si no se ha completado
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2] + actual.getPenalizacionesParciales().get(valores[1])[1]});
							actual.sumarProblemasResueltos(1);
							actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2]} );
						actual.sumarProblemasResueltos(1);
						actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
					}
					
				//	Si el envio fue incorrecto
				}else{
					
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(
									valores[1], new Integer[]{0, 20 + actual.getPenalizacionesParciales().get(valores[1])[1]});
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{0, 20});
					}
				}
			}
			
			
			MyBinaryHeap<Concursante> BinH = new MyBinaryHeap<>("BinH", true);
			//	Agregar los concursantes a la cola de prioridad
			Iterator it = memoria.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				//System.out.println(e.getKey() + " " + e.getValue());
				BinH.offer((Concursante) e.getValue());
			}
			
			Concursante aux;
			//System.out.println(BinH.size);
			while(!BinH.isEmpty()){
				aux = BinH.poll();
				System.out.println(aux.getId()+" "+aux.getProblemasResueltos()+" "+aux.getTiempoPenalizado());
			}
			
			for(int i=0; i<4; i++){
				if(i==0)
					System.out.print(CITR[i]);
				else
					System.out.print(" "+CITR[i]);
			}
			System.out.println();
		}
	}
	
	public static class Concursante implements Comparable<Concursante>{
		private int id;
		private int problemasResueltos;
		private int tiempoPenalizado;	//Tiempo de penalizacion total acumulados
		private HashMap<Integer, Integer[]> penalizacionesParciales;

		public Concursante(int id) {
			super();
			this.id = id;
			this.problemasResueltos = 0;
			this.tiempoPenalizado = 0;
			this.penalizacionesParciales = new HashMap<>();
		}

		public int getId() {
			return this.id;
		}
		public int getProblemasResueltos() {
			return this.problemasResueltos;
		}
		public int getTiempoPenalizado() {
			return this.tiempoPenalizado;
		}
		public HashMap<Integer, Integer[]> getPenalizacionesParciales(){
			return this.penalizacionesParciales;
		}
		
		public void setId(int id) {
			this.id = id;
		}
		public void setProblemasResueltos(int problemasResueltos) {
			this.problemasResueltos = problemasResueltos;
		}
		public void setTiempoPenalizado(int tiempoPenalizado) {
			this.tiempoPenalizado = tiempoPenalizado;
		}
		public void setPenalizacionesParciales(HashMap<Integer, Integer[]> penalizacionesParciales){
			this.penalizacionesParciales = penalizacionesParciales;
		}

		public void sumarProblemasResueltos(int cantidad){
			this.problemasResueltos += cantidad;
		}
		public void sumarTiempoPenalizado(int cantidad){
			this.tiempoPenalizado += cantidad;
		}
		
		@Override
		public int compareTo(Concursante o) {
			if(this.problemasResueltos > o.problemasResueltos)
				return 1;
			else if(this.problemasResueltos < o.problemasResueltos)
				return -1;
			
			//	Else this.problemasResueltos == o.problemasResueltos
			if(this.tiempoPenalizado < o.tiempoPenalizado)
				return 1;
			else if(this.tiempoPenalizado > o.tiempoPenalizado)
				return -1;
			
			//	Else this.tiempoPenalizado == o.tiempoPenalizado
			if(this.id < o.id)
				return 1;
			else if(this.id > o.id)
				return -1;
			
			//	Else this.id == o.id
			return 0;
		}
		
	}

	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind) {
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.NoSuchElementException;

public class ProblemaA {
	public static void main(String[] args) throws Exception {
		File f = new File("AEntrada1.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("ASalida1.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int numEquipos, numEnvios;
		HashMap<Integer, Concursante> memoria = new HashMap<>();
		int[] CITR = new int[4];
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			memoria.clear();

			Arrays.fill(CITR, 0);
			
			entrada = br.readLine().split(" ");
			numEquipos = Integer.parseInt(entrada[0]);
			numEnvios = Integer.parseInt(entrada[1]);
			
			for(int i=0; i<numEnvios; i++){
				
				entrada = br.readLine().split(" ");
				valores = new int[3];
				for(int j=0; j<3; j++)
					valores[j] = Integer.parseInt(entrada[j]);
				
				switch (entrada[3]) {
				case "C":
					CITR[0]++;
					break;
				case "I":
					CITR[1]++;
					break;
				case "T":
					CITR[2]++;
					break;
				case "R":
					CITR[3]++;
					break;
				default:
					break;
				}
				
				//	Si el concurrsante no ha subido nada
				if(!memoria.containsKey(valores[0])){
					memoria.put(valores[0], new Concursante(valores[0]));
				}
				Concursante actual = memoria.get(valores[0]);
				
				//	Si el envio fue correcto
				if(entrada[3].equalsIgnoreCase("C")){
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						//	Si no se ha completado
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2] + actual.getPenalizacionesParciales().get(valores[1])[1]});
							actual.sumarProblemasResueltos(1);
							actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{1, valores[2]} );
						actual.sumarProblemasResueltos(1);
						actual.sumarTiempoPenalizado(actual.getPenalizacionesParciales().get(valores[1])[1]);
					}
					
				//	Si el envio fue incorrecto
				}else{
					
					//	Si el problema ya tiene historial
					if(actual.getPenalizacionesParciales().containsKey(valores[1])){
						if(actual.getPenalizacionesParciales().get(valores[1])[0] == 0){
							actual.getPenalizacionesParciales().put(
									valores[1], new Integer[]{0, 20 + actual.getPenalizacionesParciales().get(valores[1])[1]});
						}
					}else{
						actual.getPenalizacionesParciales().put(valores[1], new Integer[]{0, 20});
					}
				}
			}
			
			
			MyBinaryHeap<Concursante> BinH = new MyBinaryHeap<>("BinH", true);
			//	Agregar los concursantes a la cola de prioridad
			Iterator it = memoria.entrySet().iterator();
			while (it.hasNext()) {
				Map.Entry e = (Map.Entry)it.next();
				//System.out.println(e.getKey() + " " + e.getValue());
				BinH.offer((Concursante) e.getValue());
			}
			
			Concursante aux;
			//System.out.println(BinH.size);
			while(!BinH.isEmpty()){
				aux = BinH.poll();
				System.out.println(aux.getId()+" "+aux.getProblemasResueltos()+" "+aux.getTiempoPenalizado());
			}
			
			for(int i=0; i<4; i++){
				if(i==0)
					System.out.print(CITR[i]);
				else
					System.out.print(" "+CITR[i]);
			}
			System.out.println();
		}
	}
	
	public static class Concursante implements Comparable<Concursante>{
		private int id;
		private int problemasResueltos;
		private int tiempoPenalizado;	//Tiempo de penalizacion total acumulados
		private HashMap<Integer, Integer[]> penalizacionesParciales;

		public Concursante(int id) {
			super();
			this.id = id;
			this.problemasResueltos = 0;
			this.tiempoPenalizado = 0;
			this.penalizacionesParciales = new HashMap<>();
		}

		public int getId() {
			return this.id;
		}
		public int getProblemasResueltos() {
			return this.problemasResueltos;
		}
		public int getTiempoPenalizado() {
			return this.tiempoPenalizado;
		}
		public HashMap<Integer, Integer[]> getPenalizacionesParciales(){
			return this.penalizacionesParciales;
		}
		
		public void setId(int id) {
			this.id = id;
		}
		public void setProblemasResueltos(int problemasResueltos) {
			this.problemasResueltos = problemasResueltos;
		}
		public void setTiempoPenalizado(int tiempoPenalizado) {
			this.tiempoPenalizado = tiempoPenalizado;
		}
		public void setPenalizacionesParciales(HashMap<Integer, Integer[]> penalizacionesParciales){
			this.penalizacionesParciales = penalizacionesParciales;
		}

		public void sumarProblemasResueltos(int cantidad){
			this.problemasResueltos += cantidad;
		}
		public void sumarTiempoPenalizado(int cantidad){
			this.tiempoPenalizado += cantidad;
		}
		
		@Override
		public int compareTo(Concursante o) {
			if(this.problemasResueltos > o.problemasResueltos)
				return 1;
			else if(this.problemasResueltos < o.problemasResueltos)
				return -1;
			
			//	Else this.problemasResueltos == o.problemasResueltos
			if(this.tiempoPenalizado < o.tiempoPenalizado)
				return 1;
			else if(this.tiempoPenalizado > o.tiempoPenalizado)
				return -1;
			
			//	Else this.tiempoPenalizado == o.tiempoPenalizado
			if(this.id < o.id)
				return 1;
			else if(this.id > o.id)
				return -1;
			
			//	Else this.id == o.id
			return 0;
		}
		
	}

	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind) {
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

public class ProblemaD {

	public static void main(String[] args) throws NumberFormatException, IOException {
		File f = new File("DEntrada2.txt");
		Scanner s = null;
		BufferedReader br = null;
		if(f.exists()){
			s = new Scanner(f);
			br = new BufferedReader(new FileReader(f));
			System.setOut(new PrintStream(new File("DSalida2.txt")));
		}else{
			s = new Scanner(System.in);
			br = new BufferedReader(new InputStreamReader(System.in));
		}
		
		int casos = Integer.parseInt(br.readLine().split(" ")[0]);
		String[] entrada;
		int[] valores;
		int cantPersonas, cantOperaciones;
		MyUnionFind2 UnionFind;
		
		for(int t=1; t<=casos; t++){
			System.out.println("Caso #"+t+":");
			
			entrada = br.readLine().split(" ");
			cantPersonas = Integer.parseInt(entrada[0]);
			cantOperaciones = Integer.parseInt(entrada[1]);
			
			UnionFind = new MyUnionFind2(cantPersonas);
			
			//	leer operaciones
			for(int k=0; k<cantOperaciones; k++){
				entrada = br.readLine().split(" ");
				valores = new int[3];
				for(int i=0; i<3; i++)
					valores[i] = Integer.parseInt(entrada[i]);
				
				switch (valores[0]) {
				case 1:
					if(UnionFind.getEnemies(valores[1], valores[2]))
						System.out.println(-1);
					else
						UnionFind.union(valores[1], valores[2]);
					break;
				case 2:
					if(valores[1] == valores[2] || UnionFind.atSameSet(valores[1], valores[2]))
						System.out.println(-1);
					else
						UnionFind.setEnemies(valores[1], valores[2]);
					break;
				case 3:
					if(UnionFind.atSameSet(valores[1], valores[2]))
						System.out.println(1);
					else
						System.out.println(0);
					break;
				case 4:
					if(UnionFind.getEnemies(valores[1], valores[2]))
						System.out.println(1);
					else
						System.out.println(0);
					break;

				default:
					break;
				}
			}
					
		}
	}
	
	
	public static class MyUnionFind2 {
		int[] friend;		//Array of roots y rank; ???
		int[] enemy;
		int[] sizeSet;		//# elements in the Set[i];
		int sets;			//# sets;
		
		public MyUnionFind2(int size){
			this.friend = new int[size];
			this.enemy = new int[size];
			this.sizeSet = new int[size];
			
			Arrays.fill(this.friend, -1);
			Arrays.fill(this.enemy, -1);
			Arrays.fill(this.sizeSet, 1);
			this.sets = size;
		}
		
		public int sets(){
			return this.sets;
		}
		
		public boolean atSameSet(int element1, int element2){
			return this.findSet(element1) == findSet(element2);
		}
		
		public int sizeOfSet(int element1){
			return this.sizeSet[findSet(element1)];
		}
		
		public int findSet(int element){
			if(this.friend[element] < 0)
				return element;
			else
				return this.friend[element] = findSet(this.friend[element]);
		}
		
		public void union(int element1, int element2){
			if(!this.atSameSet(element1, element2)){
				this.sets--;
				int root_element1 = findSet(element1);
				int root_element2 = findSet(element2);
				
				if(this.friend[root_element1] < this.friend[root_element2]){
					this.friend[root_element2] = root_element1;
					this.sizeSet[root_element1] += this.sizeSet[root_element2];
				}else{
					if(this.friend[root_element1] == this.friend[root_element2])
						this.friend[root_element2]--;
					
					this.friend[root_element1] = root_element2;
					this.sizeSet[root_element2] += this.sizeSet[root_element1];
				}
				
			}
		}
		
		public void setEnemies(int element1, int element2){
			if(this.enemy[element1] == -1)
				this.enemy[element1] = element2;
			else if(this.enemy[element1] != this.findSet(element2)){
				this.union(this.enemy[element1], element2); 
				for(int i=0; i<this.enemy.length; i++){
					if(this.enemy[i] != -1)
						this.enemy[i] = this.findSet(this.enemy[i]);
				}
			}
			
			if(this.enemy[element2] == -1)
				this.enemy[element2] = element1;
			else if(this.enemy[element2] != this.findSet(element1)){
				this.union(this.enemy[element2], element1);
				for(int i=0; i<this.enemy.length; i++){
					if(this.enemy[i] != -1)
						this.enemy[i] = this.findSet(this.enemy[i]);
				}
			}
			
			this.enemy[this.findSet(element1)] = this.findSet(element2);
			this.enemy[this.findSet(element2)] = this.findSet(element1);
		}
		
		public boolean getEnemies(int element1, int element2){
			return this.enemy[element1] == this.findSet(element2) || this.enemy[element2] == this.findSet(element1);
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashSet;
import java.util.Scanner;


public class problemaA {
	public static void main(String[] args) throws FileNotFoundException{
		File f = new File("AEntrada1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
			System.setOut(new PrintStream(new File("ASalida1.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		MyQueueSingleLinkedList<Integer> miCola = new MyQueueSingleLinkedList<>();
		HashSet<Integer> miHashSet = new HashSet<>();
		
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 1; t <= n; t++) {
			System.out.println("Caso #"+t+":");
			miCola.clear();
			miHashSet.clear();
			
			int Q = Integer.parseInt(scan.nextLine());// numero de consultas
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que
															// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					miCola.enqueue(Integer.parseInt(line[1]));
				} else if (type.equals("atender")) {
					miHashSet.add(miCola.dequeue());
				} else if (type.equals("existe")) {
					if(miHashSet.contains(Integer.parseInt(line[1])))
						System.out.println("SI");
					else
						System.out.println("NO");
				}
	
			}
		}
	}
	public static class MyQueueSingleLinkedList<AnyType>{
	    public MyQueueSingleLinkedList( )
	    {
	        clear( );
	    }
	    
	    public void clear( )
	    {
	        beginMarker = new Node<>( null, null );
	        endNode = beginMarker;
	        theSize = 0;
	    }
	    
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    public boolean enqueue (AnyType x){
	        Node<AnyType> newNode = new Node<>( x, null );
	        endNode.next = newNode;
	        endNode = newNode;
	        theSize++;
	        return true;
	    }
	    
	    public AnyType dequeue (){
	    	if(beginMarker.next == endNode){ 
	    		endNode = beginMarker;
	    	}
	    	AnyType data = beginMarker.next.data;
	    	beginMarker.next = beginMarker.next.next;
	        theSize--;
	        
	        return data;
	    }
	    
	    public AnyType peek(){
	    	return beginMarker.next.data;
	    }
	    
	    public void print(){
	    	for(int i=0; i<theSize; i++){
	    		AnyType item = dequeue();
	    		System.out.println(item);
	    		enqueue(item);
	    	}
	    }
	    
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> n )
	        {
	            data = d; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType> next;
	    }
	    
	    private int theSize;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endNode;
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.NoSuchElementException;
import java.util.Scanner;


public class problemaB {
	public static void main(String[] args) throws FileNotFoundException{
		File f = new File("BEntrada1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
			System.setOut(new PrintStream(new File("BSalida1.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		MyQueueSingleLinkedList<Integer> miCola = new MyQueueSingleLinkedList<>();
		HashMap<Integer, Integer> myHashMap = new HashMap<>();
		MyBinaryHeap<Integer> puestos = new MyBinaryHeap<>("puestos", false);
		
		String[] line;
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 1; t <= n; t++) {
			System.out.println("Caso #"+t+":");
			miCola.clear();
			myHashMap.clear();
			puestos.clear();
			
			line = scan.nextLine().split(" ");
			int Q = Integer.parseInt(line[0]);
			int N = Integer.parseInt(line[1]);
			for(int i=0; i<N; i++)
				puestos.offer(i);
			
			for (int i = 0; i < Q; i++) {
				line = scan.nextLine().split(" ");// linea para ver que
															// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					miCola.enqueue(Integer.parseInt(line[1]));
				} else if (type.equals("atender")) {
					myHashMap.put(miCola.dequeue(), puestos.poll());
				} else if (type.equals("existe")) {
					if(myHashMap.containsKey(Integer.parseInt(line[1])))
						System.out.println("SI "+myHashMap.get(Integer.parseInt(line[1])));
					else
						System.out.println("NO");
				} else if (type.equals("salir")) {
					puestos.offer(myHashMap.remove(Integer.parseInt(line[1])));
				}
	
			}
		}
	}
	
	
	public static class MyQueueSingleLinkedList<AnyType>{
	    public MyQueueSingleLinkedList( )
	    {
	        clear( );
	    }
	    
	    public void clear( )
	    {
	        beginMarker = new Node<>( null, null );
	        endNode = beginMarker;
	        theSize = 0;
	    }
	    
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    public boolean enqueue (AnyType x){
	        Node<AnyType> newNode = new Node<>( x, null );
	        endNode.next = newNode;
	        endNode = newNode;
	        theSize++;
	        return true;
	    }
	    
	    public AnyType dequeue (){
	    	if(beginMarker.next == endNode){ 
	    		endNode = beginMarker;
	    	}
	    	AnyType data = beginMarker.next.data;
	    	beginMarker.next = beginMarker.next.next;
	        theSize--;
	        
	        return data;
	    }
	    
	    public AnyType peek(){
	    	return beginMarker.next.data;
	    }
	    
	    public void print(){
	    	for(int i=0; i<theSize; i++){
	    		AnyType item = dequeue();
	    		System.out.println(item);
	    		enqueue(item);
	    	}
	    }
	    
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> n )
	        {
	            data = d; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType> next;
	    }
	    
	    private int theSize;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endNode;
	}
	
	public static class MyBinaryHeap<Type extends Comparable<Type>> {
	    
	    private final String Name;
	    private Type[] Items; 
	    private final boolean Kind; // True for Max, False for Min
	    private int Size;
	
	    public MyBinaryHeap(String Name, boolean Kind){
	        this.Name = Name;
	        this.Kind = Kind;
	        this.Size = 1;
	        this.Items = (Type[]) new Comparable[10];
	    }
	
	    public void clear(){
	        this.Size = 1;
	    }
	
	    public boolean isEmpty(){
	        return this.Size == 1;
	    }
	    
	    public int size(){
	        return this.Size-1;
	    }
	    
	    private void ensureCapacity(int NewSize){
	        Type[] Old = this.Items;
	        this.Items = (Type[]) new Comparable[NewSize];
	        System.arraycopy(Old, 0, this.Items, 0, Old.length); 
	    }
	    
	    public Type peek(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
	        return this.Items[1];
	    }
	
	    public void offer(Type New){
	        if(this.Size == this.Items.length)
	            this.ensureCapacity(this.Size * 2 + 1);
	        this.Items[this.Size] = New;
	        if(this.Kind)
	            this.UpperSortMax(this.Size++);
	        else
	            this.UpperSortMin(this.Size++);
	    }
	
	    public Type poll(){
	        if(this.Size == 1)
	            throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
	        Type Aux = this.Items[1];
	        this.Items[1] = this.Items[--this.Size];
	        if(this.Kind)
	            this.LowerSortMax(1);
	        else
	            this.LowerSortMin(1); 
	        return Aux;
	    }
	
	    private void LowerSortMax(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Max < 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMax(Current*2+1); 
	            }
	        }else {
	            if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMax(Current*2); 
	            }
	        }
	    }
	
	    private void LowerSortMin(int Current){
	        if(Current*2+1 > this.Size)
	            return ;
	        Type Aux;
	        int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
	        if(Min > 0){
	            if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2+1];
	                this.Items[Current*2+1] = Aux;
	                this.LowerSortMin(Current*2+1); 
	            }
	        }else{
	            if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
	                Aux = this.Items[Current];
	                this.Items[Current] = this.Items[Current*2];
	                this.Items[Current*2] = Aux;
	                this.LowerSortMin(Current*2); 
	            }
	        }
	    }
	
	    private void UpperSortMax(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMax(Current/2); 
	        }
	    }
	
	    private void UpperSortMin(int Current){
	        if(Current <= 1)
	            return ;
	        Type Aux = null;
	        if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
	            Aux = this.Items[Current/2];
	            this.Items[Current/2] = this.Items[Current];
	            this.Items[Current] = Aux;
	            this.UpperSortMin(Current/2); 
	        }
	    }
	
	    @Override
	    public String toString() {
	        StringBuilder Aux = new StringBuilder(this.Name+": [ ");
	        for (int i = 1; i < this.Size; i++) {
	            Aux.append(this.Items[i].toString()).append(" ");
	        }
	        Aux.append("]");
	        return Aux.toString();
	    }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Scanner;

public class ProblemaA {
    public static void main(String[] args) throws FileNotFoundException {
        File inputFile = new File("A_2.txt");
        File outputFile = new File("ASalida2.txt");
        BufferedReader buffReader = null;
        Scanner scan = null;
        if(inputFile.exists()){
            buffReader = new BufferedReader(new FileReader(inputFile));
            scan = new Scanner(inputFile);
            System.setOut(new PrintStream(outputFile));
        }else{
            buffReader = new BufferedReader(new InputStreamReader(System.in));
            scan = new Scanner(new InputStreamReader(System.in));
        }
        
        int casos = Integer.parseInt(scan.nextLine());
        int N;
        HashMap<Character, Vertex> allVertex = new HashMap<>();
        char[][] operations;
        
        for (int t = 1; t <= casos; t++) {
            allVertex.clear();            
            System.out.println("Caso #"+t+":");
            
            N = Integer.parseInt(scan.nextLine().split(" ")[0]);
            allVertex = makeAllVertexAlVertex(N, scan.nextLine());
            operations = makeOperations(scan.nextLine());
            
            for(int i=0; i<operations.length; i++){
                char menor = '.', mayor = '.';
                
                boolean repeated = false;
                if(operations[i][1] == '<'){
                    menor = operations[i][0];
                    mayor = operations[i][2];
                }else if(operations[i][1] == '>'){
                    menor = operations[i][2];
                    mayor = operations[i][0];
                }
                
                allVertex.get(mayor).increaseInDegree();
                allVertex.get(menor).getAdjacent().add(allVertex.get(mayor));
            }
            topSort(N, allVertex);
        }
    }

    public static HashMap<Character, Vertex> makeAllVertexAlVertex(int size, String entrada){
        String[] strings = entrada.split(" ");
        HashMap<Character, Vertex> allVertex = new HashMap<>();
        for(int i=0; i<size; i++)
            allVertex.put(strings[i].charAt(0), new Vertex(strings[i].charAt(0)));
        return allVertex;
    }
    
    public static char[][] makeOperations(String input){
        String[] strings = input.split(" ");
        char[][] characters = new char[strings.length][3];
        for(int i=0; i<strings.length; i++){
            characters[i][0] = strings[i].charAt(0);
            characters[i][1] = strings[i].charAt(1);
            characters[i][2] = strings[i].charAt(2);
        }
        return characters;
    }
    
    public static void topSort(int size, HashMap<Character, Vertex> allVertex){
        MyBinaryHeap<Vertex> binHeap = new MyBinaryHeap<>("binHeap", false);
        Vertex currentVertex = null;
        StringBuilder sb = new StringBuilder();
        int counter = 0;
        
        for(Map.Entry<Character, Vertex> entry : allVertex.entrySet())
            if(entry.getValue().getInDegree() == 0)
                binHeap.offer(entry.getValue());
        
        while(!binHeap.isEmpty()){
            currentVertex = binHeap.poll();
            counter++;
            sb.append(" "+currentVertex.getValue());
            for(Vertex adjacentVertex : currentVertex.getAdjacent()){
                adjacentVertex.decreaseInDegree();
                if(adjacentVertex.getInDegree() == 0)
                    binHeap.offer(adjacentVertex);
            }
        }
        if(counter != size){
            System.out.println("NO");
        }else{
            sb.deleteCharAt(0);
            System.out.println(sb.toString());
        }
    }
    
    private static class Vertex implements Comparable<Vertex>{
        private char value;
        private int inDegree;
        private LinkedList<Vertex> adjacent;
        
        public Vertex(char value){
            this.value = value;
            this.inDegree = 0;
            this.adjacent = new LinkedList<>();
        }
        
        public char getValue(){
            return this.value;
        }
        public int getInDegree(){
            return this.inDegree;
        }
        public LinkedList<Vertex> getAdjacent(){
            return this.adjacent;
        }
        
        public void setValue(char value){
            this.value = value;
        }
        public void setInDegree(int inDegree){
            this.inDegree = inDegree;
        }
        public void setAdjacent(LinkedList<Vertex> adjacent){
            this.adjacent = adjacent;
        }
        
        public void increaseInDegree(){
            this.inDegree++;
        }
        public void decreaseInDegree(){
            this.inDegree--;
        }

        @Override
        public int compareTo(Vertex o) {
            if(this.value > o.value)
                return 1;
            if(this.value < o.value)
                return -1;
            return 0;
        }
    }
    
    public static class MyBinaryHeap<Type extends Comparable<Type>> {
        
        private final String Name;
        private Type[] Items; 
        private final boolean Kind; // True for Max, False for Min
        private int Size;

        public MyBinaryHeap(String Name, boolean Kind){
            this.Name = Name;
            this.Kind = Kind;
            this.Size = 1;
            this.Items = (Type[]) new Comparable[10];
        }

        public void clear(){
            this.Size = 1;
        }

        public boolean isEmpty(){
            return this.Size == 1;
        }

        public int size(){
            return this.Size-1;
        }

        private void ensureCapacity(int NewSize){
            Type[] Old = this.Items;
            this.Items = (Type[]) new Comparable[NewSize];
            System.arraycopy(Old, 0, this.Items, 0, Old.length); 
        }

        public Type peek(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
            return this.Items[1];
        }

        public void offer(Type New){
            if(this.Size == this.Items.length)
                this.ensureCapacity(this.Size * 2 + 1);
            this.Items[this.Size] = New;
            if(this.Kind)
                this.UpperSortMax(this.Size++);
            else
                this.UpperSortMin(this.Size++);
        }

        public Type poll(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
            Type Aux = this.Items[1];
            this.Items[1] = this.Items[--this.Size];
            if(this.Kind)
                this.LowerSortMax(1);
            else
                this.LowerSortMin(1); 
            return Aux;
        }

        private void LowerSortMax(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Max < 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMax(Current*2+1); 
                }
            }else {
                if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMax(Current*2); 
                }
            }
        }

        private void LowerSortMin(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Min > 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMin(Current*2+1); 
                }
            }else{
                if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMin(Current*2); 
                }
            }
        }

        private void UpperSortMax(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMax(Current/2); 
            }
        }

        private void UpperSortMin(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMin(Current/2); 
            }
        }

        @Override
        public String toString() {
            StringBuilder Aux = new StringBuilder(this.Name+": [ ");
            for (int i = 1; i < this.Size; i++) {
                Aux.append(this.Items[i].toString()).append(" ");
            }
            Aux.append("]");
            return Aux.toString();
        }
    }
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.*;
import java.util.Arrays;
import java.util.Scanner;

public class Proyecto08B {
    public static void main(String[] args) throws FileNotFoundException {
        File inputFile = new File("BEntrada2.txt");
        File outputFile = new File("BSalida2.txt");
        Scanner scan = null;
        BufferedReader buffReader = null;
        if(inputFile.exists()){
            scan = new Scanner(inputFile);
            buffReader = new BufferedReader(new FileReader(inputFile));
            System.setOut(new PrintStream(outputFile));
        }else{
            scan = new Scanner(new InputStreamReader(System.in));
            buffReader = new BufferedReader(new InputStreamReader(System.in));
        }
        
        int casos = Integer.parseInt(scan.nextLine().split(" ")[0]);
        String[] strings;
        int N, M, A, B; //  Datos de entrada para cada caso
        int i, j, value;    //  Valores de conexion entre dos vertices
        HashMap<Integer, Vertex> allVertexs = new HashMap<>();  //  Todos los vertices de cada caso
        
        for(int t=1; t<=casos; t++){
            allVertexs.clear();
            
            System.out.println("Caso #"+t+":");
            
            //  Recibir los datos de entrada
            strings = scan.nextLine().split(" ");
            N = Integer.parseInt(strings[0]);
            M = Integer.parseInt(strings[1]);
            A = Integer.parseInt(strings[2]);
            B = Integer.parseInt(strings[3]);
            
            //  Crear todos los vertices (Nota: inicialmente todos los vertices quedan con distancia cero)
            for(int n=0; n<N; n++){
                allVertexs.put(n, new Vertex(n, false)); //  Identificador, bandera de estado
            }
            
            //  Inicializacion de las aristas
            for(int m=0; m<M; m++){
                //  Lectura de conexion
                strings = scan.nextLine().split(" ");
                i = Integer.parseInt(strings[0]);   //  Vertice incial
                j = Integer.parseInt(strings[1]);   //  Vertice final
                value = Integer.parseInt(strings[2]);   //  Peso del arco
                
                //  Los vertices se agregan mutuamente a la lista de adyacencia del otro
                allVertexs.get(i).getAdjacencyList().add(allVertexs.get(j));
                allVertexs.get(j).getAdjacencyList().add(allVertexs.get(i));
                
                //  Ingreso (en ambos sentidos) de pesos
                allVertexs.get(i).getEdges().put(allVertexs.get(j), value);
                allVertexs.get(j).getEdges().put(allVertexs.get(i), value);
                
            }
            
            //  Calcular distancias desde el vertice A
            calculateDistances(allVertexs.get(A), allVertexs);
            
            //  Si el calculo de distancias alcanzo al vertice B
            if(allVertexs.get(B).getDistance() > 0)
                System.out.println(allVertexs.get(B).getDistance());
            else
                System.out.println("Inalcanzable");
        }
    }
    
    public static void calculateDistances(Vertex currentVertex, HashMap<Integer, Vertex> allVertexs){
        currentVertex.setKnow(true);
        
        //  Se crea una cola de prioridad para que empiece a recorrer desde los vertices adyacentes que tengan menor distancia
        MyBinaryHeap<Vertex> auxiliarHeap = new MyBinaryHeap<>("auxiliarHeap", false);  //  Cola de prioridad para MINIMOS
        int newDistance = 0;
        //  Se recorre la lista de adyacencia del vertice actual
        for(Vertex adjacentVertex : currentVertex.getAdjacencyList()){
            //  posible nueva distancia igual al valor de la distancia del vertice actual mas el peso del arco
            newDistance = currentVertex.getDistance() + currentVertex.getEdges().get(adjacentVertex);
            
            //  La siguiente condicion es verdadera en dos casos
            //  caso 1: El vertice adjacente no es conocido
            //  caso 2: El vertice adjacente si es conocido pero la distancia encontrada es menor a la que tenia
            if(!adjacentVertex.getKnow() || newDistance < adjacentVertex.getDistance()){
                adjacentVertex.setKnow(true);               //  Esta linea es redundante solo en el caso de que ya se conozca al vertice adyacente
                adjacentVertex.setDistance(newDistance);    //  Se le actualiza la distancia mas corta siempre
                auxiliarHeap.offer(adjacentVertex);         //  Se agrega a la cola de prioridad
            }
        }
        
        //  Vacia la cola de prioridad de los vertices adyacentes
        while(!auxiliarHeap.isEmpty())
            calculateDistances(auxiliarHeap.poll(), allVertexs);
            //  Desencola el vertice con distancia minima y calcula distancias a partir de este
    }
    
    public static class Vertex implements Comparable<Vertex>{
        
        private int id;
        private int distance;
        private boolean know;
        private MyArrayList<Vertex> adjacencyList;
        private HashMap<Vertex, Integer> edges;
        
        public Vertex(int id, boolean know){
            this.id = id;
            this.distance = 0;
            this.know = know;
            this.adjacencyList = new MyArrayList<>();
            this.edges = new HashMap<>();
        }
        public int getId(){
            return this.id;
        }
        public boolean getKnow(){
            return this.know;
        }
        public int getDistance(){
            return this.distance;
        }
        public MyArrayList<Vertex> getAdjacencyList(){
            return this.adjacencyList;
        }
        public HashMap<Vertex, Integer> getEdges(){
            return this.edges;
        }
        public void setId(int id){
            this.id = id;
        }
        public void setKnow(boolean know){
            this.know = know;
        }
        public void setDistance(int distance){
            this.distance = distance;
        }
        public void setAdjacencyList(MyArrayList<Vertex> adjacencyList){
            this.adjacencyList = adjacencyList;
        }
        public void setEdges(HashMap<Vertex, Integer> edges){
            this.edges = edges;
        }
        
        //  Evalua a partir de las distancias de cada vertice
        @Override
        public int compareTo(Vertex o) {
            if(this.distance > o.distance)
                return 1;
            if(this.distance < o.distance)
                return -1;
            return 0;
        }
    }
    
    public static class MyArrayList<Type> implements Iterable<Type> {

        private String name;
        private Type[] items;
        private int size;
        private final int DEFAULT_CAPACITY = 10;
        private int modificationCounter;

        @SuppressWarnings("unchecked")
        public MyArrayList() {
            super();
            this.items = (Type[]) new Object[this.DEFAULT_CAPACITY];
            this.size = 0;
            this.modificationCounter = 0;
            this.name = "No Name";
        }

        public MyArrayList(String name) {
            this();
            this.name = name;
        }

        public MyArrayList(int newCapacity) {
            this();
            this.ensureCapacity(newCapacity);
        }

        public MyArrayList(String name, int newCapacity) {
            this(name);
            this.ensureCapacity(newCapacity);
        }

        public String getName() {
            return this.name;
        }

        public Type[] getItems() {
            return this.items;
        }

        public int size() {
            return this.size;
        }

        public boolean isEmpty() {
            return this.size == 0;
        }

        public void clear() {
            this.ensureCapacity(DEFAULT_CAPACITY);
            this.size = 0;
            this.modificationCounter = 0;
        }

        @SuppressWarnings("unchecked")
        private void ensureCapacity(int newCapacity) {
            if (newCapacity < this.items.length) {
                return;
            }
            Type[] newItems = (Type[]) new Object[newCapacity];
            System.arraycopy(this.items, 0, newItems, 0, this.items.length);
            this.items = newItems;
        }

        public void add(Type element) {
            this.add(this.size, element);
        }

        public void add(int index, Type element) {
            //	Esta es la unica excepcion en que el index puede ser incluso this.size
            if (index < 0 || index > this.size) {
                throw new IndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            if (this.size == this.items.length) {
                ensureCapacity(2 * this.size + 1);
            }

            for (int i = this.size; i > index; i--) {
                this.items[i] = this.items[i - 1];
            }

            this.items[index] = element;
            this.size++;
            modificationCounter++;
        }

        public Type remove(int index) {
            if (index < 0 || index >= this.size) {
                throw new IndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            Type oldElement = this.items[index];
            for (int i = index; i < this.size - 1; i++) {
                this.items[i] = this.items[i + 1];
            }

            this.size--;
            modificationCounter++;
            return oldElement;
        }

        public Type get(int index) {
            if (index < 0 || index >= this.size) {
                throw new ArrayIndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            return this.items[index];
        }

        public Type set(int index, Type element) {
            if (index < 0 || index >= this.size) {
                throw new ArrayIndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            Type oldElement = this.items[index];
            this.items[index] = element;
            return oldElement;
        }

        //	Se puede dejar independiente, sin usar el iterator().
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");
            for (int i = 0; i < this.size; i++) {
                sb.append(this.items[i] + " ");
            }
            sb.append("]");
            return sb.toString();
        }

        @Override
        public java.util.Iterator<Type> iterator() {
            return new MyArrayListIterator();
        }

        private class MyArrayListIterator implements java.util.Iterator<Type> {

            private int currentIndex;
            private boolean okToRemove;
            private int expectedModificationCounter;

            public MyArrayListIterator() {
                super();
                this.reset();
            }

            public void reset() {
                this.currentIndex = 0;
                this.okToRemove = false;
                this.expectedModificationCounter = MyArrayList.this.modificationCounter;
            }

            @Override
            public boolean hasNext() {
                return this.currentIndex < MyArrayList.this.size;
            }

            @Override
            public Type next() {
                if (MyArrayList.this.modificationCounter != this.expectedModificationCounter) {
                    throw new java.util.ConcurrentModificationException("In " + MyArrayList.this.name);
                }

                if (!this.hasNext()) {
                    throw new java.util.NoSuchElementException("In " + MyArrayList.this.name);
                }

                this.okToRemove = true;
                return MyArrayList.this.items[this.currentIndex++];
            }

            public void remove() {
                if (MyArrayList.this.modificationCounter != this.expectedModificationCounter) {
                    throw new java.util.ConcurrentModificationException("In " + MyArrayList.this.name);
                }

                if (!this.okToRemove) {
                    throw new IllegalStateException("In " + MyArrayList.this.name);
                }

                MyArrayList.this.remove(--this.currentIndex);
                this.expectedModificationCounter++;
                this.okToRemove = false;
            }
        }
    }
        
    public static class MyBinaryHeap<Type extends Comparable<Type>> {
        
        private final String Name;
        private Type[] Items; 
        private final boolean Kind; // True for Max, False for Min
        private int Size;

        public MyBinaryHeap(String Name, boolean Kind){
            this.Name = Name;
            this.Kind = Kind;
            this.Size = 1;
            this.Items = (Type[]) new Comparable[10];
        }

        public void clear(){
            this.Size = 1;
        }

        public boolean isEmpty(){
            return this.Size == 1;
        }

        public int size(){
            return this.Size-1;
        }

        private void ensureCapacity(int NewSize){
            Type[] Old = this.Items;
            this.Items = (Type[]) new Comparable[NewSize];
            System.arraycopy(Old, 0, this.Items, 0, Old.length); 
        }

        public Type peek(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
            return this.Items[1];
        }

        public void offer(Type New){
            if(this.Size == this.Items.length)
                this.ensureCapacity(this.Size * 2 + 1);
            this.Items[this.Size] = New;
            if(this.Kind)
                this.UpperSortMax(this.Size++);
            else
                this.UpperSortMin(this.Size++);
        }

        public Type poll(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
            Type Aux = this.Items[1];
            this.Items[1] = this.Items[--this.Size];
            if(this.Kind)
                this.LowerSortMax(1);
            else
                this.LowerSortMin(1); 
            return Aux;
        }

        private void LowerSortMax(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Max < 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMax(Current*2+1); 
                }
            }else {
                if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMax(Current*2); 
                }
            }
        }

        private void LowerSortMin(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Min > 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMin(Current*2+1); 
                }
            }else{
                if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMin(Current*2); 
                }
            }
        }

        private void UpperSortMax(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMax(Current/2); 
            }
        }

        private void UpperSortMin(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMin(Current/2); 
            }
        }

        @Override
        public String toString() {
            StringBuilder Aux = new StringBuilder(this.Name+": [ ");
            for (int i = 1; i < this.Size; i++) {
                Aux.append(this.Items[i].toString()).append(" ");
            }
            Aux.append("]");
            return Aux.toString();
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>



import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class ProblemaC {
    public static void main(String[] args) throws FileNotFoundException{
        File inputFile = new File("C_2.txt");
        File outputFile = new File("CSalida2.txt");
        Scanner scan = null;
        BufferedReader buffReader = null;
        if(inputFile.exists()){
            scan = new Scanner(inputFile);
            buffReader = new BufferedReader(new FileReader(inputFile));
            System.setOut(new PrintStream(outputFile));
        }else{
            scan = new Scanner(new InputStreamReader(System.in));
            buffReader = new BufferedReader(new InputStreamReader(System.in));
        }
        
        int casos = Integer.parseInt(scan.nextLine().split(" ")[0]);
        int N;
        HashMap<Integer, Kind> types = new HashMap<>();
        int[][] table;
        boolean isOk;
        for(int t=1; t<=casos; t++){
            types.clear();
            System.out.println("Caso #"+t+":");
            N = Integer.parseInt(scan.nextLine().split(" ")[0]);
            table = makeTable(N, types, scan);
            
            isOk = true;
            for(Map.Entry<Integer, Kind> entry : types.entrySet()){
                if(!check(entry.getValue(), table)){
                    isOk = false;
                    break;
                }
            }
            
            if(isOk)
                System.out.println("YES");
            else
                System.out.println("NO");
        }
    }
    
    public static int[][] makeTable(int size, HashMap<Integer, Kind> types, Scanner scan){
        int[][] table = new int[size][size];
        String[] strings;
        for(int i=0; i<size; i++){
            strings = scan.nextLine().split(" ");
            for(int j=0; j<size; j++){
                table[i][j] = Integer.parseInt(strings[j]);
                if(!types.containsKey(table[i][j]))
                    types.put(table[i][j], new Kind(table[i][j], i, j));
                else
                    types.get(table[i][j]).inclreaseSize();
            }
        }
        return table;
    }
    
    public static boolean check(Kind kind, int[][] table){
        int counter = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{kind.getI(), kind.getJ()});
        int[] aux;
        while(!queue.isEmpty()){
            aux = queue.poll();
            if(table[aux[0]][aux[1]] == kind.getId()){
                counter++;
                table[aux[0]][aux[1]] = -1;
                
                if(aux[0] > 0 && table[aux[0]-1][aux[1]] != -1)
                    queue.offer(new int[]{aux[0]-1, aux[1]});
                
                if(aux[0] < table.length-1 && table[aux[0]+1][aux[1]] != -1)
                    queue.offer(new int[]{aux[0]+1, aux[1]});
                
                if(aux[1] > 0 && table[aux[0]][aux[1]-1] != -1)
                    queue.offer(new int[]{aux[0], aux[1]-1});
                
                if(aux[1] < table.length-1 && table[aux[0]][aux[1]+1] != -1)
                    queue.offer(new int[]{aux[0], aux[1]+1});
            }
        }
        return kind.size == counter;
    }
    
    public static class Kind{
        private int id;
        private int i;
        private int j;
        private int size;
        
        public Kind(int id, int i, int j){
            this.id = id;
            this.i = i;
            this.j = j;
            this.size = 1;
        }
        public int getId(){
            return this.id;
        }
        public int getI(){
            return this.i;
        }
        public int getJ(){
            return this.j;
        }
        public int getSize(){
            return this.size;
        }
        public void setId(int id){
            this.id = id;
        }
        public void setI(int i){
            this.i = i;
        }
        public void setJ(int j){
            this.j = j;
        }
        public void setSize(int size){
            this.size = size;
        }
        public void inclreaseSize(){
            this.size++;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.*;
import java.util.Arrays;
import java.util.Scanner;

public class Proyecto08B {
    public static void main(String[] args) throws FileNotFoundException {
        File inputFile = new File("BEntrada2.txt");
        File outputFile = new File("BSalida2.txt");
        Scanner scan = null;
        BufferedReader buffReader = null;
        if(inputFile.exists()){
            scan = new Scanner(inputFile);
            buffReader = new BufferedReader(new FileReader(inputFile));
            System.setOut(new PrintStream(outputFile));
        }else{
            scan = new Scanner(new InputStreamReader(System.in));
            buffReader = new BufferedReader(new InputStreamReader(System.in));
        }
        
        int casos = Integer.parseInt(scan.nextLine().split(" ")[0]);
        String[] strings;
        int N, M, A, B; //  Datos de entrada para cada caso
        int i, j, value;    //  Valores de conexion entre dos vertices
        HashMap<Integer, Vertex> allVertexs = new HashMap<>();  //  Todos los vertices de cada caso
        
        for(int t=1; t<=casos; t++){
            allVertexs.clear();
            
            System.out.println("Caso #"+t+":");
            
            //  Recibir los datos de entrada
            strings = scan.nextLine().split(" ");
            N = Integer.parseInt(strings[0]);
            M = Integer.parseInt(strings[1]);
            A = Integer.parseInt(strings[2]);
            B = Integer.parseInt(strings[3]);
            
            //  Crear todos los vertices (Nota: inicialmente todos los vertices quedan con distancia cero)
            for(int n=0; n<N; n++){
                allVertexs.put(n, new Vertex(n, false)); //  Identificador, bandera de estado
            }
            
            //  Inicializacion de las aristas
            for(int m=0; m<M; m++){
                //  Lectura de conexion
                strings = scan.nextLine().split(" ");
                i = Integer.parseInt(strings[0]);   //  Vertice incial
                j = Integer.parseInt(strings[1]);   //  Vertice final
                value = Integer.parseInt(strings[2]);   //  Peso del arco
                
                //  Los vertices se agregan mutuamente a la lista de adyacencia del otro
                allVertexs.get(i).getAdjacencyList().add(allVertexs.get(j));
                allVertexs.get(j).getAdjacencyList().add(allVertexs.get(i));
                
                //  Ingreso (en ambos sentidos) de pesos
                allVertexs.get(i).getEdges().put(allVertexs.get(j), value);
                allVertexs.get(j).getEdges().put(allVertexs.get(i), value);
                
            }
            
            //  Calcular distancias desde el vertice A
            calculateDistances(allVertexs.get(A), allVertexs);
            
            //  Si el calculo de distancias alcanzo al vertice B
            if(allVertexs.get(B).getDistance() > 0)
                System.out.println(allVertexs.get(B).getDistance());
            else
                System.out.println("inalcanzable");
        }
    }
    
    public static void calculateDistances(Vertex currentVertex, HashMap<Integer, Vertex> allVertexs){
        currentVertex.setKnow(true);
        
        //  Se crea una cola de prioridad para que empiece a recorrer desde los vertices adyacentes que tengan menor distancia
        MyBinaryHeap<Vertex> auxiliarHeap = new MyBinaryHeap<>("auxiliarHeap", false);  //  Cola de prioridad para MINIMOS
        int newDistance = 0;
        //  Se recorre la lista de adyacencia del vertice actual
        for(Vertex adjacentVertex : currentVertex.getAdjacencyList()){
            //  posible nueva distancia igual al valor de la distancia del vertice actual mas el peso del arco
            newDistance = currentVertex.getDistance() + currentVertex.getEdges().get(adjacentVertex);
            
            //  La siguiente condicion es verdadera en dos casos
            //  caso 1: El vertice adjacente no es conocido
            //  caso 2: El vertice adjacente si es conocido pero la distancia encontrada es menor a la que tenia
            if(!adjacentVertex.getKnow() || newDistance < adjacentVertex.getDistance()){
                adjacentVertex.setKnow(true);               //  Esta linea es redundante solo en el caso de que ya se conozca al vertice adyacente
                adjacentVertex.setDistance(newDistance);    //  Se le actualiza la distancia mas corta siempre
                auxiliarHeap.offer(adjacentVertex);         //  Se agrega a la cola de prioridad
            }
        }
        
        //  Vacia la cola de prioridad de los vertices adyacentes
        while(!auxiliarHeap.isEmpty())
            calculateDistances(auxiliarHeap.poll(), allVertexs);
            //  Desencola el vertice con distancia minima y calcula distancias a partir de este
    }
    
    public static class Vertex implements Comparable<Vertex>{
        
        private int id;
        private int distance;
        private boolean know;
        private MyArrayList<Vertex> adjacencyList;
        private HashMap<Vertex, Integer> edges;
        
        public Vertex(int id, boolean know){
            this.id = id;
            this.distance = 0;
            this.know = know;
            this.adjacencyList = new MyArrayList<>();
            this.edges = new HashMap<>();
        }
        public int getId(){
            return this.id;
        }
        public boolean getKnow(){
            return this.know;
        }
        public int getDistance(){
            return this.distance;
        }
        public MyArrayList<Vertex> getAdjacencyList(){
            return this.adjacencyList;
        }
        public HashMap<Vertex, Integer> getEdges(){
            return this.edges;
        }
        public void setId(int id){
            this.id = id;
        }
        public void setKnow(boolean know){
            this.know = know;
        }
        public void setDistance(int distance){
            this.distance = distance;
        }
        public void setAdjacencyList(MyArrayList<Vertex> adjacencyList){
            this.adjacencyList = adjacencyList;
        }
        public void setEdges(HashMap<Vertex, Integer> edges){
            this.edges = edges;
        }
        
        //  Evalua a partir de las distancias de cada vertice
        @Override
        public int compareTo(Vertex o) {
            if(this.distance > o.distance)
                return 1;
            if(this.distance < o.distance)
                return -1;
            return 0;
        }
    }
    
    public static class MyArrayList<Type> implements Iterable<Type> {

        private String name;
        private Type[] items;
        private int size;
        private final int DEFAULT_CAPACITY = 10;
        private int modificationCounter;

        @SuppressWarnings("unchecked")
        public MyArrayList() {
            super();
            this.items = (Type[]) new Object[this.DEFAULT_CAPACITY];
            this.size = 0;
            this.modificationCounter = 0;
            this.name = "No Name";
        }

        public MyArrayList(String name) {
            this();
            this.name = name;
        }

        public MyArrayList(int newCapacity) {
            this();
            this.ensureCapacity(newCapacity);
        }

        public MyArrayList(String name, int newCapacity) {
            this(name);
            this.ensureCapacity(newCapacity);
        }

        public String getName() {
            return this.name;
        }

        public Type[] getItems() {
            return this.items;
        }

        public int size() {
            return this.size;
        }

        public boolean isEmpty() {
            return this.size == 0;
        }

        public void clear() {
            this.ensureCapacity(DEFAULT_CAPACITY);
            this.size = 0;
            this.modificationCounter = 0;
        }

        @SuppressWarnings("unchecked")
        private void ensureCapacity(int newCapacity) {
            if (newCapacity < this.items.length) {
                return;
            }
            Type[] newItems = (Type[]) new Object[newCapacity];
            System.arraycopy(this.items, 0, newItems, 0, this.items.length);
            this.items = newItems;
        }

        public void add(Type element) {
            this.add(this.size, element);
        }

        public void add(int index, Type element) {
            //	Esta es la unica excepcion en que el index puede ser incluso this.size
            if (index < 0 || index > this.size) {
                throw new IndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            if (this.size == this.items.length) {
                ensureCapacity(2 * this.size + 1);
            }

            for (int i = this.size; i > index; i--) {
                this.items[i] = this.items[i - 1];
            }

            this.items[index] = element;
            this.size++;
            modificationCounter++;
        }

        public Type remove(int index) {
            if (index < 0 || index >= this.size) {
                throw new IndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            Type oldElement = this.items[index];
            for (int i = index; i < this.size - 1; i++) {
                this.items[i] = this.items[i + 1];
            }

            this.size--;
            modificationCounter++;
            return oldElement;
        }

        public Type get(int index) {
            if (index < 0 || index >= this.size) {
                throw new ArrayIndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            return this.items[index];
        }

        public Type set(int index, Type element) {
            if (index < 0 || index >= this.size) {
                throw new ArrayIndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            Type oldElement = this.items[index];
            this.items[index] = element;
            return oldElement;
        }

        //	Se puede dejar independiente, sin usar el iterator().
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");
            for (int i = 0; i < this.size; i++) {
                sb.append(this.items[i] + " ");
            }
            sb.append("]");
            return sb.toString();
        }

        @Override
        public java.util.Iterator<Type> iterator() {
            return new MyArrayListIterator();
        }

        private class MyArrayListIterator implements java.util.Iterator<Type> {

            private int currentIndex;
            private boolean okToRemove;
            private int expectedModificationCounter;

            public MyArrayListIterator() {
                super();
                this.reset();
            }

            public void reset() {
                this.currentIndex = 0;
                this.okToRemove = false;
                this.expectedModificationCounter = MyArrayList.this.modificationCounter;
            }

            @Override
            public boolean hasNext() {
                return this.currentIndex < MyArrayList.this.size;
            }

            @Override
            public Type next() {
                if (MyArrayList.this.modificationCounter != this.expectedModificationCounter) {
                    throw new java.util.ConcurrentModificationException("In " + MyArrayList.this.name);
                }

                if (!this.hasNext()) {
                    throw new java.util.NoSuchElementException("In " + MyArrayList.this.name);
                }

                this.okToRemove = true;
                return MyArrayList.this.items[this.currentIndex++];
            }

            public void remove() {
                if (MyArrayList.this.modificationCounter != this.expectedModificationCounter) {
                    throw new java.util.ConcurrentModificationException("In " + MyArrayList.this.name);
                }

                if (!this.okToRemove) {
                    throw new IllegalStateException("In " + MyArrayList.this.name);
                }

                MyArrayList.this.remove(--this.currentIndex);
                this.expectedModificationCounter++;
                this.okToRemove = false;
            }
        }
    }
        
    public static class MyBinaryHeap<Type extends Comparable<Type>> {
        
        private final String Name;
        private Type[] Items; 
        private final boolean Kind; // True for Max, False for Min
        private int Size;

        public MyBinaryHeap(String Name, boolean Kind){
            this.Name = Name;
            this.Kind = Kind;
            this.Size = 1;
            this.Items = (Type[]) new Comparable[10];
        }

        public void clear(){
            this.Size = 1;
        }

        public boolean isEmpty(){
            return this.Size == 1;
        }

        public int size(){
            return this.Size-1;
        }

        private void ensureCapacity(int NewSize){
            Type[] Old = this.Items;
            this.Items = (Type[]) new Comparable[NewSize];
            System.arraycopy(Old, 0, this.Items, 0, Old.length); 
        }

        public Type peek(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
            return this.Items[1];
        }

        public void offer(Type New){
            if(this.Size == this.Items.length)
                this.ensureCapacity(this.Size * 2 + 1);
            this.Items[this.Size] = New;
            if(this.Kind)
                this.UpperSortMax(this.Size++);
            else
                this.UpperSortMin(this.Size++);
        }

        public Type poll(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
            Type Aux = this.Items[1];
            this.Items[1] = this.Items[--this.Size];
            if(this.Kind)
                this.LowerSortMax(1);
            else
                this.LowerSortMin(1); 
            return Aux;
        }

        private void LowerSortMax(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Max < 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMax(Current*2+1); 
                }
            }else {
                if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMax(Current*2); 
                }
            }
        }

        private void LowerSortMin(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Min > 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMin(Current*2+1); 
                }
            }else{
                if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMin(Current*2); 
                }
            }
        }

        private void UpperSortMax(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMax(Current/2); 
            }
        }

        private void UpperSortMin(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMin(Current/2); 
            }
        }

        @Override
        public String toString() {
            StringBuilder Aux = new StringBuilder(this.Name+": [ ");
            for (int i = 1; i < this.Size; i++) {
                Aux.append(this.Items[i].toString()).append(" ");
            }
            Aux.append("]");
            return Aux.toString();
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.*;
import java.util.Arrays;
import java.util.Scanner;

public class Proyecto08B {
    public static void main(String[] args) throws FileNotFoundException {
        File inputFile = new File("B_2.txt");
        File outputFile = new File("BSalida1.txt");
        Scanner scan = null;
        BufferedReader buffReader = null;
        if(inputFile.exists()){
            scan = new Scanner(inputFile);
            buffReader = new BufferedReader(new FileReader(inputFile));
            System.setOut(new PrintStream(outputFile));
        }else{
            scan = new Scanner(new InputStreamReader(System.in));
            buffReader = new BufferedReader(new InputStreamReader(System.in));
        }
        
        int casos = Integer.parseInt(scan.nextLine().split(" ")[0]);
        String[] strings;
        int N, M, A, B; //  Datos de entrada para cada caso
        int[][] adjacencyMatrix;    //  Matriz de adyacencia
        int i, j, value;    //  Valores de conexion entre dos vertices
        HashMap<Integer, Vertex> allVertexs = new HashMap<>();  //  Todos los vertices de cada caso
        
        for(int t=1; t<=casos; t++){
            allVertexs.clear();
            
            System.out.println("Caso #"+t+":");
            
            //  Recibir los datos de entrada
            strings = scan.nextLine().split(" ");
            N = Integer.parseInt(strings[0]);
            M = Integer.parseInt(strings[1]);
            A = Integer.parseInt(strings[2]);
            B = Integer.parseInt(strings[3]);
            
            //  Crear todos los vertices (Nota: inicialmente todos los vertices quedan con distancia cero)
            for(int n=0; n<N; n++){
                allVertexs.put(n, new Vertex(n, false)); //  Identificador, bandera de estado
            }
            
            //  Instancia de matriz de adyacencia
            adjacencyMatrix = new int[N][N];
            //  Inicializacion de matriz de adyacencia
            for(int m=0; m<M; m++){
                //  Lectura de conexion
                strings = scan.nextLine().split(" ");
                i = Integer.parseInt(strings[0]);   //  Vertice incial
                j = Integer.parseInt(strings[1]);   //  Vertice final
                value = Integer.parseInt(strings[2]);   //  Peso del arco
                
                //  Ingreso (en ambos sentidos) de pesos en la matriz de adyacencia
                adjacencyMatrix[i][j] = value;
                adjacencyMatrix[j][i] = value;
                
                //  Los vertices se agregan mutuamente a la lista de adyacencia del otro
                allVertexs.get(i).getAdjacencyList().add(allVertexs.get(j));
                allVertexs.get(j).getAdjacencyList().add(allVertexs.get(i));
            }
            
            //  Calcular distancias desde el vertice A
            calculateDistances(allVertexs.get(A), adjacencyMatrix, allVertexs);
            
            //  Si el calculo de distancias alcanzo al vertice B
            if(allVertexs.get(B).getDistance() > 0)
                System.out.println(allVertexs.get(B).getDistance());
            else
                System.out.println("inalcanzable");
        }
    }
    
    public static void calculateDistances(Vertex currentVertex, int[][] adjacencyMatrix, HashMap<Integer, Vertex> allVertexs){
        currentVertex.setKnow(true);
        
        //  Se crea una cola de prioridad para que empiece a recorrer desde los vertices adyacentes que tengan menor distancia
        MyBinaryHeap<Vertex> auxiliarHeap = new MyBinaryHeap<>("auxiliarHeap", false);  //  Cola de prioridad para MINIMOS
        int newDistance = 0;
        //  Se recorre la lista de adyacencia del vertice actual
        for(Vertex adjacentVertex : currentVertex.getAdjacencyList()){
            //  posible nueva distancia igual al valor de la distancia del vertice actual mas el peso del arco (que esta en la matriz de adyacencia)
            newDistance = currentVertex.getDistance() + adjacencyMatrix[ currentVertex.getId() ] [ adjacentVertex.getId() ];
            
            //  caso 1: No es conocido
            //  caso 2: Si es conocido pero la distancia encontrada es menor a la que tenia
            if(!adjacentVertex.getKnow() || newDistance < adjacentVertex.getDistance()){
                adjacentVertex.setKnow(true);               //  Esta linea es redundante solo en el caso de que ya se conozca al vertice adyacente
                adjacentVertex.setDistance(newDistance);    //  Se le actualiza la distancia mas corta siempre
                auxiliarHeap.offer(adjacentVertex);         //  Se agrega a la cola de prioridad
            }
        }
        
        //  Vacia la cola de prioridad de los vertices adyacentes
        while(!auxiliarHeap.isEmpty())
            calculateDistances(auxiliarHeap.poll(), adjacencyMatrix, allVertexs);
            //  Desencola el vertice con distancia minima y calcula distancias a partir de este
    }
    
    public static class Vertex implements Comparable<Vertex>{
        
        private int id;
        private int distance;
        private boolean know;
        private MyArrayList<Vertex> adjacencyList;
        
        public Vertex(int id, boolean know){
            this.id = id;
            this.distance = 0;
            this.know = know;
            this.adjacencyList = new MyArrayList<>();
        }
        public int getId(){
            return this.id;
        }
        public boolean getKnow(){
            return this.know;
        }
        public int getDistance(){
            return this.distance;
        }
        public MyArrayList<Vertex> getAdjacencyList(){
            return this.adjacencyList;
        }
        public void setId(int id){
            this.id = id;
        }
        public void setKnow(boolean know){
            this.know = know;
        }
        public void setDistance(int distance){
            this.distance = distance;
        }
        public void setAdjacencyList(MyArrayList<Vertex> adjacencyList){
            this.adjacencyList = adjacencyList;
        }

        //  Evalua a partir de las distancias de cada vertice
        @Override
        public int compareTo(Vertex o) {
            if(this.distance > o.distance)
                return 1;
            if(this.distance < o.distance)
                return -1;
            return 0;
        }
    }
    
    public static class MyArrayList<Type> implements Iterable<Type> {

        private String name;
        private Type[] items;
        private int size;
        private final int DEFAULT_CAPACITY = 10;
        private int modificationCounter;

        @SuppressWarnings("unchecked")
        public MyArrayList() {
            super();
            this.items = (Type[]) new Object[this.DEFAULT_CAPACITY];
            this.size = 0;
            this.modificationCounter = 0;
            this.name = "No Name";
        }

        public MyArrayList(String name) {
            this();
            this.name = name;
        }

        public MyArrayList(int newCapacity) {
            this();
            this.ensureCapacity(newCapacity);
        }

        public MyArrayList(String name, int newCapacity) {
            this(name);
            this.ensureCapacity(newCapacity);
        }

        public String getName() {
            return this.name;
        }

        public Type[] getItems() {
            return this.items;
        }

        public int size() {
            return this.size;
        }

        public boolean isEmpty() {
            return this.size == 0;
        }

        public void clear() {
            this.ensureCapacity(DEFAULT_CAPACITY);
            this.size = 0;
            this.modificationCounter = 0;
        }

        @SuppressWarnings("unchecked")
        private void ensureCapacity(int newCapacity) {
            if (newCapacity < this.items.length) {
                return;
            }
            Type[] newItems = (Type[]) new Object[newCapacity];
            System.arraycopy(this.items, 0, newItems, 0, this.items.length);
            this.items = newItems;
        }

        public void add(Type element) {
            this.add(this.size, element);
        }

        public void add(int index, Type element) {
            //	Esta es la unica excepcion en que el index puede ser incluso this.size
            if (index < 0 || index > this.size) {
                throw new IndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            if (this.size == this.items.length) {
                ensureCapacity(2 * this.size + 1);
            }

            for (int i = this.size; i > index; i--) {
                this.items[i] = this.items[i - 1];
            }

            this.items[index] = element;
            this.size++;
            modificationCounter++;
        }

        public Type remove(int index) {
            if (index < 0 || index >= this.size) {
                throw new IndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            Type oldElement = this.items[index];
            for (int i = index; i < this.size - 1; i++) {
                this.items[i] = this.items[i + 1];
            }

            this.size--;
            modificationCounter++;
            return oldElement;
        }

        public Type get(int index) {
            if (index < 0 || index >= this.size) {
                throw new ArrayIndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            return this.items[index];
        }

        public Type set(int index, Type element) {
            if (index < 0 || index >= this.size) {
                throw new ArrayIndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            Type oldElement = this.items[index];
            this.items[index] = element;
            return oldElement;
        }

        //	Se puede dejar independiente, sin usar el iterator().
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");
            for (int i = 0; i < this.size; i++) {
                sb.append(this.items[i] + " ");
            }
            sb.append("]");
            return sb.toString();
        }

        @Override
        public java.util.Iterator<Type> iterator() {
            return new MyArrayListIterator();
        }

        private class MyArrayListIterator implements java.util.Iterator<Type> {

            private int currentIndex;
            private boolean okToRemove;
            private int expectedModificationCounter;

            public MyArrayListIterator() {
                super();
                this.reset();
            }

            public void reset() {
                this.currentIndex = 0;
                this.okToRemove = false;
                this.expectedModificationCounter = MyArrayList.this.modificationCounter;
            }

            @Override
            public boolean hasNext() {
                return this.currentIndex < MyArrayList.this.size;
            }

            @Override
            public Type next() {
                if (MyArrayList.this.modificationCounter != this.expectedModificationCounter) {
                    throw new java.util.ConcurrentModificationException("In " + MyArrayList.this.name);
                }

                if (!this.hasNext()) {
                    throw new java.util.NoSuchElementException("In " + MyArrayList.this.name);
                }

                this.okToRemove = true;
                return MyArrayList.this.items[this.currentIndex++];
            }

            public void remove() {
                if (MyArrayList.this.modificationCounter != this.expectedModificationCounter) {
                    throw new java.util.ConcurrentModificationException("In " + MyArrayList.this.name);
                }

                if (!this.okToRemove) {
                    throw new IllegalStateException("In " + MyArrayList.this.name);
                }

                MyArrayList.this.remove(--this.currentIndex);
                this.expectedModificationCounter++;
                this.okToRemove = false;
            }
        }
    }
        
    public static class MyBinaryHeap<Type extends Comparable<Type>> {
        
        private final String Name;
        private Type[] Items; 
        private final boolean Kind; // True for Max, False for Min
        private int Size;

        public MyBinaryHeap(String Name, boolean Kind){
            this.Name = Name;
            this.Kind = Kind;
            this.Size = 1;
            this.Items = (Type[]) new Comparable[10];
        }

        public void clear(){
            this.Size = 1;
        }

        public boolean isEmpty(){
            return this.Size == 1;
        }

        public int size(){
            return this.Size-1;
        }

        private void ensureCapacity(int NewSize){
            Type[] Old = this.Items;
            this.Items = (Type[]) new Comparable[NewSize];
            System.arraycopy(Old, 0, this.Items, 0, Old.length); 
        }

        public Type peek(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
            return this.Items[1];
        }

        public void offer(Type New){
            if(this.Size == this.Items.length)
                this.ensureCapacity(this.Size * 2 + 1);
            this.Items[this.Size] = New;
            if(this.Kind)
                this.UpperSortMax(this.Size++);
            else
                this.UpperSortMin(this.Size++);
        }

        public Type poll(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
            Type Aux = this.Items[1];
            this.Items[1] = this.Items[--this.Size];
            if(this.Kind)
                this.LowerSortMax(1);
            else
                this.LowerSortMin(1); 
            return Aux;
        }

        private void LowerSortMax(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Max < 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMax(Current*2+1); 
                }
            }else {
                if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMax(Current*2); 
                }
            }
        }

        private void LowerSortMin(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Min > 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMin(Current*2+1); 
                }
            }else{
                if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMin(Current*2); 
                }
            }
        }

        private void UpperSortMax(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMax(Current/2); 
            }
        }

        private void UpperSortMin(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMin(Current/2); 
            }
        }

        @Override
        public String toString() {
            StringBuilder Aux = new StringBuilder(this.Name+": [ ");
            for (int i = 1; i < this.Size; i++) {
                Aux.append(this.Items[i].toString()).append(" ");
            }
            Aux.append("]");
            return Aux.toString();
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.*;
import java.util.Arrays;
import java.util.Scanner;

public class Proyecto08B {
    public static void main(String[] args) throws FileNotFoundException {
        File inputFile = new File("BEntrada2.txt");
        File outputFile = new File("BSalida2.txt");
        Scanner scan = null;
        BufferedReader buffReader = null;
        if(inputFile.exists()){
            scan = new Scanner(inputFile);
            buffReader = new BufferedReader(new FileReader(inputFile));
            System.setOut(new PrintStream(outputFile));
        }else{
            scan = new Scanner(new InputStreamReader(System.in));
            buffReader = new BufferedReader(new InputStreamReader(System.in));
        }
        
        int casos = Integer.parseInt(scan.nextLine().split(" ")[0]);
        String[] strings;
        int N, M, A, B; //  Datos de entrada para cada caso
        int i, j, value;    //  Valores de conexion entre dos vertices
        HashMap<Integer, Vertex> allVertexs = new HashMap<>();  //  Todos los vertices de cada caso
        
        for(int t=1; t<=casos; t++){
            allVertexs.clear();
            
            System.out.println("Caso #"+t+":");
            
            //  Recibir los datos de entrada
            strings = scan.nextLine().split(" ");
            N = Integer.parseInt(strings[0]);
            M = Integer.parseInt(strings[1]);
            A = Integer.parseInt(strings[2]);
            B = Integer.parseInt(strings[3]);
            
            //  Crear todos los vertices (Nota: inicialmente todos los vertices quedan con distancia cero)
            for(int n=0; n<N; n++){
                allVertexs.put(n, new Vertex(n, false)); //  Identificador, bandera de estado
            }
            
            //  Inicializacion de las aristas
            for(int m=0; m<M; m++){
                //  Lectura de conexion
                strings = scan.nextLine().split(" ");
                i = Integer.parseInt(strings[0]);   //  Vertice incial
                j = Integer.parseInt(strings[1]);   //  Vertice final
                value = Integer.parseInt(strings[2]);   //  Peso del arco
                
                //  Los vertices se agregan mutuamente a la lista de adyacencia del otro
                allVertexs.get(i).getAdjacencyList().add(allVertexs.get(j));
                allVertexs.get(j).getAdjacencyList().add(allVertexs.get(i));
                
                //  Ingreso (en ambos sentidos) de pesos
                allVertexs.get(i).getEdges().put(allVertexs.get(j), value);
                allVertexs.get(j).getEdges().put(allVertexs.get(i), value);
                
            }
            
            //  Calcular distancias desde el vertice A
            calculateDistances(allVertexs.get(A), allVertexs);
            
            //  Si el calculo de distancias alcanzo al vertice B
            if(allVertexs.get(B).getDistance() > 0)
                System.out.println(allVertexs.get(B).getDistance());
            else
                System.out.println("inalcanzable");
        }
    }
    
    public static void calculateDistances(Vertex currentVertex, HashMap<Integer, Vertex> allVertexs){
        currentVertex.setKnow(true);
        
        //  Se crea una cola de prioridad para que empiece a recorrer desde los vertices adyacentes que tengan menor distancia
        MyBinaryHeap<Vertex> auxiliarHeap = new MyBinaryHeap<>("auxiliarHeap", false);  //  Cola de prioridad para MINIMOS
        int newDistance = 0;
        //  Se recorre la lista de adyacencia del vertice actual
        for(Vertex adjacentVertex : currentVertex.getAdjacencyList()){
            //  posible nueva distancia igual al valor de la distancia del vertice actual mas el peso del arco
            newDistance = currentVertex.getDistance() + currentVertex.getEdges().get(adjacentVertex);
            
            //  La siguiente condicion es verdadera en dos casos
            //  caso 1: El vertice adjacente no es conocido
            //  caso 2: El vertice adjacente si es conocido pero la distancia encontrada es menor a la que tenia
            if(!adjacentVertex.getKnow() || newDistance < adjacentVertex.getDistance()){
                adjacentVertex.setKnow(true);               //  Esta linea es redundante solo en el caso de que ya se conozca al vertice adyacente
                adjacentVertex.setDistance(newDistance);    //  Se le actualiza la distancia mas corta siempre
                auxiliarHeap.offer(adjacentVertex);         //  Se agrega a la cola de prioridad
            }
        }
        
        //  Vacia la cola de prioridad de los vertices adyacentes
        while(!auxiliarHeap.isEmpty())
            calculateDistances(auxiliarHeap.poll(), allVertexs);
            //  Desencola el vertice con distancia minima y calcula distancias a partir de este
    }
    
    public static class Vertex implements Comparable<Vertex>{
        
        private int id;
        private int distance;
        private boolean know;
        private MyArrayList<Vertex> adjacencyList;
        private HashMap<Vertex, Integer> edges;
        
        public Vertex(int id, boolean know){
            this.id = id;
            this.distance = 0;
            this.know = know;
            this.adjacencyList = new MyArrayList<>();
            this.edges = new HashMap<>();
        }
        public int getId(){
            return this.id;
        }
        public boolean getKnow(){
            return this.know;
        }
        public int getDistance(){
            return this.distance;
        }
        public MyArrayList<Vertex> getAdjacencyList(){
            return this.adjacencyList;
        }
        public HashMap<Vertex, Integer> getEdges(){
            return this.edges;
        }
        public void setId(int id){
            this.id = id;
        }
        public void setKnow(boolean know){
            this.know = know;
        }
        public void setDistance(int distance){
            this.distance = distance;
        }
        public void setAdjacencyList(MyArrayList<Vertex> adjacencyList){
            this.adjacencyList = adjacencyList;
        }
        public void setEdges(HashMap<Vertex, Integer> edges){
            this.edges = edges;
        }
        
        //  Evalua a partir de las distancias de cada vertice
        @Override
        public int compareTo(Vertex o) {
            if(this.distance > o.distance)
                return 1;
            if(this.distance < o.distance)
                return -1;
            return 0;
        }
    }
    
    public static class MyArrayList<Type> implements Iterable<Type> {

        private String name;
        private Type[] items;
        private int size;
        private final int DEFAULT_CAPACITY = 10;
        private int modificationCounter;

        @SuppressWarnings("unchecked")
        public MyArrayList() {
            super();
            this.items = (Type[]) new Object[this.DEFAULT_CAPACITY];
            this.size = 0;
            this.modificationCounter = 0;
            this.name = "No Name";
        }

        public MyArrayList(String name) {
            this();
            this.name = name;
        }

        public MyArrayList(int newCapacity) {
            this();
            this.ensureCapacity(newCapacity);
        }

        public MyArrayList(String name, int newCapacity) {
            this(name);
            this.ensureCapacity(newCapacity);
        }

        public String getName() {
            return this.name;
        }

        public Type[] getItems() {
            return this.items;
        }

        public int size() {
            return this.size;
        }

        public boolean isEmpty() {
            return this.size == 0;
        }

        public void clear() {
            this.ensureCapacity(DEFAULT_CAPACITY);
            this.size = 0;
            this.modificationCounter = 0;
        }

        @SuppressWarnings("unchecked")
        private void ensureCapacity(int newCapacity) {
            if (newCapacity < this.items.length) {
                return;
            }
            Type[] newItems = (Type[]) new Object[newCapacity];
            System.arraycopy(this.items, 0, newItems, 0, this.items.length);
            this.items = newItems;
        }

        public void add(Type element) {
            this.add(this.size, element);
        }

        public void add(int index, Type element) {
            //	Esta es la unica excepcion en que el index puede ser incluso this.size
            if (index < 0 || index > this.size) {
                throw new IndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            if (this.size == this.items.length) {
                ensureCapacity(2 * this.size + 1);
            }

            for (int i = this.size; i > index; i--) {
                this.items[i] = this.items[i - 1];
            }

            this.items[index] = element;
            this.size++;
            modificationCounter++;
        }

        public Type remove(int index) {
            if (index < 0 || index >= this.size) {
                throw new IndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            Type oldElement = this.items[index];
            for (int i = index; i < this.size - 1; i++) {
                this.items[i] = this.items[i + 1];
            }

            this.size--;
            modificationCounter++;
            return oldElement;
        }

        public Type get(int index) {
            if (index < 0 || index >= this.size) {
                throw new ArrayIndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            return this.items[index];
        }

        public Type set(int index, Type element) {
            if (index < 0 || index >= this.size) {
                throw new ArrayIndexOutOfBoundsException("In " + this.name + ": Size: " + this.size + ", index: " + index);
            }

            Type oldElement = this.items[index];
            this.items[index] = element;
            return oldElement;
        }

        //	Se puede dejar independiente, sin usar el iterator().
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");
            for (int i = 0; i < this.size; i++) {
                sb.append(this.items[i] + " ");
            }
            sb.append("]");
            return sb.toString();
        }

        @Override
        public java.util.Iterator<Type> iterator() {
            return new MyArrayListIterator();
        }

        private class MyArrayListIterator implements java.util.Iterator<Type> {

            private int currentIndex;
            private boolean okToRemove;
            private int expectedModificationCounter;

            public MyArrayListIterator() {
                super();
                this.reset();
            }

            public void reset() {
                this.currentIndex = 0;
                this.okToRemove = false;
                this.expectedModificationCounter = MyArrayList.this.modificationCounter;
            }

            @Override
            public boolean hasNext() {
                return this.currentIndex < MyArrayList.this.size;
            }

            @Override
            public Type next() {
                if (MyArrayList.this.modificationCounter != this.expectedModificationCounter) {
                    throw new java.util.ConcurrentModificationException("In " + MyArrayList.this.name);
                }

                if (!this.hasNext()) {
                    throw new java.util.NoSuchElementException("In " + MyArrayList.this.name);
                }

                this.okToRemove = true;
                return MyArrayList.this.items[this.currentIndex++];
            }

            public void remove() {
                if (MyArrayList.this.modificationCounter != this.expectedModificationCounter) {
                    throw new java.util.ConcurrentModificationException("In " + MyArrayList.this.name);
                }

                if (!this.okToRemove) {
                    throw new IllegalStateException("In " + MyArrayList.this.name);
                }

                MyArrayList.this.remove(--this.currentIndex);
                this.expectedModificationCounter++;
                this.okToRemove = false;
            }
        }
    }
        
    public static class MyBinaryHeap<Type extends Comparable<Type>> {
        
        private final String Name;
        private Type[] Items; 
        private final boolean Kind; // True for Max, False for Min
        private int Size;

        public MyBinaryHeap(String Name, boolean Kind){
            this.Name = Name;
            this.Kind = Kind;
            this.Size = 1;
            this.Items = (Type[]) new Comparable[10];
        }

        public void clear(){
            this.Size = 1;
        }

        public boolean isEmpty(){
            return this.Size == 1;
        }

        public int size(){
            return this.Size-1;
        }

        private void ensureCapacity(int NewSize){
            Type[] Old = this.Items;
            this.Items = (Type[]) new Comparable[NewSize];
            System.arraycopy(Old, 0, this.Items, 0, Old.length); 
        }

        public Type peek(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to peek: "+this.Name);
            return this.Items[1];
        }

        public void offer(Type New){
            if(this.Size == this.Items.length)
                this.ensureCapacity(this.Size * 2 + 1);
            this.Items[this.Size] = New;
            if(this.Kind)
                this.UpperSortMax(this.Size++);
            else
                this.UpperSortMin(this.Size++);
        }

        public Type poll(){
            if(this.Size == 1)
                throw new NoSuchElementException("There aren't more elements to poll: "+this.Name);
            Type Aux = this.Items[1];
            this.Items[1] = this.Items[--this.Size];
            if(this.Kind)
                this.LowerSortMax(1);
            else
                this.LowerSortMin(1); 
            return Aux;
        }

        private void LowerSortMax(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Max = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Max < 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMax(Current*2+1); 
                }
            }else {
                if(this.Items[Current].compareTo(this.Items[Current*2]) < 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMax(Current*2); 
                }
            }
        }

        private void LowerSortMin(int Current){
            if(Current*2+1 > this.Size)
                return ;
            Type Aux;
            int Min = this.Items[Current*2].compareTo(this.Items[Current*2+1]);
            if(Min > 0){
                if(this.Items[Current].compareTo(this.Items[Current*2+1]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2+1];
                    this.Items[Current*2+1] = Aux;
                    this.LowerSortMin(Current*2+1); 
                }
            }else{
                if(this.Items[Current].compareTo(this.Items[Current*2]) > 0){
                    Aux = this.Items[Current];
                    this.Items[Current] = this.Items[Current*2];
                    this.Items[Current*2] = Aux;
                    this.LowerSortMin(Current*2); 
                }
            }
        }

        private void UpperSortMax(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) > 0){ 
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMax(Current/2); 
            }
        }

        private void UpperSortMin(int Current){
            if(Current <= 1)
                return ;
            Type Aux = null;
            if(this.Items[Current].compareTo(this.Items[Current/2]) < 0){
                Aux = this.Items[Current/2];
                this.Items[Current/2] = this.Items[Current];
                this.Items[Current] = Aux;
                this.UpperSortMin(Current/2); 
            }
        }

        @Override
        public String toString() {
            StringBuilder Aux = new StringBuilder(this.Name+": [ ");
            for (int i = 1; i < this.Size; i++) {
                Aux.append(this.Items[i].toString()).append(" ");
            }
            Aux.append("]");
            return Aux.toString();
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>



import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class ProblemaD {
    public static void main(String[] args) throws FileNotFoundException{
        File inputFile = new File("CEntrada1.txt");
        File outputFile = new File("CSalida1.txt");
        Scanner scan = null;
        BufferedReader buffReader = null;
        if(inputFile.exists()){
            scan = new Scanner(inputFile);
            buffReader = new BufferedReader(new FileReader(inputFile));
            System.setOut(new PrintStream(outputFile));
        }else{
            scan = new Scanner(new InputStreamReader(System.in));
            buffReader = new BufferedReader(new InputStreamReader(System.in));
        }
        
        int casos = Integer.parseInt(scan.nextLine().split(" ")[0]);
        int N;
        HashMap<Arreglo, Kind> types = new HashMap<>();
        Arreglo[][] table;
        
        boolean isOk;
        for(int t=1; t<=casos; t++){
            types.clear();
            
            System.out.println("Caso #"+t+":");
            System.err.println("Caso #"+t+":");
            N = Integer.parseInt(scan.nextLine().split(" ")[0]);
            table = makeTable(N, types, scan);
            
            int counter = 0;
            Integer[] array;
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    if(types.containsKey(table[i][j])){
                        counter++;
                        check(types.get(table[i][j]), types, table);
                    }
                }
            }
            System.out.println(counter);
        }
    }
    
    public static Arreglo[][] makeTable(int size, HashMap<Arreglo, Kind> types, Scanner scan){
        Arreglo[][] table = new Arreglo[size][size];
        String[] strings;
        
        for(int i=0; i<size; i++){
            strings = scan.nextLine().split(" ");
            for(int j=0; j<size; j++){
                table[i][j] = new Arreglo(i, j, Integer.parseInt(strings[j]));
                types.put(table[i][j], new Kind(table[i][j].id, i, j));
            }
        }
        return table;
    }
    public static class Arreglo{
        int i;
        int j;
        int id;
        public Arreglo(int i, int j, int id){
            this.i = i;
            this.j = j;
            this.id = id;
        }
    }
    
    public static void check(Kind kind, HashMap<Arreglo, Kind> types, Arreglo[][] table){
        Queue<Kind> queue = new LinkedList<>();
        Kind current;
        int id = kind.getId();
        Arreglo[] array;
        
        queue.offer(kind);
        while(!queue.isEmpty()){
            current = queue.poll();
            if(current.getId() == id){
                
                table[current.getI()][current.getJ()].id = -1;
                current.setId(-1);
                types.remove(table[current.getI()][current.getJ()]);
                if(current.getI() > 0)
                    if(types.containsKey(table[current.getI()-1][current.getJ()]))
                        queue.offer(types.get(table[current.getI()-1][current.getJ()]));
                if(current.getI() < table.length-1)
                if(types.containsKey(table[current.getI()+1][current.getJ()]))
                    queue.offer(types.get(table[current.getI()+1][current.getJ()]));
                if(current.getJ() > 0)
                if(types.containsKey(table[current.getI()][current.getJ()-1]))
                    queue.offer(types.get(table[current.getI()][current.getJ()-1]));
                if(current.getJ() < table.length-1)
                if(types.containsKey(table[current.getI()][current.getJ()+1]))
                    queue.offer(types.get(table[current.getI()][current.getJ()+1]));
            }
        }
    }
    
    public static class Kind{
        private int id;
        private int i;
        private int j;
        private int size;
        
        public Kind(int id, int i, int j){
            this.id = id;
            this.i = i;
            this.j = j;
            this.size = 1;
        }
        public int getId(){
            return this.id;
        }
        public int getI(){
            return this.i;
        }
        public int getJ(){
            return this.j;
        }
        public int getSize(){
            return this.size;
        }
        public void setId(int id){
            this.id = id;
        }
        public void setI(int i){
            this.i = i;
        }
        public void setJ(int j){
            this.j = j;
        }
        public void setSize(int size){
            this.size = size;
        }
        public void inclreaseSize(){
            this.size++;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
