/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemaa;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 *
 */
public class ProblemaA {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("A_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("A_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;
        int h = 0;
        int s = 0;
        int g = 0;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            int k = Integer.parseInt(in.readLine());
            String m = (in.readLine());
            int[] r = readInts(m, k);
            for (int i = 0; i < r.length; i++) {
                for (int j = 0; j < r.length; j++) {
                    if (i != j) {
                        if (r[i] > r[j]) {
                            h = h + 1;
                        } else if (r[i] < r[j]) {
                            s = s + 1;
                        } else if (r[i] == r[j]) {
                            g = g + 1;
                        }
                    }
                }
            }
            System.out.println(h + "\n" + s + "\n" + g);
            h = 0;
            s = 0;
            g = 0;

        }

    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemab;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Scanner;

/**
 *
 */
public class ProblemaB {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("B_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("B_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }

        int cas = 1;
        int aux = 0;
        String a = " ";
        a = in.readLine();

        while (a != null) {

            System.out.println("Case #" + cas + ":");
            int n = Integer.parseInt(a);

            String m = " ";
            int[][] matrix = new int[n][n];

            m = (in.readLine());

            String[] array = new String[n];

            for (int j = 0; j < n; j++) {
                array = m.split(" ");
                for (int k = 0; k < n; k++) {
                    matrix[j][k] = Integer.parseInt(array[k]);
                }

                m = in.readLine();
            }
            System.out.println(CasillaGanadora(matrix));

            a = m;
            if (m == null) {
                a = null;
            }

            cas++;
        }

    }

    public static int CasillaGanadora(int[][] m) {
        int g = 0;
        int sumf = 0;
        int sumc = 0;
        for (int i = 0; i < m.length; i++) {
            for (int j = 0; j < m.length; j++) {

                for (int k = 0; k < m.length; k++) {
                    sumf = sumf + m[j][k];//fila

                    sumc = sumc + m[k][i];//columna

                }

                if (sumf < sumc) {
                    g++;

                }

                sumf = 0;
                sumc = 0;

            }
            sumf = 0;
            sumc = 0;

        }
        return g;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 *
 */
public class ProblemaD {
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("D_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("D_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c;
        int g = 0;
        String a = in.readLine();
        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");

            int k = Integer.parseInt(a);
            // System.out.println(k);
            int[][] matrix = new int[k][2];
            String[] array = new String[2];
            String m = "";
            m = (in.readLine());

            for (int i = 0; i < k; i++) {
                array = m.split(" ");
                for (int j = 0; j < 2; j++) {
                    matrix[i][j] = Integer.parseInt(array[j]);
                }

                m = in.readLine();

            }

            a = m;

            for (int i = 0; i < k; i++) {
                for (int j = 0; j < k; j++) {
                    if (i != j) {
                        if (matrix[i][0] == matrix[j][1]) {

                            g++;

                        }
                    }

                }

            }
            System.out.println(g);
            g = 0;
        }

    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemac;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 *
 */
public class ProblemaC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("C_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("C_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;
        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            int k = Integer.parseInt(in.readLine());
            //  System.out.println(k);
            String m = (in.readLine());
            //  System.out.println(m);
            String[] r = readInts(m, k);
            /*boolean b= false;
            
            for (int i = 0; i < r.length; i++) {
                for (int j = 0; j < r.length; j++) {

                    if (r[i] != r[j]) {
                        b= true;
                    
                    }
                    
                }
            }*/
            //if (b) {
                FormasOrdenar(r, "", k, k);
            }
        }
            

    public static void FormasOrdenar(String[] s, String z, int k, int r) {
        if (k == 0) {
            System.out.println(z);
        } else {
            for (int i = 0; i < r; i++) {

                if (!z.contains(s[i])) {

                    FormasOrdenar(s, z + s[i], k - 1, r);

                }
            }

        }

    }

    public static String[] readInts(String s, int n) {
        String split[] = s.split(" ");
        String arr[] = new String[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (split[i]);
        }

        return arr;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemae;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 *
 */
public class ProblemaE {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("E_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("E_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {

            int k = Integer.parseInt(in.readLine());
            String m = (in.readLine());
            int[] r = readInts(m, k);
            int s = 0;
            boolean b = false;

            for (int i = 0; i < r.length; i++) {

                if (i == 0) {

                    b = true;
                
                if (r[i] == 0 && b) {
                    s++;

                } else if (r[i] == 1) {
                    s = s;
                }}
                if (i != 0) {
                    if (r[i] == 0 && r[i]!=r[i-1]) {
                        s++;

                    } else if (r[i] == 1) {
                        s = s;
                    }
                }

            }
            System.out.println(s);
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemaa6;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaA6 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException, Exception {
        BufferedReader in;
        File f = new File("A_1.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("A_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            SeparateChainingHashTable<Integer> H;
            SeparateChainingHashTable<Integer> H1;
            String m = (in.readLine());
            int[] r = readInts(m, 2);
            String num = (in.readLine());
            int[] numeros = readInts(num, r[0]);
            String fun = (in.readLine());
            int[] funciones = readInts(fun, r[1]);
            int funfinal = 0;
            int funf = 0;
            int llavefin = 0;

            MyLinkedList<MyLinkedList> listacolisiones = new MyLinkedList<>();
            TreeMap<Integer, Integer> tm = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tm2 = new TreeMap<Integer, Integer>();
            MyLinkedList<Integer> lista = new MyLinkedList<>();
            MyLinkedList<Integer> lista2 = new MyLinkedList<>();
            MyLinkedList<Integer> listaindices = new MyLinkedList<>();

            //encuentra el K que provoca menos colsiones
            for (int i = 0; i < funciones.length; i++) {
                H = new SeparateChainingHashTable<>();
                for (int j = 0; j < numeros.length; j++) {
                    H.insert(numeros[j], funciones[i]);

                }
               
                int colm = H.ColisionMayor(H);
             //     System.out.println("colision mayor: " + colm);
                tm.put(funciones[i], colm);
                // System.out.println("adiciono a treemap: " + funciones[i] + " " + colm);
                // int tmm = 0;
            }
            /*Set<Map.Entry<Integer, Integer>> set = tm.entrySet();
             //System.out.println("TreeMap:");
             for (Map.Entry<Integer, Integer> me : set) {

             System.out.println("treemap tm: " + me.getKey() + " " + me.getValue());

             }*/

            //    System.out.println("tam: "+funciones.length);
            if (funciones.length > 1) {
                int i = 1;
                funfinal = 0;
                while (i < funciones.length) {

                    int d = tm.get(funciones[funfinal]);

                    int g = tm.get(funciones[i]);

                    if (d >= g) {
                        //System.out.println("d<g");
                        funfinal = i;
                        i++;

                    } else {

                        //   System.out.println("d>=g: ");
                        i++;
                    }

                }
                funf = tm.get(funciones[funfinal]);

            } else {
                funf = tm.get(funciones[0]);
                // System.out.println("valor de funfinal: "+funfinal);

            }
            //     System.out.println("valor menor de colisiones: " + funf);
            //int aux1 = 0;
            for (Integer key : tm.keySet()) {

                int value = tm.get(key);
                //     while (aux1 != 1) {
                //  System.out.println("valie=tm.get(key)= "+value);
                if (funf == value) {
                    //    System.out.println("entro a condicion");
                    llavefin = key;
                    break;
                    //aux1=1;
                    //  System.out.println("llave= "+tm.get(key));
                }

            }
////////////////////////////////////////////////////////////////////////////////////////////////primer resultado
            //   System.out.println("K menor: " + llavefin);
            System.out.println(llavefin);
//crea la tabla hash con k menor
            H1 = new SeparateChainingHashTable<>();
            for (int j = 0; j < numeros.length; j++) {
                H1.insert(numeros[j], llavefin);

            }
//crea un Linkedlist de listas de numeros colisionados ordenados de menor a mayor
            for (int i = 0; i < H1.theLists.length; i++) {
                if (H1.theLists[i].size() > 1) {
                   BinaryHeap<Integer> h = new BinaryHeap<>();
                    for (int j = 0; j < H1.theLists[i].size(); j++) {
                        int val = H1.theLists[i].get(j);
                        h.insert(val);
                    }
                    lista = new MyLinkedList<>();
                    while(!h.isEmpty()){
                      int min=  h.getMin();
                    lista.add(min);
                    h.deleteMin();
                    }
                   

                    listacolisiones.add(lista);
                }

            }
//Halla el numero de colisiones
            int sum = 0;
             for (int i = 0; i < listacolisiones.size(); i++) {
             int por = listacolisiones.get(i).size() - 1;
             sum = sum + por;

             }

            //////////////////////////////////////////////////////////////////////////////////////segundo resultado
            System.out.println(sum);
//impresion con el menor primer numero
            int aux = 0;
            int b = 0;

            for (int i = 0; i < listacolisiones.size(); i++) {

                lista2 = listacolisiones.get(i);
                int ini = lista2.get(0);
                tm2.put(ini, i);
            }
            listaindices = new MyLinkedList<>();
            for (Map.Entry<Integer, Integer> entry : tm2.entrySet()) {
                //  System.out.println("key: "+entry.getKey()+" "+"value: "+entry.getValue());
                int valu = entry.getValue();
                listaindices.add(valu);
                //    System.out.println("valu: "+valu);
            }
            //  System.out.println("listaindices: "+listaindices.toString());
            // for (int i = 0; i < listacolisiones.size(); i++) {

            for (int j = 0; j < listaindices.size(); j++) {
                int indi = listaindices.get(j);
                if (listacolisiones.size() > 0) {
                    ////////////////////////////////////////////////////////////////////////tercer resultado
                    System.out.println(listacolisiones.get(indi).toString());
                    // }
                    // }
                }
            }

        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;

    }

    public static class SeparateChainingHashTable<AnyType> {

        /**
         * Construct the hash table.
         */
        public SeparateChainingHashTable() {
            this(DEFAULT_TABLE_SIZE);
        }

        /**
         * Construct the hash table.
         *
         * @param size approximate table size.
         */
        public SeparateChainingHashTable(int size) {
            theLists = new LinkedList[nextPrime(size)];
            for (int i = 0; i < theLists.length; i++) {
                theLists[i] = new LinkedList<>();
            }
        }

        /**
         * Insert into the hash table. If the item is already present, then do
         * nothing.
         *
         * @param x the item to insert.
         */
        
        public void insert(AnyType x, int funcion) {
            List<AnyType> whichList = theLists[myhash(x, funcion)];

            if (!whichList.contains(x)) {
                whichList.add(x);
            
                // Rehash; see Section 5.5
                if (++currentSize > theLists.length) {
                    rehash();
                }
            }else{
                whichList.add(x);
               
            }
         

        }

        public int ColisionMayor(SeparateChainingHashTable H) {
            int col = 0;

            for (int i = 0; i < H.theLists.length; i++) {

                if (H.theLists[i].size() > 1) {
                    int tam = H.theLists[i].size();
                    col = col + tam;
                }

            }
            return col;
        }

        public void insert(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];

            if (!whichList.contains(x)) {
                whichList.add(x);

                // Rehash; see Section 5.5
                if (++currentSize > theLists.length) {
                    rehash();
                }

            }

        }

        /**
         * Remove from the hash table.
         *
         * @param x the item to remove.
         */
        public void remove(AnyType x, int funcion) {
            List<AnyType> whichList = theLists[myhash(x, funcion)];
            if (whichList.contains(x)) {
                whichList.remove(x);
                currentSize--;
            }
        }

        /**
         * Find an item in the hash table.
         *
         * @param x the item to search for.
         * @return true if x is found.
         */
        public boolean contains(AnyType x, int funcion) {
            List<AnyType> whichList = theLists[myhash(x, funcion)];
            return whichList.contains(x);
        }

        /**
         * Make the hash table logically empty.
         */
        public void makeEmpty() {
            for (int i = 0; i < theLists.length; i++) {
                theLists[i].clear();
            }
            currentSize = 0;
        }

        /**
         * A hash routine for String objects.
         *
         * @param key the String to hash.
         * @param tableSize the size of the hash table.
         * @return the hash value.
         */
        public int hash(String key, int tableSize) {
            int hashVal = 0;

            for (int i = 0; i < key.length(); i++) {
                hashVal = 37 * hashVal + key.charAt(i);
            }

            hashVal %= tableSize;
            if (hashVal < 0) {
                hashVal += tableSize;
            }

            return hashVal;
        }

        private void rehash() {
            List<AnyType>[] oldLists = theLists;

            // Create new double-sized, empty table
            theLists = new List[nextPrime(2 * theLists.length)];
            for (int j = 0; j < theLists.length; j++) {
                theLists[j] = new LinkedList<>();
            }

            // Copy table over
            currentSize = 0;
            for (List<AnyType> list : oldLists) {
                for (AnyType item : list) {
                    insert(item);
                }
            }
        }

        public int myhash(AnyType x, int funcion) {
            int hashVal = x.hashCode();
            int k = funcion;
            //   System.out.println("es el myhash: " + x.hashCode());
            //  System.out.println("theList.length: " + theLists.length);
            hashVal %= funcion;
            // System.out.println("es el hashval: " + hashVal);
            if (hashVal < 0) {
                hashVal += funcion;
            }

            return hashVal;
        }

        public int myhash(AnyType x) {
            int hashVal = x.hashCode();

            hashVal %= theLists.length;

            if (hashVal < 0) {
                hashVal += theLists.length;
            }

            return hashVal;
        }

        private static final int DEFAULT_TABLE_SIZE = 101;

        /**
         * The array of Lists.
         */
        private List<AnyType>[] theLists;
        private int currentSize;
     

        /**
         * Internal method to find a prime number at least as large as n.
         *
         * @param n the starting number (must be positive).
         * @return a prime number larger than or equal to n.
         */
        @SuppressWarnings("empty-statement")
        private int nextPrime(int n) {
            if (n % 2 == 0) {
                n++;
            }

            for (; !isPrime(n); n += 2)
            ;

            return n;
        }

        /**
         * Internal method to test if a number is prime. Not an efficient
         * algorithm.
         *
         * @param n the number to test.
         * @return the result of the test.
         */
        private boolean isPrime(int n) {
            if (n == 2 || n == 3) {
                return true;
            }

            if (n == 1 || n % 2 == 0) {
                return false;
            }

            for (int i = 3; i * i <= n; i += 2) {
                if (n % i == 0) {
                    return false;
                }
            }

            return true;
        }

    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x + " ");
            }

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }
  public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

        /**
         * Construct the binary heap.
         */
        public BinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        /**
         * Construct the binary heap.
         *
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        /**
         * Construct the binary heap given an array of items.
         *
         * @param items
         */
        public BinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        /**
         * Insert into the priority queue, maintaining heap order. Duplicates
         * are allowed.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }

            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public AnyType getMin() {

            return array[1];
        }

        /**
         * Find the smallest item in the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        /**
         * Remove the smallest item from the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }

            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary arrangement of items.
         * Runs in linear time.
         */
        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        /**
         * Test if the priority queue is logically empty.
         *
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty() {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty() {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType[] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         *
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];

            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize
                        && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }

    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemab6;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 */
public class ProblemaB6 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("B_2.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("B_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            int comllevar = 0;
            LinkedHashMap<Integer, Integer> H = new LinkedHashMap<>();
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {
                String m = (in.readLine());
                int[] r = readInts(m, 2);
                if (H.containsKey(r[0])) {
                    int cantidad = H.get(r[0]);
                    H.put(r[0], cantidad + 1);

                } else {
                    H.put(r[0], 1);
                }

                if (H.containsKey(r[1])) {
                    if(H.get(r[1])==0){
                        comllevar++;
                    }else{
                    int cantidad1 = H.get(r[1]);
                    H.put(r[1], cantidad1 - 1);
                    }
                }else{
                comllevar++;
                }

                
            }System.out.println(comllevar);
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;
    }


    public static class SeparateChainingHashTable<AnyType> {

        /**
         * Construct the hash table.
         */
        public SeparateChainingHashTable() {
            this(DEFAULT_TABLE_SIZE);
        }

        /**
         * Construct the hash table.
         *
         * @param size approximate table size.
         */
        public SeparateChainingHashTable(int size) {
            theLists = new LinkedList[nextPrime(size)];
            for (int i = 0; i < theLists.length; i++) {
                theLists[i] = new LinkedList<>();
            }
        }

        /**
         * Insert into the hash table. If the item is already present, then do
         * nothing.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            if (!whichList.contains(x)) {
                whichList.add(x);

                // Rehash; see Section 5.5
                if (++currentSize > theLists.length) {
                    rehash();
                }
            }
        }

        /**
         * Remove from the hash table.
         *
         * @param x the item to remove.
         */
        public void remove(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            if (whichList.contains(x)) {
                whichList.remove(x);
                currentSize--;
            }
        }

        /**
         * Find an item in the hash table.
         *
         * @param x the item to search for.
         * @return true if x is found.
         */
        public boolean contains(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            return whichList.contains(x);
        }

        /**
         * Make the hash table logically empty.
         */
        public void makeEmpty() {
            for (int i = 0; i < theLists.length; i++) {
                theLists[i].clear();
            }
            currentSize = 0;
        }

        /**
         * A hash routine for String objects.
         *
         * @param key the String to hash.
         * @param tableSize the size of the hash table.
         * @return the hash value.
         */
        public int hash(String key, int tableSize) {
            int hashVal = 0;

            for (int i = 0; i < key.length(); i++) {
                hashVal = 37 * hashVal + key.charAt(i);
            }

            hashVal %= tableSize;
            if (hashVal < 0) {
                hashVal += tableSize;
            }

            return hashVal;
        }

        private void rehash() {
            List<AnyType>[] oldLists = theLists;

            // Create new double-sized, empty table
            theLists = new List[nextPrime(2 * theLists.length)];
            for (int j = 0; j < theLists.length; j++) {
                theLists[j] = new LinkedList<>();
            }

            // Copy table over
            currentSize = 0;
            for (List<AnyType> list : oldLists) {
                for (AnyType item : list) {
                    insert(item);
                }
            }
        }

        public int myhash(AnyType x) {
            int hashVal = x.hashCode();

            hashVal %= theLists.length;
            if (hashVal < 0) {
                hashVal += theLists.length;
            }

            return hashVal;
        }

        private static final int DEFAULT_TABLE_SIZE = 101;

        /**
         * The array of Lists.
         */
        private List<AnyType>[] theLists;
        private int currentSize;

        /**
         * Internal method to find a prime number at least as large as n.
         *
         * @param n the starting number (must be positive).
         * @return a prime number larger than or equal to n.
         */
        @SuppressWarnings("empty-statement")
        private int nextPrime(int n) {
            if (n % 2 == 0) {
                n++;
            }

            for (; !isPrime(n); n += 2)
            ;

            return n;
        }

        /**
         * Internal method to test if a number is prime. Not an efficient
         * algorithm.
         *
         * @param n the number to test.
         * @return the result of the test.
         */
        private boolean isPrime(int n) {
            if (n == 2 || n == 3) {
                return true;
            }

            if (n == 1 || n % 2 == 0) {
                return false;
            }

            for (int i = 3; i * i <= n; i += 2) {
                if (n % i == 0) {
                    return false;
                }
            }

            return true;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemac6;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaC6 {

    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("C_1.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("C_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            String m = (in.readLine());
            int[] r = readInts(m, 3);
            String num = (in.readLine());
            int[] numerosNorma = readInts(num, r[0]);
            String mun = (in.readLine());
            int[] numerosMario = readInts(mun, r[1]);
            String pun = (in.readLine());
            int[] numerosPipe = readInts(pun, r[2]);

            TreeMap<Integer, Integer> tmNorma = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tmMario = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tmPipe = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tmTam = new TreeMap<Integer, Integer>();

            MyLinkedList<Integer> lista1 = new MyLinkedList<>();
            MyLinkedList<Integer> lista2 = new MyLinkedList<>();
            MyLinkedList<Integer> lista3 = new MyLinkedList<>();
            MyLinkedList<Integer> lista5 = new MyLinkedList<>();
            MyLinkedList<Integer> lista6 = new MyLinkedList<>();
            MyLinkedList<MyLinkedList> lista4 = new MyLinkedList<>();

            for (int i = 0; i < numerosNorma.length; i++) {
                tmNorma.put(numerosNorma[i], 1);
            }
            for (int j = 0; j < numerosMario.length; j++) {
                tmMario.put(numerosMario[j], 2);
            }
            for (int k = 0; k < numerosPipe.length; k++) {
                tmPipe.put(numerosPipe[k], 3);

            }
////////////////////////////comparo treemaps
//            System.out.println("numeros Norma= " + numerosNorma.length);
            Set<Map.Entry<Integer, Integer>> set = tmNorma.entrySet();
            //System.out.println("TreeMap:");
            for (Map.Entry<Integer, Integer> me : set) {
                int value = me.getKey();
                lista1.add(value);

            }
            for (int i = 0; i < lista1.size(); i++) {

                if (tmMario.containsKey(lista1.get(i))) {
                    tmNorma.remove(lista1.get(i));
                    tmMario.remove(lista1.get(i));
                }
                if (tmPipe.containsKey(lista1.get(i))) {
                    tmNorma.remove(lista1.get(i));
                    tmPipe.remove(lista1.get(i));

                }
            }

//            System.out.println("longitud1= " + tmNorma.size());
//            System.out.println("lista1= " + lista1.toString());
            //       System.out.println("com mario y pipe");
            //     System.out.println("tam tmMario= " + tmMario.size());
            //   System.out.println("tam tmPipe= " + tmPipe.size());
//            System.out.println("numeros Mario= " + numerosMario.length);
            Set<Map.Entry<Integer, Integer>> set2 = tmMario.entrySet();
            //System.out.println("TreeMap:");
            for (Map.Entry<Integer, Integer> pe : set2) {
                int value = pe.getKey();
                lista2.add(value);

            }
            //System.out.println("tam lista12= " + lista2.toString());
//            System.out.println("numeros Pipe= " + numerosPipe.length);
            for (int i = 0; i < lista2.size(); i++) {

                if (tmPipe.containsKey(lista2.get(i))) {
                    //        System.out.println("entro a condicion de remove");
                    tmMario.remove(lista2.get(i));

                    //      System.out.println("longitud2= " + tmMario.size());
                    tmPipe.remove(lista2.get(i));
                    //    System.out.println("longitud3= " + tmPipe.size());
                }

            }
//            System.out.println("longitud2= " + tmMario.size());
//            System.out.println("longitud3= " + tmPipe.size());
///////////////////////////////////////////////////////////determinar los mayores
            //    Set<Map.Entry<Integer, Integer>> set1 = tmNorma.entrySet();
            lista1.clear();
            for (Map.Entry<Integer, Integer> me : set) {
                int value = me.getKey();
//                System.out.println("key= " + value);
                lista1.add(value);
//                System.out.println("adiciono");

            }

//            System.out.println("lista1= " + lista1.toString());
            lista2.clear();
            for (Map.Entry<Integer, Integer> pe : set2) {
                int value = pe.getKey();
//                System.out.println("key= " + value);
                lista2.add(value);
//                System.out.println("adiciono");

            }
            Set<Map.Entry<Integer, Integer>> set3 = tmPipe.entrySet();
            lista3.clear();
            for (Map.Entry<Integer, Integer> pi : set3) {
                int value = pi.getKey();
//                System.out.println("key= " + value);
                lista3.add(value);
//                System.out.println("adiciono");

            }
            int tam1 = tmNorma.size();
            int tam2 = tmMario.size();
            int tam3 = tmPipe.size();

            //     tmTam.put(1, tam1);
            //   tmTam.put(2, tam2);
            // tmTam.put(3, tam3);
            if ((tam1 >= tam2) && (tam1 >= tam3)) {
                System.out.println("Norma" + " " + tam1 + " " + lista1.toString());
            }
            if ((tam2 >= tam1) && (tam2 >= tam3)) {
                System.out.println("Mario" + " " + tam2 + " " + lista2.toString());
            }
            if ((tam3 >= tam1) && (tam3 >= tam2)) {
                System.out.println("Pipe" + " " + tam3 + " " + lista3.toString());
            }
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x + " ");
            }

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad6;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaD6 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {

        BufferedReader in;
        File f = new File("D_1.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("D_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            TreeMap<String, String> tm1 = new TreeMap<String, String>();
            TreeMap<String, Integer> tm2 = new TreeMap<String, Integer>();
            TreeMap<String, Integer> tm3 = new TreeMap<String, Integer>();
            MyLinkedList<String> lista = new MyLinkedList<>();
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {
                String m = (in.readLine());
                String split[] = m.split(" ");
                tm1.put(split[0], split[1]);
                tm2.put(split[1], 0);
                lista.add(split[1]);

            }
//          System.out.println("lista de partidos: "+lista.toString());
            int v = Integer.parseInt(in.readLine());
//            System.out.println("cant votos: "+v);
            for (int i = 0; i < v; i++) {
                String voto = (in.readLine());
                if (tm1.containsKey(voto)) {
                    String partido = tm1.get(voto);
                    tm2.put(partido, (tm2.get(partido) + 1));
                }

            }
            
        /*     Set<Map.Entry<String, Integer>> set = tm2.entrySet();
            //System.out.println("TreeMap:");
            for (Map.Entry<String, Integer> me : set) {
              System.out.println("Votos= "+me.getKey()+" "+me.getValue());
            }*/
           
          

            int i = 1;
            int pos = 0;
            if((lista.size()>1)){
            while (i < lista.size()) {
//                System.out.println("Entro a while");
                String posi= lista.get(pos);
//                System.out.println("posi= "+posi );
                
                int d = tm2.get(posi);
//                System.out.println("d= "+d);
//                System.out.println("i= "+i);
                String posi2=lista.get(i);
//                System.out.println("posi2= "+lista.get(i));
                int g = tm2.get(lista.get(i));
//                System.out.println("g= "+g);

                if (d < g) {
//                    System.out.println("d<g");
                    tm3.clear();
                    tm3.put(posi2, g);
//                    System.out.println("agrega g a tm3");
                    pos = i;
                    i++;

                }
                if (d > g) {
//                    System.out.println("d>g");
                tm3.put(posi, d);
//                    System.out.println("agrego d tm3");
                    i++;
                }
                if(d==g){
                       tm3.put(posi2, g);
                i++;
                }
            }
           
//                System.out.println("salio del while");
            }else{
               int unico= tm2.get(lista.get(0));
                    tm3.put(lista.get(0), unico);
                    }
                   Set<Map.Entry<String, Integer>> set = tm3.entrySet();
            for (Map.Entry<String, Integer> me : set) {
                System.out.println(me.getKey());
            }
            lista.clear();
            tm3.clear();
            

        }
    }

    public static Character[] readLine(String s, int n) {

        Character arr[] = new Character[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = s.charAt(i);
        }

        return arr;
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x + " ");
            }

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemae6.pkg3;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaE63 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("E_13.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("E_13.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            int comllevar = 0;
            int cont = 1;
            LinkedHashMap<Integer, Integer> H = new LinkedHashMap<>();
            TreeMap<Integer, Integer> tm1 = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tm2 = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tm3 = new TreeMap<Integer, Integer>();
            MyLinkedList<Integer> lista = new MyLinkedList<>();
            MyLinkedList<Integer> lista1 = new MyLinkedList<>();
            MyLinkedList<Integer> lista2 = new MyLinkedList<>();
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {
                String m = (in.readLine());
                int[] r = readInts(m, 2);
                if (H.containsKey(r[0])) {
                    int cantidad = H.get(r[0]);
                    H.put(r[0], cantidad + 1);

                } else {
                    H.put(r[0], 1);
                }

                if (H.containsKey(r[1])) {

//                    System.out.println("entro a valor de llave contenida en H= " + r[1]);
                    if (H.get(r[1]) == 0) {
//                       System.out.println("entro a valor de llave =0");
//                        System.out.println("valor anterior de llave en H= " + H.get(r[1]));

//                        System.out.println("valor de llave despues de agregar a tm1= " + tm1.get(r[1]));
                        comllevar++;
                        if (tm1.containsKey(r[1])) {
//                            System.out.println("entro a que si esta contenido en tm1");
//                            System.out.println("tm1.get(r[1]= "+tm1.get(r[1]));
                            int valor = tm1.get(r[1]) + 1;
//                            System.out.println("tm1.get(r[1]+1=  " + valor);
                            tm1.put(r[1], (valor));
                        }
                        if (!tm1.containsKey(r[1])) {
//                            System.out.println("entro a que no esta contenida");
                            tm1.put(r[1], 1);
//                            System.out.println("la agrego con valor = "+tm1.get(r[1]));
                        }

                    } else {
//                        System.out.println("si esta contenida y No es 0 no agrego a tm1");
                        int cantidad1 = H.get(r[1]);
//                        System.out.println("valor de llave antes= " + cantidad1);
                        H.put(r[1], (cantidad1 - 1));
                        //    System.out.println("valor de llave");
                        //   cont--;
                    }
                } else {
//                     System.out.println("entro a valor de llave NO contenida en H= " + r[1]);
//                    System.out.println("no esta la llave contenida");
                    if (tm1.containsKey(r[1])) {
//                            System.out.println("entro a que si esta contenido en tm1");
//                            System.out.println("tm1.get(r[1]= "+tm1.get(r[1]));
                        int valor = tm1.get(r[1]) + 1;
////                            System.out.println("tm1.get(r[1]+1=  " + valor);
                        tm1.put(r[1], (valor));
                    }

                    if (!tm1.containsKey(r[1])) {
//                    System.out.println("agrego a tm1 la llave= " + r[1] + "con valor de= " + 1);

                        tm1.put(r[1], 1);

                    }

                    comllevar++;
                }
//                System.out.println("otro dato:");
            }
            // System.out.println(comllevar);
            Set<Map.Entry<Integer, Integer>> set0 = tm1.entrySet();
            for (Map.Entry<Integer, Integer> me : set0) {
                int key = me.getKey();
                lista.add(key);
            }

            int i = 1;
            int pos = 0;
            if ((lista.size() > 1)) {
                while (i < lista.size()) {
//                System.out.println("Entro a while");
                    int posi = lista.get(pos);
//                System.out.println("posi= "+posi );

                    int d = tm1.get(posi);
//                System.out.println("d= "+d);
//                System.out.println("i= "+i);
                    int posi2 = lista.get(i);
//                System.out.println("posi2= "+lista.get(i));
                    int g = tm1.get(lista.get(i));
//                System.out.println("g= "+g);

                    if (d < g) {
//                    System.out.println("d<g");
                        tm2.clear();
                        tm2.put(posi2, g);
//                    System.out.println("agrega g a tm3");
                        pos = i;
                        i++;

                    }
                    if (d > g) {
//                    System.out.println("d>g");
                        tm2.put(posi, d);
//                    System.out.println("agrego d tm3");
                        i++;
                    }
                    if (d == g) {
                        if(!tm2.containsKey(posi)){
                        tm2.put(posi, d);
                        }
                        tm2.put(posi2, g);
                        i++;
                    }
                }

            } else {
                int unico = tm1.get(lista.get(0));
                tm2.put(lista.get(0), unico);
            }
            lista1.clear();
            Set<Map.Entry<Integer, Integer>> set = tm2.entrySet();
            for (Map.Entry<Integer, Integer> me : set) {
           //     System.out.println(me.getKey()+" "+me.getValue());
                lista1.add(me.getKey());
            }
///////////////////////////////////////////
            if (lista1.size() > 0) {
                System.out.println(tm2.get(lista1.get(0)) + " " + lista1.get(0));
            }
           // lista.clear();
        /*    Set<Map.Entry<Integer, Integer>> set5 = tm1.entrySet();
            for (Map.Entry<Integer, Integer> me : set5) {
                int key = me.getKey();
                lista.add(key);
            }*/

            /////////////////////////////////////////////////////////
            int j = 1;
            int pos1 = 0;
            if ((lista.size() > 1)) {

                while (j < lista.size()) {
//                System.out.println("Entro a while");
                    int posi = lista.get(pos1);
//                System.out.println("posi= "+posi );
                    //   if (tm1.containsKey(posi)) {
                    int d = tm1.get(posi);
//                System.out.println("d= "+d);
//                System.out.println("i= "+i);
                    int posi2 = lista.get(j);
//                System.out.println("posi2= "+lista.get(i));
                    int g = tm1.get(lista.get(j));
//                System.out.println("g= "+g);

                    if (d < g) {
//                    System.out.println("d<g");

                        tm3.put(posi, d);
//                    System.out.println("agrega g a tm3");
                        //pos1 = j;
                        j++;

                    }
                    if (d > g) {
//                    System.out.println("d>g");
                        tm3.clear();
                        tm3.put(posi2, g);
//                    System.out.println("agrego d tm3");
                        j++;
                        pos1 = j;
                    }
                    if (d == g) {
                        if(!tm3.containsKey(posi)){
                        tm3.put(posi, d);
                        }
                        tm3.put(posi2, d);
                        j++;
                    }
                } //else {

                //j++;
                //}
            } else {
                int unico = tm1.get(lista.get(0));
                tm3.put(lista.get(0), unico);
            }

            lista2.clear();
            Set<Map.Entry<Integer, Integer>> set1 = tm3.entrySet();
            for (Map.Entry<Integer, Integer> me : set1) {

                lista2.add(me.getKey());

            }
            if (lista1.size() > 0) {
                System.out.println(tm3.get(lista2.get(0)) + " " + lista2.get(0));
            }

            if ((lista1.isEmpty()) && (lista2.isEmpty())){
                System.out.println("-1");
            }

            lista.clear();
            tm3.clear();
            tm2.clear();
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;
    }

    public static class SeparateChainingHashTable<AnyType> {

        /**
         * Construct the hash table.
         */
        public SeparateChainingHashTable() {
            this(DEFAULT_TABLE_SIZE);
        }

        /**
         * Construct the hash table.
         *
         * @param size approximate table size.
         */
        public SeparateChainingHashTable(int size) {
            theLists = new LinkedList[nextPrime(size)];
            for (int i = 0; i < theLists.length; i++) {
                theLists[i] = new LinkedList<>();
            }
        }

        /**
         * Insert into the hash table. If the item is already present, then do
         * nothing.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            if (!whichList.contains(x)) {
                whichList.add(x);

                // Rehash; see Section 5.5
                if (++currentSize > theLists.length) {
                    rehash();
                }
            }
        }

        /**
         * Remove from the hash table.
         *
         * @param x the item to remove.
         */
        public void remove(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            if (whichList.contains(x)) {
                whichList.remove(x);
                currentSize--;
            }
        }

        /**
         * Find an item in the hash table.
         *
         * @param x the item to search for.
         * @return true if x is found.
         */
        public boolean contains(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            return whichList.contains(x);
        }

        /**
         * Make the hash table logically empty.
         */
        public void makeEmpty() {
            for (int i = 0; i < theLists.length; i++) {
                theLists[i].clear();
            }
            currentSize = 0;
        }

        /**
         * A hash routine for String objects.
         *
         * @param key the String to hash.
         * @param tableSize the size of the hash table.
         * @return the hash value.
         */
        public int hash(String key, int tableSize) {
            int hashVal = 0;

            for (int i = 0; i < key.length(); i++) {
                hashVal = 37 * hashVal + key.charAt(i);
            }

            hashVal %= tableSize;
            if (hashVal < 0) {
                hashVal += tableSize;
            }

            return hashVal;
        }

        private void rehash() {
            List<AnyType>[] oldLists = theLists;

            // Create new double-sized, empty table
            theLists = new List[nextPrime(2 * theLists.length)];
            for (int j = 0; j < theLists.length; j++) {
                theLists[j] = new LinkedList<>();
            }

            // Copy table over
            currentSize = 0;
            for (List<AnyType> list : oldLists) {
                for (AnyType item : list) {
                    insert(item);
                }
            }
        }

        public int myhash(AnyType x) {
            int hashVal = x.hashCode();

            hashVal %= theLists.length;
            if (hashVal < 0) {
                hashVal += theLists.length;
            }

            return hashVal;
        }

        private static final int DEFAULT_TABLE_SIZE = 101;

        /**
         * The array of Lists.
         */
        private List<AnyType>[] theLists;
        private int currentSize;

        /**
         * Internal method to find a prime number at least as large as n.
         *
         * @param n the starting number (must be positive).
         * @return a prime number larger than or equal to n.
         */
        @SuppressWarnings("empty-statement")
        private int nextPrime(int n) {
            if (n % 2 == 0) {
                n++;
            }

            for (; !isPrime(n); n += 2)
            ;

            return n;
        }

        /**
         * Internal method to test if a number is prime. Not an efficient
         * algorithm.
         *
         * @param n the number to test.
         * @return the result of the test.
         */
        private boolean isPrime(int n) {
            if (n == 2 || n == 3) {
                return true;
            }

            if (n == 1 || n % 2 == 0) {
                return false;
            }

            for (int i = 3; i * i <= n; i += 2) {
                if (n % i == 0) {
                    return false;
                }
            }

            return true;
        }
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x + " ");
            }

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemae6.pkg3;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaE63 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("E_13.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("E_13.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;
 int cantidad=0;
        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            int comllevar = 0;
            int cont = 1;
            LinkedHashMap<Integer, Integer> H = new LinkedHashMap<>();
            TreeMap<Integer, Integer> tm1 = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tm2 = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tm3 = new TreeMap<Integer, Integer>();
            MyLinkedList<Integer> lista = new MyLinkedList<>();
            MyLinkedList<Integer> lista1 = new MyLinkedList<>();
            MyLinkedList<Integer> lista2 = new MyLinkedList<>();
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {
                String m = (in.readLine());
                int[] r = readInts(m, 2);
                if (H.containsKey(r[0])) {
                   cantidad = H.get(r[0]);
                    H.put(r[0], cantidad + 1);

                } else {
                    H.put(r[0], 1);
                }

                if (H.containsKey(r[1])) {

//                    System.out.println("entro a valor de llave contenida en H= " + r[1]);
                    if (H.get(r[1]) == 0) {
//                       System.out.println("entro a valor de llave =0");
//                        System.out.println("valor anterior de llave en H= " + H.get(r[1]));

//                        System.out.println("valor de llave despues de agregar a tm1= " + tm1.get(r[1]));
                       // comllevar++;
                        if (tm1.containsKey(r[1])) {
//                            System.out.println("entro a que si esta contenido en tm1");
//                            System.out.println("tm1.get(r[1]= "+tm1.get(r[1]));
                            int valor = tm1.get(r[1]) + 1;
//                            System.out.println("tm1.get(r[1]+1=  " + valor);
                            tm1.put(r[1], (valor));
                        }
                        if (!tm1.containsKey(r[1])) {
//                            System.out.println("entro a que no esta contenida");
                            tm1.put(r[1], 1);
//                            System.out.println("la agrego con valor = "+tm1.get(r[1]));
                        }

                    } else {
//                        System.out.println("si esta contenida y No es 0 no agrego a tm1");
                        int cantidad1 = H.get(r[1]);
//                        System.out.println("valor de llave antes= " + cantidad1);
                        H.put(r[1], (cantidad1 - 1));
                        //    System.out.println("valor de llave");
                        //   cont--;
                    }
                } else {
//                     System.out.println("entro a valor de llave NO contenida en H= " + r[1]);
//                    System.out.println("no esta la llave contenida");
                    if (tm1.containsKey(r[1])) {
//                            System.out.println("entro a que si esta contenido en tm1");
//                            System.out.println("tm1.get(r[1]= "+tm1.get(r[1]));
                        int valor = tm1.get(r[1]) + 1;
////                            System.out.println("tm1.get(r[1]+1=  " + valor);
                        tm1.put(r[1], (valor));
                    }

                    if (!tm1.containsKey(r[1])) {
//                    System.out.println("agrego a tm1 la llave= " + r[1] + "con valor de= " + 1);

                        tm1.put(r[1], 1);

                    }

                  //  comllevar++;
                }
//                System.out.println("otro dato:");
            }
            // System.out.println(comllevar);
            Set<Map.Entry<Integer, Integer>> set0 = tm1.entrySet();
            for (Map.Entry<Integer, Integer> me : set0) {
                System.out.println("key"+me.getKey()+" "+"valor"+me.getValue());
                int key = me.getKey();
                lista.add(key);
            }

            int i = 1;
            int pos = 0;
            if ((lista.size() > 1)) {
                while (i < lista.size()) {
//                System.out.println("Entro a while");
                    int posi = lista.get(pos);
//                System.out.println("posi= "+posi );

                    int d = tm1.get(posi);
//                System.out.println("d= "+d);
//                System.out.println("i= "+i);
                    int posi2 = lista.get(i);
//                System.out.println("posi2= "+lista.get(i));
                    int g = tm1.get(lista.get(i));
//                System.out.println("g= "+g);

                    if (d < g) {
//                    System.out.println("d<g");
                        tm2.clear();
                        tm2.put(posi2, g);
//                    System.out.println("agrega g a tm3");
                        pos = i;
                        i++;

                    }
                    if (d > g) {
//                    System.out.println("d>g");
                        tm2.put(posi, d);
//                    System.out.println("agrego d tm3");
                        i++;
                    }
                    if (d == g) {
                        if(!tm2.containsKey(posi)){
                        tm2.put(posi, d);
                        }
                        tm2.put(posi2, g);
                        i++;
                    }
                }

            } else {
                int unico = tm1.get(lista.get(0));
                tm2.put(lista.get(0), unico);
            }
            lista1.clear();
            Set<Map.Entry<Integer, Integer>> set = tm2.entrySet();
            for (Map.Entry<Integer, Integer> me : set) {
           //     System.out.println(me.getKey()+" "+me.getValue());
                lista1.add(me.getKey());
            }
///////////////////////////////////////////
            if (lista1.size() > 0) {
                System.out.println(tm2.get(lista1.get(0)) + " " + lista1.get(0));
            }
           // lista.clear();
        /*    Set<Map.Entry<Integer, Integer>> set5 = tm1.entrySet();
            for (Map.Entry<Integer, Integer> me : set5) {
                int key = me.getKey();
                lista.add(key);
            }*/

            /////////////////////////////////////////////////////////
            int j = 1;
            int pos1 = 0;
            if ((lista.size() > 1)) {

                while (j < lista.size()) {
//                System.out.println("Entro a while");
                    int posi = lista.get(pos1);
//                System.out.println("posi= "+posi );
                    //   if (tm1.containsKey(posi)) {
                    int d = tm1.get(posi);
//                System.out.println("d= "+d);
//                System.out.println("i= "+i);
                    int posi2 = lista.get(j);
//                System.out.println("posi2= "+lista.get(i));
                    int g = tm1.get(lista.get(j));
//                System.out.println("g= "+g);

                    if (d < g) {
//                    System.out.println("d<g");

                        tm3.put(posi, d);
//                    System.out.println("agrega g a tm3");
                        //pos1 = j;
                        j++;

                    }
                    if (d > g) {
//                    System.out.println("d>g");
                        tm3.clear();
                        tm3.put(posi2, g);
//                    System.out.println("agrego d tm3");
                        j++;
                        pos1 = j;
                    }
                    if (d == g) {
                        if(!tm3.containsKey(posi)){
                        tm3.put(posi, d);
                        }
                        tm3.put(posi2, d);
                        j++;
                    }
                } //else {

                //j++;
                //}
            } else {
                int unico = tm1.get(lista.get(0));
                tm3.put(lista.get(0), unico);
            }

            lista2.clear();
            Set<Map.Entry<Integer, Integer>> set1 = tm3.entrySet();
            for (Map.Entry<Integer, Integer> me : set1) {

                lista2.add(me.getKey());

            }
            if (lista1.size() > 0) {
                System.out.println(tm3.get(lista2.get(0)) + " " + lista2.get(0));
            }

            if ((lista1.isEmpty()) && (lista2.isEmpty())){
                System.out.println("-1");
            }

            lista.clear();
            tm3.clear();
            tm2.clear();
            cantidad=0;
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;
    }

    public static class SeparateChainingHashTable<AnyType> {

        /**
         * Construct the hash table.
         */
        public SeparateChainingHashTable() {
            this(DEFAULT_TABLE_SIZE);
        }

        /**
         * Construct the hash table.
         *
         * @param size approximate table size.
         */
        public SeparateChainingHashTable(int size) {
            theLists = new LinkedList[nextPrime(size)];
            for (int i = 0; i < theLists.length; i++) {
                theLists[i] = new LinkedList<>();
            }
        }

        /**
         * Insert into the hash table. If the item is already present, then do
         * nothing.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            if (!whichList.contains(x)) {
                whichList.add(x);

                // Rehash; see Section 5.5
                if (++currentSize > theLists.length) {
                    rehash();
                }
            }
        }

        /**
         * Remove from the hash table.
         *
         * @param x the item to remove.
         */
        public void remove(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            if (whichList.contains(x)) {
                whichList.remove(x);
                currentSize--;
            }
        }

        /**
         * Find an item in the hash table.
         *
         * @param x the item to search for.
         * @return true if x is found.
         */
        public boolean contains(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            return whichList.contains(x);
        }

        /**
         * Make the hash table logically empty.
         */
        public void makeEmpty() {
            for (int i = 0; i < theLists.length; i++) {
                theLists[i].clear();
            }
            currentSize = 0;
        }

        /**
         * A hash routine for String objects.
         *
         * @param key the String to hash.
         * @param tableSize the size of the hash table.
         * @return the hash value.
         */
        public int hash(String key, int tableSize) {
            int hashVal = 0;

            for (int i = 0; i < key.length(); i++) {
                hashVal = 37 * hashVal + key.charAt(i);
            }

            hashVal %= tableSize;
            if (hashVal < 0) {
                hashVal += tableSize;
            }

            return hashVal;
        }

        private void rehash() {
            List<AnyType>[] oldLists = theLists;

            // Create new double-sized, empty table
            theLists = new List[nextPrime(2 * theLists.length)];
            for (int j = 0; j < theLists.length; j++) {
                theLists[j] = new LinkedList<>();
            }

            // Copy table over
            currentSize = 0;
            for (List<AnyType> list : oldLists) {
                for (AnyType item : list) {
                    insert(item);
                }
            }
        }

        public int myhash(AnyType x) {
            int hashVal = x.hashCode();

            hashVal %= theLists.length;
            if (hashVal < 0) {
                hashVal += theLists.length;
            }

            return hashVal;
        }

        private static final int DEFAULT_TABLE_SIZE = 101;

        /**
         * The array of Lists.
         */
        private List<AnyType>[] theLists;
        private int currentSize;

        /**
         * Internal method to find a prime number at least as large as n.
         *
         * @param n the starting number (must be positive).
         * @return a prime number larger than or equal to n.
         */
        @SuppressWarnings("empty-statement")
        private int nextPrime(int n) {
            if (n % 2 == 0) {
                n++;
            }

            for (; !isPrime(n); n += 2)
            ;

            return n;
        }

        /**
         * Internal method to test if a number is prime. Not an efficient
         * algorithm.
         *
         * @param n the number to test.
         * @return the result of the test.
         */
        private boolean isPrime(int n) {
            if (n == 2 || n == 3) {
                return true;
            }

            if (n == 1 || n % 2 == 0) {
                return false;
            }

            for (int i = 3; i * i <= n; i += 2) {
                if (n % i == 0) {
                    return false;
                }
            }

            return true;
        }
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x + " ");
            }

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemae6.pkg3;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaE63 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        BufferedReader in;
        File f = new File("E_13.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("E_13.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;
 int cantidad=0;
        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");
            int comllevar = 0;
            int cont = 1;
            LinkedHashMap<Integer, Integer> H = new LinkedHashMap<>();
            TreeMap<Integer, Integer> tm1 = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tm2 = new TreeMap<Integer, Integer>();
            TreeMap<Integer, Integer> tm3 = new TreeMap<Integer, Integer>();
            MyLinkedList<Integer> lista = new MyLinkedList<>();
            MyLinkedList<Integer> lista1 = new MyLinkedList<>();
            MyLinkedList<Integer> lista2 = new MyLinkedList<>();
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {
                String m = (in.readLine());
                int[] r = readInts(m, 2);
                if (H.containsKey(r[0])) {
                   cantidad = H.get(r[0]);
                    H.put(r[0], cantidad + 1);

                } else {
                    H.put(r[0], 1);
                }

                if (H.containsKey(r[1])) {

//                    System.out.println("entro a valor de llave contenida en H= " + r[1]);
                    if (H.get(r[1]) == 0) {
//                       System.out.println("entro a valor de llave =0");
//                        System.out.println("valor anterior de llave en H= " + H.get(r[1]));

//                        System.out.println("valor de llave despues de agregar a tm1= " + tm1.get(r[1]));
                       // comllevar++;
                        if (tm1.containsKey(r[1])) {
//                            System.out.println("entro a que si esta contenido en tm1");
//                            System.out.println("tm1.get(r[1]= "+tm1.get(r[1]));
                            int valor = tm1.get(r[1]) + 1;
//                            System.out.println("tm1.get(r[1]+1=  " + valor);
                            tm1.put(r[1], (valor));
                        }
                        if (!tm1.containsKey(r[1])) {
//                            System.out.println("entro a que no esta contenida");
                            tm1.put(r[1], 1);
//                            System.out.println("la agrego con valor = "+tm1.get(r[1]));
                        }

                    } else {
//                        System.out.println("si esta contenida y No es 0 no agrego a tm1");
                        int cantidad1 = H.get(r[1]);
//                        System.out.println("valor de llave antes= " + cantidad1);
                        H.put(r[1], (cantidad1 - 1));
                        //    System.out.println("valor de llave");
                        //   cont--;
                    }
                } else {
//                     System.out.println("entro a valor de llave NO contenida en H= " + r[1]);
//                    System.out.println("no esta la llave contenida");
                    if (tm1.containsKey(r[1])) {
//                            System.out.println("entro a que si esta contenido en tm1");
//                            System.out.println("tm1.get(r[1]= "+tm1.get(r[1]));
                        int valor = tm1.get(r[1]) + 1;
////                            System.out.println("tm1.get(r[1]+1=  " + valor);
                        tm1.put(r[1], (valor));
                    }

                    if (!tm1.containsKey(r[1])) {
//                    System.out.println("agrego a tm1 la llave= " + r[1] + "con valor de= " + 1);

                        tm1.put(r[1], 1);

                    }

                  //  comllevar++;
                }
//                System.out.println("otro dato:");
            }
            // System.out.println(comllevar);
            Set<Map.Entry<Integer, Integer>> set0 = tm1.entrySet();
            for (Map.Entry<Integer, Integer> me : set0) {
               // System.out.println("key"+me.getKey()+" "+"valor"+me.getValue());
                int key = me.getKey();
                lista.add(key);
            }

            int i = 1;
            int pos = 0;
            if ((lista.size() > 1)) {
                while (i < lista.size()) {
//                System.out.println("Entro a while");
                    int posi = lista.get(pos);
//                System.out.println("posi= "+posi );

                    int d = tm1.get(posi);
//                System.out.println("d= "+d);
//                System.out.println("i= "+i);
                    int posi2 = lista.get(i);
//                System.out.println("posi2= "+lista.get(i));
                    int g = tm1.get(lista.get(i));
//                System.out.println("g= "+g);

                    if (d < g) {
//                    System.out.println("d<g");
                        tm2.clear();
                        tm2.put(posi2, g);
//                    System.out.println("agrega g a tm3");
                        pos = i;
                        i++;

                    }
                    if (d > g) {
//                    System.out.println("d>g");
                        tm2.put(posi, d);
//                    System.out.println("agrego d tm3");
                        i++;
                    }
                    if (d == g) {
                        if(!tm2.containsKey(posi)){
                        tm2.put(posi, d);
                        }
                        tm2.put(posi2, g);
                        i++;
                    }
                }

            } else {
                int unico = tm1.get(lista.get(0));
                tm2.put(lista.get(0), unico);
            }
            lista1.clear();
            Set<Map.Entry<Integer, Integer>> set = tm2.entrySet();
            for (Map.Entry<Integer, Integer> me : set) {
           //     System.out.println(me.getKey()+" "+me.getValue());
                lista1.add(me.getKey());
            }
///////////////////////////////////////////
            if (lista1.size() > 0) {
                System.out.println(tm2.get(lista1.get(0)) + " " + lista1.get(0));
            }
           // lista.clear();
        /*    Set<Map.Entry<Integer, Integer>> set5 = tm1.entrySet();
            for (Map.Entry<Integer, Integer> me : set5) {
                int key = me.getKey();
                lista.add(key);
            }*/

            /////////////////////////////////////////////////////////
            int j = 1;
            int pos1 = 0;
            if ((lista.size() > 1)) {

                while (j < lista.size()) {
//                System.out.println("Entro a while");
                    int posi = lista.get(pos1);
//                System.out.println("posi= "+posi );
                    //   if (tm1.containsKey(posi)) {
                    int d = tm1.get(posi);
//                System.out.println("d= "+d);
//                System.out.println("i= "+i);
                    int posi2 = lista.get(j);
//                System.out.println("posi2= "+lista.get(i));
                    int g = tm1.get(lista.get(j));
//                System.out.println("g= "+g);

                    if (d < g) {
//                    System.out.println("d<g");

                        tm3.put(posi, d);
//                    System.out.println("agrega g a tm3");
                        //pos1 = j;
                        j++;

                    }
                    if (d > g) {
//                    System.out.println("d>g");
                        tm3.clear();
                        tm3.put(posi2, g);
//                    System.out.println("agrego d tm3");
                         pos1 = j;
                        j++;
                       
                    }
                    if (d == g) {
                        if(!tm3.containsKey(posi)){
                        tm3.put(posi, d);
                        }
                        tm3.put(posi2, d);
                        j++;
                    }
                } //else {

                //j++;
                //}
            } else {
                int unico = tm1.get(lista.get(0));
                tm3.put(lista.get(0), unico);
            }

            lista2.clear();
            Set<Map.Entry<Integer, Integer>> set1 = tm3.entrySet();
            for (Map.Entry<Integer, Integer> me : set1) {

                lista2.add(me.getKey());

            }
            if (lista1.size() > 0) {
                System.out.println(tm3.get(lista2.get(0)) + " " + lista2.get(0));
            }

            if ((lista1.isEmpty()) && (lista2.isEmpty())){
                System.out.println("-1");
            }

            lista.clear();
            tm3.clear();
            tm2.clear();
            cantidad=0;
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;
    }

    public static class SeparateChainingHashTable<AnyType> {

        /**
         * Construct the hash table.
         */
        public SeparateChainingHashTable() {
            this(DEFAULT_TABLE_SIZE);
        }

        /**
         * Construct the hash table.
         *
         * @param size approximate table size.
         */
        public SeparateChainingHashTable(int size) {
            theLists = new LinkedList[nextPrime(size)];
            for (int i = 0; i < theLists.length; i++) {
                theLists[i] = new LinkedList<>();
            }
        }

        /**
         * Insert into the hash table. If the item is already present, then do
         * nothing.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            if (!whichList.contains(x)) {
                whichList.add(x);

                // Rehash; see Section 5.5
                if (++currentSize > theLists.length) {
                    rehash();
                }
            }
        }

        /**
         * Remove from the hash table.
         *
         * @param x the item to remove.
         */
        public void remove(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            if (whichList.contains(x)) {
                whichList.remove(x);
                currentSize--;
            }
        }

        /**
         * Find an item in the hash table.
         *
         * @param x the item to search for.
         * @return true if x is found.
         */
        public boolean contains(AnyType x) {
            List<AnyType> whichList = theLists[myhash(x)];
            return whichList.contains(x);
        }

        /**
         * Make the hash table logically empty.
         */
        public void makeEmpty() {
            for (int i = 0; i < theLists.length; i++) {
                theLists[i].clear();
            }
            currentSize = 0;
        }

        /**
         * A hash routine for String objects.
         *
         * @param key the String to hash.
         * @param tableSize the size of the hash table.
         * @return the hash value.
         */
        public int hash(String key, int tableSize) {
            int hashVal = 0;

            for (int i = 0; i < key.length(); i++) {
                hashVal = 37 * hashVal + key.charAt(i);
            }

            hashVal %= tableSize;
            if (hashVal < 0) {
                hashVal += tableSize;
            }

            return hashVal;
        }

        private void rehash() {
            List<AnyType>[] oldLists = theLists;

            // Create new double-sized, empty table
            theLists = new List[nextPrime(2 * theLists.length)];
            for (int j = 0; j < theLists.length; j++) {
                theLists[j] = new LinkedList<>();
            }

            // Copy table over
            currentSize = 0;
            for (List<AnyType> list : oldLists) {
                for (AnyType item : list) {
                    insert(item);
                }
            }
        }

        public int myhash(AnyType x) {
            int hashVal = x.hashCode();

            hashVal %= theLists.length;
            if (hashVal < 0) {
                hashVal += theLists.length;
            }

            return hashVal;
        }

        private static final int DEFAULT_TABLE_SIZE = 101;

        /**
         * The array of Lists.
         */
        private List<AnyType>[] theLists;
        private int currentSize;

        /**
         * Internal method to find a prime number at least as large as n.
         *
         * @param n the starting number (must be positive).
         * @return a prime number larger than or equal to n.
         */
        @SuppressWarnings("empty-statement")
        private int nextPrime(int n) {
            if (n % 2 == 0) {
                n++;
            }

            for (; !isPrime(n); n += 2)
            ;

            return n;
        }

        /**
         * Internal method to test if a number is prime. Not an efficient
         * algorithm.
         *
         * @param n the number to test.
         * @return the result of the test.
         */
        private boolean isPrime(int n) {
            if (n == 2 || n == 3) {
                return true;
            }

            if (n == 1 || n % 2 == 0) {
                return false;
            }

            for (int i = 3; i * i <= n; i += 2) {
                if (n % i == 0) {
                    return false;
                }
            }

            return true;
        }
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x + " ");
            }

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemaa7;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Iterator;
import java.util.Queue;

/**
 *
 */
public class ProblemaA7 {

    MyArrayList<Vertice> grafo;

    /*  public  ProblemaA7() {
     grafo = new MyArrayList<>();
     }*/
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException, Exception {
        BufferedReader in;
        //////////////P7A_15_2_1.in
        //////////////P7A_15_2_2.in
        File f = new File("P7A_15_2_2.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("A_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;
        //  MyArrayList<Vertice> grafo = new MyArrayList<>();
        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");

            String m = (in.readLine());
            int[] r1 = readInts(m, 2);
//            System.out.println("TAM grafo= " + r1[0]);
            Grafo grafo = new Grafo(r1[0]);

            for (int i = 0; i < r1[0]; i++) {
                Vertice estacion = new Vertice(i);
                grafo.grafo.add(i, estacion);

            }
            
//            System.out.println("tamgrafodespues de llenar: "+grafo.grafo.size());
            for (int i = 0; i < r1[1]; i++) {
                String l = (in.readLine());
                int[] r2 = readInts(l, 2);
                Vertice estacion1 = new Vertice(r2[0]);
                Vertice estacion2 = new Vertice(r2[1]);
//                System.out.println("vertice1: " + estacion1.getNombre());
                
//                System.out.println("!!!!!Vertice1: "+estacion1);
//                System.out.println("!!!!!Vertice2: "+estacion2);
//                System.out.println("vertice2: " + estacion2.getNombre());
                if ((grafo.grafo.get(estacion1.getNombre()).getVecinos().isEmpty())) {
//                    System.out.println("entro a grafoadiciones por condicion 1");
                    grafo.Grafoadicionar(estacion1);
                    
//                      System.out.println("Vertice agregado1: "+grafo.grafo.get(estacion1.getNombre()));
                }
//                System.out.println("tam grafo.grafo: " + grafo.grafo.size());
                if ((grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty())) {
//                    System.out.println("entro a grafoadiciones por condicion 2");
                    grafo.Grafoadicionar(estacion2);
//                    System.out.println("Vertice agregado2: "+grafo.grafo.get(estacion2.getNombre()));
                }
             //   System.out.println("pos= " + r2[0]);
                //     System.out.println("tam1 vecinos main antes: " + grafo.getvertice(r2[0]).getVecinos().size());
                if ((grafo.getvertice(estacion1.getNombre()).getVecinos().isEmpty()) || (!(grafo.getvertice(estacion1.getNombre()).getvecino(estacion1)))) {
//                    System.out.println("entro a condicion de vecino1");
                    Vertice est2=grafo.getvertice(estacion2.getNombre());
                    grafo.getvertice(estacion1.getNombre()).getVecinos().add(est2);
                    
                    
                }
//                System.out.println("tam1 vecinos main despues: " + grafo.getvertice(estacion1.getNombre()).getVecinos().size());
                //  System.out.println("tam2 vecinos main antes: " + grafo.getvertice(r2[1]).getVecinos().size());
//                System.out.println("tamgrafo:  " + grafo.grafo.size());

                if ((grafo.getvertice(estacion2.getNombre()).getVecinos().isEmpty()) || (!(grafo.getvertice(estacion2.getNombre()).getvecino(estacion2)))) {
//                    System.out.println("entro a condicion de vecino2");
                    Vertice est1=grafo.getvertice(estacion1.getNombre());
                    grafo.getvertice(estacion2.getNombre()).getVecinos().add(est1);
                }
//                System.out.println("tam2 vecinos main despues: " + grafo.getvertice(estacion2.getNombre()).getVecinos().size());

            }
//            System.out.println("listas de vecinos");
          /*  for (int i = 0; i < grafo.grafo.size(); i++) {
//                System.out.println("lista");
                System.out.println(grafo.getvertice(i).getVecinos().size());
            }*/
            int inicio = Integer.parseInt(in.readLine());
            Vertice estacioninicio = new Vertice(inicio);
//            System.out.println("Vertice inicio");
            grafo.BFS(estacioninicio);
            System.out.println(grafo.getcontador());
             grafo.grafo.clear();
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;

    }

    public static class Grafo {

        int contador = 0;
        int tamano = 0;
        Vertice vertice;
        MyArrayList<Vertice> grafo;

        public Grafo(int tamano) {
            this.tamano = tamano;
            grafo = new MyArrayList<>(tamano);
//            System.out.println("contruye grafo tamano= " + grafo.size());
        }

        public void Grafoadicionar(Vertice vertice) {
//            System.out.println("entro a grafoadicionar");
            this.vertice = vertice;
            grafo.set(vertice.getNombre(), vertice);
        }

        public boolean getverarreglo(int nombre) {
            boolean cont1 = false;
            for (int i = 0; i < grafo.size(); i++) {
                int verarreglo = grafo.get(i).getNombre();
                if (nombre == verarreglo) {
                    cont1 = true;
                }
            }
            return cont1;
        }

        public Vertice getvertice(int pos) {

     //       System.out.println("entro a getvertice");
            // System.out.println("pos: "+pos );
            //     System.out.println("TAM grafo detro de getvertice " + tamano);
            //     System.out.println("grafo.get(pos) " + grafo.get(pos).getNombre());
            return grafo.get(pos);

        }
     int infinity = (int)Double.POSITIVE_INFINITY;
     
        public void BFS(Vertice s) {
//            System.out.println("vertice inicio BFS: " + s.getNombre() + " numero: " + s.getNumero());
       
            MyQueue<Vertice> q = new MyQueue<Vertice>();
            MyLinkedList<Vertice> vecinos = new MyLinkedList<>();

            for (Vertice v : grafo) {
                v.numero = infinity;
//                System.out.println("vertice:  "+v);
//                System.out.println("vertice inicio BFS despues: " + v.getNombre() + " numero: " + v.getNumero());
                /*   vecinos = grafo.get(v.getNombre()).getVecinos();
                 for(Vertice x: vecinos){
                 x.setNumero(infinity);
                 } */
            }
            //System.out.println("vertice inicio BFS despues: "+v.getNombre()+" numero: "+v.getNumero());
          /*  if (vecinos.size() > 1) {
                System.out.println("primer condd");
                System.out.println("vecino1: " + vecinos.get(0).getNumero() + " vecino2: " + vecinos.get(1).getNumero());
            }*/

            s.numero = 0;
            q.Enqueue(s);

            while (!q.isEmpty()) {
                Vertice v = q.Dequeue();
                vecinos = grafo.get(v.getNombre()).getVecinos();
//                System.out.println("vecinos de V= " + v.getNombre());
                for (int i = 0; i < vecinos.size(); i++) {
//                    System.out.println("lista");
////                    System.out.println(vecinos.get(i).getNombre());
                }
//                System.out.println("tam vecinos dentro BFS: " + vecinos.size());
                if (vecinos.size() > 1) {
//                    System.out.println("vecino1: " + vecinos.get(0).getNumero() + " vecino2: " + vecinos.get(1).getNumero());
                }
                for (Vertice w : vecinos) {
//                    System.out.println("VErtice w: "+w);
//                    System.out.println("w: " + w.getNombre() + " numero: " + w.getNumero());
                    if (w.getNombre() == (s.getNombre())) {
                        w.numero = 0;
                    }
//                    System.out.println("w.numero antes de if de infin: "+w.numero);
                    if (w.numero == infinity) {

                        w.numero = v.numero + 1;
//                        System.out.println("w despues de if inf: "+w.numero);
                        q.Enqueue(w);
                        contador++;
//                        System.out.println("contador++: " + contador);

                    }
                }
            }

        }

        public int getcontador() {
            return contador;
        }

    }

    public static class Vertice {
             double infinity = Double.POSITIVE_INFINITY;
        public int nombre;
        private int numero;
        private int gradodeentrada;
        private int gradodesalida;
        private MyLinkedList<Vertice> vecinos;

        public Vertice(int nombre) {
            this.nombre = nombre;
            vecinos = new MyLinkedList<>();

        }

        public boolean getvecino(Vertice vertice) {
            boolean cont = false;
            for (int i = 0; i < vecinos.size(); i++) {
                Vertice vecino = vecinos.get(i);
                if (vecino.equals(vertice)) {
                    cont = true;
                }
            }
            return cont;
        }

        public int getNombre() {
            return nombre;
        }

        public void setNombre(int nombre) {
            this.nombre = nombre;
        }

        public double getNumero() {
            return numero;
        }

        public void setNumero(int numero) {
            this.numero = numero;
        }

        public int getGradodeentrada() {
            return gradodeentrada;
        }

        public void setGradodeentrada(int gradodeentrada) {
            this.gradodeentrada = gradodeentrada;
        }

        public int getGradodesalida() {
            return gradodesalida;
        }

        public void setGradodesalida(int gradodesalida) {
            this.gradodesalida = gradodesalida;
        }

        public MyLinkedList getVecinos() {
            //    System.out.println("entro a getvecinos");

            return vecinos;
        }

        public void setVecinos(MyLinkedList vecinos) {
            this.vecinos = vecinos;
        }

    }

    public static class MyArrayList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty ArrayList.
         */
        public MyArrayList(int n) {
            ensureCapacity(n);
            theSize = 0;
        }

        public MyArrayList() {
            theSize = 0;
            doClear();

        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        /**
         * Returns true if this collection is empty.
         *
         * @return true if this collection is empty.
         */
        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            return theItems[idx];
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            AnyType old = theItems[idx];
            theItems[idx] = newVal;

            return old;
        }

        @SuppressWarnings("unchecked")
        public void ensureCapacity(int newCapacity) {
            if (newCapacity < theSize) {
                return;
            }

            AnyType[] old = theItems;
            theItems = (AnyType[]) new Object[newCapacity];
            for (int i = 0; i < size(); i++) {
                theItems[i] = old[i];
            }
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {
            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at the specified index.
         *
         * @param x any object.
         * @return true.
         */
        public void add(int idx, AnyType x) {
            if (theItems.length == size()) {
                ensureCapacity(size() * 2 + 1);
            }

            for (int i = theSize; i > idx; i--) {
                theItems[i] = theItems[i - 1];
            }

            theItems[idx] = x;
            theSize++;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            AnyType removedItem = theItems[idx];

            for (int i = idx; i < size() - 1; i++) {
                theItems[i] = theItems[i + 1];
            }
            theSize--;

            return removedItem;
        }

        /**
         * Change the size of this collection to zero.
         */
        public void clear() {
            doClear();
        }

        private void doClear() {
            theSize = 0;
            ensureCapacity(DEFAULT_CAPACITY);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new ArrayListIterator();
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x);
            }
            // sb.append(  );

            return new String(sb);
        }

        /**
         * This is the implementation of the ArrayListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyArrayList.
         */
        private class ArrayListIterator implements java.util.Iterator<AnyType> {

            private int current = 0;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current < size();
            }

            public AnyType next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                okToRemove = true;
                return theItems[current++];
            }

            public void remove() {
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyArrayList.this.remove(--current);
                okToRemove = false;
            }
        }

        private static final int DEFAULT_CAPACITY = 10;

        private AnyType[] theItems;
        private int theSize;
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");

            for (AnyType x : this) {
                sb.append(x + " ");
            }
            sb.append("]");

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

    public static class MyQueue<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyQueue() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean Enqueue(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType peek() {
            return getNode(0).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType Dequeue() {
            return remove(getNode(0));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");

            for (AnyType x : this) {
                sb.append(x + " ");
            }
            sb.append("]");

            return new String(sb);
        }

        @Override
        public Iterator<AnyType> iterator() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemac7;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Iterator;

/**
 *
 */
public class ProblemaC7 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException, Exception {
        BufferedReader in;
        //////////////P7C_15_2_1.in
        //////////////P7C_15_2_2.in
        File f = new File("P7C_15_2_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("C_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");

            String m = (in.readLine());
            int[] r1 = readInts(m, 3);
            int tiempo = r1[2];
            Vertice verticefinal = new Vertice(r1[1]);
            Grafo grafo = new Grafo(r1[0]);
            for (int i = 0; i < r1[0]; i++) {
                Vertice estacion = new Vertice(i);
                grafo.grafo.add(i, estacion);

            }
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {

                //      System.out.println("empieza ciclo");
                String l = (in.readLine());
                int[] r2 = readInts(l, 3);
                //    System.out.println("distancia: "+r2[2]);
                Vertice estacion1 = new Vertice(r2[0]);
                Vertice estacion2 = new Vertice(r2[1]);
                estacion2.setNumero(r2[2]);

//////////////////////////// se tiene un problema al agregar los vertices, ya que si la lista de vecinos es vacia lo agregaria de nueno aun cuando este ya esta agregado
                if ((grafo.grafo.get(estacion1.getNombre()).getVecinos().isEmpty())) {
//                    System.out.println("entro a grafoadiciones por condicion 1");
                    grafo.Grafoadicionar(estacion1);
                   // grafo.getvertice(estacion1.getNombre()).getVecinos().add(null);
//                      System.out.println("Vertice agregado1: "+grafo.grafo.get(estacion1.getNombre()));
                }
//                System.out.println("grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty()"+ grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty());
               // System.out.println("tam grafo.grafo: " + grafo.grafo.size());
                if ((grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty())) {
//                    System.out.println("entro a grafoadiciones por condicion 2");
                    grafo.Grafoadicionar(estacion2);
                 //   grafo.getvertice(estacion2.getNombre()).getVecinos().add(null);
//                    System.out.println("Vertice agregado2: "+grafo.grafo.get(estacion2.getNombre()));
                }

            
//                System.out.println("si esta ya en lisnked "+grafo.getvertice(estacion1.getNombre()).getvecino(estacion2));
                 if(!grafo.getvertice(estacion1.getNombre()).getvecino(estacion2)){
//                     System.out.println("entro a agregar a linked");
                     
                             grafo.getvertice(estacion2.getNombre()).setNumero(r2[2]);
                    grafo.getvertice(estacion1.getNombre()).getVecinos().add(grafo.getvertice(estacion2.getNombre()));

             }

            }
            grafo.Dijkstra(verticefinal);
            int contaratones = 0;
            //MyLinkedList <Vertice> ratones= new MyLinkedList<>();
            for (int i = 0; i < grafo.grafo.size(); i++) {
//                System.out.println("numero de vertice: " + grafo.getvertice(i).getNombre());
//                System.out.println("tiempo: "+tiempo);
               int dis= grafo.getvertice(i).getDistancia();
//                System.out.println("dis: "+dis);
                if (dis< (tiempo + 1)) {
//                    System.out.println("entra a contar");
                    contaratones++;
                }

            }

            System.out.println(contaratones);
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;

    }

    public static class Grafo {

        int contador = 0;
        int tamano = 0;
        Vertice vertice;
        MyArrayList<Vertice> grafo;

        public Grafo(int tamano) {
            this.tamano = tamano;
            grafo = new MyArrayList<>(tamano);
//            System.out.println("contruye grafo tamano= " + grafo.size());
        }

        public void Grafoadicionar(Vertice vertice) {
//            System.out.println("entro a grafoadicionar");
            this.vertice = vertice;
            grafo.set(vertice.getNombre(), vertice);
        }

        public boolean getverarreglo(int nombre) {
            boolean cont1 = false;
            for (int i = 0; i < grafo.size(); i++) {
                int verarreglo = grafo.get(i).getNombre();
                if (nombre == verarreglo) {
                    cont1 = true;
                }
            }
            return cont1;
        }

        public Vertice getvertice(int pos) {

            //       System.out.println("entro a getvertice");
            // System.out.println("pos: "+pos );
            //     System.out.println("TAM grafo detro de getvertice " + tamano);
            //     System.out.println("grafo.get(pos) " + grafo.get(pos).getNombre());
            return grafo.get(pos);

        }
        int infinity = (int) Double.POSITIVE_INFINITY;

        public void Dijkstra(Vertice s) throws Exception {
//            System.out.println("vertice inicio BFS: " + s.getNombre() + " numero: " + s.getNumero());
            BinaryHeap<Vertice> q = new BinaryHeap<>();
            MyLinkedList<Vertice> vecinos = new MyLinkedList<>();

            for (Vertice v : grafo) {
                v.distancia = infinity;
                v.conocido = false;
                
                if (s.getNombre() == (v.getNombre())) {
//                    System.out.println("entro a s: "+s.distancia);
                    v.distancia = 0;
//                    System.out.println("v asignado por s: "+v.getNombre()+" distancia: " + v.distancia);
                }
                q.insert(v);
            }

            boolean conoci = false;

            while (conoci == false) {
//                System.out.println("q.vacio: " + q.isEmpty());
                Vertice v = q.deleteMin();
//                System.out.println("v.deletemin: " + v.getNombre() + " distancia: " + v.distancia);
                v.conocido = true;
                vecinos = grafo.get(v.getNombre()).getVecinos();
//                System.out.println("vecinos de V= " + v.getNombre());

                for (Vertice w : vecinos) {
//                      System.out.println("VErtice w= "+w.getNombre()+" "+w);
//                    System.out.println("w: " + w.getNombre() + " numero: " + w.getNumero());
                    /*  if (w.getNombre() == (s.getNombre())) {
                     w.numero = 0;
                     }*/
//                    System.out.println("w.numero antes de if de infin: "+w.numero);
                    if (w.conocido == false) {
                        int cvw = w.numero;
//                        System.out.println("cvw: " + cvw);
//                        System.out.println("v.distancia: " + v.distancia);
//                        System.out.println("w.distancia: " + w.distancia);
                        
                        if (v.distancia + cvw < w.distancia) {
//                            System.out.println("entro a if v.dis+cvw<w.dis:  ");
                           w.distancia=(v.distancia + cvw);
//                            System.out.println("nueva dis de w= "+w.getNombre()+"  "+ w.distancia);
                        }
                    }
                }
                for (int i = 0; i < grafo.size(); i++) {
                    boolean c1 = grafo.get(i).conocido;
                    if (c1 == false) {
                        conoci = false;
                    } else {
                        conoci = true;
                    }

                }
            }

        }

        public int getcontador() {
            return contador;
        }

    }

    public static class Vertice implements Comparable<Vertice> {

        public int nombre;
        public int numero;
        public int distancia;
        private int gradodeentrada;
        private int gradodesalida;

        public boolean isConocido() {
            return conocido;
        }

        public void setConocido(boolean conocido) {
            this.conocido = conocido;
        }
        public boolean conocido;
        private MyLinkedList<Vertice> vecinos;

        public Vertice(int nombre) {
            this.nombre = nombre;
            vecinos = new MyLinkedList<>();

        }

        public boolean getvecino(Vertice vertice) {
            boolean cont = false;
            for (int i = 0; i < vecinos.size(); i++) {
                Vertice vecino = vecinos.get(i);
                if (vecino.getNombre()==vertice.getNombre()) {
                    cont = true;
                }
            }
            return cont;
        }
        
        

        public int getDistancia() {
            return distancia;
        }

        public void setDistancia(int distancia) {
            this.distancia = distancia;
        }

        public int getNombre() {
            return nombre;
        }

        public void setNombre(int nombre) {
            this.nombre = nombre;
        }

        public int getNumero() {
            return numero;
        }

        public void setNumero(int numero) {
            this.numero = numero;
        }

        public int getGradodeentrada() {
            return gradodeentrada;
        }

        public void setGradodeentrada(int gradodeentrada) {
            this.gradodeentrada = gradodeentrada;
        }

        public int getGradodesalida() {
            return gradodesalida;
        }

        public void setGradodesalida(int gradodesalida) {
            this.gradodesalida = gradodesalida;
        }

        public MyLinkedList getVecinos() {
            //    System.out.println("entro a getvecinos");

            return vecinos;
        }

        public void setVecinos(MyLinkedList vecinos) {
            this.vecinos = vecinos;
        }

        @Override
        public int compareTo(Vertice v) {

            if (distancia < v.distancia) {
                return -1;
            }
            if (distancia > v.distancia) {
                return 1;
            }

            return 0;

        }
    }

    public static class MyArrayList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty ArrayList.
         */
        public MyArrayList(int n) {
            ensureCapacity(n);
            theSize = 0;
        }

        public MyArrayList() {
            theSize = 0;
            doClear();

        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        /**
         * Returns true if this collection is empty.
         *
         * @return true if this collection is empty.
         */
        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            return theItems[idx];
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            AnyType old = theItems[idx];
            theItems[idx] = newVal;

            return old;
        }

        @SuppressWarnings("unchecked")
        public void ensureCapacity(int newCapacity) {
            if (newCapacity < theSize) {
                return;
            }

            AnyType[] old = theItems;
            theItems = (AnyType[]) new Object[newCapacity];
            for (int i = 0; i < size(); i++) {
                theItems[i] = old[i];
            }
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {
            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at the specified index.
         *
         * @param x any object.
         * @return true.
         */
        public void add(int idx, AnyType x) {
            if (theItems.length == size()) {
                ensureCapacity(size() * 2 + 1);
            }

            for (int i = theSize; i > idx; i--) {
                theItems[i] = theItems[i - 1];
            }

            theItems[idx] = x;
            theSize++;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            AnyType removedItem = theItems[idx];

            for (int i = idx; i < size() - 1; i++) {
                theItems[i] = theItems[i + 1];
            }
            theSize--;

            return removedItem;
        }

        /**
         * Change the size of this collection to zero.
         */
        public void clear() {
            doClear();
        }

        private void doClear() {
            theSize = 0;
            ensureCapacity(DEFAULT_CAPACITY);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new ArrayListIterator();
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x);
            }
            // sb.append(  );

            return new String(sb);
        }

        /**
         * This is the implementation of the ArrayListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyArrayList.
         */
        private class ArrayListIterator implements java.util.Iterator<AnyType> {

            private int current = 0;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current < size();
            }

            public AnyType next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                okToRemove = true;
                return theItems[current++];
            }

            public void remove() {
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyArrayList.this.remove(--current);
                okToRemove = false;
            }
        }

        private static final int DEFAULT_CAPACITY = 10;

        private AnyType[] theItems;
        private int theSize;
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");

            for (AnyType x : this) {
                sb.append(x + " ");
            }
            sb.append("]");

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

        /**
         * Construct the binary heap.
         */
        public BinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        /**
         * Construct the binary heap.
         *
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        /**
         * Construct the binary heap given an array of items.
         *
         * @param items
         */
        public BinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        /**
         * Insert into the priority queue, maintaining heap order. Duplicates
         * are allowed.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }

            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        /**
         * Find the smallest item in the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];

        }

        public AnyType getMin() {
            return array[1];
        }

        /**
         * Remove the smallest item from the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }

            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary arrangement of items.
         * Runs in linear time.
         */
        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        /**
         * Test if the priority queue is logically empty.
         *
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty() {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty() {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType[] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         *
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];

            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize
                        && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }

    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemac7;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Iterator;

/**
 *
 */
public class ProblemaC7 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException, Exception {
        BufferedReader in;
        //////////////P7C_15_2_1.in
        //////////////P7C_15_2_2.in
        File f = new File("P7C_15_2_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("C_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");

            String m = (in.readLine());
            int[] r1 = readInts(m, 3);
            int tiempo = r1[2];
            Vertice verticefinal = new Vertice(r1[1]);
            Grafo grafo = new Grafo(r1[0]);
            for (int i = 0; i < r1[0]; i++) {
                Vertice estacion = new Vertice(i);
                grafo.grafo.add(i, estacion);

            }
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {

                //      System.out.println("empieza ciclo");
                String l = (in.readLine());
                int[] r2 = readInts(l, 3);
                //    System.out.println("distancia: "+r2[2]);
                Vertice estacion1 = new Vertice(r2[0]);
                Vertice estacion2 = new Vertice(r2[1]);
                estacion2.setNumero(r2[2]);

//////////////////////////// se tiene un problema al agregar los vertices, ya que si la lista de vecinos es vacia lo agregaria de nueno aun cuando este ya esta agregado
                if ((grafo.grafo.get(estacion1.getNombre()).getVecinos().isEmpty())) {
//                    System.out.println("entro a grafoadiciones por condicion 1");
                    grafo.Grafoadicionar(estacion1);
                    
                    
                   // grafo.getvertice(estacion1.getNombre()).getVecinos().add(null);
//                      System.out.println("Vertice agregado1: "+grafo.grafo.get(estacion1.getNombre()));
                }
//                System.out.println("grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty()"+ grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty());
               // System.out.println("tam grafo.grafo: " + grafo.grafo.size());
                if ((grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty())) {
//                    System.out.println("entro a grafoadiciones por condicion 2");
                    grafo.Grafoadicionar(estacion2);
                    grafo.getvertice(estacion2.getNombre()).getVecinos().setisEmpty();
                 //   grafo.getvertice(estacion2.getNombre()).getVecinos().add(null);
//                    System.out.println("Vertice agregado2: "+grafo.grafo.get(estacion2.getNombre()));
                }

            
//                System.out.println("si esta ya en lisnked "+grafo.getvertice(estacion1.getNombre()).getvecino(estacion2));
                 if(!grafo.getvertice(estacion1.getNombre()).getvecino(estacion2)){
//                     System.out.println("entro a agregar a linked");
                     
                             grafo.getvertice(estacion2.getNombre()).setNumero(r2[2]);
                    grafo.getvertice(estacion1.getNombre()).getVecinos().add(grafo.getvertice(estacion2.getNombre()));

             }

            }
            grafo.Dijkstra(verticefinal);
            int contaratones = 0;
            //MyLinkedList <Vertice> ratones= new MyLinkedList<>();
            for (int i = 0; i < grafo.grafo.size(); i++) {
//                System.out.println("numero de vertice: " + grafo.getvertice(i).getNombre());
//                System.out.println("tiempo: "+tiempo);
               int dis= grafo.getvertice(i).getDistancia();
//                System.out.println("dis: "+dis);
                if (dis< (tiempo + 1)) {
//                    System.out.println("entra a contar");
                    contaratones++;
                }

            }

            System.out.println(contaratones);
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;

    }

    public static class Grafo {

        int contador = 0;
        int tamano = 0;
        Vertice vertice;
        MyArrayList<Vertice> grafo;

        public Grafo(int tamano) {
            this.tamano = tamano;
            grafo = new MyArrayList<>(tamano);
//            System.out.println("contruye grafo tamano= " + grafo.size());
        }

        public void Grafoadicionar(Vertice vertice) {
//            System.out.println("entro a grafoadicionar");
            this.vertice = vertice;
            grafo.set(vertice.getNombre(), vertice);
        }

        public boolean getverarreglo(int nombre) {
            boolean cont1 = false;
            for (int i = 0; i < grafo.size(); i++) {
                int verarreglo = grafo.get(i).getNombre();
                if (nombre == verarreglo) {
                    cont1 = true;
                }
            }
            return cont1;
        }

        public Vertice getvertice(int pos) {

            //       System.out.println("entro a getvertice");
            // System.out.println("pos: "+pos );
            //     System.out.println("TAM grafo detro de getvertice " + tamano);
            //     System.out.println("grafo.get(pos) " + grafo.get(pos).getNombre());
            return grafo.get(pos);

        }
        int infinity = (int) Double.POSITIVE_INFINITY;

        public void Dijkstra(Vertice s) throws Exception {
//            System.out.println("vertice inicio BFS: " + s.getNombre() + " numero: " + s.getNumero());
            BinaryHeap<Vertice> q = new BinaryHeap<>();
            MyLinkedList<Vertice> vecinos = new MyLinkedList<>();

            for (Vertice v : grafo) {
                v.distancia = infinity;
                v.conocido = false;
                
                if (s.getNombre() == (v.getNombre())) {
//                    System.out.println("entro a s: "+s.distancia);
                    v.distancia = 0;
//                    System.out.println("v asignado por s: "+v.getNombre()+" distancia: " + v.distancia);
                }
                q.insert(v);
            }

            boolean conoci = false;

            while (conoci == false) {
//                System.out.println("q.vacio: " + q.isEmpty());
                Vertice v = q.deleteMin();
//                System.out.println("v.deletemin: " + v.getNombre() + " distancia: " + v.distancia);
                v.conocido = true;
                vecinos = grafo.get(v.getNombre()).getVecinos();
//                System.out.println("vecinos de V= " + v.getNombre());

                for (Vertice w : vecinos) {
//                      System.out.println("VErtice w= "+w.getNombre()+" "+w);
//                    System.out.println("w: " + w.getNombre() + " numero: " + w.getNumero());
                    /*  if (w.getNombre() == (s.getNombre())) {
                     w.numero = 0;
                     }*/
//                    System.out.println("w.numero antes de if de infin: "+w.numero);
                    if (w.conocido == false) {
                        int cvw = w.numero;
//                        System.out.println("cvw: " + cvw);
//                        System.out.println("v.distancia: " + v.distancia);
//                        System.out.println("w.distancia: " + w.distancia);
                        
                        if (v.distancia + cvw < w.distancia) {
//                            System.out.println("entro a if v.dis+cvw<w.dis:  ");
                           w.distancia=(v.distancia + cvw);
//                            System.out.println("nueva dis de w= "+w.getNombre()+"  "+ w.distancia);
                        }
                    }
                }
                for (int i = 0; i < grafo.size(); i++) {
                    boolean c1 = grafo.get(i).conocido;
                    if (c1 == false) {
                        conoci = false;
                    } else {
                        conoci = true;
                    }

                }
            }

        }

        public int getcontador() {
            return contador;
        }

    }

    public static class Vertice implements Comparable<Vertice> {

        public int nombre;
        public int numero;
        public int distancia;
        private int gradodeentrada;
        private int gradodesalida;

        public boolean isConocido() {
            return conocido;
        }

        public void setConocido(boolean conocido) {
            this.conocido = conocido;
        }
        public boolean conocido;
        private MyLinkedList<Vertice> vecinos;

        public Vertice(int nombre) {
            this.nombre = nombre;
            vecinos = new MyLinkedList<>();

        }

        public boolean getvecino(Vertice vertice) {
            boolean cont = false;
            for (int i = 0; i < vecinos.size(); i++) {
                Vertice vecino = vecinos.get(i);
                if (vecino.getNombre()==vertice.getNombre()) {
                    cont = true;
                }
            }
            return cont;
        }
        
        

        public int getDistancia() {
            return distancia;
        }

        public void setDistancia(int distancia) {
            this.distancia = distancia;
        }

        public int getNombre() {
            return nombre;
        }

        public void setNombre(int nombre) {
            this.nombre = nombre;
        }

        public int getNumero() {
            return numero;
        }

        public void setNumero(int numero) {
            this.numero = numero;
        }

        public int getGradodeentrada() {
            return gradodeentrada;
        }

        public void setGradodeentrada(int gradodeentrada) {
            this.gradodeentrada = gradodeentrada;
        }

        public int getGradodesalida() {
            return gradodesalida;
        }

        public void setGradodesalida(int gradodesalida) {
            this.gradodesalida = gradodesalida;
        }

        public MyLinkedList getVecinos() {
            //    System.out.println("entro a getvecinos");

            return vecinos;
        }

        public void setVecinos(MyLinkedList vecinos) {
            this.vecinos = vecinos;
        }

        @Override
        public int compareTo(Vertice v) {

            if (distancia < v.distancia) {
                return -1;
            }
            if (distancia > v.distancia) {
                return 1;
            }

            return 0;

        }
    }

    public static class MyArrayList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty ArrayList.
         */
        public MyArrayList(int n) {
            ensureCapacity(n);
            theSize = 0;
        }

        public MyArrayList() {
            theSize = 0;
            doClear();

        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        /**
         * Returns true if this collection is empty.
         *
         * @return true if this collection is empty.
         */
        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            return theItems[idx];
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            AnyType old = theItems[idx];
            theItems[idx] = newVal;

            return old;
        }

        @SuppressWarnings("unchecked")
        public void ensureCapacity(int newCapacity) {
            if (newCapacity < theSize) {
                return;
            }

            AnyType[] old = theItems;
            theItems = (AnyType[]) new Object[newCapacity];
            for (int i = 0; i < size(); i++) {
                theItems[i] = old[i];
            }
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {
            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at the specified index.
         *
         * @param x any object.
         * @return true.
         */
        public void add(int idx, AnyType x) {
            if (theItems.length == size()) {
                ensureCapacity(size() * 2 + 1);
            }

            for (int i = theSize; i > idx; i--) {
                theItems[i] = theItems[i - 1];
            }

            theItems[idx] = x;
            theSize++;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            AnyType removedItem = theItems[idx];

            for (int i = idx; i < size() - 1; i++) {
                theItems[i] = theItems[i + 1];
            }
            theSize--;

            return removedItem;
        }

        /**
         * Change the size of this collection to zero.
         */
        public void clear() {
            doClear();
        }

        private void doClear() {
            theSize = 0;
            ensureCapacity(DEFAULT_CAPACITY);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new ArrayListIterator();
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x);
            }
            // sb.append(  );

            return new String(sb);
        }

        /**
         * This is the implementation of the ArrayListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyArrayList.
         */
        private class ArrayListIterator implements java.util.Iterator<AnyType> {

            private int current = 0;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current < size();
            }

            public AnyType next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                okToRemove = true;
                return theItems[current++];
            }

            public void remove() {
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyArrayList.this.remove(--current);
                okToRemove = false;
            }
        }

        private static final int DEFAULT_CAPACITY = 10;

        private AnyType[] theItems;
        private int theSize;
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }
        public boolean setisEmpty(){
        return size()!=0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");

            for (AnyType x : this) {
                sb.append(x + " ");
            }
            sb.append("]");

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

        /**
         * Construct the binary heap.
         */
        public BinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        /**
         * Construct the binary heap.
         *
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        /**
         * Construct the binary heap given an array of items.
         *
         * @param items
         */
        public BinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        /**
         * Insert into the priority queue, maintaining heap order. Duplicates
         * are allowed.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }

            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        /**
         * Find the smallest item in the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];

        }

        public AnyType getMin() {
            return array[1];
        }

        /**
         * Remove the smallest item from the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }

            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary arrangement of items.
         * Runs in linear time.
         */
        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        /**
         * Test if the priority queue is logically empty.
         *
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty() {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty() {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType[] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         *
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];

            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize
                        && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }

    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemac7;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Iterator;

/**
 *
 */
public class ProblemaC7 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException, Exception {
        BufferedReader in;
        //////////////P7C_15_2_1.in
        //////////////P7C_15_2_2.in
        File f = new File("P7C_15_2_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("C_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");

            String m = (in.readLine());
            int[] r1 = readInts(m, 3);
            int tiempo = r1[2];
            Vertice verticefinal = new Vertice(r1[1]);
            Grafo grafo = new Grafo(r1[0]);
            for (int i = 0; i < r1[0]; i++) {
                Vertice estacion = new Vertice(i);
                grafo.grafo.add(i, estacion);

            }
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {

               
                String l = (in.readLine());
                int[] r2 = readInts(l, 3);
              
                Vertice estacion1 = new Vertice(r2[0]);
                Vertice estacion2 = new Vertice(r2[1]);
                estacion2.setNumero(r2[2]);

//////////////////////////// se tiene un problema al agregar los vertices ya que si la lista de vecinos es vacia lo agregaria de nuevo aun cuando este ya esta agregado
                if ((grafo.grafo.get(estacion1.getNombre()).getVecinos().isEmpty())) {

                    grafo.Grafoadicionar(estacion1);
                    
                    
                   
                }

                if ((grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty())) {

                    grafo.Grafoadicionar(estacion2);
                    grafo.getvertice(estacion2.getNombre()).getVecinos().setisEmpty();
                 
                }

            

                 if(!grafo.getvertice(estacion1.getNombre()).getvecino(estacion2)){

                             grafo.getvertice(estacion2.getNombre()).setNumero(r2[2]);
                    grafo.getvertice(estacion1.getNombre()).getVecinos().add(grafo.getvertice(estacion2.getNombre()));

             }

            }
            grafo.Dijkstra(verticefinal);
            int contaratones = 0;
           
            for (int i = 0; i < grafo.grafo.size(); i++) {

               int dis= grafo.getvertice(i).getDistancia();

                if (dis< (tiempo + 1)) {

                    contaratones++;
                }

            }

            System.out.println(contaratones);
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;

    }

    public static class Grafo {

        int contador = 0;
        int tamano = 0;
        Vertice vertice;
        MyArrayList<Vertice> grafo;

        public Grafo(int tamano) {
            this.tamano = tamano;
            grafo = new MyArrayList<>(tamano);

        }

        public void Grafoadicionar(Vertice vertice) {

            this.vertice = vertice;
            grafo.set(vertice.getNombre(), vertice);
        }

        public boolean getverarreglo(int nombre) {
            boolean cont1 = false;
            for (int i = 0; i < grafo.size(); i++) {
                int verarreglo = grafo.get(i).getNombre();
                if (nombre == verarreglo) {
                    cont1 = true;
                }
            }
            return cont1;
        }

        public Vertice getvertice(int pos) {

        
            return grafo.get(pos);

        }
        int infinity = (int) Double.POSITIVE_INFINITY;

        public void Dijkstra(Vertice s) throws Exception {

            BinaryHeap<Vertice> q = new BinaryHeap<>();
            MyLinkedList<Vertice> vecinos = new MyLinkedList<>();

            for (Vertice v : grafo) {
                v.distancia = infinity;
                v.conocido = false;
                
                if (s.getNombre() == (v.getNombre())) {

                    v.distancia = 0;

                }
                q.insert(v);
            }

            boolean conoci = false;

            while (conoci == false) {

                Vertice v = q.deleteMin();

                v.conocido = true;
                vecinos = grafo.get(v.getNombre()).getVecinos();


                for (Vertice w : vecinos) {

                    if (w.conocido == false) {
                        int cvw = w.numero;

                        
                        if (v.distancia + cvw < w.distancia) {

                           w.distancia=(v.distancia + cvw);

                        }
                    }
                }
                for (int i = 0; i < grafo.size(); i++) {
                    boolean c1 = grafo.get(i).conocido;
                    if (c1 == false) {
                        conoci = false;
                    } else {
                        conoci = true;
                    }

                }
            }

        }

        public int getcontador() {
            return contador;
        }

    }

    public static class Vertice implements Comparable<Vertice> {

        public int nombre;
        public int numero;
        public int distancia;
        private int gradodeentrada;
        private int gradodesalida;

        public boolean isConocido() {
            return conocido;
        }

        public void setConocido(boolean conocido) {
            this.conocido = conocido;
        }
        public boolean conocido;
        private MyLinkedList<Vertice> vecinos;

        public Vertice(int nombre) {
            this.nombre = nombre;
            vecinos = new MyLinkedList<>();

        }

        public boolean getvecino(Vertice vertice) {
            boolean cont = false;
            for (int i = 0; i < vecinos.size(); i++) {
                Vertice vecino = vecinos.get(i);
                if (vecino.getNombre()==vertice.getNombre()) {
                    cont = true;
                }
            }
            return cont;
        }
        
        

        public int getDistancia() {
            return distancia;
        }

        public void setDistancia(int distancia) {
            this.distancia = distancia;
        }

        public int getNombre() {
            return nombre;
        }

        public void setNombre(int nombre) {
            this.nombre = nombre;
        }

        public int getNumero() {
            return numero;
        }

        public void setNumero(int numero) {
            this.numero = numero;
        }

        public int getGradodeentrada() {
            return gradodeentrada;
        }

        public void setGradodeentrada(int gradodeentrada) {
            this.gradodeentrada = gradodeentrada;
        }

        public int getGradodesalida() {
            return gradodesalida;
        }

        public void setGradodesalida(int gradodesalida) {
            this.gradodesalida = gradodesalida;
        }

        public MyLinkedList getVecinos() {
            //    System.out.println("entro a getvecinos");

            return vecinos;
        }

        public void setVecinos(MyLinkedList vecinos) {
            this.vecinos = vecinos;
        }

        @Override
        public int compareTo(Vertice v) {

            if (distancia < v.distancia) {
                return -1;
            }
            if (distancia > v.distancia) {
                return 1;
            }

            return 0;

        }
    }

    public static class MyArrayList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty ArrayList.
         */
        public MyArrayList(int n) {
            ensureCapacity(n);
            theSize = 0;
        }

        public MyArrayList() {
            theSize = 0;
            doClear();

        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        /**
         * Returns true if this collection is empty.
         *
         * @return true if this collection is empty.
         */
        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            return theItems[idx];
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            AnyType old = theItems[idx];
            theItems[idx] = newVal;

            return old;
        }

        @SuppressWarnings("unchecked")
        public void ensureCapacity(int newCapacity) {
            if (newCapacity < theSize) {
                return;
            }

            AnyType[] old = theItems;
            theItems = (AnyType[]) new Object[newCapacity];
            for (int i = 0; i < size(); i++) {
                theItems[i] = old[i];
            }
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {
            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at the specified index.
         *
         * @param x any object.
         * @return true.
         */
        public void add(int idx, AnyType x) {
            if (theItems.length == size()) {
                ensureCapacity(size() * 2 + 1);
            }

            for (int i = theSize; i > idx; i--) {
                theItems[i] = theItems[i - 1];
            }

            theItems[idx] = x;
            theSize++;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            AnyType removedItem = theItems[idx];

            for (int i = idx; i < size() - 1; i++) {
                theItems[i] = theItems[i + 1];
            }
            theSize--;

            return removedItem;
        }

        /**
         * Change the size of this collection to zero.
         */
        public void clear() {
            doClear();
        }

        private void doClear() {
            theSize = 0;
            ensureCapacity(DEFAULT_CAPACITY);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new ArrayListIterator();
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x);
            }
            // sb.append(  );

            return new String(sb);
        }

        /**
         * This is the implementation of the ArrayListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyArrayList.
         */
        private class ArrayListIterator implements java.util.Iterator<AnyType> {

            private int current = 0;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current < size();
            }

            public AnyType next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                okToRemove = true;
                return theItems[current++];
            }

            public void remove() {
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyArrayList.this.remove(--current);
                okToRemove = false;
            }
        }

        private static final int DEFAULT_CAPACITY = 10;

        private AnyType[] theItems;
        private int theSize;
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }
        public boolean setisEmpty(){
        return size()!=0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");

            for (AnyType x : this) {
                sb.append(x + " ");
            }
            sb.append("]");

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

        /**
         * Construct the binary heap.
         */
        public BinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        /**
         * Construct the binary heap.
         *
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        /**
         * Construct the binary heap given an array of items.
         *
         * @param items
         */
        public BinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        /**
         * Insert into the priority queue, maintaining heap order. Duplicates
         * are allowed.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }

            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        /**
         * Find the smallest item in the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];

        }

        public AnyType getMin() {
            return array[1];
        }

        /**
         * Remove the smallest item from the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }

            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary arrangement of items.
         * Runs in linear time.
         */
        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        /**
         * Test if the priority queue is logically empty.
         *
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty() {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty() {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType[] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         *
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];

            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize
                        && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }

    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemac7;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Iterator;

/**
 *
 */
public class ProblemaC7 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException, Exception {
        BufferedReader in;
        //////////////P7C_15_2_1.in
        //////////////P7C_15_2_2.in
        File f = new File("P7C_15_2_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("C_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");

            String m = (in.readLine());
            int[] r1 = readInts(m, 3);
            int tiempo = r1[2];
            Vertice verticefinal = new Vertice(r1[1]);
            Grafo grafo = new Grafo(r1[0]);
            for (int i = 0; i < r1[0]; i++) {
                Vertice estacion = new Vertice(i);
                grafo.grafo.add(i, estacion);

            }
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {

                String l = (in.readLine());
                int[] r2 = readInts(l, 3);
                Vertice estacion1 = new Vertice(r2[0]);
                Vertice estacion2 = new Vertice(r2[1]);
                estacion2.setNumero(r2[2]);
                boolean contenidos1=true;
                boolean contenidos2=true;
                    for (int j = 0; j < r1[0]; j++) {
                        MyLinkedList<Vertice> veci = grafo.getvertice(j).getVecinos();
                        for (int k = 0; k < veci.size(); k++) {
                           if(estacion1.getNombre()==veci.get(k).getNombre()){
                            contenidos1=false;
                           }

                        }

                    }
                    for (int j = 0; j < r1[0]; j++) {
                        MyLinkedList<Vertice> veci = grafo.getvertice(j).getVecinos();
                        for (int k = 0; k < veci.size(); k++) {
                           if(estacion2.getNombre()==veci.get(k).getNombre()){
                            contenidos2=false;
                           }

                        }

                    }
//////////////////////////// se tiene un problema al agregar los vertices ya que si la lista de vecinos es vacia lo agregaria de nuevo aun cuando este ya esta agregado
                if ((grafo.grafo.get(estacion1.getNombre()).getVecinos().isEmpty())&&(contenidos1)) {
                    
                   
                    grafo.Grafoadicionar(estacion1);

                }

                if ((grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty())) {

                    grafo.Grafoadicionar(estacion2);

                }

                if (!grafo.getvertice(estacion1.getNombre()).getvecino(estacion2)&&(contenidos1)) {

                    grafo.getvertice(estacion2.getNombre()).setNumero(r2[2]);
                    grafo.getvertice(estacion1.getNombre()).getVecinos().add(grafo.getvertice(estacion2.getNombre()));

                }

            }
            grafo.Dijkstra(verticefinal);
            int contaratones = 0;

            for (int i = 0; i < grafo.grafo.size(); i++) {

                int dis = grafo.getvertice(i).getDistancia();

                if (dis < (tiempo + 1)) {

                    contaratones++;
                }

            }

            System.out.println(contaratones);
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;

    }

    public static class Grafo {

        int contador = 0;
        int tamano = 0;
        Vertice vertice;
        MyArrayList<Vertice> grafo;

        public Grafo(int tamano) {
            this.tamano = tamano;
            grafo = new MyArrayList<>(tamano);

        }

        public void Grafoadicionar(Vertice vertice) {

            this.vertice = vertice;
            grafo.set(vertice.getNombre(), vertice);
        }

        public boolean getverarreglo(int nombre) {
            boolean cont1 = false;
            for (int i = 0; i < grafo.size(); i++) {
                int verarreglo = grafo.get(i).getNombre();
                if (nombre == verarreglo) {
                    cont1 = true;
                }
            }
            return cont1;
        }

        public Vertice getvertice(int pos) {

            return grafo.get(pos);

        }
        int infinity = (int) Double.POSITIVE_INFINITY;

        public void Dijkstra(Vertice s) throws Exception {

            BinaryHeap<Vertice> q = new BinaryHeap<>();
            MyLinkedList<Vertice> vecinos = new MyLinkedList<>();

            for (Vertice v : grafo) {
                v.distancia = infinity;
                v.conocido = false;

                if (s.getNombre() == (v.getNombre())) {

                    v.distancia = 0;

                }
                q.insert(v);
            }

            boolean conoci = false;

            while (conoci == false) {

                Vertice v = q.deleteMin();

                v.conocido = true;
                vecinos = grafo.get(v.getNombre()).getVecinos();

                for (Vertice w : vecinos) {

                    if (w.conocido == false) {
                        int cvw = w.numero;

                        if (v.distancia + cvw < w.distancia) {

                            w.distancia = (v.distancia + cvw);

                        }
                    }
                }
                for (int i = 0; i < grafo.size(); i++) {
                    boolean c1 = grafo.get(i).conocido;
                    if (c1 == false) {
                        conoci = false;
                    } else {
                        conoci = true;
                    }

                }
            }

        }

        public int getcontador() {
            return contador;
        }

    }

    public static class Vertice implements Comparable<Vertice> {

        public int nombre;
        public int numero;
        public int distancia;
        private int gradodeentrada;
        private int gradodesalida;

        public boolean isConocido() {
            return conocido;
        }

        public void setConocido(boolean conocido) {
            this.conocido = conocido;
        }
        public boolean conocido;
        private MyLinkedList<Vertice> vecinos;

        public Vertice(int nombre) {
            this.nombre = nombre;
            vecinos = new MyLinkedList<>();

        }

        public boolean getvecino(Vertice vertice) {
            boolean cont = false;
            for (int i = 0; i < vecinos.size(); i++) {
                Vertice vecino = vecinos.get(i);
                if (vecino.getNombre() == vertice.getNombre()) {
                    cont = true;
                }
            }
            return cont;
        }

        public int getDistancia() {
            return distancia;
        }

        public void setDistancia(int distancia) {
            this.distancia = distancia;
        }

        public int getNombre() {
            return nombre;
        }

        public void setNombre(int nombre) {
            this.nombre = nombre;
        }

        public int getNumero() {
            return numero;
        }

        public void setNumero(int numero) {
            this.numero = numero;
        }

        public int getGradodeentrada() {
            return gradodeentrada;
        }

        public void setGradodeentrada(int gradodeentrada) {
            this.gradodeentrada = gradodeentrada;
        }

        public int getGradodesalida() {
            return gradodesalida;
        }

        public void setGradodesalida(int gradodesalida) {
            this.gradodesalida = gradodesalida;
        }

        public MyLinkedList getVecinos() {
            //    System.out.println("entro a getvecinos");

            return vecinos;
        }

        public void setVecinos(MyLinkedList vecinos) {
            this.vecinos = vecinos;
        }

        @Override
        public int compareTo(Vertice v) {

            if (distancia < v.distancia) {
                return -1;
            }
            if (distancia > v.distancia) {
                return 1;
            }

            return 0;

        }
    }

    public static class MyArrayList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty ArrayList.
         */
        public MyArrayList(int n) {
            ensureCapacity(n);
            theSize = 0;
        }

        public MyArrayList() {
            theSize = 0;
            doClear();

        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        /**
         * Returns true if this collection is empty.
         *
         * @return true if this collection is empty.
         */
        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            return theItems[idx];
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            AnyType old = theItems[idx];
            theItems[idx] = newVal;

            return old;
        }

        @SuppressWarnings("unchecked")
        public void ensureCapacity(int newCapacity) {
            if (newCapacity < theSize) {
                return;
            }

            AnyType[] old = theItems;
            theItems = (AnyType[]) new Object[newCapacity];
            for (int i = 0; i < size(); i++) {
                theItems[i] = old[i];
            }
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {
            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at the specified index.
         *
         * @param x any object.
         * @return true.
         */
        public void add(int idx, AnyType x) {
            if (theItems.length == size()) {
                ensureCapacity(size() * 2 + 1);
            }

            for (int i = theSize; i > idx; i--) {
                theItems[i] = theItems[i - 1];
            }

            theItems[idx] = x;
            theSize++;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            AnyType removedItem = theItems[idx];

            for (int i = idx; i < size() - 1; i++) {
                theItems[i] = theItems[i + 1];
            }
            theSize--;

            return removedItem;
        }

        /**
         * Change the size of this collection to zero.
         */
        public void clear() {
            doClear();
        }

        private void doClear() {
            theSize = 0;
            ensureCapacity(DEFAULT_CAPACITY);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new ArrayListIterator();
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x);
            }
            // sb.append(  );

            return new String(sb);
        }

        /**
         * This is the implementation of the ArrayListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyArrayList.
         */
        private class ArrayListIterator implements java.util.Iterator<AnyType> {

            private int current = 0;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current < size();
            }

            public AnyType next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                okToRemove = true;
                return theItems[current++];
            }

            public void remove() {
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyArrayList.this.remove(--current);
                okToRemove = false;
            }
        }

        private static final int DEFAULT_CAPACITY = 10;

        private AnyType[] theItems;
        private int theSize;
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        public boolean setisEmpty() {
            return size() != 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");

            for (AnyType x : this) {
                sb.append(x + " ");
            }
            sb.append("]");

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

        /**
         * Construct the binary heap.
         */
        public BinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        /**
         * Construct the binary heap.
         *
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        /**
         * Construct the binary heap given an array of items.
         *
         * @param items
         */
        public BinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        /**
         * Insert into the priority queue, maintaining heap order. Duplicates
         * are allowed.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }

            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        /**
         * Find the smallest item in the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];

        }

        public AnyType getMin() {
            return array[1];
        }

        /**
         * Remove the smallest item from the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }

            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary arrangement of items.
         * Runs in linear time.
         */
        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        /**
         * Test if the priority queue is logically empty.
         *
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty() {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty() {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType[] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         *
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];

            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize
                        && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }

    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemac7;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Iterator;

/**
 *
 */
public class ProblemaC7 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException, Exception {
        BufferedReader in;
        //////////////P7C_15_2_1.in
        //////////////P7C_15_2_2.in
        File f = new File("P7C_15_2_1.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("C_1.out")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        int c = n;

        for (c = 1; c < n + 1; c++) {
            System.out.println("Case #" + c + ":");

            String m = (in.readLine());
            int[] r1 = readInts(m, 3);
            int tiempo = r1[2];
            Vertice verticefinal = new Vertice(r1[1]);
            Grafo grafo = new Grafo(r1[0]);
            for (int i = 0; i < r1[0]; i++) {
                Vertice estacion = new Vertice(i);
                grafo.grafo.add(i, estacion);

            }
            int t = Integer.parseInt(in.readLine());
            for (int i = 0; i < t; i++) {

                String l = (in.readLine());
                int[] r2 = readInts(l, 3);
                Vertice estacion1 = new Vertice(r2[0]);
                Vertice estacion2 = new Vertice(r2[1]);
                estacion2.setNumero(r2[2]);
                boolean contenidos1=true;
                boolean contenidos2=true;
                    for (int j = 0; j < r1[0]; j++) {
                        MyLinkedList<Vertice> veci = grafo.getvertice(j).getVecinos();
                        for (int k = 0; k < veci.size(); k++) {
                           if(estacion1.getNombre()==veci.get(k).getNombre()){
                            contenidos1=false;
                           }

                        }

                    }
                    for (int j = 0; j < r1[0]; j++) {
                        MyLinkedList<Vertice> veci = grafo.getvertice(j).getVecinos();
                        for (int k = 0; k < veci.size(); k++) {
                           if(estacion2.getNombre()==veci.get(k).getNombre()){
                            contenidos2=false;
                           }

                        }

                    }
//////////////////////////// se tiene un problema al agregar los vertices ya que si la lista de vecinos es vacia lo agregaria de nuevo aun cuando este ya esta agregado
                if ((grafo.grafo.get(estacion1.getNombre()).getVecinos().isEmpty())&&(contenidos1)) {
                    
                   
                    grafo.Grafoadicionar(estacion1);

                }

                if ((grafo.grafo.get(estacion2.getNombre()).getVecinos().isEmpty())) {

                    grafo.Grafoadicionar(estacion2);

                }

                if (!grafo.getvertice(estacion1.getNombre()).getvecino(estacion2)&&(contenidos1)) {

                    grafo.getvertice(estacion2.getNombre()).setNumero(r2[2]);
                    grafo.getvertice(estacion1.getNombre()).getVecinos().add(grafo.getvertice(estacion2.getNombre()));

                }

            }
            grafo.Dijkstra(verticefinal);
            int contaratones = 0;

            for (int i = 0; i < grafo.grafo.size(); i++) {

                int dis = grafo.getvertice(i).getDistancia();

                if (dis < (tiempo + 1)) {

                    contaratones++;
                }

            }

            System.out.println(contaratones);
        }
    }

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }

        return arr;

    }

    public static class Grafo {

        int contador = 0;
        int tamano = 0;
        Vertice vertice;
        MyArrayList<Vertice> grafo;

        public Grafo(int tamano) {
            this.tamano = tamano;
            grafo = new MyArrayList<>(tamano);

        }

        public void Grafoadicionar(Vertice vertice) {

            this.vertice = vertice;
            grafo.set(vertice.getNombre(), vertice);
        }

        public boolean getverarreglo(int nombre) {
            boolean cont1 = false;
            for (int i = 0; i < grafo.size(); i++) {
                int verarreglo = grafo.get(i).getNombre();
                if (nombre == verarreglo) {
                    cont1 = true;
                }
            }
            return cont1;
        }

        public Vertice getvertice(int pos) {

            return grafo.get(pos);

        }
        int infinity = (int) Double.POSITIVE_INFINITY;

        public void Dijkstra(Vertice s) throws Exception {

            BinaryHeap<Vertice> q = new BinaryHeap<>();
            MyLinkedList<Vertice> vecinos = new MyLinkedList<>();

            for (Vertice v : grafo) {
                v.distancia = infinity;
                v.conocido = false;

                if (s.getNombre() == (v.getNombre())) {

                    v.distancia = 0;

                }
                q.insert(v);
            }

            boolean conoci = false;

            while (conoci == false) {

                Vertice v = q.deleteMin();

                v.conocido = true;
                vecinos = grafo.get(v.getNombre()).getVecinos();

                for (Vertice w : vecinos) {

                    if (w.conocido == false) {
                        int cvw = w.numero;

                        if (v.distancia + cvw < w.distancia) {

                            w.distancia = (v.distancia + cvw);

                        }
                    }
                }
                for (int i = 0; i < grafo.size(); i++) {
                    boolean c1 = grafo.get(i).conocido;
                    if (c1 == false) {
                        conoci = false;
                    } else {
                        conoci = true;
                    }

                }
            }

        }

        public int getcontador() {
            return contador;
        }

    }

    public static class Vertice implements Comparable<Vertice> {

        public int nombre;
        public int numero;
        public int distancia;
        private int gradodeentrada;
        private int gradodesalida;

        public boolean isConocido() {
            return conocido;
        }

        public void setConocido(boolean conocido) {
            this.conocido = conocido;
        }
        public boolean conocido;
        private MyLinkedList<Vertice> vecinos;

        public Vertice(int nombre) {
            this.nombre = nombre;
            vecinos = new MyLinkedList<>();

        }

        public boolean getvecino(Vertice vertice) {
            boolean cont = false;
            for (int i = 0; i < vecinos.size(); i++) {
                Vertice vecino = vecinos.get(i);
                if (vecino.getNombre() == vertice.getNombre()) {
                    cont = true;
                }
            }
            return cont;
        }

        public int getDistancia() {
            return distancia;
        }

        public void setDistancia(int distancia) {
            this.distancia = distancia;
        }

        public int getNombre() {
            return nombre;
        }

        public void setNombre(int nombre) {
            this.nombre = nombre;
        }

        public int getNumero() {
            return numero;
        }

        public void setNumero(int numero) {
            this.numero = numero;
        }

        public int getGradodeentrada() {
            return gradodeentrada;
        }

        public void setGradodeentrada(int gradodeentrada) {
            this.gradodeentrada = gradodeentrada;
        }

        public int getGradodesalida() {
            return gradodesalida;
        }

        public void setGradodesalida(int gradodesalida) {
            this.gradodesalida = gradodesalida;
        }

        public MyLinkedList getVecinos() {
            //    System.out.println("entro a getvecinos");

            return vecinos;
        }

        public void setVecinos(MyLinkedList vecinos) {
            this.vecinos = vecinos;
        }

        @Override
        public int compareTo(Vertice v) {

            if (distancia < v.distancia) {
                return -1;
            }
            if (distancia > v.distancia) {
                return 1;
            }

            return 0;

        }
    }

    public static class MyArrayList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty ArrayList.
         */
        public MyArrayList(int n) {
            ensureCapacity(n);
            theSize = 0;
        }

        public MyArrayList() {
            theSize = 0;
            doClear();

        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        /**
         * Returns true if this collection is empty.
         *
         * @return true if this collection is empty.
         */
        public boolean isEmpty() {
            return size() == 0;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            return theItems[idx];
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws ArrayIndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            if (idx < 0 || idx >= size()) {
                throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
            }
            AnyType old = theItems[idx];
            theItems[idx] = newVal;

            return old;
        }

        @SuppressWarnings("unchecked")
        public void ensureCapacity(int newCapacity) {
            if (newCapacity < theSize) {
                return;
            }

            AnyType[] old = theItems;
            theItems = (AnyType[]) new Object[newCapacity];
            for (int i = 0; i < size(); i++) {
                theItems[i] = old[i];
            }
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {
            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at the specified index.
         *
         * @param x any object.
         * @return true.
         */
        public void add(int idx, AnyType x) {
            if (theItems.length == size()) {
                ensureCapacity(size() * 2 + 1);
            }

            for (int i = theSize; i > idx; i--) {
                theItems[i] = theItems[i - 1];
            }

            theItems[idx] = x;
            theSize++;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            AnyType removedItem = theItems[idx];

            for (int i = idx; i < size() - 1; i++) {
                theItems[i] = theItems[i + 1];
            }
            theSize--;

            return removedItem;
        }

        /**
         * Change the size of this collection to zero.
         */
        public void clear() {
            doClear();
        }

        private void doClear() {
            theSize = 0;
            ensureCapacity(DEFAULT_CAPACITY);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new ArrayListIterator();
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (AnyType x : this) {
                sb.append(x);
            }
            // sb.append(  );

            return new String(sb);
        }

        /**
         * This is the implementation of the ArrayListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyArrayList.
         */
        private class ArrayListIterator implements java.util.Iterator<AnyType> {

            private int current = 0;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current < size();
            }

            public AnyType next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                okToRemove = true;
                return theItems[current++];
            }

            public void remove() {
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyArrayList.this.remove(--current);
                okToRemove = false;
            }
        }

        private static final int DEFAULT_CAPACITY = 10;

        private AnyType[] theItems;
        private int theSize;
    }

    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {

        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList() {

            doClear();
        }

        private void clear() {
            doClear();
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear() {
            beginMarker = new Node<>(null, null, null);
            endMarker = new Node<>(null, beginMarker, null);
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         *
         * @return the number of items in this collection.
         */
        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        public boolean setisEmpty() {
            return size() != 0;
        }

        /**
         * Adds an item to this collection, at the end.
         *
         * @param x any object.
         * @return true.
         */
        public boolean add(AnyType x) {

            add(size(), x);
            return true;
        }

        /**
         * Adds an item to this collection, at specified position. Items at or
         * after that position are slid one position higher.
         *
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        public void add(int idx, AnyType x) {
            addBefore(getNode(idx, 0, size()), x);
        }

        /**
         * Adds an item to this collection, at specified position p. Items at or
         * after that position are slid one position higher.
         *
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(),
         * inclusive.
         */
        private void addBefore(Node<AnyType> p, AnyType x) {
            Node<AnyType> newNode = new Node<>(x, p.prev, p);
            newNode.prev.next = newNode;
            p.prev = newNode;
            theSize++;
            modCount++;
        }

        /**
         * Returns the item at position idx.
         *
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get(int idx) {
            return getNode(idx).data;
        }

        /**
         * Changes the item at position idx.
         *
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set(int idx, AnyType newVal) {
            Node<AnyType> p = getNode(idx);
            AnyType oldVal = p.data;

            p.data = newVal;
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) -
         * 1.
         *
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( )
         * - 1, inclusive.
         */
        private Node<AnyType> getNode(int idx) {
            return getNode(idx, 0, size() - 1);
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         *
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and
         * upper, inclusive.
         */
        private Node<AnyType> getNode(int idx, int lower, int upper) {
            Node<AnyType> p;
            if (idx < lower || idx > upper) {
                throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
            }
            if (idx < size() / 2) {
                p = beginMarker.next;
                for (int i = 0; i < idx; i++) {
                    p = p.next;
                }
            } else {
                p = endMarker;
                for (int i = size(); i > idx; i--) {
                    p = p.prev;
                }
            }
            return p;
        }

        /**
         * Removes an item from this collection.
         *
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove(int idx) {
            return remove(getNode(idx));
        }

        /**
         * Removes the object contained in Node p.
         *
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove(Node<AnyType> p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString() {
            StringBuilder sb = new StringBuilder("[ ");

            for (AnyType x : this) {
                sb.append(x + " ");
            }
            sb.append("]");

            return new String(sb);
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         *
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator() {
            return new LinkedListIterator();
        }

        /**
         * This is the implementation of the LinkedListIterator. It maintains a
         * notion of a current position and of course the implicit reference to
         * the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType> {

            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext() {
                return current != endMarker;
            }

            public AnyType next() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove() {
                if (modCount != expectedModCount) {
                    throw new java.util.ConcurrentModificationException();
                }
                if (!okToRemove) {
                    throw new IllegalStateException();
                }

                MyLinkedList.this.remove(current.prev);
                expectedModCount++;
                okToRemove = false;
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType> {

            public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
                data = d;
                prev = p;
                next = n;
            }

            public AnyType data;
            public Node<AnyType> prev;
            public Node<AnyType> next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }

    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

        /**
         * Construct the binary heap.
         */
        public BinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        /**
         * Construct the binary heap.
         *
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        /**
         * Construct the binary heap given an array of items.
         *
         * @param items
         */
        public BinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        /**
         * Insert into the priority queue, maintaining heap order. Duplicates
         * are allowed.
         *
         * @param x the item to insert.
         */
        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }

            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        /**
         * Find the smallest item in the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];

        }

        public AnyType getMin() {
            return array[1];
        }

        /**
         * Remove the smallest item from the priority queue.
         *
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }

            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary arrangement of items.
         * Runs in linear time.
         */
        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        /**
         * Test if the priority queue is logically empty.
         *
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty() {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty() {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType[] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         *
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];

            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize
                        && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }

    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
