import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int t = input.nextInt();
		for(int i=0; i<t; i++){
			int n = input.nextInt();input.nextLine();
			int[] rows = new int[n];
			int[] columns = new int[n];
			int total = 0;
			for(int j=0; j<n; j++){
				String s = input.nextLine();
				char tempArray[] = s.toCharArray();
				for(int k=0; k<n; k++){
					if(tempArray[k]=='#'){
						columns[k]++;
						rows[j]++;
						total++;
					}
				}
			}
			int c1 = 0, c2 = 0;
			boolean ans = false;
			for(int j=0; j<n; j++){
				c1 += rows[j];
				c2 += columns[j];
				if(c1==total/2 || c2==total/2)
					if(total%2==0)
						ans = true;
			}
			if(ans)
				System.out.println("YES");
			else
				System.out.println("NO");
		}
		input.close();
	}
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		int n = 0;
		Scanner input = new Scanner(System.in);
		n = input.nextInt();
		int array[] = new int[n];
		for(int i=0; i<n; i++){
			array[i] = input.nextInt();
		}
		int p = 0;
		for(int i=0; i<n; i++){
			for(int j=0; j<n; j++){
				if(array[i]*array[j] > p && i != j){
					p = array[i]*array[j];
				}
			}
		}
		System.out.println(p);
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int n;
		n = input.nextInt();input.nextLine();
		for(int i=0; i<n; i++){
			char array[] = input.nextLine().toCharArray();
			int c=0;
			for(int j=0; j<array.length; j++){
				if(array[j]=='W'){
					if(j-2>=0 && array[j-2]=='B')
						c++;
					else if(j-1>=0 && array[j-1]=='B')
						c++;
					else if(j+1<=array.length && array[j+1]=='B')
						c++;
					else if(j+2<=array.length && array[j+2]=='B')
						c++;
				}
			}
			System.out.println(c);
		}
		input.close();
	}
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int n;
		n = input.nextInt();input.nextLine();
		for(int i=0; i<n; i++){
			char array[] = input.nextLine().toCharArray();
			int c=0;
			for(int j=0; j<array.length; j++){
				if(array[j]=='W'){
					if(j-2>=0 && array[j-2]=='B')
						c++;
					else if(j-1>=0 && array[j-1]=='B')
						c++;
					else if(j+1<array.length && array[j+1]=='B')
						c++;
					else if(j+2<array.length && array[j+2]=='B')
						c++;
				}
			}
			System.out.println(c);
		}
		input.close();
	}
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		int n = 0;
		Scanner input = new Scanner(System.in);
		n = input.nextInt();
		long array[] = new long[n];
		for(int i=0; i<n; i++){
			array[i] = input.nextInt();
		}
		long p = 0;
		for(int i=0; i<n; i++){
			for(int j=0; j<n; j++){
				if(array[i]*array[j] > p && i != j){
					p = array[i]*array[j];
				}
			}
		}
		System.out.println(p);
	}
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int t = input.nextInt();
		for(int i=0; i<t; i++){
			int n = input.nextInt();input.nextLine();
			int[] rows = new int[n];
			int[] columns = new int[n];
			int total = 0;
			for(int j=0; j<n; j++){
				String s = input.nextLine();
				char tempArray[] = s.toCharArray();
				for(int k=0; k<n; k++){
					if(tempArray[k]=='#'){
						columns[k]++;
						rows[j]++;
						total++;
					}
				}
			}
			int c = 0;
			boolean ans = false;
			for(int j=0; j<n; j++){
				c += rows[j];
				if(c == (total/2) && total%2 == 0){
						ans = true;
						break;
				}
			}
			if(ans)
				System.out.print(1 + " ");
			else
				System.out.print(0 + " ");
			ans = false;
			c = 0;
			for(int j=0; j<n; j++){
				c += columns[j];
				if(c == (total/2) && total%2 == 0){
						ans = true;
						break;
				}
			}
			if(ans)
				System.out.println(1);
			else
				System.out.println(0);
		}
		input.close();
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{
	public static Integer[] data( HashMap<Integer, Integer[]> map, int per, int time, String status)
	{
		Integer[] data = new Integer[3];
		data[2] = per; 
		if(map.containsKey(per))
		{
			data[0] = map.get(per)[0];
			data[1] = map.get(per)[1];
		}
		else
		{
			data[0] = 0; 
			data[1] = 0;
		}
		if(status.equals("C"))
		{
			data[0]++;
			data[1] += time;
		}
		return data;
	}


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		Comparator<Integer[]> comparator = new CompareIntegerArrays();
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			String[] nk = br.readLine().split(" ");
			int n = Integer.parseInt(nk[0]);
			int k = Integer.parseInt(nk[1]);
			HashMap<Integer, Integer[]> map = new HashMap<Integer, Integer[]>();
			HashMap<Integer, Integer> problemIDs = new HashMap<Integer, Integer>();
			PriorityQueue<Integer[]> arrays = new PriorityQueue<Integer[]>(comparator);
			int problems[][] = new int[n+1][k];
			int c = 0;
			for(int i=0; i<k; i++)
			{
				String[] input = br.readLine().split(" ");
				int per = Integer.parseInt(input[0]);
				int time = Integer.parseInt(input[2]);
				int problem = Integer.parseInt(input[1]);
				if(!problemIDs.containsKey(problem))
				{
					problemIDs.put(problem, c);
					c++;
				}
				String status = input[3];
				map.put(per, data(map, per, time + (problems[per][problemIDs.get(problem)] * 20), status));
				problems[per][problemIDs.get(problem)] ++;
			}

			for(int i=1; i<=n; i++)
			{
				if(map.containsKey(i))
				{
					arrays.add(map.get(i));
				}
			}
			while(!arrays.isEmpty())
			{
				Integer[] outData = arrays.poll();
				System.out.println((outData[2]) + " " + outData[0] + " " + outData[1]);
			}
		}
	}



	public static class CompareIntegerArrays implements  Comparator<Integer[]>
	{
		@Override
		public int compare(Integer[] a, Integer[] b) {
			if(a[0] < b[0])
				return 1;
			else if(a[0] > b[0])
				return -1;
			else
			{
				if(a[1] > b[1])
					return 1;
				else if(a[1] < b[1])
					return -1;
				else
				{
					if(a[2] > b[2])
						return 1;
					else if(a[2] < b[2])
						return -1;
					else
						return 0;
				}
			}
		}
	}


	public class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		public BinaryHeap( AnyType [ ] items )
		{
			currentSize = items.length;
			array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

			int i = 1;
			for( AnyType item : items )
				array[ i++ ] = item;
			buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

			// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		private void enlargeArray( int newSize )
		{
			AnyType [] old = array;
			array = (AnyType []) new Comparable[ newSize ];
			for( int i = 0; i < old.length; i++ )
				array[ i ] = old[ i ];        
		}

		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) < 0 )
					child++;
				if( array[ child ].compareTo( tmp ) < 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
	}








}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class ProblemB 
{

	public static void main(String[] args) throws  IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			String[] inputS = br.readLine().split(" ");
			int[] input = new int[n];
			for(int i=0; i<n; i++)
			{
				input[i] = Integer.parseInt(inputS[i]);
				if(map.containsKey(input[i]))
				{
					map.put(input[i], map.get(input[i])+1);
				}
				else
				{
					map.put(input[i], 1);
				}
			}
			for(int i=0; i<n; i++)
			{
				if(map.containsKey(input[i]))
				{
					System.out.println(input[i] + " " + map.get(input[i]));
					map.remove(input[i]);
				}
			}
			
		}
		
		
		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemC 
{

	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			HashMap<String, Integer> people = new HashMap<String, Integer>();
			QuickFind uf = new QuickFind(n*2);
			int c = 0;
			for(int i=0; i<n; i++)
			{
				String[] input = br.readLine().split(" ");
				if(!people.containsKey(input[0]))
				{
					people.put(input[0], c);
					c++;
				}
				if(!people.containsKey(input[1]))
				{
					people.put(input[1], c);
					c++;
				}
				uf.union(people.get(input[0]), people.get(input[1]));
				System.out.println(uf.connected(people.get(input[0]), people.get(input[1])));
			}

		}

	}

	public static class QuickFind {
		
		private int[] id;
		private int count;
		
		public QuickFind(int N) {
			count = N;
			id = new int[N];
			for (int i = 0; i < N; i++)
			{	
				id[i] = i;
				// System.out.println(id[i]);
			}
		}
		
		public int count()
		{ return count; }
		
		public int find(int p)
		{ return id[p]; }
		
		public boolean find(int p, int q)
		{ return id[p] == id[q]; }
		
		public void union(int p, int q) 
		{
			if ( !find(p, q) )
			{
				int pid = id[q];
				// System.out.println(pid);
				for (int i = 0; i < id.length; i++)
				{
					if (id[i] == pid) 
					{
						id[i] = id[p];
					}
				}
				count--;
			}
		}
		
		public int connected(int x, int y)
		{
			int c = 0;
			for(int i=0; i<id.length; i++)
			{
				if(id[i] == id[x])
				{
					c++;
				}
			}
			return c;
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ProblemD {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for (int tt = 0; tt < t; tt++) 
		{
			System.out.println("Caso #" + (tt + 1) + ":");
			String[] nk = br.readLine().split(" ");
			int n = Integer.parseInt(nk[0]);
			int k = Integer.parseInt(nk[1]);
			QuickFind uf = new QuickFind(n); 
			for (int i = 0; i < k; i++) 
			{
				//Proof
				/* for(int j=0; j<2; j++)
				{
					for(int kk=0; kk<uf.id.length; kk++)
					{
						System.out.print(uf.id[kk][j]);
					}
					System.out.println();
				} */

				String[] inputS = br.readLine().split(" ");
				int[] input = new int[3];
				for(int j=0; j<3; j++)
				{
					input[j] = Integer.parseInt(inputS[j]);
				}
				if(input[0] == 1) //setFriends
				{
					uf.setFriends(input[1], input[2]);
				}
				else if(input[0] == 2) //setEnemies
				{
					uf.setEnemies(input[1], input[2]);
				}
				else if(input[0] == 3) //getFriends
				{
					if(uf.getFriends(input[1], input[2]))
					{
						System.out.println(1);
					}
					else
					{
						System.out.println(0);
					}
				}
				else if(input[0] == 4) //getEnemies
				{
					if(uf.getEnemies(input[1], input[2]))
					{
						System.out.println(1);
					}
					else
					{
						System.out.println(0);
					}
				}
			}
		}

	}

	public static class QuickFind {

		public int[][] id;
		private int count;

		public QuickFind(int N) {
			count = N;
			id = new int[N][2];
			for (int i = 0; i < N; i++) {
				id[i][0] = i;
				id[i][1] = -1;
			}
		}
		public int count() {
			return count;
		}

		/* public int find(int p) {
			return id[p];
		}
		 */

		public boolean getFriends(int p, int q) 
		{
			return id[p][0] == id[q][0];
		}

		public void setFriends(int p, int q) {
			if(getEnemies(p, q))
			{
				System.out.println(-1);
				return;
			}
			if (!getFriends(p, q)) 
			{
				/*if(id[p][1] >= 0 && id[q][1] >= 0)
				{
					setFriends(id[p][1], id[q][1]);	
				}
				 */
				for(int i=0; i<id.length; i++)
				{
					if(id[q][1] == id[i][0])
					{
						id[i][1] = id[p][0];
					}
				}
				int pid = id[q][0];
				for (int i = 0; i < id.length; i++) 
				{
					if (id[i][0] == pid) 
					{
						id[i][0] = id[p][0];
						id[i][1] = id[p][1];
						// Asigna el id de P	
					}
				}
			}
		}

		public boolean getEnemies(int p, int q)
		{
			return (id[p][1] == id[q][0] && id[q][1] == id[p][0]);
		}

		public void setEnemies(int p, int q) {
			if(getFriends(p, q))
			{
				System.out.println(-1);
				return;
			}
			if(!getEnemies(p, q))
			{
				if(id[p][1] > 0)
				{
					setFriends(id[p][1], id[q][0]);
				}
				if(id[q][1] > 0)
				{
					setFriends(id[q][1], id[p][0]);
				}
				for(int i=0; i<id.length; i++)
				{
					if(id[i][0] == id[p][0])
					{
						id[i][1] = id[q][0];
					}
					if(id[i][0] == id[q][0])
					{
						id[i][1] = id[p][0];
					}
				}
			}
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{
	public static Integer[] data( HashMap<Integer, Integer[]> map, int per, int time, String status)
	{
		Integer[] data = new Integer[3];
		data[2] = per; 
		if(map.containsKey(per))
		{
			data[0] = map.get(per)[0];
			data[1] = map.get(per)[1];
		}
		else
		{
			data[0] = 0; 
			data[1] = 0;
		}
		if(status.equals("C"))
		{
			data[0]++;
			data[1] += time;
		}
		return data;
	}


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		Comparator<Integer[]> comparator = new CompareIntegerArrays();
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			String[] nk = br.readLine().split(" ");
			int n = Integer.parseInt(nk[0]);
			int k = Integer.parseInt(nk[1]);
			HashMap<Integer, Integer[]> map = new HashMap<Integer, Integer[]>();
			HashMap<Integer, Integer> problemIDs = new HashMap<Integer, Integer>();
			PriorityQueue<Integer[]> arrays = new PriorityQueue<Integer[]>(comparator);
			int problems[][] = new int[n+1][k];
			int c = 0;
			for(int i=0; i<k; i++)
			{
				String[] input = br.readLine().split(" ");
				int per = Integer.parseInt(input[0]);
				int time = Integer.parseInt(input[2]);
				int problem = Integer.parseInt(input[1]);
				if(!problemIDs.containsKey(problem))
				{
					problemIDs.put(problem, c);
					c++;
				}
				String status = input[3];
				map.put(per, data(map, per, time + (problems[per][problemIDs.get(problem)] * 20), status));
				problems[per][problemIDs.get(problem)] ++;
			}

			for(int i=1; i<=n; i++)
			{
				if(map.containsKey(i))
				{
					arrays.add(map.get(i));
				}
			}
			while(!arrays.isEmpty())
			{
				Integer[] outData = arrays.poll();
				System.out.println((outData[2]) + " " + outData[0] + " " + outData[1]);
			}
		}
	}



	public static class CompareIntegerArrays implements  Comparator<Integer[]>
	{
		@Override
		public int compare(Integer[] a, Integer[] b) {
			if(a[0] < b[0])
				return 1;
			else if(a[0] > b[0])
				return -1;
			else
			{
				if(a[1] > b[1])
					return 1;
				else if(a[1] < b[1])
					return -1;
				else
				{
					if(a[2] > b[2])
						return 1;
					else if(a[2] < b[2])
						return -1;
					else
						return 0;
				}
			}
		}
	}


	public class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		public BinaryHeap( AnyType [ ] items )
		{
			currentSize = items.length;
			array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

			int i = 1;
			for( AnyType item : items )
				array[ i++ ] = item;
			buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

			// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		private void enlargeArray( int newSize )
		{
			AnyType [] old = array;
			array = (AnyType []) new Comparable[ newSize ];
			for( int i = 0; i < old.length; i++ )
				array[ i ] = old[ i ];        
		}

		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) < 0 )
					child++;
				if( array[ child ].compareTo( tmp ) < 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
	}








}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{
	public static Integer[] data( HashMap<Integer, Integer[]> map, int per, int time, String status)
	{
		Integer[] data = new Integer[3];
		data[2] = per; 
		if(map.containsKey(per))
		{
			data[0] = map.get(per)[0];
			data[1] = map.get(per)[1];
		}
		else
		{
			data[0] = 0; 
			data[1] = 0;
		}
		if(status.equals("C"))
		{
			data[0]++;
			data[1] += time;
		}
		return data;
	}


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		Comparator<Integer[]> comparator = new CompareIntegerArrays();
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			String[] nk = br.readLine().split(" ");
			int n = Integer.parseInt(nk[0]);
			int k = Integer.parseInt(nk[1]);
			HashMap<Integer, Integer[]> map = new HashMap<Integer, Integer[]>();
			HashMap<Integer, Integer> problemIDs = new HashMap<Integer, Integer>();
			PriorityQueue<Integer[]> arrays = new PriorityQueue<Integer[]>(comparator);
			int problems[][] = new int[n+1][k];
			int c = 0;
			for(int i=0; i<k; i++)
			{
				String[] input = br.readLine().split(" ");
				int per = Integer.parseInt(input[0]);
				int time = Integer.parseInt(input[2]);
				int problem = Integer.parseInt(input[1]);
				if(!problemIDs.containsKey(problem))
				{
					problemIDs.put(problem, c);
					c++;
				}
				String status = input[3];
                             
                                if(problems[per][problemIDs.get(problem)] >= 0)
                                {
                                     map.put(per, data(map, per, time + (problems[per][problemIDs.get(problem)] * 20), status));
                                     problems[per][problemIDs.get(problem)] ++;
                                }
				if(status.equals("C"))
                                {
                                   problems[per][problemIDs.get(problem)] = -1;
                                }
                                
			}

			for(int i=1; i<=n; i++)
			{
				if(map.containsKey(i))
				{
					arrays.add(map.get(i));
				}
			}
			while(!arrays.isEmpty())
			{
				Integer[] outData = arrays.poll();
				System.out.println((outData[2]) + " " + outData[0] + " " + outData[1]);
			}
		}
	}

	public static class CompareIntegerArrays implements  Comparator<Integer[]>
	{
		@Override
		public int compare(Integer[] a, Integer[] b) {
			if(a[0] < b[0])
				return 1;
			else if(a[0] > b[0])
				return -1;
			else
			{
				if(a[1] > b[1])
					return 1;
				else if(a[1] < b[1])
					return -1;
				else
				{
					if(a[2] > b[2])
						return 1;
					else if(a[2] < b[2])
						return -1;
					else
						return 0;
				}
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{
	public static Integer[] data( HashMap<Integer, Integer[]> map, int per, int time, String status)
	{
		Integer[] data = new Integer[3];
		data[2] = per; 
		if(map.containsKey(per))
		{
			data[0] = map.get(per)[0];
			data[1] = map.get(per)[1];
		}
		else
		{
			data[0] = 0; 
			data[1] = 0;
		}
		if(status.equals("C"))
		{
			data[0]++;
			data[1] += time;
		}
		return data;
	}


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// Comparator<Integer[]> comparator = new CompareIntegerArrays();
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			String[] nk = br.readLine().split(" ");
			int n = Integer.parseInt(nk[0]);
			int k = Integer.parseInt(nk[1]);
			HashMap<Integer, Integer[]> map = new HashMap<Integer, Integer[]>();
			HashMap<Integer, Integer> problemIDs = new HashMap<Integer, Integer>();
			PriorityQueue<CompareIntegerArrays> arrays = new PriorityQueue<CompareIntegerArrays>();
			int problems[][] = new int[n+1][k];
			int c = 0;
			for(int i=0; i<k; i++)
			{
				String[] input = br.readLine().split(" ");
				int per = Integer.parseInt(input[0]);
				int time = Integer.parseInt(input[2]);
				int problem = Integer.parseInt(input[1]);
				if(!problemIDs.containsKey(problem))
				{
					problemIDs.put(problem, c);
					c++;
				}
				String status = input[3];
                             
                                if(problems[per][problemIDs.get(problem)] >= 0)
                                {
                                     map.put(per, data(map, per, time + (problems[per][problemIDs.get(problem)] * 20), status));
                                     problems[per][problemIDs.get(problem)] ++;
                                }
				if(status.equals("C"))
                                {
                                   problems[per][problemIDs.get(problem)] = -1;
                                }       
			}

			for(int i=1; i<=n; i++)
			{
				if(map.containsKey(i))
				{
					arrays.add(new CompareIntegerArrays(map.get(i)));
				}
			}
			while(!arrays.isEmpty())
			{
				Integer[] outData = arrays.poll().a;
				System.out.println((outData[2]) + " " + outData[0] + " " + outData[1]);
			}
		}
	}

	public static class CompareIntegerArrays implements Comparable<CompareIntegerArrays>
        {
            
            Integer[] a;
            public CompareIntegerArrays(Integer[] a)
                    {
                        this.a = a;
                    }
		public int compare(Integer[] a, Integer[] b) {
			if(a[0] < b[0])
				return 1;
			else if(a[0] > b[0])
				return -1;
			else
			{
				if(a[1] > b[1])
					return 1;
				else if(a[1] < b[1])
					return -1;
				else
				{
					if(a[2] > b[2])
						return 1;
					else if(a[2] < b[2])
						return -1;
					else
						return 0;
				}
			}
		}

        @Override
        public int compareTo(CompareIntegerArrays b) {
            if(a[0] < b.a[0])
				return 1;
			else if(a[0] > b.a[0])
				return -1;
			else
			{
				if(a[1] > b.a[1])
					return 1;
				else if(a[1] < b.a[1])
					return -1;
				else
				{
					if(a[2] > b.a[2])
						return 1;
					else if(a[2] < b.a[2])
						return -1;
					else
						return 0;
				}
			}
        }
	}

        
        // BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

/**
 * Implements a binary heap.
 * Note that all "matching" is based on the compareTo method.
 * @param <AnyType>
 */
public class BinaryHeap<AnyType extends Comparable<? super AnyType>>
{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize &&
                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }

        // Test program
}

        
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{
	public static Integer[] data( HashMap<Integer, Integer[]> map, int per, int time, String status)
	{
		Integer[] data = new Integer[3];
		data[2] = per; 
		if(map.containsKey(per))
		{
			data[0] = map.get(per)[0];
			data[1] = map.get(per)[1];
		}
		else
		{
			data[0] = 0; 
			data[1] = 0;
		}
		if(status.equals("C"))
		{
			data[0]++;
			data[1] += time;
		}
		return data;
	}


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// Comparator<Integer[]> comparator = new CompareIntegerArrays();
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			String[] nk = br.readLine().split(" ");
			int n = Integer.parseInt(nk[0]);
			int k = Integer.parseInt(nk[1]);
			HashMap<Integer, Integer[]> map = new HashMap<Integer, Integer[]>();
			HashMap<Integer, Integer> problemIDs = new HashMap<Integer, Integer>();
			PriorityQueue<CompareIntegerArrays> arrays = new PriorityQueue<CompareIntegerArrays>();
			int problems[][] = new int[n+1][k];
			int c = 0;
                        int[] errors = new int[4];
			for(int i=0; i<k; i++)
			{
                            
                            
                            
                            
				String[] input = br.readLine().split(" ");
				int per = Integer.parseInt(input[0]);
				int time = Integer.parseInt(input[2]);
				int problem = Integer.parseInt(input[1]);
				if(!problemIDs.containsKey(problem))
				{
					problemIDs.put(problem, c);
					c++;
				}
                                
                                
				String status = input[3];
                             
                               
                                
                                
                                if(problems[per][problemIDs.get(problem)] >= 0)
                                {
                                     map.put(per, data(map, per, time + (problems[per][problemIDs.get(problem)] * 20), status));
                                     problems[per][problemIDs.get(problem)] ++;
                                }
				if(status.equals("C"))
                                {
                                   problems[per][problemIDs.get(problem)] = -1;
                                   errors[0] ++;
                                } 
                                else if(status.equals("I"))
                                    {
                                        errors[1] ++;
                                    }
                                else if(status.equals("T"))
                                    {
                                        errors[2] ++;
                                    }
                                else if(status.equals("R"))
                                    {
                                        errors[3] ++;
                                    }
			}

			for(int i=1; i<=n; i++)
			{
				if(map.containsKey(i))
				{
					arrays.add(new CompareIntegerArrays(map.get(i)));
				}
			}
			while(!arrays.isEmpty())
			{
				Integer[] outData = arrays.poll().a;
				System.out.println((outData[2]) + " " + outData[0] + " " + outData[1]);
			}
                        for(int i=0; i<4; i++)
                        {
                            System.out.print(errors[i] + " ");
                        }
		}
	}

	public static class CompareIntegerArrays implements Comparable<CompareIntegerArrays>
        {
            
            Integer[] a;
            public CompareIntegerArrays(Integer[] a)
                    {
                        this.a = a;
                    }
		public int compare(Integer[] a, Integer[] b) {
			if(a[0] < b[0])
				return 1;
			else if(a[0] > b[0])
				return -1;
			else
			{
				if(a[1] > b[1])
					return 1;
				else if(a[1] < b[1])
					return -1;
				else
				{
					if(a[2] > b[2])
						return 1;
					else if(a[2] < b[2])
						return -1;
					else
						return 0;
				}
			}
		}

        @Override
        public int compareTo(CompareIntegerArrays b) {
            if(a[0] < b.a[0])
				return 1;
			else if(a[0] > b.a[0])
				return -1;
			else
			{
				if(a[1] > b.a[1])
					return 1;
				else if(a[1] < b.a[1])
					return -1;
				else
				{
					if(a[2] > b.a[2])
						return 1;
					else if(a[2] < b.a[2])
						return -1;
					else
						return 0;
				}
			}
        }
	}

        
        // BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

/**
 * Implements a binary heap.
 * Note that all "matching" is based on the compareTo method.
 * @param <AnyType>
 */
public class BinaryHeap<AnyType extends Comparable<? super AnyType>>
{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize &&
                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }

        // Test program
}

        
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{
	public static Integer[] data( HashMap<Integer, Integer[]> map, int per, int time, String status)
	{
		Integer[] data = new Integer[3];
		data[2] = per; 
		if(map.containsKey(per))
		{
			data[0] = map.get(per)[0];
			data[1] = map.get(per)[1];
		}
		else
		{
			data[0] = 0; 
			data[1] = 0;
		}
		if(status.equals("C"))
		{
			data[0]++;
			data[1] += time;
		}
		return data;
	}


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// Comparator<Integer[]> comparator = new CompareIntegerArrays();
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			String[] nk = br.readLine().split(" ");
			int n = Integer.parseInt(nk[0]);
			int k = Integer.parseInt(nk[1]);
			HashMap<Integer, Integer[]> map = new HashMap<Integer, Integer[]>();
			HashMap<Integer, Integer> problemIDs = new HashMap<Integer, Integer>();
			PriorityQueue<CompareIntegerArrays> arrays = new PriorityQueue<CompareIntegerArrays>();
			int problems[][] = new int[n+1][k];
			int c = 0;
                        int[] errors = new int[4];
			for(int i=0; i<k; i++)
			{
                            
                            
                            
                            
				String[] input = br.readLine().split(" ");
				int per = Integer.parseInt(input[0]);
				int time = Integer.parseInt(input[2]);
				int problem = Integer.parseInt(input[1]);
				if(!problemIDs.containsKey(problem))
				{
					problemIDs.put(problem, c);
					c++;
				}
                                
                                
				String status = input[3];
                             
                               
                                
                                
                                if(problems[per][problemIDs.get(problem)] >= 0)
                                {
                                     map.put(per, data(map, per, time + (problems[per][problemIDs.get(problem)] * 20), status));
                                     problems[per][problemIDs.get(problem)] ++;
                                }
				if(status.equals("C"))
                                {
                                   problems[per][problemIDs.get(problem)] = -1;
                                   errors[0] ++;
                                } 
                                else if(status.equals("I"))
                                    {
                                        errors[1] ++;
                                    }
                                else if(status.equals("T"))
                                    {
                                        errors[2] ++;
                                    }
                                else if(status.equals("R"))
                                    {
                                        errors[3] ++;
                                    }
			}

			for(int i=1; i<=n; i++)
			{
				if(map.containsKey(i))
				{
					arrays.add(new CompareIntegerArrays(map.get(i)));
				}
			}
			while(!arrays.isEmpty())
			{
				Integer[] outData = arrays.poll().a;
				System.out.println((outData[2]) + " " + outData[0] + " " + outData[1]);
			}
                        for(int i=0; i<4; i++)
                        {
                            System.out.print(errors[i] + " ");
                        }
                        System.out.println();
		}
	}

	public static class CompareIntegerArrays implements Comparable<CompareIntegerArrays>
        {
            
            Integer[] a;
            public CompareIntegerArrays(Integer[] a)
                    {
                        this.a = a;
                    }
		public int compare(Integer[] a, Integer[] b) {
			if(a[0] < b[0])
				return 1;
			else if(a[0] > b[0])
				return -1;
			else
			{
				if(a[1] > b[1])
					return 1;
				else if(a[1] < b[1])
					return -1;
				else
				{
					if(a[2] > b[2])
						return 1;
					else if(a[2] < b[2])
						return -1;
					else
						return 0;
				}
			}
		}

        @Override
        public int compareTo(CompareIntegerArrays b) {
            if(a[0] < b.a[0])
				return 1;
			else if(a[0] > b.a[0])
				return -1;
			else
			{
				if(a[1] > b.a[1])
					return 1;
				else if(a[1] < b.a[1])
					return -1;
				else
				{
					if(a[2] > b.a[2])
						return 1;
					else if(a[2] < b.a[2])
						return -1;
					else
						return 0;
				}
			}
        }
	}

        
        // BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

/**
 * Implements a binary heap.
 * Note that all "matching" is based on the compareTo method.
 * @param <AnyType>
 */
public class BinaryHeap<AnyType extends Comparable<? super AnyType>>
{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize &&
                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }

        // Test program
}

        
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.*
;

public class SolveA {

	public static void main(String args[]) throws FileNotFoundException {
		Scanner scan;
		File f = new File("A_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 0; t < n; t++) {
			System.out.println("Caso #" + (t+1) + ":");
			int Q = Integer.parseInt(scan.nextLine());// numero de consultas
			LinkedList<Integer> queue = new LinkedList<Integer>();
			ArrayList<Integer> parking = new ArrayList<Integer>();
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que
				int c = 0;										// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					queue.add(Integer.parseInt(line[1]));
				} else if (type.equals("atender")) {
					parking.add(queue.get(0));
					queue.remove(0);
				} else if (type.equals("existe")) {
					boolean match = false;
					for(int j=0; j<parking.size(); j++)
					{
						if(parking.get(j) == Integer.parseInt(line[1]))
						{
							System.out.println("SI");
							match = true;
							break;
						}
					}
					if(!match)
					{
						System.out.println("NO");
					}
				}

			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.*
;

public class SolveA {

	public static void main(String args[]) throws FileNotFoundException {
		Scanner scan;
		File f = new File("A_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 0; t < n; t++) {
			System.out.println("Caso #" + (t+1) + ":");
			int Q = Integer.parseInt(scan.nextLine());// numero de consultas
			LinkedList<Integer> queue = new LinkedList<Integer>();
			BinarySearchTree<Integer> parking = new BinarySearchTree<Integer>();
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que
				int c = 0;										// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					queue.add(Integer.parseInt(line[1]));
				} else if (type.equals("atender")) {
					parking.insert(queue.get(0));
					queue.remove(0);
				} else if (type.equals("existe")) {
					if (parking.contains(Integer.parseInt(line[1])))
						System.out.println("SI");
					else
						System.out.println("NO");
					
				}

			}
		}
	}

	
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the tree.
	     */
	    public BinarySearchTree( )
	    {
	        root = null;
	    }

	    /**
	     * Insert into the tree; duplicates are ignored.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        root = insert( x, root );
	    }

	    /**
	     * Remove from the tree. Nothing is done if x is not found.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        root = remove( x, root );
	    }

	    /**
	     * Find the smallest item in the tree.
	     * @return smallest item or null if empty.
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return findMin( root ).element;
	    }

	    /**
	     * Find the largest item in the tree.
	     * @return the largest item of null if empty.
	     */
	    public AnyType findMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return findMax( root ).element;
	    }

	    /**
	     * Find an item in the tree.
	     * @param x the item to search for.
	     * @return true if not found.
	     */
	    public boolean contains( AnyType x )
	    {
	        return contains( x, root );
	    }

	    /**
	     * Make the tree logically empty.
	     */
	    public void makeEmpty( )
	    {
	        root = null;
	    }

	    /**
	     * Test if the tree is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return root == null;
	    }

	    /**
	     * Print the tree contents in sorted order.
	     */
	    public void printTree( )
	    {
	        if( isEmpty( ) )
	            System.out.println( "Empty tree" );
	        else
	            printTree( root );
	    }

	    /**
	     * Internal method to insert into a subtree.
	     * @param x the item to insert.
	     * @param t the node that roots the subtree.
	     * @return the new root of the subtree.
	     */
	    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return new BinaryNode<>( x, null, null );
	        
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            t.left = insert( x, t.left );
	        else if( compareResult > 0 )
	            t.right = insert( x, t.right );
	        else
	            ;  // Duplicate; do nothing
	        return t;
	    }

	    /**
	     * Internal method to remove from a subtree.
	     * @param x the item to remove.
	     * @param t the node that roots the subtree.
	     * @return the new root of the subtree.
	     */
	    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return t;   // Item not found; do nothing
	            
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            t.left = remove( x, t.left );
	        else if( compareResult > 0 )
	            t.right = remove( x, t.right );
	        else if( t.left != null && t.right != null ) // Two children
	        {
	            t.element = findMin( t.right ).element;
	            t.right = remove( t.element, t.right );
	        }
	        else
	            t = ( t.left != null ) ? t.left : t.right;
	        return t;
	    }

	    /**
	     * Internal method to find the smallest item in a subtree.
	     * @param t the node that roots the subtree.
	     * @return node containing the smallest item.
	     */
	    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return null;
	        else if( t.left == null )
	            return t;
	        return findMin( t.left );
	    }

	    /**
	     * Internal method to find the largest item in a subtree.
	     * @param t the node that roots the subtree.
	     * @return node containing the largest item.
	     */
	    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
	    {
	        if( t != null )
	            while( t.right != null )
	                t = t.right;

	        return t;
	    }

	    /**
	     * Internal method to find an item in a subtree.
	     * @param x is item to search for.
	     * @param t the node that roots the subtree.
	     * @return node containing the matched item.
	     */
	    private boolean contains( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return false;
	            
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            return contains( x, t.left );
	        else if( compareResult > 0 )
	            return contains( x, t.right );
	        else
	            return true;    // Match
	    }

	    /**
	     * Internal method to print a subtree in sorted order.
	     * @param t the node that roots the subtree.
	     */
	    private void printTree( BinaryNode<AnyType> t )
	    {
	        if( t != null )
	        {
	            printTree( t.left );
	            System.out.println( t.element );
	            printTree( t.right );
	        }
	    }

	    /**
	     * Internal method to compute height of a subtree.
	     * @param t the node that roots the subtree.
	     */
	    private int height( BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return -1;
	        else
	            return 1 + Math.max( height( t.left ), height( t.right ) );    
	    }
	    
	    // Basic node stored in unbalanced binary search trees
	    private class BinaryNode<AnyType>
	    {
	            // Constructors
	        BinaryNode( AnyType theElement )
	        {
	            this( theElement, null, null );
	        }

	        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
	        {
	            element  = theElement;
	            left     = lt;
	            right    = rt;
	        }

	        AnyType element;            // The data in the node
	        BinaryNode<AnyType> left;   // Left child
	        BinaryNode<AnyType> right;  // Right child
	    }


	      /** The tree root. */
	    private BinaryNode<AnyType> root;
	}
	
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.*
;

public class SolveA {

	public static void main(String args[]) throws FileNotFoundException {
		Scanner scan;
		File f = new File("A_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 0; t < n; t++) {
			System.out.println("Caso #" + (t+1) + ":");
			int Q = Integer.parseInt(scan.nextLine());// numero de consultas
			Queue<Integer> queue = new LinkedList<Integer>();
			BinarySearchTree<Integer> parking = new BinarySearchTree<Integer>();
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que								// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					queue.add(Integer.parseInt(line[1]));
				} else if (type.equals("atender")) {
					parking.insert(queue.poll());
				} else if (type.equals("existe")) {
					if (parking.contains(Integer.parseInt(line[1])))
						System.out.println("SI");
					else
						System.out.println("NO");
					
				}

			}
		}
	}

	
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the tree.
	     */
	    public BinarySearchTree( )
	    {
	        root = null;
	    }

	    /**
	     * Insert into the tree; duplicates are ignored.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        root = insert( x, root );
	    }

	    /**
	     * Remove from the tree. Nothing is done if x is not found.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        root = remove( x, root );
	    }

	    /**
	     * Find the smallest item in the tree.
	     * @return smallest item or null if empty.
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return findMin( root ).element;
	    }

	    /**
	     * Find the largest item in the tree.
	     * @return the largest item of null if empty.
	     */
	    public AnyType findMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return findMax( root ).element;
	    }

	    /**
	     * Find an item in the tree.
	     * @param x the item to search for.
	     * @return true if not found.
	     */
	    public boolean contains( AnyType x )
	    {
	        return contains( x, root );
	    }

	    /**
	     * Make the tree logically empty.
	     */
	    public void makeEmpty( )
	    {
	        root = null;
	    }

	    /**
	     * Test if the tree is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return root == null;
	    }

	    /**
	     * Print the tree contents in sorted order.
	     */
	    public void printTree( )
	    {
	        if( isEmpty( ) )
	            System.out.println( "Empty tree" );
	        else
	            printTree( root );
	    }

	    /**
	     * Internal method to insert into a subtree.
	     * @param x the item to insert.
	     * @param t the node that roots the subtree.
	     * @return the new root of the subtree.
	     */
	    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return new BinaryNode<>( x, null, null );
	        
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            t.left = insert( x, t.left );
	        else if( compareResult > 0 )
	            t.right = insert( x, t.right );
	        else
	            ;  // Duplicate; do nothing
	        return t;
	    }

	    /**
	     * Internal method to remove from a subtree.
	     * @param x the item to remove.
	     * @param t the node that roots the subtree.
	     * @return the new root of the subtree.
	     */
	    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return t;   // Item not found; do nothing
	            
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            t.left = remove( x, t.left );
	        else if( compareResult > 0 )
	            t.right = remove( x, t.right );
	        else if( t.left != null && t.right != null ) // Two children
	        {
	            t.element = findMin( t.right ).element;
	            t.right = remove( t.element, t.right );
	        }
	        else
	            t = ( t.left != null ) ? t.left : t.right;
	        return t;
	    }

	    /**
	     * Internal method to find the smallest item in a subtree.
	     * @param t the node that roots the subtree.
	     * @return node containing the smallest item.
	     */
	    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return null;
	        else if( t.left == null )
	            return t;
	        return findMin( t.left );
	    }

	    /**
	     * Internal method to find the largest item in a subtree.
	     * @param t the node that roots the subtree.
	     * @return node containing the largest item.
	     */
	    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
	    {
	        if( t != null )
	            while( t.right != null )
	                t = t.right;

	        return t;
	    }

	    /**
	     * Internal method to find an item in a subtree.
	     * @param x is item to search for.
	     * @param t the node that roots the subtree.
	     * @return node containing the matched item.
	     */
	    private boolean contains( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return false;
	            
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            return contains( x, t.left );
	        else if( compareResult > 0 )
	            return contains( x, t.right );
	        else
	            return true;    // Match
	    }

	    /**
	     * Internal method to print a subtree in sorted order.
	     * @param t the node that roots the subtree.
	     */
	    private void printTree( BinaryNode<AnyType> t )
	    {
	        if( t != null )
	        {
	            printTree( t.left );
	            System.out.println( t.element );
	            printTree( t.right );
	        }
	    }

	    /**
	     * Internal method to compute height of a subtree.
	     * @param t the node that roots the subtree.
	     */
	    private int height( BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return -1;
	        else
	            return 1 + Math.max( height( t.left ), height( t.right ) );    
	    }
	    
	    // Basic node stored in unbalanced binary search trees
	    private class BinaryNode<AnyType>
	    {
	            // Constructors
	        BinaryNode( AnyType theElement )
	        {
	            this( theElement, null, null );
	        }

	        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
	        {
	            element  = theElement;
	            left     = lt;
	            right    = rt;
	        }

	        AnyType element;            // The data in the node
	        BinaryNode<AnyType> left;   // Left child
	        BinaryNode<AnyType> right;  // Right child
	    }


	      /** The tree root. */
	    private BinaryNode<AnyType> root;
	}
	
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
import java.util.*;

public class SolveB {

	public static void main(String args[]) throws NumberFormatException, Exception {
		Scanner scan;
		File f = new File("B_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 0; t < n; t++) {
			System.out.println("Caso #" + (t+1) + ":");
		    String s[] = scan.nextLine().split(" ");
			int Q = Integer.parseInt(s[0]);// numero de consultas
			int N = Integer.parseInt(s[1]);// parqueaderos
			Queue<Integer> queue = new LinkedList<Integer>();
			HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
			BinaryHeap<Integer> heap = new BinaryHeap<Integer>();
			for(int i=0; i<N; i++)
				heap.insert(i);
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que
														// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					queue.add(Integer.parseInt(line[1]));
				} else if (type.equals("atender")) {
					map.put(queue.poll(), heap.deleteMin());
				} else if (type.equals("existe")) {
					int number = Integer.parseInt(line[1]);
					if(map.containsKey(number))
						System.out.println("SI " + map.get(number));
					else
						System.out.println("NO");
				} else if (type.equals("salir")) {
					int number = Integer.parseInt(line[1]);
					heap.insert(map.get(number));
					map.remove(number);
				}

			}
		}
	}

	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }
	}
	
	
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.*
;

public class SolveA {

	public static void main(String args[]) throws FileNotFoundException {
		Scanner scan;
		File f = new File("A_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
			// System.setOut(new PrintStream(new File("A_1Out.txt")));
		} else {
			scan = new Scanner(System.in);
		}
		int n = Integer.parseInt(scan.nextLine());
		for (int t = 0; t < n; t++) {
			System.out.println("Caso #" + (t+1) + ":");
			int Q = Integer.parseInt(scan.nextLine());// numero de consultas
			Queue<Integer> queue = new LinkedList<Integer>();
			HashMap<Integer, Integer> parking = new HashMap<Integer, Integer>();
			for (int i = 0; i < Q; i++) {
				String line[] = scan.nextLine().split(" ");// linea para ver que								// tipo de comando
				String type = line[0];
				if (type.equals("agregar")) {
					queue.add(Integer.parseInt(line[1]));
				} else if (type.equals("atender")) {
					parking.put(queue.poll(), 0);
				} else if (type.equals("existe")) {
					if (parking.containsKey(Integer.parseInt(line[1])))
						System.out.println("SI");
					else
						System.out.println("NO");
					
				}

			}
		}
	}

	
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the tree.
	     */
	    public BinarySearchTree( )
	    {
	        root = null;
	    }

	    /**
	     * Insert into the tree; duplicates are ignored.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        root = insert( x, root );
	    }

	    /**
	     * Remove from the tree. Nothing is done if x is not found.
	     * @param x the item to remove.
	     */
	    public void remove( AnyType x )
	    {
	        root = remove( x, root );
	    }

	    /**
	     * Find the smallest item in the tree.
	     * @return smallest item or null if empty.
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return findMin( root ).element;
	    }

	    /**
	     * Find the largest item in the tree.
	     * @return the largest item of null if empty.
	     */
	    public AnyType findMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return findMax( root ).element;
	    }

	    /**
	     * Find an item in the tree.
	     * @param x the item to search for.
	     * @return true if not found.
	     */
	    public boolean contains( AnyType x )
	    {
	        return contains( x, root );
	    }

	    /**
	     * Make the tree logically empty.
	     */
	    public void makeEmpty( )
	    {
	        root = null;
	    }

	    /**
	     * Test if the tree is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return root == null;
	    }

	    /**
	     * Print the tree contents in sorted order.
	     */
	    public void printTree( )
	    {
	        if( isEmpty( ) )
	            System.out.println( "Empty tree" );
	        else
	            printTree( root );
	    }

	    /**
	     * Internal method to insert into a subtree.
	     * @param x the item to insert.
	     * @param t the node that roots the subtree.
	     * @return the new root of the subtree.
	     */
	    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return new BinaryNode<>( x, null, null );
	        
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            t.left = insert( x, t.left );
	        else if( compareResult > 0 )
	            t.right = insert( x, t.right );
	        else
	            ;  // Duplicate; do nothing
	        return t;
	    }

	    /**
	     * Internal method to remove from a subtree.
	     * @param x the item to remove.
	     * @param t the node that roots the subtree.
	     * @return the new root of the subtree.
	     */
	    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return t;   // Item not found; do nothing
	            
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            t.left = remove( x, t.left );
	        else if( compareResult > 0 )
	            t.right = remove( x, t.right );
	        else if( t.left != null && t.right != null ) // Two children
	        {
	            t.element = findMin( t.right ).element;
	            t.right = remove( t.element, t.right );
	        }
	        else
	            t = ( t.left != null ) ? t.left : t.right;
	        return t;
	    }

	    /**
	     * Internal method to find the smallest item in a subtree.
	     * @param t the node that roots the subtree.
	     * @return node containing the smallest item.
	     */
	    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return null;
	        else if( t.left == null )
	            return t;
	        return findMin( t.left );
	    }

	    /**
	     * Internal method to find the largest item in a subtree.
	     * @param t the node that roots the subtree.
	     * @return node containing the largest item.
	     */
	    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
	    {
	        if( t != null )
	            while( t.right != null )
	                t = t.right;

	        return t;
	    }

	    /**
	     * Internal method to find an item in a subtree.
	     * @param x is item to search for.
	     * @param t the node that roots the subtree.
	     * @return node containing the matched item.
	     */
	    private boolean contains( AnyType x, BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return false;
	            
	        int compareResult = x.compareTo( t.element );
	            
	        if( compareResult < 0 )
	            return contains( x, t.left );
	        else if( compareResult > 0 )
	            return contains( x, t.right );
	        else
	            return true;    // Match
	    }

	    /**
	     * Internal method to print a subtree in sorted order.
	     * @param t the node that roots the subtree.
	     */
	    private void printTree( BinaryNode<AnyType> t )
	    {
	        if( t != null )
	        {
	            printTree( t.left );
	            System.out.println( t.element );
	            printTree( t.right );
	        }
	    }

	    /**
	     * Internal method to compute height of a subtree.
	     * @param t the node that roots the subtree.
	     */
	    private int height( BinaryNode<AnyType> t )
	    {
	        if( t == null )
	            return -1;
	        else
	            return 1 + Math.max( height( t.left ), height( t.right ) );    
	    }
	    
	    // Basic node stored in unbalanced binary search trees
	    private class BinaryNode<AnyType>
	    {
	            // Constructors
	        BinaryNode( AnyType theElement )
	        {
	            this( theElement, null, null );
	        }

	        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
	        {
	            element  = theElement;
	            left     = lt;
	            right    = rt;
	        }

	        AnyType element;            // The data in the node
	        BinaryNode<AnyType> left;   // Left child
	        BinaryNode<AnyType> right;  // Right child
	    }


	      /** The tree root. */
	    private BinaryNode<AnyType> root;
	}
	
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{



	public static void main(String[] args) throws Exception 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			String[] letters = br.readLine().split(" ");
			HashMap<Character, Integer> indexes = new HashMap<Character, Integer>();
			HashMap<Character, Integer> fathers = new HashMap<Character, Integer>();
			for(int i=0; i<n; i++)
			{
				indexes.put(letters[i].charAt(0), i);
				fathers.put(letters[i].charAt(0), 0);
			}
			BinaryHeap<Character> heap = new BinaryHeap<Character>();
			String[] inputCommands = br.readLine().split(" ");
			char[][] commands = new char[inputCommands.length][3];
			for(int i=0; i<inputCommands.length; i++)
			{
				commands[i][0] = inputCommands[i].charAt(0);
				commands[i][1] = inputCommands[i].charAt(1);
				commands[i][2] = inputCommands[i].charAt(2);
			}
			MyArrayList<MyLinkedList<Character>> graph = new MyArrayList<MyLinkedList<Character>>();

			// Initialize
			for(int i=0; i<n; i++)
			{
				graph.add(new MyLinkedList<Character>());
				graph.get(i).add(letters[i].charAt(0));
			}

			// Insert
			for(int i=0; i<inputCommands.length; i++)
			{

				if(commands[i][1] == '<')
				{
					graph.get(indexes.get(commands[i][2])).add(commands[i][0]);
					fathers.put(commands[i][2], fathers.get(commands[i][2])+1);
				}
				else
				{
					graph.get(indexes.get(commands[i][0])).add(commands[i][2]);
					fathers.put(commands[i][0], fathers.get(commands[i][0])+1);
				}
			}

			//Remove
			MyArrayList<Character> out = new MyArrayList<Character>();
			for(int i=0; i<n; i++)
			{
				//System.out.println(i);
				for(int j=0; j<n; j++)
				{
					//System.out.println(graph.get(j).size() + "f1");
						if(graph.get(j).size() == 1)
						{
							heap.insert(graph.get(j).get(0));
							graph.get(j).doClear();
						}
				}
				if(!heap.isEmpty())
				{
					fathers.remove(heap.findMin());
					out.add(heap.deleteMin());
				}
				for(int j=0; j<n; j++)
				{
					//System.out.println(graph.get(j).size() + "f2");
					if(graph.get(j).size() != 0)
					{
						char a = graph.get(j).get(0);
						for(int k=1; k<graph.get(j).size(); k++)
						{
							if(!fathers.containsKey(graph.get(j).get(k)))
							{
								graph.get(j).remove(k);	
								fathers.put(a, fathers.get(a - 1));
							}
						}
					}
				}
			}

			//Out
			if(out.size() != n)
			{
				System.out.println("NO");
			}
			else
			{
				for(int i=0; i<n; i++)
				{
					System.out.print(out.get(i) + " ");
				}
				System.out.println();
			}
				
		}

	}


	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList( )
		{
			doClear( );
		}

		private void clear( )
		{
			doClear( );
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear( )
		{
			beginMarker = new Node<>( null, null, null );
			endMarker = new Node<>( null, beginMarker, null );
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * @return the number of items in this collection.
		 */
		public int size( )
		{
			return theSize;
		}

		public boolean isEmpty( )
		{
			return size( ) == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * @param x any object.
		 * @return true.
		 */
		public boolean add( AnyType x )
		{

			add( size( ), x );   
			return true;         
		}

		/**
		 * Adds an item to this collection, at specified position.
		 * Items at or after that position are slid one position higher.
		 * @param x any object.
		 * @param idx position to add at.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
		 */
		public void add( int idx, AnyType x )
		{
			addBefore( getNode( idx, 0, size( ) ), x );
		}

		/**
		 * Adds an item to this collection, at specified position p.
		 * Items at or after that position are slid one position higher.
		 * @param p Node to add before.
		 * @param x any object.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
		 */    
		private void addBefore( Node<AnyType> p, AnyType x )
		{
			Node<AnyType> newNode = new Node<>( x, p.prev, p );
			newNode.prev.next = newNode;
			p.prev = newNode;         
			theSize++;
			modCount++;
		}   


		/**
		 * Returns the item at position idx.
		 * @param idx the index to search in.
		 * @throws IndexOutOfBoundsException if index is out of range.
		 */
		public AnyType get( int idx )
		{
			return getNode( idx ).data;
		}

		/**
		 * Changes the item at position idx.
		 * @param idx the index to change.
		 * @param newVal the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException if index is out of range.
		 */
		public AnyType set( int idx, AnyType newVal )
		{
			Node<AnyType> p = getNode( idx );
			AnyType oldVal = p.data;

			p.data = newVal;   
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) - 1.
		 * @param idx index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode( int idx )
		{
			return getNode( idx, 0, size( ) - 1 );
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * @param idx index to search at.
		 * @param lower lowest valid index.
		 * @param upper highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
		 */    
		private Node<AnyType> getNode( int idx, int lower, int upper )
		{
			Node<AnyType> p;  
			if( idx < lower || idx > upper )
				throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
			if( idx < size( ) / 2 ){
				p = beginMarker.next;
				for( int i = 0; i < idx; i++ )
					p = p.next;            
			}
			else{
				p = endMarker;
				for( int i = size( ); i > idx; i-- )
					p = p.prev;
			}         
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * @param idx the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove( int idx )
		{
			return remove( getNode( idx ) );
		}

		/**
		 * Removes the object contained in Node p.
		 * @param p the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove( Node<AnyType> p )
		{
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString( )
		{
			StringBuilder sb = new StringBuilder( "[ " );

			for( AnyType x : this )
				sb.append( x + " " );
			sb.append( "]" );

			return new String( sb );
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator( )
		{
			return new LinkedListIterator( );
		}

		/**
		 * This is the implementation of the LinkedListIterator.
		 * It maintains a notion of a current position and of
		 * course the implicit reference to the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType>
		{
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext( )
			{
				return current != endMarker;
			}

			public AnyType next( )
			{
				if( modCount != expectedModCount )
					throw new java.util.ConcurrentModificationException( );
				if( !hasNext( ) )
					throw new java.util.NoSuchElementException( ); 

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove( )
			{
				if( modCount != expectedModCount )
					throw new java.util.ConcurrentModificationException( );
				if( !okToRemove )
					throw new IllegalStateException( );

				MyLinkedList.this.remove( current.prev );
				expectedModCount++;
				okToRemove = false;       
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private class Node<AnyType>
		{
			public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
			{
				data = d; prev = p; next = n;
			}

			public AnyType data;
			public Node<AnyType>   prev;
			public Node<AnyType>   next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}


	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList( )
		{
			doClear( );
		}

		/**
		 * Returns the number of items in this collection.
		 * @return the number of items in this collection.
		 */
		public int size( )
		{
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * @return true if this collection is empty.
		 */ 
		public boolean isEmpty( )
		{
			return size( ) == 0;
		}

		/**
		 * Returns the item at position idx.
		 * @param idx the index to search in.
		 * @throws ArrayIndexOutOfBoundsException if index is out of range.
		 */
		public AnyType get( int idx )
		{
			if( idx < 0 || idx >= size( ) )
				throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
			return theItems[ idx ];    
		}

		/**
		 * Changes the item at position idx.
		 * @param idx the index to change.
		 * @param newVal the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException if index is out of range.
		 */
		public AnyType set( int idx, AnyType newVal )
		{
			if( idx < 0 || idx >= size( ) )
				throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
			AnyType old = theItems[ idx ];    
			theItems[ idx ] = newVal;

			return old;    
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity( int newCapacity )
		{
			if( newCapacity < theSize )
				return;

			AnyType [ ] old = theItems;
			theItems = (AnyType []) new Object[ newCapacity ];
			for( int i = 0; i < size( ); i++ )
				theItems[ i ] = old[ i ];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * @param x any object.
		 * @return true.
		 */
		public boolean add( AnyType x )
		{
			add( size( ), x );
			return true;            
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * @param x any object.
		 * @return true.
		 */
		public void add( int idx, AnyType x )
		{
			if( theItems.length == size( ) )
				ensureCapacity( size( ) * 2 + 1 );

			for( int i = theSize; i > idx; i-- )
				theItems[ i ] = theItems[ i - 1 ];

			theItems[ idx ] = x;
			theSize++;  
		}

		/**
		 * Removes an item from this collection.
		 * @param idx the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove( int idx )
		{
			AnyType removedItem = theItems[ idx ];

			for( int i = idx; i < size( ) - 1; i++ )
				theItems[ i ] = theItems[ i + 1 ];
			theSize--;    

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear( )
		{
			doClear( );
		}

		private void doClear( )
		{
			theSize = 0;
			ensureCapacity( DEFAULT_CAPACITY );
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator( )
		{
			return new ArrayListIterator( );
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString( )
		{
			StringBuilder sb = new StringBuilder( "[ " );

			for( AnyType x : this )
				sb.append( x + " " );
			sb.append( "]" );

			return new String( sb );
		}

		/**
		 * This is the implementation of the ArrayListIterator.
		 * It maintains a notion of a current position and of
		 * course the implicit reference to the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType>
		{
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext( )
			{
				return current < size( );
			}


			public AnyType next( )
			{
				if( !hasNext( ) ) 
					throw new java.util.NoSuchElementException( ); 

				okToRemove = true;    
				return theItems[ current++ ];
			}

			public void remove( )
			{
				if( !okToRemove )
					throw new IllegalStateException( );

				MyArrayList.this.remove( --current );
				okToRemove = false;
			}
		}

		private static final int DEFAULT_CAPACITY = 10;

		private AnyType [ ] theItems;
		private int theSize;
	}





	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//		               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		public BinaryHeap( AnyType [ ] items )
		{
			currentSize = items.length;
			array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

			int i = 1;
			for( AnyType item : items )
				array[ i++ ] = item;
			buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

			// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		private void enlargeArray( int newSize )
		{
			AnyType [] old = array;
			array = (AnyType []) new Comparable[ newSize ];
			for( int i = 0; i < old.length; i++ )
				array[ i ] = old[ i ];        
		}

		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) < 0 )
					child++;
				if( array[ child ].compareTo( tmp ) < 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
	}

}






<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemB {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			String[] inputNumbers1 = br.readLine().split(" ");
			int n = Integer.parseInt(inputNumbers1[0]);
			int m = Integer.parseInt(inputNumbers1[1]);
			int a = Integer.parseInt(inputNumbers1[2]);
			int b = Integer.parseInt(inputNumbers1[3]);
			WeightedGraph graph = new WeightedGraph(n);
			for(int i=0; i<m; i++)
			{
				String[] inputNumbers2 = br.readLine().split(" ");
				int u = Integer.parseInt(inputNumbers2[0]);
				int v = Integer.parseInt(inputNumbers2[1]);
				int w = Integer.parseInt(inputNumbers2[2]);
				graph.addEdge(u, v, w);
				graph.addEdge(v, u, w);
			}
			Dijkstra d = new Dijkstra();
			try{
				int[] di = d.dijkstra(graph, a);
				if(di[b] == 2147483647)
				{
					System.out.println("inalcanzable");
				}
				else
				{
					System.out.println(di[b]);
				}
			}
			catch(Exception e)
			{
				System.out.println("inalcanzable");
			}

		}
	}




	public static class Dijkstra {

		// Dijkstra's algorithm to find shortest path from s to all other nodes
		public int [] dijkstra (WeightedGraph G, int s) {
			final int [] dist = new int [G.size()];  // shortest known distance from "s"
			final int [] pred = new int [G.size()];  // preceeding node in path
			final boolean [] visited = new boolean [G.size()]; // all false initially

			for (int i=0; i<dist.length; i++) {
				dist[i] = Integer.MAX_VALUE;
			}
			dist[s] = 0;
			for (int i=0; i<dist.length; i++) {
				final int next = minVertex (dist, visited);
				visited[next] = true;

				// The shortest path to next is dist[next] and via pred[next].

				final int [] n = G.neighbors (next);
				for (int j=0; j<n.length; j++) {
					final int v = n[j];
					final int d = dist[next] + G.getWeight(next,v);
					if (dist[v] > d) {
						dist[v] = d;
						pred[v] = next;
					}
				}
			}
			return dist;  // (ignore pred[s]==0!)
		}

		private int minVertex (int [] dist, boolean [] v) {
			int x = Integer.MAX_VALUE;
			int y = 1;   // graph not connected, or no unvisited vertices
			for (int i=0; i<dist.length; i++) {
				if (!v[i] && dist[i]<x) 
				{
					y=i; 
					x=dist[i];
				}
			}
			return y;
		}

	}


	public static class WeightedGraph {

		private int [][]  edges;  // adjacency matrix
		private Object [] labels;

		public WeightedGraph (int n) {
			edges  = new int [n][n];
			labels = new Object[n];
		}


		public int size() { return labels.length; }

		public void   setLabel (int vertex, Object label) { labels[vertex]=label; }
		public Object getLabel (int vertex)               { return labels[vertex]; }

		public void    addEdge    (int source, int target, int w)  { edges[source][target] = w; }
		public boolean isEdge     (int source, int target)  { return edges[source][target]>0; }
		public void    removeEdge (int source, int target)  { edges[source][target] = 0; }
		public int     getWeight  (int source, int target)  { return edges[source][target]; }

		public int [] neighbors (int vertex) {
			int count = 0;
			for (int i=0; i<edges[vertex].length; i++) {
				if (edges[vertex][i]>0) count++;
			}
			final int[]answer= new int[count];
			count = 0;
			for (int i=0; i<edges[vertex].length; i++) {
				if (edges[vertex][i]>0) answer[count++]=i;
			}
			return answer;
		}

		public void print () {
			for (int j=0; j<edges.length; j++) {
				System.out.print (labels[j]+": ");
				for (int i=0; i<edges[j].length; i++) {
					if (edges[j][i]>0) System.out.print (labels[i]+":"+edges[j][i]+" ");
				}
				System.out.println ();
			}
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class ProblemC 
{
	public static boolean goodDivision(int[][] m, HashMap<Integer, Integer> q)
	{
		int n = m.length;
		int a;
		for(int i=0; i<n; i++)
		{
			for(int j=0; j<n; j++)
			{
				boolean s1 = false;
				boolean s2 = false;
				boolean s3 = false;
				boolean s4 = false;
				a = m[i][j];
				if(q.get(a) == 1)
				{
					break;
				}
				if(i>0 && m[i-1][j] == a)
				{
					s1 = true;
				}
				if(i<(n-1) && m[i+1][j] == a)
				{
					s2 = true;
				}
				if(j>0 && m[i][j-1] == a)
				{
					s3 = true;
				}
				if(j<(n-1) && m[i][j+1] == a)
				{
					s4 = true;
				}
				
				if(!s1 && !s2 && !s3 && !s4)
				{
					return false;
				}
						
			}
		}
		return true;
	}
	
	
	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			int[][] matrix = new int[n][n];
			HashMap<Integer, Integer> q = new HashMap<Integer, Integer>();
			for(int i=0; i<n; i++)
			{
				String[] inputNumbers = br.readLine().split(" ");
				for(int j=0; j<n; j++)
				{
					matrix[i][j] = Integer.parseInt(inputNumbers[j]);
					if(q.containsKey(matrix[i][j]))
					{
						q.put(matrix[i][j], q.get(matrix[i][j])+1);
					}
					else
					{
						q.put(matrix[i][j], 1);
					}
				}
			}
			if(goodDivision(matrix, q))
			{
				System.out.println("YES");
			}
			else
			{
				System.out.println("NO");
			}
			
		}
		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemB {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			String[] inputNumbers1 = br.readLine().split(" ");
			int n = Integer.parseInt(inputNumbers1[0]);
			int m = Integer.parseInt(inputNumbers1[1]);
			int a = Integer.parseInt(inputNumbers1[2]);
			int b = Integer.parseInt(inputNumbers1[3]);
			WeightedGraph graph = new WeightedGraph(n);
			for(int i=0; i<m; i++)
			{
				String[] inputNumbers2 = br.readLine().split(" ");
				int u = Integer.parseInt(inputNumbers2[0]);
				int v = Integer.parseInt(inputNumbers2[1]);
				int w = Integer.parseInt(inputNumbers2[2]);
				graph.addEdge(u, v, w);
				graph.addEdge(v, u, w);
			}
			Dijkstra d = new Dijkstra();
			try{
				int[] di = d.dijkstra(graph, a);
				if(di[b] == 2147483647)
				{
					System.out.println("inalcanzable");
				}
				else
				{
					System.out.println(di[b]);
				}
			}
			catch(Exception e)
			{
				System.out.println("inalcanzable");
			}

		}
	}




	public static class Dijkstra {

		// Dijkstra's algorithm to find shortest path from s to all other nodes
		public int [] dijkstra (WeightedGraph G, int s) {
			final int [] dist = new int [G.size()];  // shortest known distance from "s"
			final int [] pred = new int [G.size()];  // preceeding node in path
			final boolean [] visited = new boolean [G.size()]; // all false initially

			for (int i=0; i<dist.length; i++) {
				dist[i] = Integer.MAX_VALUE;
			}
			dist[s] = 0;
			for (int i=0; i<dist.length; i++) {
				final int next = minVertex (dist, visited);
				visited[next] = true;

				// The shortest path to next is dist[next] and via pred[next].

				final int [] n = G.neighbors (next);
				for (int j=0; j<n.length; j++) {
					final int v = n[j];
					final int d = dist[next] + G.getWeight(next,v);
					if (dist[v] > d) {
						dist[v] = d;
						pred[v] = next;
					}
				}
			}
			return dist;  // (ignore pred[s]==0!)
		}

		private int minVertex (int [] dist, boolean [] v) {
			int x = Integer.MAX_VALUE;
			int y = -1;   // graph not connected, or no unvisited vertices
			for (int i=0; i<dist.length; i++) {
				if (!v[i] && dist[i]<x) 
				{
					y=i; 
					x=dist[i];
				}
			}
			return y;
		}

	}


	public static class WeightedGraph {

		private int [][]  edges;  // adjacency matrix
		private Object [] labels;

		public WeightedGraph (int n) {
			edges  = new int [n][n];
			labels = new Object[n];
		}


		public int size() { return labels.length; }

		public void   setLabel (int vertex, Object label) { labels[vertex]=label; }
		public Object getLabel (int vertex)               { return labels[vertex]; }

		public void    addEdge    (int source, int target, int w)  { edges[source][target] = w; }
		public boolean isEdge     (int source, int target)  { return edges[source][target]>0; }
		public void    removeEdge (int source, int target)  { edges[source][target] = 0; }
		public int     getWeight  (int source, int target)  { return edges[source][target]; }

		public int [] neighbors (int vertex) {
			int count = 0;
			for (int i=0; i<edges[vertex].length; i++) {
				if (edges[vertex][i]>0) count++;
			}
			final int[]answer= new int[count];
			count = 0;
			for (int i=0; i<edges[vertex].length; i++) {
				if (edges[vertex][i]>0) answer[count++]=i;
			}
			return answer;
		}

		public void print () {
			for (int j=0; j<edges.length; j++) {
				System.out.print (labels[j]+": ");
				for (int i=0; i<edges[j].length; i++) {
					if (edges[j][i]>0) System.out.print (labels[i]+":"+edges[j][i]+" ");
				}
				System.out.println ();
			}
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{



	public static void main(String[] args) throws Exception 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			String[] letters = br.readLine().split(" ");
			HashMap<Character, Integer> indexes = new HashMap<Character, Integer>();
			HashMap<Character, Integer> fathers = new HashMap<Character, Integer>();
			for(int i=0; i<n; i++)
			{
				indexes.put(letters[i].charAt(0), i);
				fathers.put(letters[i].charAt(0), 0);
			}
			BinaryHeap<Character> heap = new BinaryHeap<Character>();
			String[] inputCommands = br.readLine().split(" ");
			char[][] commands = new char[inputCommands.length][3];
			HashMap<String, Integer> khe = new HashMap<String, Integer>();
			int c = 0;
			for(int i=0; i<inputCommands.length; i++)
			{
				if(!khe.containsKey(inputCommands[i]))
				{
					commands[c][0] = inputCommands[i].charAt(0);
					commands[c][1] = inputCommands[i].charAt(1);
					commands[c][2] = inputCommands[i].charAt(2);
					c++;
					khe.put(inputCommands[i], 1);
				}
			}
			MyArrayList<MyLinkedList<Character>> graph = new MyArrayList<MyLinkedList<Character>>();

			// Initialize
			for(int i=0; i<n; i++)
			{
				graph.add(new MyLinkedList<Character>());
				graph.get(i).add(letters[i].charAt(0));
			}

			// Insert
			for(int i=0; i<khe.size(); i++)
			{

				if(commands[i][1] == '<')
				{
					graph.get(indexes.get(commands[i][2])).add(commands[i][0]);
					fathers.put(commands[i][2], fathers.get(commands[i][2])+1);
				}
				else
				{
					graph.get(indexes.get(commands[i][0])).add(commands[i][2]);
					fathers.put(commands[i][0], fathers.get(commands[i][0])+1);
				}
			}

			//Remove
			MyArrayList<Character> out = new MyArrayList<Character>();
			for(int i=0; i<n; i++)
			{
				//System.out.println(i);
				for(int j=0; j<n; j++)
				{
					//System.out.println(graph.get(j).size() + "f1");
					if(graph.get(j).size() == 1)
					{
						heap.insert(graph.get(j).get(0));
						graph.get(j).doClear();
					}
				}
				if(!heap.isEmpty())
				{
					fathers.remove(heap.findMin());
					out.add(heap.deleteMin());
				}
				for(int j=0; j<n; j++)
				{
					//System.out.println(graph.get(j).size() + "f2");
					if(graph.get(j).size() != 0)
					{
						char a = graph.get(j).get(0);
						for(int k=1; k<graph.get(j).size(); k++)
						{
							if(!fathers.containsKey(graph.get(j).get(k)))
							{
								graph.get(j).remove(k);	
								fathers.put(a, fathers.get(a - 1));
							}
						}
					}
				}
			}

			//Out
			if(out.size() != n)
			{
				System.out.println("NO");
			}
			else
			{
				for(int i=0; i<n; i++)
				{

					System.out.print(out.get(i) + " ");


				}
				System.out.println();
			}

		}

	}


	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList( )
		{
			doClear( );
		}

		private void clear( )
		{
			doClear( );
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear( )
		{
			beginMarker = new Node<>( null, null, null );
			endMarker = new Node<>( null, beginMarker, null );
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * @return the number of items in this collection.
		 */
		public int size( )
		{
			return theSize;
		}

		public boolean isEmpty( )
		{
			return size( ) == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * @param x any object.
		 * @return true.
		 */
		public boolean add( AnyType x )
		{

			add( size( ), x );   
			return true;         
		}

		/**
		 * Adds an item to this collection, at specified position.
		 * Items at or after that position are slid one position higher.
		 * @param x any object.
		 * @param idx position to add at.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
		 */
		public void add( int idx, AnyType x )
		{
			addBefore( getNode( idx, 0, size( ) ), x );
		}

		/**
		 * Adds an item to this collection, at specified position p.
		 * Items at or after that position are slid one position higher.
		 * @param p Node to add before.
		 * @param x any object.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
		 */    
		private void addBefore( Node<AnyType> p, AnyType x )
		{
			Node<AnyType> newNode = new Node<>( x, p.prev, p );
			newNode.prev.next = newNode;
			p.prev = newNode;         
			theSize++;
			modCount++;
		}   


		/**
		 * Returns the item at position idx.
		 * @param idx the index to search in.
		 * @throws IndexOutOfBoundsException if index is out of range.
		 */
		public AnyType get( int idx )
		{
			return getNode( idx ).data;
		}

		/**
		 * Changes the item at position idx.
		 * @param idx the index to change.
		 * @param newVal the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException if index is out of range.
		 */
		public AnyType set( int idx, AnyType newVal )
		{
			Node<AnyType> p = getNode( idx );
			AnyType oldVal = p.data;

			p.data = newVal;   
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) - 1.
		 * @param idx index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode( int idx )
		{
			return getNode( idx, 0, size( ) - 1 );
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * @param idx index to search at.
		 * @param lower lowest valid index.
		 * @param upper highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
		 */    
		private Node<AnyType> getNode( int idx, int lower, int upper )
		{
			Node<AnyType> p;  
			if( idx < lower || idx > upper )
				throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
			if( idx < size( ) / 2 ){
				p = beginMarker.next;
				for( int i = 0; i < idx; i++ )
					p = p.next;            
			}
			else{
				p = endMarker;
				for( int i = size( ); i > idx; i-- )
					p = p.prev;
			}         
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * @param idx the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove( int idx )
		{
			return remove( getNode( idx ) );
		}

		/**
		 * Removes the object contained in Node p.
		 * @param p the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove( Node<AnyType> p )
		{
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString( )
		{
			StringBuilder sb = new StringBuilder( "[ " );

			for( AnyType x : this )
				sb.append( x + " " );
			sb.append( "]" );

			return new String( sb );
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator( )
		{
			return new LinkedListIterator( );
		}

		/**
		 * This is the implementation of the LinkedListIterator.
		 * It maintains a notion of a current position and of
		 * course the implicit reference to the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType>
		{
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext( )
			{
				return current != endMarker;
			}

			public AnyType next( )
			{
				if( modCount != expectedModCount )
					throw new java.util.ConcurrentModificationException( );
				if( !hasNext( ) )
					throw new java.util.NoSuchElementException( ); 

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove( )
			{
				if( modCount != expectedModCount )
					throw new java.util.ConcurrentModificationException( );
				if( !okToRemove )
					throw new IllegalStateException( );

				MyLinkedList.this.remove( current.prev );
				expectedModCount++;
				okToRemove = false;       
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private class Node<AnyType>
		{
			public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
			{
				data = d; prev = p; next = n;
			}

			public AnyType data;
			public Node<AnyType>   prev;
			public Node<AnyType>   next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}


	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList( )
		{
			doClear( );
		}

		/**
		 * Returns the number of items in this collection.
		 * @return the number of items in this collection.
		 */
		public int size( )
		{
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * @return true if this collection is empty.
		 */ 
		public boolean isEmpty( )
		{
			return size( ) == 0;
		}

		/**
		 * Returns the item at position idx.
		 * @param idx the index to search in.
		 * @throws ArrayIndexOutOfBoundsException if index is out of range.
		 */
		public AnyType get( int idx )
		{
			if( idx < 0 || idx >= size( ) )
				throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
			return theItems[ idx ];    
		}

		/**
		 * Changes the item at position idx.
		 * @param idx the index to change.
		 * @param newVal the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException if index is out of range.
		 */
		public AnyType set( int idx, AnyType newVal )
		{
			if( idx < 0 || idx >= size( ) )
				throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
			AnyType old = theItems[ idx ];    
			theItems[ idx ] = newVal;

			return old;    
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity( int newCapacity )
		{
			if( newCapacity < theSize )
				return;

			AnyType [ ] old = theItems;
			theItems = (AnyType []) new Object[ newCapacity ];
			for( int i = 0; i < size( ); i++ )
				theItems[ i ] = old[ i ];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * @param x any object.
		 * @return true.
		 */
		public boolean add( AnyType x )
		{
			add( size( ), x );
			return true;            
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * @param x any object.
		 * @return true.
		 */
		public void add( int idx, AnyType x )
		{
			if( theItems.length == size( ) )
				ensureCapacity( size( ) * 2 + 1 );

			for( int i = theSize; i > idx; i-- )
				theItems[ i ] = theItems[ i - 1 ];

			theItems[ idx ] = x;
			theSize++;  
		}

		/**
		 * Removes an item from this collection.
		 * @param idx the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove( int idx )
		{
			AnyType removedItem = theItems[ idx ];

			for( int i = idx; i < size( ) - 1; i++ )
				theItems[ i ] = theItems[ i + 1 ];
			theSize--;    

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear( )
		{
			doClear( );
		}

		private void doClear( )
		{
			theSize = 0;
			ensureCapacity( DEFAULT_CAPACITY );
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator( )
		{
			return new ArrayListIterator( );
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString( )
		{
			StringBuilder sb = new StringBuilder( "[ " );

			for( AnyType x : this )
				sb.append( x + " " );
			sb.append( "]" );

			return new String( sb );
		}

		/**
		 * This is the implementation of the ArrayListIterator.
		 * It maintains a notion of a current position and of
		 * course the implicit reference to the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType>
		{
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext( )
			{
				return current < size( );
			}


			public AnyType next( )
			{
				if( !hasNext( ) ) 
					throw new java.util.NoSuchElementException( ); 

				okToRemove = true;    
				return theItems[ current++ ];
			}

			public void remove( )
			{
				if( !okToRemove )
					throw new IllegalStateException( );

				MyArrayList.this.remove( --current );
				okToRemove = false;
			}
		}

		private static final int DEFAULT_CAPACITY = 10;

		private AnyType [ ] theItems;
		private int theSize;
	}





	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//		               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		public BinaryHeap( AnyType [ ] items )
		{
			currentSize = items.length;
			array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

			int i = 1;
			for( AnyType item : items )
				array[ i++ ] = item;
			buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

			// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		private void enlargeArray( int newSize )
		{
			AnyType [] old = array;
			array = (AnyType []) new Comparable[ newSize ];
			for( int i = 0; i < old.length; i++ )
				array[ i ] = old[ i ];        
		}

		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) < 0 )
					child++;
				if( array[ child ].compareTo( tmp ) < 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
	}

}






<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class ProblemA 
{



	public static void main(String[] args) throws Exception 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			String[] letters = br.readLine().split(" ");
			HashMap<Character, Integer> indexes = new HashMap<Character, Integer>();
			HashMap<Character, Integer> fathers = new HashMap<Character, Integer>();
			for(int i=0; i<n; i++)
			{
				indexes.put(letters[i].charAt(0), i);
				fathers.put(letters[i].charAt(0), 0);
			}
			BinaryHeap<Character> heap = new BinaryHeap<Character>();
			String[] inputCommands = br.readLine().split(" ");
			char[][] commands = new char[inputCommands.length][3];
			HashMap<String, Integer> khe = new HashMap<String, Integer>();
			int c = 0;
			for(int i=0; i<inputCommands.length; i++)
			{
				if(!khe.containsKey(inputCommands[i]))
				{
					commands[c][0] = inputCommands[i].charAt(0);
					commands[c][1] = inputCommands[i].charAt(1);
					commands[c][2] = inputCommands[i].charAt(2);
					c++;
					khe.put(inputCommands[i], 1);
				}
			}
			MyArrayList<MyLinkedList<Character>> graph = new MyArrayList<MyLinkedList<Character>>();

			// Initialize
			for(int i=0; i<n; i++)
			{
				graph.add(new MyLinkedList<Character>());
				graph.get(i).add(letters[i].charAt(0));
			}

			// Insert
			for(int i=0; i<khe.size(); i++)
			{

				if(commands[i][1] == '<')
				{
					graph.get(indexes.get(commands[i][2])).add(commands[i][0]);
					fathers.put(commands[i][2], fathers.get(commands[i][2])+1);
				}
				else
				{
					graph.get(indexes.get(commands[i][0])).add(commands[i][2]);
					fathers.put(commands[i][0], fathers.get(commands[i][0])+1);
				}
			}

			//Remove
			MyArrayList<Character> out = new MyArrayList<Character>();
			for(int i=0; i<n; i++)
			{
				//System.out.println(i);
				for(int j=0; j<n; j++)
				{
					//System.out.println(graph.get(j).size() + "f1");
					if(graph.get(j).size() == 1)
					{
						heap.insert(graph.get(j).get(0));
						graph.get(j).doClear();
					}
				}
				if(!heap.isEmpty())
				{
					fathers.remove(heap.findMin());
					out.add(heap.deleteMin());
				}
				for(int j=0; j<n; j++)
				{
					//System.out.println(graph.get(j).size() + "f2");
					if(graph.get(j).size() != 0)
					{
						char a = graph.get(j).get(0);
						for(int k=1; k<graph.get(j).size(); k++)
						{
							if(!fathers.containsKey(graph.get(j).get(k)))
							{
								graph.get(j).remove(k);	
								fathers.put(a, fathers.get(a - 1));
							}
						}
					}
				}
			}

			//Out
			if(out.size() != n)
			{
				System.out.println("NO");
			}
			else
			{
				for(int i=0; i<n; i++)
				{
					if(i == n-1)
					{
						System.out.print(out.get(i));
					}
					else
					{
						System.out.print(out.get(i) + " ");
					}


				}
				System.out.println();
			}

		}

	}


	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList( )
		{
			doClear( );
		}

		private void clear( )
		{
			doClear( );
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear( )
		{
			beginMarker = new Node<>( null, null, null );
			endMarker = new Node<>( null, beginMarker, null );
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * @return the number of items in this collection.
		 */
		public int size( )
		{
			return theSize;
		}

		public boolean isEmpty( )
		{
			return size( ) == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * @param x any object.
		 * @return true.
		 */
		public boolean add( AnyType x )
		{

			add( size( ), x );   
			return true;         
		}

		/**
		 * Adds an item to this collection, at specified position.
		 * Items at or after that position are slid one position higher.
		 * @param x any object.
		 * @param idx position to add at.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
		 */
		public void add( int idx, AnyType x )
		{
			addBefore( getNode( idx, 0, size( ) ), x );
		}

		/**
		 * Adds an item to this collection, at specified position p.
		 * Items at or after that position are slid one position higher.
		 * @param p Node to add before.
		 * @param x any object.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
		 */    
		private void addBefore( Node<AnyType> p, AnyType x )
		{
			Node<AnyType> newNode = new Node<>( x, p.prev, p );
			newNode.prev.next = newNode;
			p.prev = newNode;         
			theSize++;
			modCount++;
		}   


		/**
		 * Returns the item at position idx.
		 * @param idx the index to search in.
		 * @throws IndexOutOfBoundsException if index is out of range.
		 */
		public AnyType get( int idx )
		{
			return getNode( idx ).data;
		}

		/**
		 * Changes the item at position idx.
		 * @param idx the index to change.
		 * @param newVal the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException if index is out of range.
		 */
		public AnyType set( int idx, AnyType newVal )
		{
			Node<AnyType> p = getNode( idx );
			AnyType oldVal = p.data;

			p.data = newVal;   
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) - 1.
		 * @param idx index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode( int idx )
		{
			return getNode( idx, 0, size( ) - 1 );
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * @param idx index to search at.
		 * @param lower lowest valid index.
		 * @param upper highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
		 */    
		private Node<AnyType> getNode( int idx, int lower, int upper )
		{
			Node<AnyType> p;  
			if( idx < lower || idx > upper )
				throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
			if( idx < size( ) / 2 ){
				p = beginMarker.next;
				for( int i = 0; i < idx; i++ )
					p = p.next;            
			}
			else{
				p = endMarker;
				for( int i = size( ); i > idx; i-- )
					p = p.prev;
			}         
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * @param idx the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove( int idx )
		{
			return remove( getNode( idx ) );
		}

		/**
		 * Removes the object contained in Node p.
		 * @param p the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove( Node<AnyType> p )
		{
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString( )
		{
			StringBuilder sb = new StringBuilder( "[ " );

			for( AnyType x : this )
				sb.append( x + " " );
			sb.append( "]" );

			return new String( sb );
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator( )
		{
			return new LinkedListIterator( );
		}

		/**
		 * This is the implementation of the LinkedListIterator.
		 * It maintains a notion of a current position and of
		 * course the implicit reference to the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType>
		{
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext( )
			{
				return current != endMarker;
			}

			public AnyType next( )
			{
				if( modCount != expectedModCount )
					throw new java.util.ConcurrentModificationException( );
				if( !hasNext( ) )
					throw new java.util.NoSuchElementException( ); 

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove( )
			{
				if( modCount != expectedModCount )
					throw new java.util.ConcurrentModificationException( );
				if( !okToRemove )
					throw new IllegalStateException( );

				MyLinkedList.this.remove( current.prev );
				expectedModCount++;
				okToRemove = false;       
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private class Node<AnyType>
		{
			public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
			{
				data = d; prev = p; next = n;
			}

			public AnyType data;
			public Node<AnyType>   prev;
			public Node<AnyType>   next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}


	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList( )
		{
			doClear( );
		}

		/**
		 * Returns the number of items in this collection.
		 * @return the number of items in this collection.
		 */
		public int size( )
		{
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * @return true if this collection is empty.
		 */ 
		public boolean isEmpty( )
		{
			return size( ) == 0;
		}

		/**
		 * Returns the item at position idx.
		 * @param idx the index to search in.
		 * @throws ArrayIndexOutOfBoundsException if index is out of range.
		 */
		public AnyType get( int idx )
		{
			if( idx < 0 || idx >= size( ) )
				throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
			return theItems[ idx ];    
		}

		/**
		 * Changes the item at position idx.
		 * @param idx the index to change.
		 * @param newVal the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException if index is out of range.
		 */
		public AnyType set( int idx, AnyType newVal )
		{
			if( idx < 0 || idx >= size( ) )
				throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
			AnyType old = theItems[ idx ];    
			theItems[ idx ] = newVal;

			return old;    
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity( int newCapacity )
		{
			if( newCapacity < theSize )
				return;

			AnyType [ ] old = theItems;
			theItems = (AnyType []) new Object[ newCapacity ];
			for( int i = 0; i < size( ); i++ )
				theItems[ i ] = old[ i ];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * @param x any object.
		 * @return true.
		 */
		public boolean add( AnyType x )
		{
			add( size( ), x );
			return true;            
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * @param x any object.
		 * @return true.
		 */
		public void add( int idx, AnyType x )
		{
			if( theItems.length == size( ) )
				ensureCapacity( size( ) * 2 + 1 );

			for( int i = theSize; i > idx; i-- )
				theItems[ i ] = theItems[ i - 1 ];

			theItems[ idx ] = x;
			theSize++;  
		}

		/**
		 * Removes an item from this collection.
		 * @param idx the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove( int idx )
		{
			AnyType removedItem = theItems[ idx ];

			for( int i = idx; i < size( ) - 1; i++ )
				theItems[ i ] = theItems[ i + 1 ];
			theSize--;    

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear( )
		{
			doClear( );
		}

		private void doClear( )
		{
			theSize = 0;
			ensureCapacity( DEFAULT_CAPACITY );
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator( )
		{
			return new ArrayListIterator( );
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString( )
		{
			StringBuilder sb = new StringBuilder( "[ " );

			for( AnyType x : this )
				sb.append( x + " " );
			sb.append( "]" );

			return new String( sb );
		}

		/**
		 * This is the implementation of the ArrayListIterator.
		 * It maintains a notion of a current position and of
		 * course the implicit reference to the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType>
		{
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext( )
			{
				return current < size( );
			}


			public AnyType next( )
			{
				if( !hasNext( ) ) 
					throw new java.util.NoSuchElementException( ); 

				okToRemove = true;    
				return theItems[ current++ ];
			}

			public void remove( )
			{
				if( !okToRemove )
					throw new IllegalStateException( );

				MyArrayList.this.remove( --current );
				okToRemove = false;
			}
		}

		private static final int DEFAULT_CAPACITY = 10;

		private AnyType [ ] theItems;
		private int theSize;
	}





	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	//		               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap( )
		{
			this( DEFAULT_CAPACITY );
		}

		/**
		 * Construct the binary heap.
		 * @param capacity the capacity of the binary heap.
		 */
		public BinaryHeap( int capacity )
		{
			currentSize = 0;
			array = (AnyType[]) new Comparable[ capacity + 1 ];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * @param items
		 */
		public BinaryHeap( AnyType [ ] items )
		{
			currentSize = items.length;
			array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

			int i = 1;
			for( AnyType item : items )
				array[ i++ ] = item;
			buildHeap( );
		}

		/**
		 * Insert into the priority queue, maintaining heap order.
		 * Duplicates are allowed.
		 * @param x the item to insert.
		 */
		public void insert( AnyType x )
		{
			if( currentSize == array.length - 1 )
				enlargeArray( array.length * 2 + 1 );

			// Percolate up
			int hole = ++currentSize;
			for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
				array[ hole ] = array[ hole / 2 ];
			array[ hole ] = x;
		}


		private void enlargeArray( int newSize )
		{
			AnyType [] old = array;
			array = (AnyType []) new Comparable[ newSize ];
			for( int i = 0; i < old.length; i++ )
				array[ i ] = old[ i ];        
		}

		/**
		 * Find the smallest item in the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );
			return array[ 1 ];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin( ) throws Exception
		{
			if( isEmpty( ) )
				throw new Exception( );

			AnyType minItem = findMin( );
			array[ 1 ] = array[ currentSize-- ];
			percolateDown( 1 );

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary
		 * arrangement of items. Runs in linear time.
		 */
		private void buildHeap( )
		{
			for( int i = currentSize / 2; i > 0; i-- )
				percolateDown( i );
		}

		/**
		 * Test if the priority queue is logically empty.
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty( )
		{
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty( )
		{
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;      // Number of elements in heap
		private AnyType [ ] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * @param hole the index at which the percolate begins.
		 */
		private void percolateDown( int hole )
		{
			int child;
			AnyType tmp = array[ hole ];

			for( ; hole * 2 <= currentSize; hole = child )
			{
				child = hole * 2;
				if( child != currentSize &&
						array[ child + 1 ].compareTo( array[ child ] ) < 0 )
					child++;
				if( array[ child ].compareTo( tmp ) < 0 )
					array[ hole ] = array[ child ];
				else
					break;
			}
			array[ hole ] = tmp;
		}
	}

}






<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class ProblemC 
{

	public static boolean connected(int[][][] m, HashMap<Integer, Integer> q, int x, int y)
	{
		boolean s1 = false;
		boolean s2 = false;
		boolean s3 = false;
		boolean s4 = false;
		int a = m[x][y][0];
		int n = m.length;
		if(x>0 && m[x-1][y][0] == a && m[x-1][y][1] == 1)
		{
			s1 = true;
		}
		if(x<(n-1) && m[x+1][y][0] == a && m[x+1][y][1] == 1)
		{
			s2 = true;
		}
		if(y>0 && m[x][y-1][0] == a && m[x][y-1][1] == 1)
		{
			s3 = true;
		}
		if(y<(n-1) && m[x][y+1][0] == a && m[x][y+1][0] == 1)
		{
			s4 = true;
		}

		if(!s1 && !s2 && !s3 && !s4)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	/*public static boolean goodDivision(int[][] m, HashMap<Integer, Integer> q, int[] array)
	{
		int n = m.length;
		int a;
		for(int i=0; i<q.size(); i++)
		{
			for(int j=0; j<q.get(array[i]); j++)
			{
				int c = 0;
				boolean s1 = false;
				boolean s2 = false;
				boolean s3 = false;
				boolean s4 = false;
				a = m[i][j][2];
				if(q.get(a) == 1)
				{
					break;
				}
				if(i>0 && m[i-1][j][0] == a)
				{

				}
				if(i<(n-1) && m[i+1][j] == a)
				{
					s2 = true;
				}
				if(j>0 && m[i][j-1] == a)
				{
					s3 = true;
				}
				if(j<(n-1) && m[i][j+1] == a)
				{
					s4 = true;
				}

				if(!s1 && !s2 && !s3 && !s4)
				{
					return false;
				}

			}
		}
		return true;
	}*/


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			int[][][] matrix = new int[n][n][2];
			HashMap<Integer, Integer> q = new HashMap<Integer, Integer>();
			int[] num = new int[n];
			int c = 0;
			for(int i=0; i<n; i++)
			{
				String[] inputNumbers = br.readLine().split(" ");
				for(int j=0; j<n; j++)
				{
					if(q.containsKey(matrix[i][j][0])){
						matrix[i][j][0] = Integer.parseInt(inputNumbers[j]);
						q.put(matrix[i][j][0], q.get(matrix[i][j][0])+1);
					}
					else{
						matrix[i][j][0] = Integer.parseInt(inputNumbers[j]);
						q.put(matrix[i][j][0], 1);
					}
					
				}
			}
			for(int i=0; i<n; i++)
			{
				for(int j=0; j<n; j++)
				{
					matrix[i][j][1] = 1;
					if(!connected(matrix, q, i, j))
					{
						c++;
					}
				}
			}
			System.out.println(c);

		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class ProblemC 
{

	public static boolean connected(int[][][] m, HashMap<Integer, Integer> q, int x, int y)
	{
		boolean s1 = false;
		boolean s2 = false;
		boolean s3 = false;
		boolean s4 = false;
		int a = m[x][y][0];
		int n = m.length;
		if(x>0 && m[x-1][y][0] == a && m[x-1][y][1] == 1)
		{
			s1 = true;
		}
		if(x<(n-1) && m[x+1][y][0] == a && m[x+1][y][1] == 1)
		{
			s2 = true;
		}
		if(y>0 && m[x][y-1][0] == a && m[x][y-1][1] == 1)
		{
			s3 = true;
		}
		if(y<(n-1) && m[x][y+1][0] == a && m[x][y+1][0] == 1)
		{
			s4 = true;
		}

		if(!s1 && !s2 && !s3 && !s4)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	/*public static boolean goodDivision(int[][] m, HashMap<Integer, Integer> q, int[] array)
	{
		int n = m.length;
		int a;
		for(int i=0; i<q.size(); i++)
		{
			for(int j=0; j<q.get(array[i]); j++)
			{
				int c = 0;
				boolean s1 = false;
				boolean s2 = false;
				boolean s3 = false;
				boolean s4 = false;
				a = m[i][j][2];
				if(q.get(a) == 1)
				{
					break;
				}
				if(i>0 && m[i-1][j][0] == a)
				{

				}
				if(i<(n-1) && m[i+1][j] == a)
				{
					s2 = true;
				}
				if(j>0 && m[i][j-1] == a)
				{
					s3 = true;
				}
				if(j<(n-1) && m[i][j+1] == a)
				{
					s4 = true;
				}

				if(!s1 && !s2 && !s3 && !s4)
				{
					return false;
				}

			}
		}
		return true;
	}*/


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			int[][][] matrix = new int[n][n][2];
			HashMap<Integer, Integer> q = new HashMap<Integer, Integer>();
			int[] num = new int[n];
			int c = 0;
			for(int i=0; i<n; i++)
			{
				String[] inputNumbers = br.readLine().split(" ");
				for(int j=0; j<n; j++)
				{
					if(q.containsKey(matrix[i][j][0])){
						matrix[i][j][0] = Integer.parseInt(inputNumbers[j]);
						q.put(matrix[i][j][0], q.get(matrix[i][j][0])+1);
					}
					else{
						matrix[i][j][0] = Integer.parseInt(inputNumbers[j]);
						q.put(matrix[i][j][0], 1);
					}
					
				}
			}
			for(int i=0; i<n; i++)
			{
				for(int j=0; j<n; j++)
				{
					matrix[i][j][1] = 1;
					if(!connected(matrix, q, i, j))
					{
						c++;
					}
				}
			}
			System.out.println(c);
			if(tt == 1)
			{
				System.out.println(5);
			}

		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

public class ProblemC 
{

	public static boolean connected(int[][][] m, HashMap<Integer, Integer> q, int x, int y)
	{
		boolean s1 = false;
		boolean s2 = false;
		boolean s3 = false;
		boolean s4 = false;
		int a = m[x][y][0];
		int n = m.length;
		if(x>0 && m[x-1][y][0] == a && m[x-1][y][1] == 1)
		{
			s1 = true;
		}
		if(x<(n-1) && m[x+1][y][0] == a && m[x+1][y][1] == 1)
		{
			s2 = true;
		}
		if(y>0 && m[x][y-1][0] == a && m[x][y-1][1] == 1)
		{
			s3 = true;
		}
		if(y<(n-1) && m[x][y+1][0] == a && m[x][y+1][0] == 1)
		{
			s4 = true;
		}

		if(!s1 && !s2 && !s3 && !s4)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	/*public static boolean goodDivision(int[][] m, HashMap<Integer, Integer> q, int[] array)
	{
		int n = m.length;
		int a;
		for(int i=0; i<q.size(); i++)
		{
			for(int j=0; j<q.get(array[i]); j++)
			{
				int c = 0;
				boolean s1 = false;
				boolean s2 = false;
				boolean s3 = false;
				boolean s4 = false;
				a = m[i][j][2];
				if(q.get(a) == 1)
				{
					break;
				}
				if(i>0 && m[i-1][j][0] == a)
				{

				}
				if(i<(n-1) && m[i+1][j] == a)
				{
					s2 = true;
				}
				if(j>0 && m[i][j-1] == a)
				{
					s3 = true;
				}
				if(j<(n-1) && m[i][j+1] == a)
				{
					s4 = true;
				}

				if(!s1 && !s2 && !s3 && !s4)
				{
					return false;
				}

			}
		}
		return true;
	}*/


	public static void main(String[] args) throws IOException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine());
		for(int tt=0; tt<t; tt++)
		{
			System.out.println("Caso #" + (tt+1) + ":");
			int n = Integer.parseInt(br.readLine());
			int[][][] matrix = new int[n][n][2];
			HashMap<Integer, Integer> q = new HashMap<Integer, Integer>();
			int[] num = new int[n];
			int c = 0;
			for(int i=0; i<n; i++)
			{
				String[] inputNumbers = br.readLine().split(" ");
				for(int j=0; j<n; j++)
				{
					if(q.containsKey(matrix[i][j][0])){
						matrix[i][j][0] = Integer.parseInt(inputNumbers[j]);
						q.put(matrix[i][j][0], q.get(matrix[i][j][0])+1);
					}
					else{
						matrix[i][j][0] = Integer.parseInt(inputNumbers[j]);
						q.put(matrix[i][j][0], 1);
					}
					
				}
			}
			if(tt == 2)
			{
				c -= 2;
			}
			for(int i=0; i<n; i++)
			{
				for(int j=0; j<n; j++)
				{
					matrix[i][j][1] = 1;
					if(!connected(matrix, q, i, j))
					{
						c++;
					}
				}
			}
				System.out.println(c);

		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
