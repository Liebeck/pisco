import java.util.Scanner;

public class Problema_A {

	public static void main(String[] args) {
		Scanner scan;
		scan = new Scanner(System.in);		
		
		int casosPrueba = Integer.parseInt(scan.nextLine());
		
		int valores[][] = new int[casosPrueba][100];
		int cantNumeros[] = new int[casosPrueba];
		
		for(int i=0; i<casosPrueba; i++){
			cantNumeros[i] = Integer.parseInt(scan.nextLine());
			for(int j=0; j<cantNumeros[i]; j++){
				valores[i][j] = Integer.parseInt(scan.nextLine());
			}
		}
		
		int a, mayor;
		
		
		for(int i=0; i<casosPrueba; i++){
			mayor = 0;
			for(int j=0; j<cantNumeros[i]; j++){
//				System.out.println("valores tomados " + valores[i][j]);
				for(int k=0; k<cantNumeros[i]-1; k++){
					if(valores[i][j] < valores[i][k+1]){ mayor ++;}
				}
			}
			a = i+1;
			System.out.println("Case #" +a);
			System.out.println(mayor);
			System.out.println(mayor);
			System.out.println(cantNumeros[i]*(cantNumeros[i]-1) - mayor*2);
		}
		
		
		
		
		scan.close();
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Problema_A {

	public static void main(String[] args) {
		Scanner scan;
		scan = new Scanner(System.in);		
		
		int casosPrueba = Integer.parseInt(scan.nextLine());
		
		int valores[][] = new int[casosPrueba][100];
		int cantNumeros[] = new int[casosPrueba];
		
		for(int i=0; i<casosPrueba; i++){
			cantNumeros[i] = Integer.parseInt(scan.nextLine());
			for(int j=0; j<cantNumeros[i]; j++){
				valores[i][j] = Integer.parseInt(scan.nextLine());
			}
		}
		
		int a, mayor;
		
		
		for(int i=0; i<casosPrueba; i++){
			mayor = 0;
			for(int j=0; j<cantNumeros[i]; j++){
//				System.out.println("valores tomados " + valores[i][j]);
				for(int k=0; k<cantNumeros[i]-1; k++){
					if(valores[i][j] < valores[i][k+1]){ mayor ++;}
				}
			}
			a = i+1;
			System.out.println("Case #" +a);
			System.out.println(mayor);
			System.out.println(mayor);
			System.out.println(cantNumeros[i]*(cantNumeros[i]-1) - mayor*2);
		}
		
		
		
		
		scan.close();
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema_A {

	
	public static int[] readInts(String s) {
		String split[] = s.split(" ");
		int arr[] = new int[split.length];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = Integer.parseInt(split[i]);
		}
		return arr;
	}
	
	
	public static void main(String[] args) throws FileNotFoundException {
			
		//--------------------------------------->>>>>>
		Scanner scan;
		File f = new File("A_1.in");
		if (f.exists()){
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		//--------------------------------------->>>>>>>>>>>>>>

		int casosPrueba = Integer.parseInt(scan.nextLine());
		
		int cantNumeros[] = new int[casosPrueba];
		int a, mayor;
		
		
		for(int i=0; i<casosPrueba; i++){
			cantNumeros[i] = Integer.parseInt(scan.nextLine());
			int valores[] = readInts(scan.nextLine());
			
			mayor = 0;
			
			for(int j=0; j<cantNumeros[i]; j++){
//				System.out.println("valores tomados " + valores[i][j]);
				for(int k=0; k<cantNumeros[i]-1; k++){
					if(valores[j] < valores[k+1]){ mayor ++;}
				}
			}
			a = i+1;
			System.out.println("Case #" +a);
			System.out.println(mayor);
			System.out.println(mayor);
			System.out.println(cantNumeros[i]*(cantNumeros[i]-1) - mayor*2);
			
			
			

		}		
		
		scan.close();
	}
	

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema_A {

	public static int[] readInts(String s) {
		String split[] = s.split(" ");
		int arr[] = new int[split.length];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = Integer.parseInt(split[i]);
		}
		return arr;
	}
	
	public static void main(String[] args) throws FileNotFoundException {
		//--------------------------------------->>>>>>
		Scanner scan;
		File f = new File("A_1.in");
		if (f.exists()){
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		//--------------------------------------->>>>>>>>>>>>>>

		int casosPrueba = Integer.parseInt(scan.nextLine());
		
		int cantNumeros[] = new int[casosPrueba];
		int a, mayor;
		
		
		for(int i=0; i<casosPrueba; i++){
			cantNumeros[i] = Integer.parseInt(scan.nextLine());
			int valores[] = readInts(scan.nextLine());
			
			mayor = 0;
			
			for(int j=0; j<cantNumeros[i]; j++){
//				System.out.println("valores tomados " + valores[i][j]);
				for(int k=0; k<cantNumeros[i]-1; k++){
					if(valores[j] < valores[k+1]){ mayor ++;}
				}
			}
			a = i+1;
			System.out.println("Case #" +a +":");
			System.out.println(mayor);
			System.out.println(mayor);
			System.out.println(cantNumeros[i]*(cantNumeros[i]-1) - mayor*2);
			
			
			

		}		
		
		scan.close();
	}
	

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema_A {

	public static int[] readInts(String s) {
		String split[] = s.split(" ");
		int arr[] = new int[split.length];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = Integer.parseInt(split[i]);
		}
		return arr;
	}
	
	public static void main(String[] args) throws FileNotFoundException {
		//--------------------------------------->>>>>>
		Scanner scan;
		File f = new File("A_1.in");
		if (f.exists()){
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		//--------------------------------------->>>>>>>>>>>>>>

		int casosPrueba = Integer.parseInt(scan.nextLine());
		
		int cantNumeros[] = new int[casosPrueba];
		int a, mayor;
		
		
		for(int i=0; i<casosPrueba; i++){
			cantNumeros[i] = Integer.parseInt(scan.nextLine());
			int valores[] = readInts(scan.nextLine());
			
			mayor = 0;
			
			for(int j=0; j<cantNumeros[i]; j++){
//				System.out.println("valores tomados " + valores[i][j]);
				for(int k=0; k<cantNumeros[i]; k++){
					if(valores[j] > valores[k]){ mayor ++;}
				}
			}
			a = i+1;
			System.out.println("Case #" +a +":");
			System.out.println(mayor);
			System.out.println(mayor);
			System.out.println(cantNumeros[i]*(cantNumeros[i]-1) - mayor*2);
			
			
			

		}		
		
		scan.close();
	}
	

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema_D {
	
	public static int[] readInts(String s) {
		String split[] = s.split(" ");
		int arr[] = new int[split.length];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = Integer.parseInt(split[i]);
		}
		return arr;
	}

	public static void main(String[] args) throws FileNotFoundException {
		//--------------------------------------->>>>>>
		Scanner scan;
		File f = new File("D_1.in");
		if (f.exists()){
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		//--------------------------------------->>>>>>>>>>>>>>
		
	
		int casosPrueba = Integer.parseInt(scan.nextLine());
		
		int local[] = new int[100];
		int visitante[] = new int[100];
		
		int cantEquipos[] = new int[casosPrueba];
		int a, uniforme;
		
		
		for(int i=0; i<casosPrueba; i++){
			cantEquipos[i] = Integer.parseInt(scan.nextLine());
			for(int j=0; j<cantEquipos[i]; j++){
				int aux[]=readInts(scan.nextLine());
				local[j] = aux[0];
				visitante[j] = aux[1];
			}
			
			
			uniforme = 0;
			for(int j=0; j<cantEquipos[i]; j++){
				for(int k=0; k<cantEquipos[i]; k++){
					if(local[j] == visitante[k]){ uniforme ++;}					
				}
			}
			
			a = i+1;
			System.out.println("Case #" +a +":");
			System.out.println(uniforme);
		}
		
		scan.close();	
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema_B {
	public static int[] readInts(String s) {
		String split[] = s.split(" ");
		int arr[] = new int[split.length];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = Integer.parseInt(split[i]);
		}
		return arr;
	}
	
	public static void main(String[] args) throws FileNotFoundException {
		//--------------------------------------->>>>>>
		Scanner scan;
		File f = new File("D_1.in");
		if (f.exists()){
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		//--------------------------------------->>>>>>>>>>>>>>

		
		int fila[][] = new int[100];
		int columna[][] = new int[100];
		
		while(scan.hasNextLine()){
		
			for(int x=0; x<casosPrueba; x++){
				contador++;
				cantNumeros[x] = Integer.parseInt(scan.nextLine());
				for(int i=0; i<cantNumeros[x]; i++){
					for(int j=0; j<cantNumeros[x]; j++){
						k = Integer.parseInt(scan.nextLine());
						fila[x][i] += k;
						columna[x][j] += k;
						
					}
				}
			}
			
			int a, ganador;
		
			for(int x=0; x<casosPrueba; x++){
				ganador = 0;
				for(int i=0; i<cantNumeros[x]; i++){
					for(int j=0; j<cantNumeros[x];j++){
						if(columna[x][i] > fila[x][j]){ ganador++;}
					}
				}
				a = x + 1;
				System.out.println("Case #" +a);
				System.out.println(ganador);
			}
		
		}
		scan.close();	
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project6;

import java.io.*;
import java.util.*;

public class Problem_A {    
    public static void main(String[] args) throws FileNotFoundException, Exception {
  
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project6_A_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <
        
        int t = Integer.parseInt(scan.nextLine());//casos de prueba
        
        for(int test=0; test<t;){
            System.out.println("Case #" + ++test + ":");
            
            TreeMap<Integer, BinaryHeap<Integer>> colisiones = new TreeMap<>();
            
            String lines[] = scan.nextLine().split(" ");//leer linea completa
            int n = Integer.parseInt(lines[0]);//cantidad numeros
            int m = Integer.parseInt(lines[1]);//cantidad funciones
            
            lines = scan.nextLine().split(" ");//leer linea
            int[] numeros = new int[n];
            for(int i=0; i<n; i++){
                numeros[i] = Integer.parseInt(lines[i]);
            }
            
            lines = scan.nextLine().split(" ");//leer linea
            int[] funciones = new int [m];
            for(int i=0; i<m; i++){
                funciones[i] = Integer.parseInt(lines[i]);
            }
            
            int minChoques = 99999999;
            int funcion = 0;
            
            for(int i=0; i<m; i++){
                BinaryHeap<Integer> aux;
                TreeMap<Integer, BinaryHeap<Integer>> auxiliar = new TreeMap<>();
                int choques=0;
                for(int j=0; j<n; j++){
                    if(auxiliar.containsKey(numeros[j]%funciones[i])){
                        aux=auxiliar.get(numeros[j]%funciones[i]);
                        aux.insert(numeros[j]);
                        choques++;
                    }
                    else{
                        aux = new BinaryHeap<>();
                        aux.insert(numeros[j]);
                        auxiliar.put(numeros[j]%funciones[i], aux);
                    }
                }
                if(choques<=minChoques){
                    if(choques == minChoques){
                        if(funciones[i]<funcion){
                            colisiones = auxiliar;
                            minChoques = choques;
                            funcion = funciones[i];
                        }
                    }else{
                        colisiones = auxiliar;
                        minChoques = choques;
                        funcion = funciones[i];
                    }
                }
            }
            
            TreeMap<Integer, BinaryHeap<Integer>> nuevo = new  TreeMap<>();
            
            for(Map.Entry<Integer, BinaryHeap<Integer>> entry : colisiones.entrySet()){
                BinaryHeap<Integer> aux = entry.getValue();
                
                nuevo.put(aux.findMin(), aux);
            }
            
            
            System.out.println(funcion);
            System.out.println(minChoques);
            for(Map.Entry<Integer, BinaryHeap<Integer>> entry : nuevo.entrySet()){
                BinaryHeap<Integer> aux = entry.getValue();
                if(aux.size() > 1)
                    System.out.println(toString(aux));
            }
        }
        scan.close(); 
    }
    
    public static String toString( BinaryHeap<Integer> cualquiera) throws Exception{
        
        StringBuilder sb = new StringBuilder();
        int tam = cualquiera.size();
        
        for(int i=0; i<tam; i++){
            sb.append(cualquiera.deleteMin() + " ");
        }
        return new String( sb );
    }
    
    
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
    {
        /**
         * Construct the binary heap.
         */
        public BinaryHeap( )
        {
            this( DEFAULT_CAPACITY );
        }

        /**
         * Construct the binary heap.
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap( int capacity )
        {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }

        /**
         * Construct the binary heap given an array of items.
         * @param items
         */
        public BinaryHeap( AnyType [ ] items )
        {
                currentSize = items.length;
                array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

                int i = 1;
                for( AnyType item : items )
                    array[ i++ ] = item;
                buildHeap( );
        }

        /**
         * Insert into the priority queue, maintaining heap order.
         * Duplicates are allowed.
         * @param x the item to insert.
         */
        public void insert( AnyType x )
        {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

                // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        /**
         * 
         * @return size of Binary Heap
         */
        public int size(){
            return currentSize;
        }        
        
        private void enlargeArray( int newSize )
        {
                AnyType [] old = array;
                array = (AnyType []) new Comparable[ newSize ];
                for( int i = 0; i < old.length; i++ )
                    array[ i ] = old[ i ];        
        }

        /**
         * Find the smallest item in the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

        /**
         * Remove the smallest item from the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );

            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary
         * arrangement of items. Runs in linear time.
         */
        private void buildHeap( )
        {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

        /**
         * Test if the priority queue is logically empty.
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty( )
        {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty( )
        {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown( int hole )
        {
            int child;
            AnyType tmp = array[ hole ];

            for( ; hole * 2 <= currentSize; hole = child )
            {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else
                    break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project6;

import java.io.*;
import java.util.*;

public class Problem_B {
    public static void main(String[] args) throws FileNotFoundException, Exception {
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project6_B_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <

        int t = Integer.parseInt(scan.nextLine());//casos de prueba
        
        
        
        
        for(int test=0; test<t;){
            System.out.println("Case #" + ++test + ":");
            
            int n = Integer.parseInt(scan.nextLine());//cantidad estanques
            
            Hashtable< Integer, Integer> comida = new Hashtable<>();
            
            int cont = 0;
            
            for(int i=0; i<n; i++){
                String lines[] = scan.nextLine().split(" ");//leer linea completa
                int a = Integer.parseInt(lines[0]);//comida
                int b = Integer.parseInt(lines[1]);//pokemon
                
                if(comida.containsKey(a)){
                    int aux = comida.get(a);
                    comida.put(a, aux+1);
                }
                else
                    comida.put(a,1);
                
                if(comida.containsKey(b)){
                    int aux = comida.get(b);
                    if(aux>0)
                        comida.put(b, aux-1);
                    else
                        cont++;
                }
                else
                    cont++;
            }
            
            System.out.println(cont);
            
        }
        
        scan.close();
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project6;

import java.io.*;
import java.util.*;

public class Problem_C {
    public static void main(String[] args) throws FileNotFoundException {
	//--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project6_C_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <
        int t = Integer.parseInt(scan.nextLine());//numero de casos de prueba       
        
        for (int test = 0; test < t;) {
            System.out.println("Case #" + ++test + ":");
            String lines[] = scan.nextLine().split(" ");//leer linea completa
            
            
            int n = Integer.parseInt(lines[0]);//problemas norma
            int m = Integer.parseInt(lines[1]);//Problemas mario
            int p = Integer.parseInt(lines[2]);//problemas pipe  
            
            HashSet<Integer> repetidos = new HashSet<>();
            TreeMap<Integer, String> colisiones = new TreeMap<>();

            lines = scan.nextLine().split(" ");//leer linea
            int norma = 0;
            
            for (int i=0; i<n; i++){
                int x = Integer.parseInt(lines[i]);//
                norma++;
                colisiones.put(x, "norma");
            }
            
            lines = scan.nextLine().split(" ");//leer linea
            int mario = 0;
            
            for (int i=0; i<m; i++){
                int x = Integer.parseInt(lines[i]);//
                if(colisiones.containsKey(x)){
                    norma--;
                    repetidos.add(x);
                    colisiones.remove(x);
                }
                else{
                    colisiones.put(x, "mario");
                    mario++;
                }
            }
            
            lines = scan.nextLine().split(" ");//leer linea
            int pipe = 0;
            
            for (int i=0; i<p; i++){
                int x = Integer.parseInt(lines[i]);//
                if(repetidos.contains(x))
                    ;
                else if(colisiones.containsKey(x)){
                    if("norma".equals(colisiones.get(x)))
                        norma--;
                    else
                        mario--;
                    
                    repetidos.add(x);
                    colisiones.remove(x);
                }
                else{
                    colisiones.put(x, "pipe");
                    pipe++;
                }
            }
            
            if(norma >= mario && norma >= pipe)
                System.out.println("norma " + norma + toString(colisiones, "norma"));
            if(mario >= norma && mario >= pipe)
                System.out.println("mario " + mario + toString(colisiones, "mario"));
            if(pipe >= norma && pipe >= mario)
                System.out.println("pipe " + pipe + toString(colisiones, "pipe"));
        }
        scan.close();
    }
    
    public static String toString( TreeMap<Integer, String> cualquiera, String name){
        
        StringBuilder sb = new StringBuilder();
        
        for(Map.Entry<Integer, String> entry : cualquiera.entrySet()){
            if(entry.getValue() == name)
                sb.append( " " + entry.getKey()  );
        }
        return new String( sb );
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project6;

import java.io.*;
import java.util.*;

public class Problem_D {
    public static void main(String[] args) throws FileNotFoundException, Exception {
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project6_D_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <
        int t = Integer.parseInt(scan.nextLine());//numero de casos de prueba

        for (int test = 0; test < t;) {
            System.out.println("Case #" + ++test + ":");
            
            TreeMap<String, Candidato> elecciones = new TreeMap<>();
            int n = Integer.parseInt(scan.nextLine());//numero candidatos
            
            for (int i=0; i<n; i++) {
                String lines[] = scan.nextLine().split(" ");//leer linea 
                String a = lines[0];//nombre candidato
                String b = lines[1];//partido politico
                
                Candidato aux = new Candidato(b, 0);
                elecciones.put(a, aux);
            }
            
            int q = Integer.parseInt(scan.nextLine());//numero de votos
            
            for (int i=0; i<q; i++) {
                String voto = scan.nextLine();//voto por el candidato
                
                if(elecciones.containsKey(voto)){
                    Candidato aux = elecciones.get(voto);
                    aux.votos++;
                }
            }
            
            int mayor=0;
            BinaryHeap<String> ganadores = new BinaryHeap<>();
            
            for(Map.Entry<String, Candidato> entry : elecciones.entrySet()){
                Candidato aux = entry.getValue();
                
                if(aux.votos==mayor)
                    ganadores.insert(aux.partido);
                
                if(aux.votos>mayor){
                    mayor=aux.votos;
                    ganadores.makeEmpty();
                    ganadores.insert(aux.partido);
                }
            }
            
            while(ganadores.size()>0)
                System.out.println(ganadores.deleteMin());
            
        }
        scan.close();
    }
    
    public static class Candidato{
        String partido;
        int votos;
        
        public Candidato(String partido, int votos){
            this.partido = partido;
            this.votos = votos;
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
    {
        /**
         * Construct the binary heap.
         */
        public BinaryHeap( )
        {
            this( DEFAULT_CAPACITY );
        }

        /**
         * Construct the binary heap.
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap( int capacity )
        {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }

        /**
         * Construct the binary heap given an array of items.
         * @param items
         */
        public BinaryHeap( AnyType [ ] items )
        {
                currentSize = items.length;
                array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

                int i = 1;
                for( AnyType item : items )
                    array[ i++ ] = item;
                buildHeap( );
        }

        /**
         * Insert into the priority queue, maintaining heap order.
         * Duplicates are allowed.
         * @param x the item to insert.
         */
        public void insert( AnyType x )
        {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

                // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        /**
         * 
         * @return size of Binary Heap
         */
        public int size(){
            return currentSize;
        }        
        
        private void enlargeArray( int newSize )
        {
                AnyType [] old = array;
                array = (AnyType []) new Comparable[ newSize ];
                for( int i = 0; i < old.length; i++ )
                    array[ i ] = old[ i ];        
        }

        /**
         * Find the smallest item in the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

        /**
         * Remove the smallest item from the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );

            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary
         * arrangement of items. Runs in linear time.
         */
        private void buildHeap( )
        {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

        /**
         * Test if the priority queue is logically empty.
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty( )
        {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty( )
        {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown( int hole )
        {
            int child;
            AnyType tmp = array[ hole ];

            for( ; hole * 2 <= currentSize; hole = child )
            {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else
                    break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project6;

import java.io.*;
import java.util.*;

public class Problem_E {
    public static void main(String[] args) throws FileNotFoundException, Exception {
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project6_E_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <

        int t = Integer.parseInt(scan.nextLine());//casos de prueba

        for(int test=0; test<t;){
            System.out.println("Case #" + ++test + ":");
            
            int n = Integer.parseInt(scan.nextLine());//cantidad estanques
            
            Hashtable< Integer, Integer> comida = new Hashtable<>();
            TreeMap< Integer, Integer> pokemon = new TreeMap<>();
            
            int cont = 0;
            
            for(int i=0; i<n; i++){
                String lines[] = scan.nextLine().split(" ");//leer linea completa
                int a = Integer.parseInt(lines[0]);//comida
                int b = Integer.parseInt(lines[1]);//pokemon
                
                if(comida.containsKey(a)){
                    int aux = comida.get(a);
                    comida.put(a, aux+1);
                }
                else
                    comida.put(a,1);
                
                if(comida.containsKey(b)){
                    int aux = comida.get(b);
                    if(aux>0)
                        comida.put(b, aux-1);
                    else{
                        cont++;
                        if(pokemon.containsKey(b)){
                            aux = pokemon.get(b);
                            pokemon.put(b, aux+1);
                        }
                        else
                            pokemon.put(b, 1);
                    }
                }
                else{
                    cont++;
                    if(pokemon.containsKey(b)){
                        int aux = pokemon.get(b);
                        pokemon.put(b, aux+1);
                    }
                    else
                        pokemon.put(b, 1);
                }
                    
            }
            
            int mayor=0, menor=99999999;
            int mayorKey =0, menorKey=0;
            
            if(pokemon.size()>0){
                for(Map.Entry<Integer, Integer> entry : pokemon.entrySet()){
                    
                    int aux = entry.getValue();
                    if(aux>mayor){
                        mayor=aux;
                        mayorKey = entry.getKey();
                    }   
                    if(aux<menor){
                        menor=aux;
                        menorKey = entry.getKey();
                    }
                }
                
                System.out.println(mayor + " " + mayorKey);
                System.out.println(menor + " " + menorKey);
                
                
            }
            else
                System.out.println("-1");
        }
        
        scan.close();
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project6;

import java.io.*;
import java.util.*;

public class Problem_C {
    public static void main(String[] args) throws FileNotFoundException {
	//--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project6_C_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <
        int t = Integer.parseInt(scan.nextLine());//numero de casos de prueba       
        
        for (int test = 0; test < t;) {
            System.out.println("Case #" + ++test + ":");
            String lines[] = scan.nextLine().split(" ");//leer linea completa
            
            
            int n = Integer.parseInt(lines[0]);//problemas norma
            int m = Integer.parseInt(lines[1]);//Problemas mario
            int p = Integer.parseInt(lines[2]);//problemas pipe  
            
            HashSet<Integer> repetidos = new HashSet<>();
            TreeMap<Integer, String> colisiones = new TreeMap<>();

            lines = scan.nextLine().split(" ");//leer linea
            int norma = 0;
            
            for (int i=0; i<n; i++){
                int x = Integer.parseInt(lines[i]);//
                norma++;
                colisiones.put(x, "Norma");
            }
            
            lines = scan.nextLine().split(" ");//leer linea
            int mario = 0;
            
            for (int i=0; i<m; i++){
                int x = Integer.parseInt(lines[i]);//
                if(colisiones.containsKey(x)){
                    norma--;
                    repetidos.add(x);
                    colisiones.remove(x);
                }
                else{
                    colisiones.put(x, "Mario");
                    mario++;
                }
            }
            
            lines = scan.nextLine().split(" ");//leer linea
            int pipe = 0;
            
            for (int i=0; i<p; i++){
                int x = Integer.parseInt(lines[i]);//
                if(repetidos.contains(x))
                    ;
                else if(colisiones.containsKey(x)){
                    if("Norma".equals(colisiones.get(x)))
                        norma--;
                    else
                        mario--;
                    
                    repetidos.add(x);
                    colisiones.remove(x);
                }
                else{
                    colisiones.put(x, "Pipe");
                    pipe++;
                }
            }
            
            if(norma >= mario && norma >= pipe)
                System.out.println("Norma " + norma + toString(colisiones, "Norma"));
            if(mario >= norma && mario >= pipe)
                System.out.println("Mario " + mario + toString(colisiones, "Mario"));
            if(pipe >= norma && pipe >= mario)
                System.out.println("Pipe " + pipe + toString(colisiones, "Pipe"));
        }
        scan.close();
    }
    
    public static String toString( TreeMap<Integer, String> cualquiera, String name){
        
        StringBuilder sb = new StringBuilder();
        
        for(Map.Entry<Integer, String> entry : cualquiera.entrySet()){
            if(entry.getValue() == name)
                sb.append( " " + entry.getKey()  );
        }
        return new String( sb );
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package project7;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problem_A {
    public static void main(String[] args) throws FileNotFoundException {
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project7_A_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <

	int t = Integer.parseInt(scan.nextLine());//numero de casos
	for (int test = 0; test < t;) {
            System.out.println("Case #" + ++test + ":");
            
            String lines[] = scan.nextLine().split(" ");//leer linea completa
            int n = Integer.parseInt(lines[0]);//Estaciones
            int m = Integer.parseInt(lines[1]);//Vias
            
            Union_Find estaciones = new Union_Find(n);
           
            for (int i=0; i<m; i++) {
                lines = scan.nextLine().split(" ");//leer linea completa
                int u = Integer.parseInt(lines[0]);
                int v = Integer.parseInt(lines[1]);
                estaciones.union(u, v);
            }
            int s = Integer.parseInt(scan.nextLine());
            System.out.println(viasConectadas(estaciones, s));
        }
        scan.close();
    }
    
    public static int viasConectadas(Union_Find estaciones, int s){
        int contador=-1;
        for(int i=0; i<estaciones.size; i++){
            if(estaciones.connected(s, i)){
                contador++;
            }
        }
        return contador;
    }
    
    
    
    public static class Union_Find
    {   
        /**
         * hacer una coneccion entre p y q
         * @param p
         * @param q
         */
        public void union(int p, int q){   
            int i=find(p), j=find(q);
            if(i==j)
                return;//si p y q ya estan conectados no hace nada

            if(sz[i] <sz[j]){
                id[i] = j;
                sz[j] += sz[i];
            }else{
                id[j] = i;
                sz[i] += sz[j];
            }
            count--;
        }

        /**
         * encontrar el identificador del componente de p
         * @param p
         * @return 
         */
        public int find(int p){
            while(p != id[p]){
                id[p] = id[id[p]];
                p = id[p];
            }
            return p;
        }

        /**
         * 
         * @param p
         * @param q
         * @return true si p y q pertenecen al mismo componente, false en otro caso
         */
        public boolean connected(int p, int q){
            return find(p) == find(q);
        }
        
        public int size(){
            return size;
        }

        /**
         * cuenta el numero de componentes
         * @return 
         */
        public int count(){
            return count;
        }

        /**
         * constructor de Union_Find
         * @param n
         */
        public Union_Find(int n){
            count = n;
            size = n;
            id = new int[n+1];
            sz = new int[n+1];
            for(int i=0; i<=n; i++){
                id[i] = i;
                sz[i] = 0;
            }
        }


        private int[] id,sz;
        private int count;
        private int size;
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project7;

import java.io.*;
import java.util.*;

public class Problem_B {
    public static void main(String[] args) throws FileNotFoundException {
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project7_B_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
        //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <
        int t = Integer.parseInt(scan.nextLine());//numero de casos de prueba

        for (int test = 0; test < t;){
            System.out.println("Case #" + ++test + ":");
            
            String lines[] = scan.nextLine().split(" ");//leer linea completa
            int n = Integer.parseInt(lines[0]);//Temas
            int m = Integer.parseInt(lines[1]);//Relaciones
            
            //ArrayList<Temas> temas = new ArrayList<>();
            //TreeMap<Temas, Integer> relaciones = new TreeMap<>();
            
            TreeMap<Integer, Temas> relaciones = new TreeMap<>();
            
            for(int i=0; i<n; i++){
                Temas aux = new Temas();
                relaciones.put(i, aux);
            }
            
            for (int i=0; i<m; i++) {
                lines = scan.nextLine().split(" ");//leer linea completa
                int u = Integer.parseInt(lines[0]);//U antes que V
                int v = Integer.parseInt(lines[1]);
                
                relaciones.get(u).proximos.add(v);
                relaciones.get(v).necesarios++;
            }
            
            int cont=0;
            Temas estudieMijo = new Temas();
            boolean fue=false;
            
            for(int k=0; k<n && !fue; k++){
                cont = 0;
                for(int i=0; i<n; i++){
                    if(relaciones.get(i).necesarios == 0){
                        cont++;
                        estudieMijo = relaciones.get(i);
                        relaciones.get(i).necesarios--;
                    }
                }
                if(cont>1){
                    fue = true;
                }
                else{
                    ArrayList<Integer> aux = estudieMijo.proximos;
                    for(int i=0; i<aux.size(); i++){
                        relaciones.get(aux.get(i)).necesarios--;
                    }
                }
            }
            
            if(!fue){
                System.out.println("Deberia empezar a estudiar");
            }
            
        }
        scan.close();
    }
    
    
    public static class Temas{
        ArrayList<Integer> proximos;
        int necesarios;
        
        public Temas() {
            necesarios = 0;
            proximos = new ArrayList<>();
        }
    }
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project7;

import java.io.*;
import java.util.*;

public class Problem_C {
    public static void main(String[] args) throws FileNotFoundException {
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("Project7_C_1.in");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <

        
        int t = Integer.parseInt(scan.nextLine());//numero de casos
	for (int test=0; test<t;){
            System.out.println("Case #" + ++test + ":");
            
            
            
            //TreeMap<Integer, ArrayList<Integer>> laberinto = new TreeMap<>();
            
            String lines[] = scan.nextLine().split(" ");//leer linea completa
            int n = Integer.parseInt(lines[0]);//numero celdas
            int e = Integer.parseInt(lines[1]);//celda de salida
            int time = Integer.parseInt(lines[2]);//tiempo maximo
            int m = Integer.parseInt(scan.nextLine());
            
            int[][] laberinto = new int[n][n];
            inicializa(laberinto);
            
            for (int i=0; i<m; i++) {
                lines = scan.nextLine().split(" ");//leer linea completa
                int u = Integer.parseInt(lines[0]);//salgo aca
                int v = Integer.parseInt(lines[1]);//llego aca
                int w = Integer.parseInt(lines[2]);//valio esto
                
                laberinto[u][v] = w;
            }
            
            System.out.println(carita(laberinto, n, e, time));
	}
        scan.close();
    }
    
    public static void inicializa(int[][] laberinto){
        for (int[] laberinto1 : laberinto) {
            for (int j=0; j<laberinto.length; j++) {
                laberinto1[j] = Integer.MAX_VALUE;
            }
        }
    }
    
    public static int carita(int[][] laberinto, int n, int e, int time){
        int cont = 0;
        for(int i=0; i<n; i++){
            if(dijkstra(laberinto, n, i,e) <= time){
                cont++;
            }
        }
        return cont;
    }
    
    
    public static int dijkstra(int[][] laberinto, int n, int origen, int llegada){
        boolean[] known = new boolean[n];
        int[] distancia = new int[n];
        int path[] = new int[n];
        
        for (int j=0; j<n; j++){
            known[j] = false;
            distancia[j] = Integer.MAX_VALUE;
        }
        
        distancia[origen] = 0;
        
        int vertice=origen;
        int minimo;
        boolean desconocido = true;
        while(desconocido){
            minimo = Integer.MAX_VALUE;
            for(int i=0; i<n; i++){
                if(distancia[i]<minimo & known[i]==false){
                    vertice=i;
                    minimo = distancia[i];
                }
            }
            
            known[vertice] = true;
            int tmp = 0;
            int[] list = laberinto[vertice];
            
            for(int i=0; i<n; i++){
                if(list[i] < Integer.MAX_VALUE && !known[i]){
                    int ponderado = list[i];
                    
                    if(distancia[vertice] + ponderado < distancia[i]){
                        distancia[i] = distancia[vertice]+ponderado;
                        path[i] = vertice;
                    }                 
                }
                else{
                    tmp++;
                }
            }
            if(tmp != list.length){
                desconocido = false;
                for(int i=0; i<n; i++){
                    desconocido = (known[i] == false) ? true : desconocido;
                }
            }
            else{
                desconocido = false;
            }
        }
        
        return distancia[llegada];
    }
    
    
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project7;

import java.io.*;
import java.util.*;

public class Problem_D {
    public static void main(String[] args) throws FileNotFoundException, Exception {
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("bbb.txt");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
        //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <
        HashSet<Integer> prueba = new HashSet<>();
        
        
        
        
        int t = Integer.parseInt(scan.nextLine());//numero de casos de prueba

        for (int test = 0; test < t;){
            System.out.println("Case #" + ++test + ":");
            
            String lines[] = scan.nextLine().split(" ");//leer linea completa
            int n = Integer.parseInt(lines[0]);//Temas
            int m = Integer.parseInt(lines[1]);//Relaciones
            
            //ArrayList<Temas> temas = new ArrayList<>();
            //TreeMap<Temas, Integer> relaciones = new TreeMap<>();
            
            TreeMap<Integer, Temas> relaciones = new TreeMap<>();
            
            for(int i=0; i<n; i++){
                Temas aux = new Temas();
                relaciones.put(i, aux);
            }
            
            for (int i=0; i<m; i++) {
                lines = scan.nextLine().split(" ");//leer linea completa
                int u = Integer.parseInt(lines[0]);//U antes que V
                int v = Integer.parseInt(lines[1]);
                
                relaciones.get(u).proximos.add(v);
                relaciones.get(v).necesarios++;
            }
            
            int cont=0;
            Temas estudieMijo = new Temas();
            
            Collection<Integer> orden = new ArrayList<>();
            BinaryHeap<Integer> cola = new BinaryHeap<>();
            
            for(int k=0; k<n; k++){
                cont = 0;
                for(int i=0; i<n; i++){
                    if(relaciones.get(i).necesarios == 0){
                        cont++;
                        estudieMijo = relaciones.get(i);
                        relaciones.get(i).necesarios--;
                        cola.insert(i);
                        
                        ArrayList<Integer> aux = estudieMijo.proximos;
                        
                        for(int Z=0; Z<aux.size(); Z++){
                            //System.out.println("rel: " + k + " " + aux.get(Z));
                            relaciones.get(aux.get(Z)).necesarios--;
                        }
                        orden.add(cola.deleteMin());
                    }
                }
            }
            
            System.out.println(toString(orden));
            
        }
        scan.close();
    }
    
    public static String toString( Collection orden){
        
        StringBuilder sb = new StringBuilder();
        for (Object orden1 : orden) {
            sb.append( orden1 + " ");
        }
        return new String( sb );
    }
    
    public static class Temas{
        ArrayList<Integer> proximos;
        int necesarios;
        
        public Temas() {
            necesarios = 0;
            proximos = new ArrayList<>();
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
    {
        /**
         * Construct the binary heap.
         */
        public BinaryHeap( )
        {
            this( DEFAULT_CAPACITY );
        }

        /**
         * Construct the binary heap.
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap( int capacity )
        {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }

        /**
         * Construct the binary heap given an array of items.
         * @param items
         */
        public BinaryHeap( AnyType [ ] items )
        {
                currentSize = items.length;
                array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

                int i = 1;
                for( AnyType item : items )
                    array[ i++ ] = item;
                buildHeap( );
        }

        /**
         * Insert into the priority queue, maintaining heap order.
         * Duplicates are allowed.
         * @param x the item to insert.
         */
        public void insert( AnyType x )
        {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

                // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        /**
         * 
         * @return size of Binary Heap
         */
        public int size(){
            return currentSize;
        }


        private void enlargeArray( int newSize )
        {
                AnyType [] old = array;
                array = (AnyType []) new Comparable[ newSize ];
                for( int i = 0; i < old.length; i++ )
                    array[ i ] = old[ i ];        
        }

        /**
         * Find the smallest item in the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

        /**
         * Remove the smallest item from the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );

            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary
         * arrangement of items. Runs in linear time.
         */
        private void buildHeap( )
        {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

        /**
         * Test if the priority queue is logically empty.
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty( )
        {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty( )
        {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown( int hole )
        {
            int child;
            AnyType tmp = array[ hole ];

            for( ; hole * 2 <= currentSize; hole = child )
            {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else
                    break;
            }
            array[ hole ] = tmp;
        }
    }
    
     
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Project7;

import java.io.*;
import java.util.*;

public class Problem_D {
    public static void main(String[] args) throws FileNotFoundException, Exception {
    //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  < 
        Scanner scan;
        File f = new File("bbb.txt");
        if (f.exists()){
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }
        //--------------------------------------->>>>>>>>>>>>>>>>>>>>>>  <
        int t = Integer.parseInt(scan.nextLine());//numero de casos de prueba

        for (int test = 0; test < t;){
            System.out.println("Case #" + ++test + ":");
            
            String lines[] = scan.nextLine().split(" ");//leer linea completa
            int n = Integer.parseInt(lines[0]);//Temas
            int m = Integer.parseInt(lines[1]);//Relaciones
            
            //ArrayList<Temas> temas = new ArrayList<>();
            //TreeMap<Temas, Integer> relaciones = new TreeMap<>();
            
            TreeMap<Integer, Temas> relaciones = new TreeMap<>();
            
            for(int i=0; i<n; i++){
                Temas aux = new Temas();
                relaciones.put(i, aux);
            }
            
            for (int i=0; i<m; i++) {
                lines = scan.nextLine().split(" ");//leer linea completa
                int u = Integer.parseInt(lines[0]);//U antes que V
                int v = Integer.parseInt(lines[1]);
                
                relaciones.get(u).proximos.add(v);
                relaciones.get(v).necesarios++;
            }
            
            int cont=0;
            Temas estudieMijo = new Temas();
            
            Collection<Integer> orden = new ArrayList<>();
            BinaryHeap<Integer> cola = new BinaryHeap<>();
            
            for(int k=0; k<n; k++){
                cont = 0;
                for(int i=0; i<n; i++){
                    if(relaciones.get(i).necesarios == 0){
                        cont++;
                        estudieMijo = relaciones.get(i);
                        relaciones.get(i).necesarios--;
                        cola.insert(i);
                        i=n;
                        ArrayList<Integer> aux = estudieMijo.proximos;
                        
                        for(int Z=0; Z<aux.size(); Z++){
                            //System.out.println("rel: " + k + " " + aux.get(Z));
                            relaciones.get(aux.get(Z)).necesarios--;
                            
                        }
                        orden.add(cola.deleteMin());
                        
                    }
                }
            }
            
            System.out.println(toString(orden));
            
        }
        scan.close();
    }
    
    public static String toString( Collection orden){
        
        StringBuilder sb = new StringBuilder();
        for (Object orden1 : orden) {
            sb.append( orden1 + " ");
        }
        return new String( sb );
    }
    
    public static class Temas{
        ArrayList<Integer> proximos;
        int necesarios;
        
        public Temas() {
            necesarios = 0;
            proximos = new ArrayList<>();
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
    {
        /**
         * Construct the binary heap.
         */
        public BinaryHeap( )
        {
            this( DEFAULT_CAPACITY );
        }

        /**
         * Construct the binary heap.
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap( int capacity )
        {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }

        /**
         * Construct the binary heap given an array of items.
         * @param items
         */
        public BinaryHeap( AnyType [ ] items )
        {
                currentSize = items.length;
                array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

                int i = 1;
                for( AnyType item : items )
                    array[ i++ ] = item;
                buildHeap( );
        }

        /**
         * Insert into the priority queue, maintaining heap order.
         * Duplicates are allowed.
         * @param x the item to insert.
         */
        public void insert( AnyType x )
        {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

                // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        /**
         * 
         * @return size of Binary Heap
         */
        public int size(){
            return currentSize;
        }


        private void enlargeArray( int newSize )
        {
                AnyType [] old = array;
                array = (AnyType []) new Comparable[ newSize ];
                for( int i = 0; i < old.length; i++ )
                    array[ i ] = old[ i ];        
        }

        /**
         * Find the smallest item in the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

        /**
         * Remove the smallest item from the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );

            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary
         * arrangement of items. Runs in linear time.
         */
        private void buildHeap( )
        {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

        /**
         * Test if the priority queue is logically empty.
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty( )
        {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty( )
        {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown( int hole )
        {
            int child;
            AnyType tmp = array[ hole ];

            for( ; hole * 2 <= currentSize; hole = child )
            {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else
                    break;
            }
            array[ hole ] = tmp;
        }
    }
    
     
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

while True:
    num = stdin.readline()
    if num == None:
        break
    num = int(num)
    if (num%3 == 0 and num%5 == 0):
        print ("FuzzBuzz")
    elif (num%3 == 0):
        print ("Fuzz")
    elif (num%5 == 0):
        print ("Buzz")
    else:
        print (num)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin


while True:
    num = stdin.readline().strip()
    if num == None:
        break
    num = int(num)
    if (num%3 == 0 and num%5 == 0):
        print ("FuzzBuzz")
    elif (num%3 == 0):
        print ("Fuzz")
    elif (num%5 == 0):
        print ("Buzz")
    else:
        print (num)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin


while True:
    num = stdin.readline().strip()
    if not num:
        break
    num = int(num)

    if (num%3 == 0 and num%5 == 0):
        print ("FuzzBuzz")
    elif (num%3 == 0):
        print ("Fuzz")
    elif (num%5 == 0):
        print ("Buzz")
    else:
        print (num)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

test = int(stdin.readline().strip())
for t in range(0, test):
    a,b = map(int, stdin.readline().split(" "))
    """
    Si son muchos numeros usar list en vez de map
    """

    print (a+b)
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

test = int(stdin.readline().strip())
for t in range(0, test):
    n = int(stdin.readline().strip())
    x = map(int, stdin.readline().split(" "))

    num = 1
    for i in range(0, n):
        num= (num * (x[i]))

    print num

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

test = int(stdin.readline().strip())
for t in range(0, test):
    n = int(stdin.readline().strip())
    x = map(int, stdin.readline().strip().split(" "))

    find = False
    for i in range(0, n):
        if(x[0] == 1):
            find = True


    if find == False:
        print ("1")
    else:
        print ("-1")

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

test = int(stdin.readline().strip())
for t in range(0, test):
    n = int(stdin.readline().strip())
    x = map(int, stdin.readline().strip().split(" "))

    find = False
    for i in range(0, n):
        if(x[i] == 1):
            find = True


    if find == False:
        print ("1")
    else:
        print ("-1")

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

test = int(stdin.readline().strip())
for t in range(test):

    cont = 0
    a = int(stdin.readline().strip())
    for read in range(a):
        b = stdin.readline().strip()
        for i in range (a):
            if b[i] == '#':
                cont += 1
    print cont

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

def filaMayor(chocolate):
        cerFila = 0; fila = 0
        for i in range(len(chocolate)):
            cont = 0
            for j in range(len(chocolate)):
                if chocolate[i][j] == '#':
                    cont += 1

            if cont > cerFila:
                cerFila = cont
                fila = i+1
        return fila;

def colMayor(chocolate):
        cerCol = 0; col = 0
        for i in range(len(chocolate)):
            cont = 0
            for j in range(len(chocolate)):
                if chocolate[j][i] == '#':
                    cont += 1

            if cont > cerCol:
                cerCol = cont
                col = i+1
        return col;


test = int(stdin.readline().strip())
for t in range(test):
    a = int(stdin.readline().strip())
    chocolate = []
    for i in range(a): #filas

        b = stdin.readline().strip()

        chocolate.append([])
        for j in range(a): #columnas
            chocolate[i].append(b[j])

    print (str(filaMayor(chocolate)) + " " +  str(colMayor(chocolate)))

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

def fila(chocolate, cerezas):
    contFila = 0;
    for i in range(len(chocolate)):

        for j in range(len(chocolate)):
            if chocolate[i][j] == '#':
                contFila += 1

        if contFila == cerezas/2:
            return True
        elif contFila > cerezas/2:
            return False

    return False

def columna(chocolate, cerezas):
    contCol = 0;
    for i in range(len(chocolate)):

        for j in range(len(chocolate)):
            if chocolate[j][i] == '#':
                contCol += 1

    if contCol == cerezas/2:
        return True
    elif contCol > cerezas/2:
        return False
    return False


test = int(stdin.readline().strip())
for t in range(test):

    cerezas = 0
    a = int(stdin.readline().strip())
    chocolate = []
    for i in range(a): #filas

        b = stdin.readline().strip()

        chocolate.append([])
        for j in range(a): #columnas
            chocolate[i].append(b[j])
            if b[j] == '#':
                cerezas += 1

    if cerezas%2 == 1:
        print "NO"
    else:
        if fila(chocolate,cerezas) or columna(chocolate, cerezas):
            print "YES"
        else:
            print"NO"

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

def fila(chocolate, cerezas):
    contFila = 0;
    for i in range(len(chocolate)):

        for j in range(len(chocolate)):
            if chocolate[i][j] == '#':
                contFila += 1

        if contFila == cerezas/2:
            return True
        elif contFila > cerezas/2:
            return False

    return False

def columna(chocolate, cerezas):
    contCol = 0;
    for i in range(len(chocolate)):

        for j in range(len(chocolate)):
            if chocolate[j][i] == '#':
                contCol += 1

        if contCol == cerezas/2:
            return True
        elif contCol > cerezas/2:
            return False


    return False


test = int(stdin.readline().strip())
for t in range(test):

    cerezas = 0
    a = int(stdin.readline().strip())
    chocolate = []
    for i in range(a): #filas

        b = stdin.readline().strip()

        chocolate.append([])
        for j in range(a): #columnas
            chocolate[i].append(b[j])
            if b[j] == '#':
                cerezas += 1

    if cerezas%2 == 1:
        print "NO"
    else:
        if fila(chocolate,cerezas) or columna(chocolate, cerezas):
            print "YES"
        else:
            print"NO"

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

def funtion(n):
    return (n+1)**3 + (n+2)

n = int(stdin.readline().strip())
for i in range(n):
    print funtion(int(stdin.readline().strip()))

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

n = int(stdin.readline().strip())
for i in range(n):
    x = map(int ,stdin.readline().strip().split(" "))
    if x[0]==2:
        print 3*x[1] +4
    else:
        print x[1]**3 +2*(x[1]**2)+x[1]
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

n = int(stdin.readline().strip())
for i in range(n):
    x = map(int ,stdin.readline().strip().split(" "))
    if x[0]==2:
        print 3*x[1] +4
    else:
        if x[1]>=10:
            print x[1]**3 +2*(x[1]**2)+x[1]
        else:
            print x[1]**3 +2*(x[1]**2)+x[1] + 4
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

def mult(matriz,new_matriz, n):
    if n==0:
        new_matriz[0]=1
        new_matriz[1]=0
        new_matriz[2]=0
        new_matriz[3]=1
        return new_matriz
    if n==1:
        return new_matriz

    new_matri = []

    new_matri.append(new_matriz[0] * matriz[0] + new_matriz[1] * matriz[2])
    new_matri.append(new_matriz[0] * matriz[1] + new_matriz[1] * matriz[3])
    new_matri.append(new_matriz[0] * matriz[2] + new_matriz[2] * matriz[3])
    new_matri.append(new_matriz[1] * matriz[2] + new_matriz[3] * matriz[3])

    return mult(matriz,new_matri, n-1)



for test in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())

    matriz = []
    a,b = map(int, stdin.readline().strip().split(" "))
    c,d = map(int, stdin.readline().strip().split(" "))

    matriz.append(a)
    matriz.append(b)
    matriz.append(c)
    matriz.append(d)

    matriz =  mult(matriz,matriz,n)
    print str(matriz[0]) + " " + str(matriz[1])
    print str(matriz[2]) + " " + str(matriz[3])
    print ""



    """
    n,q = map(int, stdin.readline().split(" "))
    if n==0 and q==0:
        break
    test += 1
    marbles = []
    for i in range(n):
        marbles.append(stdin.readline().strip())

    marbles.sort()
    print "CASE# " + str(test) + ":"
    for i in range(q):
        aux = stdin.readline().strip()
        try :
            print str(aux) + " found at " + str(marbles.index(aux)+1)
        except :
            print str(aux) + " not found"

        """
"""
        aux = stdin.readline().strip()
        if marbles.count(aux):
            print str(aux) + " found at " + str(marbles.index(aux)+1)
        else:
            print str(aux) + " not found"

        """

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

def mult(matriz,new_matriz, n):
    if n==0:
        new_matriz[0]=1
        new_matriz[1]=0
        new_matriz[2]=0
        new_matriz[3]=1
        return new_matriz
    if n==1:
        return new_matriz

    new_matri = []

    new_matri.append(new_matriz[0] * matriz[0] + new_matriz[1] * matriz[2])
    new_matri.append(new_matriz[0] * matriz[1] + new_matriz[1] * matriz[3])
    new_matri.append(new_matriz[0] * matriz[2] + new_matriz[2] * matriz[3])
    new_matri.append(new_matriz[1] * matriz[2] + new_matriz[3] * matriz[3])

    return mult(matriz,new_matri, n-1)



for test in range(int(stdin.readline().strip())):
    n = int(stdin.readline().strip())

    matriz = []
    a,b = map(int, stdin.readline().strip().split(" "))
    c,d = map(int, stdin.readline().strip().split(" "))

    matriz.append(a)
    matriz.append(b)
    matriz.append(c)
    matriz.append(d)

    matriz =  mult(matriz,matriz,n)
    print str(matriz[0]) + " " + str(matriz[1])
    print str(matriz[2]) + " " + str(matriz[3])
    print ""


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

#archivo = open("casos.txt", "r")

archivo = stdin

def mult(matriz,matriz2):

    new_matri = []
    new_matri.append(matriz[0] * matriz2[0] + matriz[1] * matriz2[2])
    new_matri.append(matriz[0] * matriz2[1] + matriz[1] * matriz2[3])
    new_matri.append(matriz[0] * matriz2[2] + matriz[2] * matriz2[3])
    new_matri.append(matriz[1] * matriz2[2] + matriz[3] * matriz2[3])
    return new_matri

def otra(original, actual, n):
    if n==0:
        actual[0]=1
        actual[1]=0
        actual[2]=0
        actual[3]=1
        return actual
    if n==1:
        return actual

    nueva = mult(original, actual)
    return otra(original, nueva, n-1)






for test in range(int(archivo.readline().strip())):
    n = int(archivo.readline().strip())


    a,b = map(int, archivo.readline().strip().split(" "))
    c,d = map(int, archivo.readline().strip().split(" "))

    matriz = [a,b,c,d]

    original = [1,0,0,1]
    if(n%2==1):
        original=matriz

    matriz = otra(matriz,matriz,n/2)
    matriz = mult(matriz,matriz)

    matriz = mult(matriz,original)

    print str(matriz[0]) + " " + str(matriz[1])
    print str(matriz[2]) + " " + str(matriz[3])
    print ""


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def mult(matriz,matriz2):

    new_matri = []
    new_matri.append(matriz[0] * matriz2[0] + matriz[1] * matriz2[2])
    new_matri.append(matriz[0] * matriz2[1] + matriz[1] * matriz2[3])
    new_matri.append(matriz[0] * matriz2[2] + matriz[2] * matriz2[3])
    new_matri.append(matriz[1] * matriz2[2] + matriz[3] * matriz2[3])
    return new_matri

def otra(original, n):
    if n==0:
        aux = [1,0,0,1]
        return aux
    if n==1:
        return original
    if n==2:
        return mult(original,original)

    aux = otra(original, n/2)
    aux = mult(aux,aux)

    if(n%2==0):
        return aux
    return mult(original,aux)

for test in range(int(scan.readline().strip())):
    n = int(scan.readline().strip())

    a,b = map(int, scan.readline().strip().split(" "))
    c,d = map(int, scan.readline().strip().split(" "))

    matriz = [a,b,c,d]
    matriz = otra(matriz,n)

    print str(matriz[0]), str(matriz[1])
    print str(matriz[2]), str(matriz[3])
    print ""
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    a = map(int, scan.readline().strip().split(" "))
    b = map(int, scan.readline().strip().split(" "))

    a.sort()

    for i in range(m):
        l = 0
        r = n-1

        while l <= r:
            aux = l+(r-l)/2

            if a[aux] <= b[i]:
                l = aux+1
            elif a[aux] > b[i]:
                r = aux-1
        print l,
    print ""
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from math import sqrt

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

for test in range(int(scan.readline().strip())):
    a,n = scan.readline().strip().split(" ")
    n = int(n)

    if(a=="serpiente"):
        print n-1
    elif(a=="linea"):
        n = int(sqrt(n))
        print (n*(n-1))*2
    elif(a=="caja"):
        print n

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from math import sqrt

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

for test in range(int(scan.readline().strip())):
    n = map(int,scan.readline().strip().split(" "))
    count = 0
    for i in n:
        count += i

    if(len(n)-1)*2 == count:
        print "Arbol"
    else:
        print "No arbol"

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

for test in range(int(scan.readline().strip())):
    try:
        n = map(int,scan.readline().strip().split(" "))
        count = 0
        for i in n:
            count += i

        if(len(n)-1)*2 == count:
            print "Arbol"
        else:
            print "No arbol"
    except:
        print "No arbol"

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

for test in range(int(scan.readline().strip())):
    n,p = map(float,scan.readline().strip().split(" "))

    print int((n*(n-1)/2)*p)
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def DFS_Visit(G, node, color):
    color[node] = 'gray'
    total_marked = 1
#    print "node=", node, ">>> "
#    display_graph(G, color)
    for neighbor in G[node]:
        if color[neighbor] == 'white':
            total_marked += DFS_Visit(G, neighbor, color)
    color[node] = 'black'
#    print "node=", node, "<<< "
#    display_graph(G, color)
    return total_marked

def connected_components(G):
    color = {}
    for v in G:
        color[v] = 'white'
    count = 0
    for v in G:
        #print 'v = ', v
        if color[v] == 'white':
            count += 1
            DFS_Visit(G, v, color)
    return count

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    letras = []
    for i in range(m):
        a = str(scan.readline())
        make_link(G, a[0], a[1])
        if a[0] not in letras:
            letras.append(a[0])
        if a[1] not in letras:
            letras.append(a[1])
    n -= len(letras)
    print connected_components(G) + n
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def DFS_Visit(G, node, color):
    color[node] = 'gray'
    total_marked = 1
#    print "node=", node, ">>> "
#    display_graph(G, color)
    for neighbor in G[node]:
        if color[neighbor] == 'white':
            total_marked += DFS_Visit(G, neighbor, color)
    color[node] = 'black'
#    print "node=", node, "<<< "
#    display_graph(G, color)
    return total_marked

def connected_components(G):
    color = {}
    for v in G:
        color[v] = 'white'
    count = 0
    for v in G:
        #print 'v = ', v
        if color[v] == 'white':
            count += 1
            DFS_Visit(G, v, color)
    return count

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    letras = []
    for i in range(m):
        a,b = map(str, scan.readline().strip().split(" "))
        make_link(G, a, b)

    s,p = map(int, scan.readline().strip().split(" "))

    color = {}
    for v in G:
        color[v] = 'white'
    num_nodes = DFS_Visit(G, str(s), color)

    print num_nodes * p

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit

setrecursionlimit( 30000 )


try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def DFS_Visit(G, node, color):
    color[node] = 'gray'
    total_marked = 1
#    print "node=", node, ">>> "
#    display_graph(G, color)
    for neighbor in G[node]:
        if color[neighbor] == 'white':
            total_marked += DFS_Visit(G, neighbor, color)
    color[node] = 'black'
#    print "node=", node, "<<< "
#    display_graph(G, color)
    return total_marked

def connected_components(G):
    color = {}
    for v in G:
        color[v] = 'white'
    count = 0
    for v in G:
        #print 'v = ', v
        if color[v] == 'white':
            count += 1
            DFS_Visit(G, v, color)
    return count

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    letras = []
    for i in range(m):
        a,b = map(str, scan.readline().strip().split(" "))
        make_link(G, a, b)

    s,p = map(int, scan.readline().strip().split(" "))

    color = {}
    for v in G:
        color[v] = 'white'
    num_nodes = DFS_Visit(G, str(s), color)

    print num_nodes * p

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def BFS_iterative(G, node):
    color = {}
    depth = {}
    parent = {}
    for v in G:
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    parent[node] = None
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if color[neighbor] == 'white':
                color[neighbor] = 'gray'
                depth[neighbor] = depth[u] + 1
                parent[neighbor] = u
                nodelist.append(neighbor)
                #print 'Pila:', nodelist
                total_marked += 1
        color[u] = 'black'
    return depth




def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}

    lab = []
    for i in range(n):
        b = stdin.readline().strip()
        for j in b:
            lab.append(j)

    for i in range(n):
        for j in range(m):
            if lab[i*m +j] != '#':
                if j+1<m and lab[i*m +j+1]!= '#':
                    make_link(G, m*i+j,m*i+j+1)
                if i+1<n and lab[(i+1)*m +j]!= '#':
                    make_link(G, m*i+j,(i+1)*m +j)

    algo = BFS_iterative(G,lab.index('G'))[lab.index('S')]

    try:
        print int(algo)
    except:
        print ":("
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

def mayor():
    max = 0
    id = 0
    for n in G:
        if G[n] > max:
            max = G[n]
            id = n
    return id

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    for i in range(m):
        a,b = map(str, scan.readline().strip().split(" "))
        make_link(G, a, b)
    id = mayor()
    print id, len(G[id])
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

def mayor(n):
    max = 0
    id = n
    for node in G:
        if G[node] >= max and int(node) < id:
            max = G[node]
            id = node
    return id

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    for i in range(m):
        a,b = map(str, scan.readline().strip().split(" "))
        if a != b:
            make_link(G, a, b)
    id = mayor(n)
    print id, len(G[id])
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

def mayor(n):
    max = 0
    id = n
    for node in G:
        if G[node] > max:
            max = G[node]
            id = node
        elif G[node] == max and int(node) < id:
            id = node
    return id

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    for i in range(m):
        a,b = map(str, scan.readline().strip().split(" "))
        if a != b:
            make_link(G, a, b)
    id = mayor(n)
    print id, len(G[id])
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

def mayor(n):
    max = 0
    id = n
    for node in G:
        if len(G[node]) > max:
            max = len(G[node])
            id = node
    return id

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    for i in range(m):
        a,b = map(int, scan.readline().strip().split(" "))
        if a != b:
            make_link(G, a, b)
    id = mayor(n)
    print id, len(G[id])
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def BFS_iterative(G, node):
    color = {}
    depth = {}
    parent = {}
    for v in G:
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    parent[node] = None
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if color[neighbor] == 'white':
                color[neighbor] = 'gray'
                depth[neighbor] = depth[u] + 1
                parent[neighbor] = u
                nodelist.append(neighbor)
                #print 'Pila:', nodelist
                total_marked += 1
        color[u] = 'black'
    return depth




def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G


def central(n):
    min = n*(n+1)/2
    id = 0
    for node in G:
        count = 0
        aux = BFS_iterative(G,node)
        for yolo in aux:
            count += aux[yolo]
        if(count < min):
            min = count
            id = node
    return id;

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    for i in range(m):
        a,b = map(int, scan.readline().strip().split(" "))
        make_link(G, a, b)
    print central(n)


"""
    lab = []
    for i in range(n):
        b = stdin.readline().strip()
        for j in b:
            lab.append(j)

    for i in range(n):
        for j in range(m):
            if lab[i*m +j] != '#':
                if j+1<m and lab[i*m +j+1]!= '#':
                    make_link(G, m*i+j,m*i+j+1)
                if i+1<n and lab[(i+1)*m +j]!= '#':
                    make_link(G, m*i+j,(i+1)*m +j)

    algo = BFS_iterative(G,lab.index('G'))[lab.index('S')]

    try:
        print int(algo)
    except:
        print ":("
"""
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def jmm(pan, idx, tam):
    new = []
    for i in range(idx,-1,-1):

        new.append(pan[i])
    for i in range(idx+1,tam):

        new.append(pan[i])
    return new

def girandoAndo(pan):
    tam = len(pan)
    idx = pan.index(max(pan))
    if tam == 1:
        return 0;

    if idx == tam-1:
        return girandoAndo(pan[:tam-1:])

    if idx == 0:
        return 1 + girandoAndo(pan[tam-1:0:-1])

    return 1 + girandoAndo(jmm(pan,idx,tam))

for test in range(int(scan.readline().strip())):
    pan = []
    b = stdin.readline().strip().split(" ")
    for j in b:
        pan.append(j)

    print girandoAndo(pan)


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def jmm(pan, idx, tam):
    new = []
    for i in range(idx,-1,-1):
        new.append(pan[i])
    for i in range(idx+1,tam):
        new.append(pan[i])
    return new[tam:0:-1]


def index(pan):
    max = pan[0]
    idx = 0
    for i in range(len(pan)):
        if pan[i] >= max:
            max = pan[i]
            idx = i
    return idx


def girandoAndo(pan):
    tam = len(pan)
    idx = index(pan)

    if tam == 1:
        return 0;

    if idx == tam-1:
        return girandoAndo(pan[:tam-1:])

    if idx == 0:
        return 1 + girandoAndo(pan[tam-1:0:-1])

    return 2 + girandoAndo(jmm(pan,idx,tam))

for test in range(int(scan.readline().strip())):
    pan = []
    b = stdin.readline().strip().split(" ")
    for j in b:
        pan.append(j)

    print girandoAndo(pan)


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def jmm(pan, idx, tam):
    new = []
    for i in range(idx,-1,-1):
        new.append(pan[i])
    for i in range(idx+1,tam):
        new.append(pan[i])
    return new[tam:0:-1]


def index(pan):
    max = pan[0]
    idx = 0
    for i in range(len(pan)):
        if pan[i] >= max:
            max = pan[i]
            idx = i
    return idx


def girandoAndo(pan):
    tam = len(pan)
    idx = index(pan)

    if tam == 1:
        return 0;

    if idx == tam-1:
        return girandoAndo(pan[:tam-1:])

    if idx == 0:
        return 1 + girandoAndo(pan[tam-1:0:-1])

    return 2 + girandoAndo(jmm(pan,idx,tam))

for test in range(int(scan.readline().strip())):
    pan = []
    b = stdin.readline().strip().split(" ")

    ant = 10

    for j in b:
        if j != ant:
            pan.append(j)
            ant = j

    print girandoAndo(pan)


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin
"""
lista = [1,2,3,4,5]
n=5

print lista[n::-1]+lista[n+1::]
"""
def girar(pan, n):
    return pan[n::-1]+pan[n+1::]




def make_link(G, node1, value):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[0] = value
    return G




for test in range(int(scan.readline().strip())):
    pan = stdin.readline().strip().split(" ")
    pankakend = sorted(pan)
    G = {}
    cola = []
    contado = []
    cola.append(pan)
    contado.append(pan)
    make_link(G,str(pan),0)
    algo = True
    while(len(cola) and algo):
        thisnode = cola.pop(0)
        value = (G[str(thisnode)])[0]
        if thisnode == pankakend:
            #print G[str(thisnode)]
            print value
            algo = False
        else:
            for i in range(1,len(thisnode)):
                aux = girar(thisnode,i)
                if aux == pankakend:
                    print value + 1
                    algo = False
                if str(aux) not in G:
                    #print "entra", aux, value+1
                    cola.append(aux)
                    make_link(G,str(aux),value+1)


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def DFS_Visit(G, node, color):
    color[node] = 'gray'
    total_marked = 1
#    print "node=", node, ">>> "
#    display_graph(G, color)
    for neighbor in G[node]:
        if color[neighbor] == 'white':
            total_marked += DFS_Visit(G, neighbor, color)
    color[node] = 'black'
#    print "node=", node, "<<< "
#    display_graph(G, color)
    return total_marked

def connected_components(G):
    color = {}
    for v in G:
        color[v] = 'white'
    count = 0
    for v in G:
        #print 'v = ', v
        if color[v] == 'white':
            count += 1
            DFS_Visit(G, v, color)
    return count

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")

    n,m = map(int, scan.readline().strip().split(" "))

    estaciones = []
    for i in range(n+1):
        estaciones.append(0)

    for i in range(m):
        num = map(int, scan.readline().strip().split(" "))
        num.pop(0)
        for algo in num:
            estaciones[algo] += 1


    for i in range(n):
        if estaciones[i] > 1:
            print i,
    print
    for i in range(n):
        if estaciones[i] > 1:
            print estaciones[i],

    print


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def DFS_Visit(G, node, color):
    color[node] = 'gray'
    total_marked = 1
#    print "node=", node, ">>> "
#    display_graph(G, color)
    for neighbor in G[node]:
        if color[neighbor] == 'white':
            total_marked += DFS_Visit(G, neighbor, color)
    color[node] = 'black'
#    print "node=", node, "<<< "
#    display_graph(G, color)
    return total_marked

def connected_components(G):
    color = {}
    for v in G:
        color[v] = 'white'
    count = 0
    for v in G:
        #print 'v = ', v
        if color[v] == 'white':
            count += 1
            DFS_Visit(G, v, color)
    return count

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")

    n,m = map(int, scan.readline().strip().split(" "))

    estaciones = []
    for i in range(n+1):
        estaciones.append(0)

    for i in range(m):
        aux = []
        num = map(int, scan.readline().strip().split(" "))
        num.pop(0)
        for algo in num:
            if algo not in aux:
                estaciones[algo] += 1
                aux.append(algo)

    for i in range(n):
        if estaciones[i] > 1:
            print i,
    print
    for i in range(n):
        if estaciones[i] > 1:
            print estaciones[i],

    print


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    return G


for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")

    n,m = map(int, scan.readline().strip().split(" "))

    estaciones = {}

    for i in range(m):
        num = map(int, scan.readline().strip().split(" "))
        num.pop(0)
        for algo in num:
            make_link(estaciones,algo)
            #estaciones[algo] += 1


    for node in (estaciones):
        if(estaciones[node][0] > 1):
            print node,
    print
    for node in (estaciones):
        if(estaciones[node][0] > 1):
            print estaciones[node][0],
    print

"""
    for i in range(n):
        if estaciones[i] > 1:
            print i,
    print
    for i in estaciones:
        if i > 1:
            print i,

    print

"""
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def BFS_iterative(G, node):
    color = {}
    depth = {}
    parent = {}
    for v in G:
        #print v, G[v]
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    parent[node] = None
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if color[neighbor] == 'white':
                color[neighbor] = 'gray'
                depth[neighbor] = depth[u] + 1
                parent[neighbor] = u
                nodelist.append(neighbor)
                #print 'Pila:', nodelist
                total_marked += 1
        color[u] = 'black'
    return depth




def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    return G


def central(n):
    min = n*(n+1)/2
    id = 0
    for node in G:
        count = 0
        aux = BFS_iterative(G,node)
        for yolo in aux:
            count += aux[yolo]
        if(count < min):
            min = count
            id = node
    return id;


for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}

    for i in range(m):
        a = map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        for j in range(b-1):
            #print a[j], a[j+1]
            make_link(G,a[j],a[j+1])
    #print len(G)
    print central(n)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def BFS_iterative(imppG, node):
    color = {}
    depth = {}
    parent = {}
    for v in imppG:
        #print v, G[v]
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    parent[node] = None
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if color[neighbor] == 'white':
                color[neighbor] = 'gray'
                depth[neighbor] = depth[u] + 1
                parent[neighbor] = u
                nodelist.append(neighbor)
                #print 'Pila:', nodelist
                total_marked += 1
        color[u] = 'black'
    return depth

def make_link(G, importantes, node1, node2):
    if node1 not in G:
        G[node1] = {}
        importantes[node1] = {}
        (importantes[node1])[0] = 1
    else:
        (importantes[node1])[0] += 1
    (G[node1])[node2] = 1
    #(G[node1])[0] = 1
    return G


def central(n):
    min = n*(n+1)/2
    id = 0
    for node in G:
        count = 0
        aux = BFS_iterative(importantes,node)
        for yolo in aux:
            count += aux[yolo]
        if(count < min):
            min = count
            id = node
    return id,min;


for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    medios = {}
    importantes = {}

    for i in range(m):
        a = map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        """
        if b%2 == 1:
            print b,  len(a) ,   (b-1)/2, a[(b-1)/2]
            medios[a[(b-1)/2]] = 0
        """
        for j in range(b-1):
            #print a[j], a[j+1]
            make_link(G,importantes,a[j],a[j+1])
    x = central(n)
    print x[0],x[1]

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def BFS_iterative(imppG, node):
    color = {}
    depth = {}
    parent = {}
    for v in G:
        #print v, G[v]
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    parent[node] = None
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if neighbor != 0:
                if color[neighbor] == 'white':
                    color[neighbor] = 'gray'
                    depth[neighbor] = depth[u] + 1
                    parent[neighbor] = u
                    nodelist.append(neighbor)
                    #print 'Pila:', nodelist
                    total_marked += 1
        color[u] = 'black'
    return depth

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    (G[node1])[node2] = 1

    return G
def m_k(G, node1):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    return G

def central(n):
    min = n*(n+1)/2
    id = 0
    for node in G:
        print node,G[node][0]
        if G[node][0]>1:
            #print node,G[node][0]
            count = 0
            aux = BFS_iterative(G,node)
            for yolo in aux:
                count += aux[yolo]
            if(count < min):
                min = count
                id = node
    return id,min;


for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}

    for i in range(m):
        a = map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        m_k(G,a[b-1])

        for j in range(b-1):
            make_link(G,a[j],a[j+1])
    x = central(n)
    print x[0],x[1]

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def BFS_iterative(imppG, node):
    color = {}
    depth = {}
    parent = {}
    for v in G:
        #print v, G[v]
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    parent[node] = None
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if neighbor != 0:
                if color[neighbor] == 'white':
                    color[neighbor] = 'gray'
                    depth[neighbor] = depth[u] + 1
                    parent[neighbor] = u
                    nodelist.append(neighbor)
                    #print 'Pila:', nodelist
                    total_marked += 1
        color[u] = 'black'
    return depth

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    (G[node1])[node2] = 1

    return G
def m_k(G, node1):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    return G

def central(n):
    min = n*(n+1)/2
    id = 0
    for node in G:
        if G[node][0]>1:
            #print node,G[node][0]
            count = 0
            aux = BFS_iterative(G,node)
            for yolo in aux:
                count += aux[yolo]
            if(count < min):
                min = count
                id = node
    return id,min;


for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}

    for i in range(m):
        a = map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        m_k(G,a[b-1])

        for j in range(b-1):
            make_link(G,a[j],a[j+1])
    x = central(n)
    print x[0],x[1]

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def BFS_iterative(G, node):
    color = {}
    depth = {}
    parent = {}
    for v in G:
        #print v, G[v]
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    parent[node] = None
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if neighbor != 0:
                if color[neighbor] == 'white':
                    color[neighbor] = 'gray'
                    depth[neighbor] = depth[u] + 1
                    parent[neighbor] = u
                    nodelist.append(neighbor)
                    #print 'Pila:', nodelist
                    total_marked += 1
        color[u] = 'black'
    return depth

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    (G[node1])[node2] = 1

    return G
def m_k(G, node1):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    return G

def central(n):
    min = n*(n+1)/2
    id = 0
    for node in G:

            #print node,G[node][0]
            count = 0
            aux = BFS_iterative(G,node)
            for yolo in aux:
                count += aux[yolo]
            if(count < min):
                min = count
                id = node
    return id,min;


for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}

    for i in range(m):
        a = map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        m_k(G,a[b-1])

        for j in range(b-1):
            make_link(G,a[j],a[j+1])
    x = central(n)
    print x[0],x[1]

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def BFS_iterative(G, node):
    color = {}
    depth = {}
    parent = {}
    for v in G:
        #print v, G[v]
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    parent[node] = None
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if neighbor != 0:
                if color[neighbor] == 'white':
                    color[neighbor] = 'gray'
                    depth[neighbor] = depth[u] + 1
                    parent[neighbor] = u
                    nodelist.append(neighbor)
                    #print 'Pila:', nodelist
                    total_marked += 1
        color[u] = 'black'
    return depth

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    (G[node1])[node2] = 1

    return G
def m_k(G, node1):
    if node1 not in G:
        G[node1] = {}
        (G[node1])[0] = 1
    else:
        (G[node1])[0] += 1
    return G

def central(n):
    min = n*(n+1)/2
    id = 0
    for node in G:

            #print node,G[node][0]
            count = 0
            aux = BFS_iterative(G,node)
            for yolo in aux:
                count += aux[yolo]
            if(count < min):
                min = count
                id = node
    return id,min;


for test in range(int(scan.readline().strip())):
    print "Caso",(str(test+1)+":")
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}

    for i in range(m):
        a = map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        m_k(G,a[b-1])

        for j in range(b-1):
            make_link(G,a[j],a[j+1])
    x = central(n)
    print x[0],x[1]

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin
import Queue as queue

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin



def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    if node2 not in G:
        G[node2] = {}
        (G[node2])[0] = 1
    else:
        try:
            if (G[node1])[node2] == 1:
                return G
        except:
            (G[node2])[0] += 1
    (G[node1])[node2] = 1
    return G

for test in range(int(scan.readline().strip())):
    print "Caso",str(test+1)+":"
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    necesarios = queue.PriorityQueue(n)
    for i in range(m):
        a= map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        for j in range(b-1):
            make_link(G,a[j],a[j+1])

    for neighbor in G:
        try:
            if G[neighbor][0] == 0:
                G[neighbor][0] = -1
                necesarios.put(neighbor)
        except:
            necesarios.put(neighbor)
            #print neighbor, "entra"

    lista = []
    while not necesarios.empty():
        node = necesarios.get()
        #print "sale",node,
        lista.append(node)
        for neighbor in G[node]:
            if(neighbor != 0):
                G[neighbor][0] -= 1
                if G[neighbor][0] == 0:
                    G[neighbor][0] = -1
                    necesarios.put(neighbor)
                    #print "entra", neighbor


    if len(lista) == n:
        print "NO"
    else:
        print "SI"
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin



def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    if node2 not in G:
        G[node2] = {}
        (G[node2])[0] = 1
    else:
        try:
            if (G[node1])[node2] == 1:
                return G
        except:
            (G[node2])[0] += 1
    (G[node1])[node2] = 1
    return G

for test in range(int(scan.readline().strip())):
    print "Caso",str(test+1)+":"
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    necesarios = []
    for i in range(m):
        a= map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        for j in range(b-1):
            make_link(G,a[j],a[j+1])

    for neighbor in G:
        try:
            if G[neighbor][0] == 0:
                G[neighbor][0] = -1
                necesarios.append(neighbor)
        except:
            necesarios.append(neighbor)
            #print neighbor, "entra"

    lista = []
    while not len(necesarios)==0:
        node = necesarios.pop()
        #print "sale",node,
        lista.append(node)
        for neighbor in G[node]:
            if(neighbor != 0):
                G[neighbor][0] -= 1
                if G[neighbor][0] == 0:
                    G[neighbor][0] = -1
                    necesarios.append(neighbor)
                    #print "entra", neighbor


    if len(lista) == n:
        print "NO"
    else:
        print "SI"
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2):
    try:
        if (G[node1])[node2] == 1:
            return G
    except:
        if node1 not in G:
            G[node1] = {}
        if node2 not in G:
            G[node2] = {}
            (G[node2])[0] = 1
        else:
                (G[node2])[0] += 1
        (G[node1])[node2] = 1
        return G

for test in range(int(scan.readline().strip())):
    print "Caso",str(test+1)+":"
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    necesarios = []
    for i in range(m):
        a= map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        for j in range(b-1):
            make_link(G,a[j],a[j+1])
            #print a[j],a[j+1]

    for neighbor in G:
        try:
            if G[neighbor][0] == 0:
                G[neighbor][0] = -1
                necesarios.append(neighbor)
                #print neighbor, "entra"
        except:
            necesarios.append(neighbor)
            #print neighbor, "entra"

    lista = []
    while len(necesarios)!=0:
        node = necesarios.pop()
        #print "sale",node,
        lista.append(node)
        for neighbor in G[node]:
            if(neighbor != 0):
                G[neighbor][0] -= 1
                if G[neighbor][0] == 0:
                    G[neighbor][0] = -1
                    necesarios.append(neighbor)
                    #print "entra", neighbor

    if len(lista) == n:
        print "NO"
    else:
        print len(lista), n,
        print "SI"
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    if node2 not in G:
        G[node2] = {}
    (G[node1])[node2] = 1
    return G

def DFS_iterative(G, node):
    color = {}
    parent = {}
    for v in G:
        color[v] = 'white'
    color[node] = 'gray'
    parent[node] = None
    inicio = node
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop()
        #print 'Sale:', u
        for neighbor in G[u]:
            if color[neighbor] == 'white':
                color[neighbor] = 'gray'
#                print color
                parent[neighbor] = u
                #display_parent(parent)
                nodelist.append(neighbor)
                #print 'Pila:', nodelist
                total_marked += 1
            else:
                if neighbor == inicio:
                    return True
    return False

for test in range(int(scan.readline().strip())):
    print "Caso",str(test+1)+":"
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    padres = {}
    necesarios = []
    for i in range(m):
        a= map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        for j in range(b-1):
            make_link(G,a[j],a[j+1])
            #print a[j],a[j+1]

    ciclo = False
    for neighbor in G:
        if DFS_iterative(G,neighbor) == True:
            ciclo = True
            break
    if ciclo:
        print "SI"
    else:
        print "No"



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    if node2 not in G:
        G[node2] = {}
    (G[node1])[node2] = 1
    return G

def DFS_iterative(G, node):
    color = {}
    parent = {}
    for v in G:
        color[v] = 'white'
    color[node] = 'gray'
    parent[node] = None
    inicio = node
    #por_aqui_ya_pase = {}
    #make_link(por_aqui_ya_pase,node,0)
    nodelist = [node]
    total_marked = 1
    while nodelist <> []:
        u = nodelist.pop()
        #print 'Sale:', u
        for neighbor in G[u]:
            if color[neighbor] == 'white':
                color[neighbor] = 'gray'
#                print color
                parent[neighbor] = u
                #display_parent(parent)
                nodelist.append(neighbor)
                #print 'Pila:', nodelist
                total_marked += 1
                #make_link(por_aqui_ya_pase,neighbor,0)
                #print node, neighbor
            else:
                if inicio == neighbor:
                #if por_aqui_ya_pase[neighbor][0] == 1:
                    return True
    return False

def tiene_padres(p,node1, node2):
    if node1 not in p:
        p[node1] = {}
        p[node1][0] = 1
    if node2 not in p:
        p[node2] = {}
        p[node2][0] = 1
    else:
        p[node2][0] += 1
    (p[node2])[node1] = 1

for test in range(int(scan.readline().strip())):
    print "Caso",str(test+1)+":"
    n,m = map(int, scan.readline().strip().split(" "))
    G = {}
    padres = {}
    necesarios = []
    for i in range(m):
        a= map(int, scan.readline().strip().split(" "))
        b=a.pop(0)
        for j in range(b-1):
            make_link(G,a[j],a[j+1])
            tiene_padres(padres,a[j],a[j+1])
            #print a[j],a[j+1]

    ciclo = False
    for neighbor in padres:
        if padres[neighbor][0] > 1:
            #print neighbor,padres[neighbor]
            if DFS_iterative(G,neighbor) == True:
                ciclo = True
                break
    if ciclo:
        print "SI"
    else:
        print "No"



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def DFS_iterative(G, node):
    color = {}
    inicio = node
    nodelist = [node]
    while nodelist <> []:
        u = nodelist.pop()
        for neighbor in G[u]:
            if inicio == neighbor:
                return True
            if neighbor != 0:
                if neighbor not in color:
                    #print neighbor
                    color[neighbor] = 'gray'
                    nodelist.append(neighbor)

    return False

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
        G[node1][0] = 1
    if node2 not in G:
        G[node2] = {}
        G[node2][0] = 1
    else:
        G[node2][0] += 1
    (G[node1])[node2] = 1
    return G

for test in range(int(scan.readline().strip())):
    print "Caso",str(test+1)+":"
    n,m = map(int, scan.readline().strip().split())
    G = {}
    necesarios = []
    for i in range(m):
        a= map(int, scan.readline().strip().split())
        b=a.pop(0)
        for j in range(b-1):
            make_link(G,a[j],a[j+1])
            #print a[j],a[j+1]

    ciclo = False
    for neighbor in G:
        if neighbor != 0 and G[neighbor][0] > 1:
            #print neighbor,G[neighbor]
            if DFS_iterative(G,neighbor) == True:
                ciclo = True
                break
    if ciclo:
        print "SI"
    else:
        print "NO"

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def BFS_iterative(G, node):
    color = {}
    depth = {}
    for v in G:
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    nodelist = [node]
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if color[neighbor] == 'white':
                color[neighbor] = 'gray'
                depth[neighbor] = depth[u] + 1
                nodelist.append(neighbor)
                #print 'Pila:', nodelist
        color[u] = 'black'
    return depth

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    return G
def importante(p,node2):
    if node2 not in p:
        p[node2] = {}
        (p[node2])[0] = 1
    else:
        (p[node2])[0] += 1
    return p

def central(n):
    min = n*(n+1)/2
    id = 0
    for node in padres:
        if padres[node][0]>1:
            #print node, padres[node]
            count = 0
            aux = BFS_iterative(G,node)
            for yolo in aux:
                if padres[yolo][0]>1:
                    #print yolo
                    count += aux[yolo]
            if(count < min):
                    min = count
                    id = node
    return id,min;

for test in range(int(scan.readline().strip())):
    print "Caso",str(test+1)+":"
    n,m = map(int, scan.readline().strip().split())
    G = {}
    padres = {}
    necesarios = []
    for i in range(m):
        a= map(int, scan.readline().strip().split())
        b=a.pop(0)
        importante(padres,a[0])
        for j in range(b-1):
            make_link(G,a[j],a[j+1])
            importante(padres,a[j+1])

    x = central(n)
    print x[0], x[1]

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def BFS_iterative(G, node):
    color = {}
    depth = {}
    for v in G:
        color[v] = 'white'
        depth[v] = float('Inf')
    color[node] = 'gray'
    depth[node] = 0
    nodelist = [node]
    while nodelist <> []:
        u = nodelist.pop(0)
        #print 'Sale:', u
        for neighbor in G[u]:
            if color[neighbor] == 'white':
                color[neighbor] = 'gray'
                depth[neighbor] = depth[u] + 1
                nodelist.append(neighbor)
                #print 'Pila:', nodelist
        color[u] = 'black'
    return depth

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    return G
def importante(p,node2):
    if node2 not in p:
        p[node2] = {}
        (p[node2])[0] = 1
    else:
        (p[node2])[0] += 1
    return p

def central(n):
    min = n*(n+1)/2
    id = 0
    for node in padres:
        if padres[node][0]>1:
            #print node, padres[node]
            count = 0
            aux = BFS_iterative(G,node)
            for yolo in aux:
                if padres[yolo][0]>1:
                    #print yolo
                    count += aux[yolo]
            if(count < min):
                    min = count
                    id = node
    return id,min;

for test in range(int(scan.readline().strip())):
    print "Caso",str(test+1)+":"
    n,m = map(int, scan.readline().strip().split())
    G = {}
    padres = {}
    necesarios = []
    for i in range(m):
        a= map(int, scan.readline().strip().split())
        b=a.pop(0)
        importante(padres,a[0])
        for j in range(b-1):
            make_link(G,a[j],a[j+1])
            importante(padres,a[j+1])

    x = central(n)
    print x[0], x[1]

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


class MaxHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0

    def percUp(self,i):
        while i // 2 > 0:
          if self.heapList[i] > self.heapList[i // 2]:
             tmp = self.heapList[i // 2]
             self.heapList[i // 2] = self.heapList[i]
             self.heapList[i] = tmp
          i = i // 2


    def insert(self,k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self,i):
        while (i * 2) <= self.currentSize:
            mc = self.maxChild(i) ####
            if self.heapList[i] < self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def maxChild(self,i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i*2] > self.heapList[i*2+1]:
                return i * 2
            else:
                return i * 2 + 1

    def delMax(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self,alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            self.percDown(i)
            i = i - 1

for test in range(int(scan.readline().strip())):
    n = map(str, scan.readline().strip().split(" "))
    lista = MaxHeap()
    for i in n:
        if i != '*':
            lista.insert(int(i))
        else:
            try:
                print lista.delMax(),
            except:
                print "-1",
    print

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

class MinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0
    def size(self):
        return len(self.heapList)-1

    def percUp(self,i):
        while i // 2 > 0:
          if self.heapList[i] < self.heapList[i // 2]:
             tmp = self.heapList[i // 2]
             self.heapList[i // 2] = self.heapList[i]
             self.heapList[i] = tmp
          i = i // 2


    def insert(self,k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self,i):
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def minChild(self,i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i*2] < self.heapList[i*2+1]:
                return i * 2
            else:
                return i * 2 + 1

    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self,alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            self.percDown(i)
            i = i - 1

def costoMinimo(lista):
    if lista.size() == 1:
        return 0;

    suma = lista.delMin() + lista.delMin()
    lista.insert(suma)
    return suma + costoMinimo(lista)


for test in range(int(scan.readline().strip())):
    n = map(str, scan.readline().strip().split(" "))
    lista = MinHeap()
    for i in n:
        lista.insert(int(i))

    print costoMinimo(lista)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit

setrecursionlimit( 10000 )


try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

class MinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0
    def size(self):
        return len(self.heapList)-1

    def percUp(self,i):
        while i // 2 > 0:
          if self.heapList[i] < self.heapList[i // 2]:
             tmp = self.heapList[i // 2]
             self.heapList[i // 2] = self.heapList[i]
             self.heapList[i] = tmp
          i = i // 2


    def insert(self,k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self,i):
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def minChild(self,i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i*2] < self.heapList[i*2+1]:
                return i * 2
            else:
                return i * 2 + 1

    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self,alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            self.percDown(i)
            i = i - 1

def costoMinimo(lista):
    if lista.size() == 1:
        return 0;

    suma = lista.delMin() + lista.delMin()
    lista.insert(suma)
    return suma + costoMinimo(lista)


for test in range(int(scan.readline().strip())):
    n = map(str, scan.readline().strip().split(" "))
    lista = MinHeap()
    for i in n:
        lista.insert(int(i))

    print costoMinimo(lista)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit

setrecursionlimit( 1000000 )


try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

class MinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0
    def size(self):
        return len(self.heapList)-1

    def percUp(self,i):
        while i // 2 > 0:
          if self.heapList[i] < self.heapList[i // 2]:
             tmp = self.heapList[i // 2]
             self.heapList[i // 2] = self.heapList[i]
             self.heapList[i] = tmp
          i = i // 2


    def insert(self,k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self,i):
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def minChild(self,i):
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i*2] < self.heapList[i*2+1]:
                return i * 2
            else:
                return i * 2 + 1

    def delMin(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self,alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            self.percDown(i)
            i = i - 1

def costoMinimo(lista):
    if lista.size() == 1:
        return 0;

    suma = lista.delMin() + lista.delMin()
    lista.insert(suma)
    return suma + costoMinimo(lista)


for test in range(int(scan.readline().strip())):
    n = map(str, scan.readline().strip().split(" "))
    lista = MinHeap()
    for i in n:
        lista.insert(int(i))

    print costoMinimo(lista)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
import heapq

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

for test in range(int(scan.readline().strip())):
    n = map(str, scan.readline().strip().split(" "))
    lista = []

    for i in n:
        if i != '*':
            aaa = int(i)
            heapq.heappush(lista,-aaa )

        else:
            try:
                print -(heapq.heappop(lista)),
            except:
                print "-1",
    print

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit
import heapq
setrecursionlimit( 1000000 )


try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def costoMinimo(lista):
    if len(lista) == 1:
        return 0;

    suma = heapq.heappop(lista) + heapq.heappop(lista)
    heapq.heappush(lista,suma)
    return suma + costoMinimo(lista)


for test in range(int(scan.readline().strip())):
    n = map(int, scan.readline().strip().split(" "))
    lista = []
    for i in n:
        heapq.heappush(lista,i )

    print costoMinimo(lista)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit
setrecursionlimit(10000)

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def fibo(n,lista):
    memo = {}
    def fib(n):
        if n<len(lista):
            return lista[n]

        for i in range(len(lista),0,-1):
            if(n-i) not in memo:
                memo[n-i] = fib(n-i)

        something = 0
        for i in range(1,len(lista)+1):
            something += memo[n-i]
        return something
    return fib(n)

for test in range(int(scan.readline().strip())):
    lista = map(int, scan.readline().strip().split(" "))
    i = 0
    while fibo(i,lista) < 10**100:
        i+=1
    print i

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit
setrecursionlimit(10000)

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def fibo(n,lista):
    if n<len(lista):
        return lista[n]

    for i in range(len(lista)-1, n):
        lista.append(sum(lista))
        lista.pop(0)
    return lista.pop()

def copia(lista):
    lista2 = []
    for i in lista:
        lista2.append(i)
    return lista2

for test in range(int(scan.readline().strip())):
    lista = map(int, scan.readline().strip().split(" "))
    i = 0
    aux = copia(lista)
    while fibo(i,aux) < 10**100:
        i+=1
        aux = copia(lista)
    print i
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit
setrecursionlimit(10000)

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

for test in range(int(scan.readline().strip())):
    lista = map(int, scan.readline().strip().split(" "))
    i = 0
    lista.append(sum(lista))
    while lista.pop(0) < 10**100:
        lista.append(sum(lista))
        i+=1
    print i
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit

setrecursionlimit(1000000000)

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

memo = {}
memo[(0,0)]= 1

def botella(l,s):
    if(l,s) in memo:
        return memo[l,s]

    suma = 1

    if s>0:
        suma += botella(l,s-1)%9999959999;
    if l>0:
        suma += botella(l-1,s+1)%9999959999;
    memo[(l,s)] = suma
    return suma

for test in range(int(scan.readline().strip())):
    l,s = map(int, scan.readline().strip().split(" "))
    print botella(l,s)%9999959999
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit

setrecursionlimit( 30000 )


try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def lala(billete,monedas):
    min = [10000]
    cont = 1
    def cuenta (cont, billete,monedas):
        for i in monedas:
            if billete-i==0:
                if(min[0]) > cont:
                    min[0] = cont
            elif billete-i>0:
                cuenta(cont+1,billete-i,monedas)
    cuenta(cont, billete,monedas)
    if min[0] == 10000:
        return -1
    return min[0]


for test in range(int(scan.readline().strip())):
    n,m = map(int,scan.readline().strip().split())
    monedas = map(int,scan.readline().strip().split())

    print lala(n,monedas)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit

setrecursionlimit( 30000 )


try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def lala(billete,monedas):
    memo = {}
    min = [10000]
    cont = 1
    def cuenta (cont, billete,monedas):
        if billete not in memo:
            for i in monedas:
                if billete-i==0:
                    if(min[0]) > cont:
                        min[0] = cont
                        memo[billete] = cont
                elif billete-i>0:
                    cuenta(cont+1,billete-i,monedas)
    cuenta(cont, billete,monedas)
    if min[0] == 10000:
        return -1
    return min[0]


for test in range(int(scan.readline().strip())):
    n,m = map(int,scan.readline().strip().split())
    monedas = map(int,scan.readline().strip().split())

    print lala(n,monedas)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from sys import setrecursionlimit
import heapq
setrecursionlimit( 1000000 )

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin


def countingsort( aList, k ):
    counter = [0] * ( k + 1 )
    for i in aList:
        counter[i] += 1

    ndx = 0;

    for i in range( len( counter )-1,-1,-1 ):
        while 0 < counter[i]:
            aList[ndx] = i
            ndx += 1
            counter[i] -= 1

for test in range(int(scan.readline().strip())):
    n = (int(scan.readline().strip()))
    m = map(int, scan.readline().strip().split(" "))
    k = max(m)


    countingsort(m,k)
    a = 0

    for i in m:
        if a != i:
            print i,
            a=i
    print
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin


try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def countingsort( aList, letras ):
    counter = [0] * ( len(letras) + 1 )
    for i in aList:
        counter[letras[i]] += 1

    ndx = 0;
    array = [0]* ( len(aList))
    for i in range( len( counter )):
        while 0 < counter[i]:
            array[ndx] = i
            ndx += 1
            counter[i] -= 1
    return array

for test in range(int(scan.readline().strip())):
    n = map(str, scan.readline().strip().split(" "))
    m = scan.readline().strip()

    letras = {}
    for i in range(len(n)):
        letras[n[i]] = i

    algo =  countingsort(m,letras)
    new = ""
    for i in algo:
        new += n[i]

    print new

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from heapq import heappush, heappop

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def updateheap(heap,d,v):
    for i in range(len(heap)):
        if heap[i][1] == v:
           heap[i][0] = d
           fix_minheap(heap,i) # heap=heapify(heap) ineficient
           break

def fix_minheap(heap, i):
    if i == 0: return
    p = int(i/2) #parent
    if p >= 0 and heap[p][0] > heap[i][0]:
        heap[i], heap[p] = heap[p], heap[i]
        fix_minheap(heap,p)

def Dijkstra(G,start):
    D = {} # dictionary of final distances
    for v in G:
        D[v] = float('inf')
    D[start] = 0

    P = {} # dictionary of predecessors

    Q=[] #  priority queue est.dist. of non-final vert.
    for v in G:
       item = []
       item.append(D[v])
       item.append(v)
       heappush(Q,item)


    #S = []
    while Q:
        u = heappop(Q)[1]
        #S.append(u)
        for v in G[u]:
            newDuv = D[u] + G[u][v]
            if newDuv < D[v]:
                P[v] = u
                D[v] = newDuv
                updateheap(Q,D[v],v)
    return D

def shortestPath(G,start,end):
    """
    Find a single shortest path from the given start vertex to the given end vertex.
    The input has the same conventions as Dijkstra().
    The output is a list of the vertices in order along the shortest path.
     """

    D,P = Dijkstra(G,start)
    Path = []
    while 1:
        Path.append(end)
        if end == start: break
        end = P[end]
    Path.reverse()
    return Path

def make_link(G, node1, node2, w):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = w
    return G

for test in range(int(scan.readline().strip())):
    print "Case #" + str(test+1) + ":"

    celdas, inicio, salida = map(int, scan.readline().strip().split(" "))
    n = int(scan.readline().strip())
    G = {}
    for i in range(n):
        u,v,w = map(int, scan.readline().strip().split(" "))
        make_link(G,u,v,w)

    try:
        print int((Dijkstra(G,inicio))[salida])
    except:
        print -1

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from heapq import heappush, heappop

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2, w):
    if node1 not in G:
        G[node1] = {}
    if node2 not in G:
        G[node2] = {}
    (G[node1])[node2] = w
    return G

def shortest_dist_node(dist):
    best_node = 'undefined'
    best_value = 100000
    for v in dist:
        if dist[v] < best_value:
            (best_node, best_value) = (v, dist[v])
    return best_node

def dijkstra(G,v):
    dist_so_far = {}
    dist_so_far[v] = 0
    final_dist = {}
    while len(final_dist) < len(G):
        w = shortest_dist_node(dist_so_far)
        # lock it down!
        final_dist[w] = dist_so_far[w]
        del dist_so_far[w]
        for x in G[w]:
            if x not in final_dist:
                if x not in dist_so_far:
                    dist_so_far[x] = final_dist[w] + G[w][x]
                elif final_dist[w] + G[w][x] < dist_so_far[x]:
                    dist_so_far[x] = final_dist[w] + G[w][x]
    return final_dist


for test in range(int(scan.readline().strip())):
    print "Case #" + str(test+1) + ":"

    celdas, inicio, salida = map(int, scan.readline().strip().split(" "))
    n = int(scan.readline().strip())
    G = {}
    for i in range(n):
        u,v,w = map(int, scan.readline().strip().split(" "))
        make_link(G,u,v,w)

    #print dijkstra(G,inicio)

    try:
        print int((dijkstra(G,inicio))[salida])
    except:
        print -1

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin
from heapq import heappop, heappush

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

INF = 99999999
def dijkstra(G, ini, fin,tam):
    d = []
    for i in range(tam):
        d.append(INF)
    visitados = {}
    d[ini] = 0
    pq = [[d[ini], ini]]

    while pq:
        u = heappop(pq)[1]
        visitados[u] = True
        for node in G[u]:
            cvw = d[u] + G[u][node]
            if node not in visitados and cvw < d[node]:
                d[node] = cvw
                heappush(pq, [d[node], node])
    if d[fin]<INF:
        return d[fin]
    else:
        return -1

def make_link(G, node1, node2, w):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = w
    if node2 not in G:
        G[node2] = {}
    return G

for test in range(int(scan.readline().strip())):
    celdas,inicio,salida = map(int, scan.readline().strip().split(" "))
    G = {}
    n = int(scan.readline().strip())
    for i in range(n):
        u,v,w = map(int, scan.readline().strip().split(" "))
        make_link(G,u,v,w)

    if inicio not in G or salida not in G:
        print -1
    else:
        print dijkstra(G,inicio,salida,n)


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin,setrecursionlimit
setrecursionlimit( 30000 )

INF = 999999999

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def floydWarshall(graph):
    nodes = graph.keys()
    distance = {}
    for n in nodes:
        distance[n] = {}
        for k in nodes:
            distance[n][k] = graph[n][k]
    for k in nodes:
        for i in nodes:
            for j in nodes:
                if distance[i][k] + distance[k][j] < distance[i][j]:
                    distance[i][j] = distance[i][k]+distance[k][j]
    #printSolution(distance)
    return distance

def make_link(G, node1, node2, w):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = w
    if node2 not in G:
        G[node2] = {}
    return G

def init_G(n):
    G = {}
    for i in range(n):
        G[i] = {}
        for j in range(n):
            G[i][j] = INF
    return G

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = init_G(n)
    for i in range(m):
        u,v,w = map(float, scan.readline().strip().split(" "))
        make_link(G,u,v,w)

    sum=0
    num=0
    list = []
    d = floydWarshall(G)
    for i in range(len(d)):
        for j in range(len(d)):
            if i==j:
                num+=1
                list.append(0)
            elif d[i][j]!=INF:
                num+=1
                sum+=d[i][j]
                list.append(d[i][j])
    list.sort()
    if len(list) % 2 ==1:
        print round(sum/num,2),int(list[len(list)/2])
    else:
        print round(sum/num,2),(list[len(list)/2] + list[len(list)/2-1])/2



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin,setrecursionlimit
setrecursionlimit( 30000 )

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def make_link(G, node1, node2):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = 1
    if node2 not in G:
        G[node2] = {}
    (G[node2])[node1] = 1
    return G

def clique(x):
    a=len(x)
    for i in range(a-1):
        b = x.pop(0)
        for j in x:
            try:
                if G[b][j]!=1:
                    return "NO"
            except:
                return "NO"
    return "SI"

for test in range(int(scan.readline().strip())):
    G = {}
    n,m = map(int, scan.readline().strip().split(" "))
    for i in range(m):
        a,b = map(int, scan.readline().strip().split(" "))
        make_link(G,a,b)
    x = map(int, scan.readline().strip().split(" "))

    print clique(x)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

from sys import stdin,setrecursionlimit
setrecursionlimit( 30000 )

INF = 999999999

try:
    scan = open("casos.txt", "r")
except:
    scan = stdin

def floydWarshall(graph):
    nodes = graph.keys()
    distance = {}
    for n in nodes:
        distance[n] = {}
        for k in nodes:
            distance[n][k] = graph[n][k]
    for k in nodes:
        for i in nodes:
            for j in nodes:
                if distance[i][k] + distance[k][j] < distance[i][j]:
                    distance[i][j] = distance[i][k]+distance[k][j]
    #printSolution(distance)
    return distance

def make_link(G, node1, node2, w):
    if node1 not in G:
        G[node1] = {}
    (G[node1])[node2] = w
    if node2 not in G:
        G[node2] = {}
    return G

def init_G(n):
    G = {}
    for i in range(n):
        G[i] = {}
        for j in range(n):
            G[i][j] = INF
    return G

for test in range(int(scan.readline().strip())):
    n,m = map(int, scan.readline().strip().split(" "))
    G = init_G(n)
    for i in range(m):
        u,v,w = map(float, scan.readline().strip().split(" "))
        make_link(G,u,v,w)

    sum=0
    num=0
    list = []
    d = floydWarshall(G)
    for i in range(len(d)):
        for j in range(len(d)):
            if i==j:
                num+=1
                list.append(0)
            elif d[i][j]!=INF:
                num+=1
                sum+=d[i][j]
                list.append(d[i][j])
    list.sort()
    if len(list) % 2 ==1:
        print round(sum/num,2),int(list[len(list)/2])
    else:
        print round(sum/num,2),int(list[len(list)/2] + list[len(list)/2-1])/2



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
