
import java.math.BigInteger;
import java.util.*;

public class MainA {
    
    
    public static void main(String[] args) {
                
        Random rnd = new Random();
        Scanner sc = new Scanner(System.in);
        int num;  
        num = sc.nextInt();
        
        while (num > 10000 || num < 1){
            System.out.println("Numero no valido");
        }
        
        long[] array = new long[num];
        for (int i = 0; i < array.length ; i++){

            array[i] = rnd.nextInt( 2000000000 ) + -1000000000 ;
            System.out.print(array[i]+"  ");
        
        }

        System.out.println("");
        int k = 0;
        long[] arrayAux = new long[100];
        for (int j = 0; j < array.length ; j++){
            for (int i = 0; i < array.length ; i++){
        
                if (j < i ){   
                long aux = array[j] * array[i];
                  
                arrayAux[k] = aux;
                System.out.print(arrayAux[k] +"  ");
                k++;
                }
            }
        }
        //System.out.println(arrayAux[0]*arrayAux[1]);
        System.out.println("");
        long mayor = -1000000000000000000L;
        for(int i = 0; i < arrayAux.length; i++){
            
            if ( arrayAux[i] > mayor){
            mayor = arrayAux[i];
            }
        }

        System.out.println(mayor);
        
        









    }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;

public class MainA {
    
    
    public static void main(String[] args) {
                
        Random rnd = new Random();
        Scanner sc = new Scanner(System.in);
        int num;  
        num = sc.nextInt();
        
        /*while (num > 10000 || num < 1){
            System.out.println("Numero no valido");
        }
        */
        long[] array = new long[num];
        for (int i = 0; i < array.length ; i++){

            array[i] = rnd.nextInt( 2000000000 ) + -1000000000 ;
            System.out.print(array[i]+"  ");
        
        }

        System.out.println("");
        int k = 0;
        long[] arrayAux = new long[100];
        for (int j = 0; j < array.length ; j++){
            for (int i = 0; i < array.length ; i++){
        
                if (j < i ){   
                long aux = array[j] * array[i];
                  
                arrayAux[k] = aux;
                System.out.print(arrayAux[k] +"  ");
                k++;
                }
            }
        }
        //System.out.println(arrayAux[0]*arrayAux[1]);
        System.out.println("");
        long mayor = -1000000000000000000L;
        for(int i = 0; i < arrayAux.length; i++){
            
            if ( arrayAux[i] > mayor){
            mayor = arrayAux[i];
            }
        }

        System.out.println(mayor);
        
        









    }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;

public class MainA {
    
    
    public static void main(String[] args) {
                
        Random rnd = new Random();
        Scanner sc = new Scanner(System.in);
        int num;  
        num = sc.nextInt();
        
        /*while (num > 10000 || num < 1){
            System.out.println("Numero no valido");
        }
        */
        long[] array = new long[num];
        for (int i = 0; i < array.length ; i++){

            array[i] = rnd.nextInt( 2000000000 ) + -1000000000 ;
//            System.out.print(array[i]+"  ");
        
        }

        System.out.println("");
        int k = 0;
        long[] arrayAux = new long[100];
        for (int j = 0; j < array.length ; j++){
            for (int i = 0; i < array.length ; i++){
        
                if (j < i ){   
                long aux = array[j] * array[i];
                  
                arrayAux[k] = aux;
               // System.out.print(arrayAux[k] +"  ");
                k++;
                }
            }
        }
        //System.out.println(arrayAux[0]*arrayAux[1]);
        System.out.println("");
        long mayor = -1000000000000000000L;
        for(int i = 0; i < arrayAux.length; i++){
            
            if ( arrayAux[i] > mayor){
            mayor = arrayAux[i];
            }
        }

        System.out.println(mayor);
        
        









    }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.*;

public class MainA {
    
    
    public static void main(String[] args) {
                
        Random rnd = new Random();
        Scanner sc = new Scanner(System.in);
        int num;  
        num = sc.nextInt();
        
        /*while (num > 10000 || num < 1){
            System.out.println("Numero no valido");
        }
        */
        
        long[] array = new long[num];
        for (int i = 0; i < array.length ; i++){
            long aux3;
            aux3 = sc.nextLong();
            array[i] = aux3  ;
            //System.out.print(array[i]+"  ");
        
        }

        System.out.println("");
        int k = 0;
        long[] arrayAux = new long[100];
        for (int j = 0; j < array.length ; j++){
            for (int i = 0; i < array.length ; i++){
        
                if (j < i ){   
                long aux = array[j] * array[i];
                  
                arrayAux[k] = aux;
                //System.out.print(arrayAux[k] +"  ");
                k++;
                }
            }
        }
        //System.out.println(arrayAux[0]*arrayAux[1]);
        System.out.println("");
        long mayor = -1000000000000000000L;
        for(int i = 0; i < arrayAux.length; i++){
            
            if ( arrayAux[i] > mayor){
            mayor = arrayAux[i];
            }
        }

        System.out.println(mayor);
        
        









    }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;

public class MainA {
    
    
    public static void main(String[] args) {
                
        Random rnd = new Random();
        Scanner sc = new Scanner(System.in);
        int num;  
        num = sc.nextInt();
        
        /*while (num > 10000 || num < 1){
            System.out.println("Numero no valido");
        }
        */
        
        long[] array = new long[num];
        for (int i = 0; i < array.length ; i++){
            
            array[i] = sc.nextLong();
        
        }

        for (int i = 0; i < array.length ; i++){
            
           //System.out.print(array[i]+"  ");
        
        }
        
        System.out.println("");
        int k = 0;
        long[] arrayAux = new long[100];
        for (int j = 0; j < array.length ; j++){
            for (int i = 0; i < array.length ; i++){
        
                if (j < i ){   
                long aux = array[j] * array[i];
                  
                arrayAux[k] = aux;
                //System.out.print(arrayAux[k] +"  ");
                k++;
                }
            }
        }
        
        //System.out.println("");
        long mayor = -1000000000000000000L;
        for(int i = 0; i < arrayAux.length; i++){
            
            if ( arrayAux[i] > mayor){
            mayor = arrayAux[i];
            }
        }

        System.out.println(mayor);
        
        









    }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;

public class MainA {
    
    
    public static void main(String[] args) {
                
        Scanner sc = new Scanner(System.in);
        int num;  
        num = sc.nextInt();
        
        long[] array = new long[num];
        for (int i = 0; i < array.length ; i++){
            
            array[i] = sc.nextLong();
        
        }

        System.out.println("");
        int k = 0;
        long[] arrayAux = new long[100];
        for (int j = 0; j < array.length ; j++){
            for (int i = 0; i < array.length ; i++){
        
                if (j < i ){   
                long aux = array[j] * array[i];
                arrayAux[k] = aux;
                k++;
                }
            }
        }
        
        
        long mayor = -1000000000000000000L;
        for(int i = 0; i < arrayAux.length; i++){
            
            if ( arrayAux[i] > mayor){
            mayor = arrayAux[i];
            }
        }

        System.out.println(mayor);
        
        









    }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;

public class MainA {
    
    
    public static void main(String[] args) {
                
        Scanner sc = new Scanner(System.in);
        int num;  
        num = sc.nextInt();
        
        long[] array = new long[num];
        for (int i = 0; i < array.length ; i++){
            
            array[i] = sc.nextLong();
        
        }

        
        int k = 0;
        long[] arrayAux = new long[100];
        for (int j = 0; j < array.length ; j++){
            for (int i = 0; i < array.length ; i++){
        
                if (j < i ){   
                long aux = array[j] * array[i];
                arrayAux[k] = aux;
                k++;
                }
            }
        }
        
        
        long mayor = -1000000000000000000L;
        for(int i = 0; i < arrayAux.length; i++){
            
            if ( arrayAux[i] > mayor){
            mayor = arrayAux[i];
            }
        }

        System.out.println(mayor);
        
        
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;

public class MainA {
    
    
    public static void main(String[] args) {
                
        Scanner sc = new Scanner( System.in );
        int num;  
        num = sc.nextInt();
        while ( num < 2 || num > 100000){
            System.exit(0);
        }
        long[] array = new long[num];
        for (int i = 0; i < array.length ; i++){
            
            array[i] = sc.nextLong();
        
        }

        
        int k = 0;
        long[] arrayAux = new long[1000000];
        for (int j = 0; j < array.length ; j++){
            for (int i = 0; i < array.length ; i++){
        
                if (j < i ){   
                long aux = array[j] * array[i];
                arrayAux[k] = aux;
                k++;
                }
            }
        }
        
        
        long mayor = -1000000000000000000L;
        for(int i = 0; i < arrayAux.length; i++){
            
            if ( arrayAux[i] > mayor){
            mayor = arrayAux[i];
            }
        }

        System.out.println(mayor);
        
        









    }
}


        
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		int caso = 0;
		while (sc.hasNext()){
			
			
		
        int num;
        num = sc.nextInt();
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
                     
            }
        }
        
        
      /*  for ( int i = 0 ; i < num ; i++){
            for ( int j = 0 ; j < num ; j++){
            
                System.out.print(matrix[i][j]+"\t");
                     
            }
            System.out.println("");
        }
        
        */
    
        int[] arrayAuxRow = new int[3];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[3];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
		
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] > arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		int auxCaso = 1;
			System.out.println("Caso #" + auxCaso);
		System.out.println(caso);
		auxCaso++;
			}
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		int caso = 0;
		int auxCaso = 1;
		while (sc.hasNext()){
			
			
		
        int num;
        num = sc.nextInt();
			while (num < 1 && num > 100){
				System.exit(0);

			}
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
				while (matrix[col][row] < 1 && matrix[col][row] > 100){
					System.exit(0);
					
				}
                     
            }
        }
        
        
      /*  for ( int i = 0 ; i < num ; i++){
            for ( int j = 0 ; j < num ; j++){
            
                System.out.print(matrix[i][j]+"\t");
                     
            }
            System.out.println("");
        }
        
        */
    
        int[] arrayAuxRow = new int[3];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[3];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
		
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] > arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		
		System.out.println("Caso #" + auxCaso + ":");
		System.out.println(caso);
		auxCaso++;
	    }
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		int caso = 0;
		int auxCaso = 1;
		while (sc.hasNext()){
			
			
		
        int num;
        num = sc.nextInt();
			while (num < 1 || num > 100){
				System.exit(0);

			}
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
				while (matrix[col][row] < 1 || matrix[col][row] > 100){
					System.exit(0);
					
				}
                     
            }
        }
        
        
     
    
        int[] arrayAuxRow = new int[3];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[3];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
		
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] > arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		
		System.out.println("Caso #" + auxCaso + ":");
		System.out.println(caso);
		auxCaso++;
	    }
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		int caso = 0;
		int auxCaso = 1;
		while (sc.hasNext()){
			
			
		
        int num;
        num = sc.nextInt();
			while (num < 1 || num > 100){
				System.exit(0);

			}
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
				while (matrix[col][row] < 1 || matrix[col][row] > 100){
					System.exit(0);
					
				}
                     
            }
        }
        
        
     
    
        int[] arrayAuxRow = new int[100];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[100];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
		
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] > arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		
		System.out.println("Caso #" + auxCaso + ":");
		System.out.println(caso);
		auxCaso++;
	    }
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		int caso = 0;
		int auxCaso = 1;
		while (sc.hasNext()){
			
			
		
        int num;
        num = sc.nextInt();
			while (num < 1 || num > 100){
				System.exit(0);

			}
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
				while (matrix[col][row] < 1 || matrix[col][row] > 100){
					System.exit(0);
					
				}
                     
            }
        }
        
        
     
    
        int[] arrayAuxRow = new int[num];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[num];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
		
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] > arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		
		System.out.println("Caso #" + auxCaso + ":");
		System.out.println(caso);
		auxCaso++;
	    }
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		int caso = 0;
		int auxCaso = 1;
		while (sc.hasNext()){
			
			
		
        int num;
        num = sc.nextInt();
			while (num < 1 || num > 100){
				System.exit(0);

			}
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
				while (matrix[col][row] < 1 || matrix[col][row] > 100){
					System.exit(0);
					
				}
                     
            }
        }
        
        
     
    
        int[] arrayAuxRow = new int[num];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[num];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
		
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] < arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		
		System.out.println("Caso #" + auxCaso + ":");
		System.out.println(caso);
		auxCaso++;
	    }
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		
		int auxCaso = 1;
		while (sc.hasNext()){
			int caso = 0;
			
		
        int num;
        num = sc.nextInt();
			while (num < 1 || num > 100){
				System.exit(0);

			}
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
				while (matrix[col][row] < 1 || matrix[col][row] > 100){
					System.exit(0);
					
				}
                     
            }
        }
        
        
     
    
        int[] arrayAuxRow = new int[num];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[num];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
		
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] > arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		
		System.out.println("Caso #" + auxCaso + ":");
		System.out.println(caso);
		auxCaso++;
	    }
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		
		int auxCaso = 1;
		while (sc.hasNext()){
			
			
		
        int num;
        num = sc.nextInt();
			while (num < 1 || num > 100){
				System.exit(0);

			}
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
				while (matrix[col][row] < 1 || matrix[col][row] > 100){
					System.exit(0);
					
				}
                     
            }
        }
        
        
     
    
        int[] arrayAuxRow = new int[num];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[num];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
			int caso = 0;
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] > arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		
		System.out.println("Caso #" + auxCaso + ":");
		System.out.println(caso);
		auxCaso++;
	    }
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;


public class MainB {
 
    public static void main(String[] args) {
        
			
			
			
		
        
        Scanner sc = new Scanner( System.in );
		
		int auxCaso = 1;
		while (sc.hasNext()){
			
			
		
        int num;
        num = sc.nextInt();
		
        int[][] matrix = new int[num][num];
        
		
        for ( int col = 0 ; col < num ; col++){
            for ( int row = 0 ; row < num ; row++){
            
                matrix[col][row] = sc.nextInt();
				
                     
            }
        }
        
        
     
    
        int[] arrayAuxRow = new int[num];
        
        for ( int col = 0 ; col < num ; col++){
            int auxRow = 0 ;
               for ( int row = 0 ; row < num ; row++){
                
                   auxRow = auxRow + matrix[col][row];
        
                }         
                
            arrayAuxRow[col] = auxRow;       
                        
        }
        
        
        
        int[] arrayAuxCol = new int[num];
        
        for ( int row = 0 ; row < num ; row++){
            int auxCol = 0 ;
               for ( int col = 0 ; col < num ; col++){
                
                   auxCol = auxCol + matrix[col][row];
        
                }         
                
            arrayAuxCol[row] = auxCol;       
                        
        }
        
        
        
        
   
			int caso = 0;
        for ( int i = 0 ; i < num ; i++){
			for ( int j = 0 ; j < num ; j++){
            if (arrayAuxCol[i] < arrayAuxRow[j]){
				
				caso++;
				
				
			}
              
        }
		}
		
		
		System.out.println("Caso #" + auxCaso + ":");
		System.out.println(caso);
		auxCaso++;
	    }
        
		
        
    
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.Scanner;
class MainC {

    public static void main(String[] args) {
	Scanner sc = new Scanner(System.in);
	int num = sc.nextInt();

        for (int j = 0; j < num; j++) {
	
            int auxNum = sc.nextInt();
            int[][] uniforme = new int[auxNum][2];

            for (int i = 0; i < auxNum; i++) {
                for (int k = 0; k < 2; k++) {
		uniforme[i][k] = sc.nextInt();
	        }
	    }

	int caso = 0;
	for (int l = 0; l < auxNum; l++) {
	    for (int m = 0; m < auxNum; m++) {
		if (l != m){
		   if (uniforme[l][0] == uniforme[m][1]){
		   caso++;
                   }
                }
	    }
                

	}

	System.out.println("Case #" + (j + 1));
        System.out.println(caso);
	}

    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.Scanner;
class MainC {

    public static void main(String[] args) {
	Scanner sc = new Scanner(System.in);
	int num = sc.nextInt();

        for (int j = 0; j < num; j++) {
	
            int auxNum = sc.nextInt();
            int[][] uniforme = new int[auxNum][2];

            for (int i = 0; i < auxNum; i++) {
                for (int k = 0; k < 2; k++) {
		uniforme[i][k] = sc.nextInt();
	        }
	    }

       	    int caso = 0;
	    for (int l = 0; l < auxNum; l++) {
	        for (int m = 0; m < auxNum; m++) {
		   if (l != m)
		   if (uniforme[l][0] == uniforme[m][1])
		   caso++;
	        }
                

	    }

	    System.out.println("Case #" + (j + 1)+":");
            System.out.println(caso);
	}

    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;



public class MainF {

    public static void main(String[] args) {
        
    
        Scanner sc = new Scanner( System.in );
        
        //for( int i = 0; i < num; i++ ){
            
            int teNum ;
            teNum = sc.nextInt();
            int[] array = new int[5];
            
            for( int j = 0; j < array.length; j++ ){
            
                array[j] = sc.nextInt();
            }
            
            int caso = 0 ;
            for( int k = 0; k < array.length; k++ ){
            
                if ( teNum == array[k] ){
                    caso++;
                }
            }
            
            System.out.println(caso);
            
            
        //}
    
       
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;



public class MainD {
	
    
    public static void main(String[] args) throws FileNotFoundException  {
	Scanner sc;
	File doc = new File("Caso.txt");
		
	if(doc.exists())
		sc = new Scanner(doc);
	else
		sc = new Scanner(System.in);
		
		

	int num = Integer.parseInt( sc.nextLine() );
	if( 0 < num && num < 1000){
		for(int i=0;i<num;i++){
			
		    int aunNum = Integer.parseInt( sc.nextLine() );

                    boolean ready = false;
		    char chocolate[][] = new char [aunNum][aunNum];
		    for(int l=0; l<aunNum; l++){
        		    char[] b = sc.nextLine().toCharArray();
			    chocolate[l] = b;						  					  
		    }
		  
                    int cherry =0;
		    for(int m=0; m<aunNum; m++){
         	        for(int n=0;n<aunNum;n++){
			    if(chocolate[m][n] == ('#'))
			       cherry++;
							 
			}
		    }
		  
                    if(cherry%2!=0){
		       System.out.println("false");
		       continue;
		    }
		  
                    int auxCaso = 0;
		    for(int r=0;r<aunNum;r++){
		        for(int w=0;w<aunNum;w++){
                           if(chocolate[r][w] == '#'){
                             auxCaso++;
							     
			   }
			}
			
                        if( auxCaso == (cherry/2) ){
			 	  System.out.println("true");
			       	  ready = true;
			          break;
		        }  
					      
		    }
		
                    auxCaso = 0;
		    if( ready ){						  
		    continue;
		    }
					  
		    for( int o=0;o<aunNum;o++ ){
			for(int p=0;p<aunNum;p++){
			  if(chocolate[p][o]== '#'){
			  auxCaso++;
			  }
			}
					  	
			if( auxCaso == (cherry/2 )){
			   	  System.out.println("true");
			    	  ready = true;
			       	  break;
			} 
		    }
		  
                    if( ready){						  
		    continue;
		    }
		    System.out.println("false");

                    
		}
	}
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;



public class MainD {
	
    
    public static void main(String[] args) throws FileNotFoundException  {
	Scanner sc;
	File doc = new File("Caso.txt");
		
	if(doc.exists())
		sc = new Scanner(doc);
	else
		sc = new Scanner(System.in);
		
		

	int num = Integer.parseInt( sc.nextLine() );
	if( 0 < num && num < 1000){
		for(int i=0;i<num;i++){
			
		    int aunNum = Integer.parseInt( sc.nextLine() );

                    boolean ready = false;
		    char chocolate[][] = new char [aunNum][aunNum];
		    for(int l=0; l<aunNum; l++){
        		    char[] b = sc.nextLine().toCharArray();
			    chocolate[l] = b;						  					  
		    }
		  
                    int cherry =0;
		    for(int m=0; m<aunNum; m++){
         	        for(int n=0;n<aunNum;n++){
			    if(chocolate[m][n] == ('#')){
			       cherry++;
			
                            }   
			}
                            
		    }
		  
                    if(cherry%2!=0){
		       System.out.println("YES");
		       continue;
		    }
		  
                    
                    
                    
                    
                    int auxCaso = 0;
		    for(int r=0;r<aunNum;r++){
		        for(int w=0;w<aunNum;w++){
                           if(chocolate[r][w] == '#'){
                             auxCaso++;
							     
			   }
			}
			
                    if( auxCaso == (cherry/2) ){
		 	  System.out.println("YES");
		       	  ready = true;
		          break;
		        }  
					      
		    }
		
                    
                    
                    
                    
                    
                    
                    auxCaso = 0;
		    if( ready ){						  
		    continue;
		    }
			
                    
                    
                    
                    
		    for( int o=0;o<aunNum;o++ ){
			for(int p=0;p<aunNum;p++){
			  if(chocolate[p][o]== '#'){
			  auxCaso++;
			  }
			}
					  	
			if( auxCaso == (cherry/2 )){
			   	  System.out.println("YES");
			    	  ready = true;
			       	  break;
			} 
		    }
		  
                    
                    
                    
                    
                    
                    if( ready){						  
		    continue;
		    }
		    System.out.println("NO");

                    
		}
	}
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;



public class MainD {
	
    
    public static void main(String[] args) throws FileNotFoundException  {
	Scanner sc;
	File doc = new File("Caso.txt");
		
	if(doc.exists())
		sc = new Scanner(doc);
	else
		sc = new Scanner(System.in);
		
		

	int num = Integer.parseInt( sc.nextLine() );
	if( 0 < num && num < 1000){
		for(int i=0;i<num;i++){
			
		    int aunNum = Integer.parseInt( sc.nextLine() );

                    boolean ready = false;
		    char chocolate[][] = new char [aunNum][aunNum];
		    for(int l=0; l<aunNum; l++){
        		    char[] b = sc.nextLine().toCharArray();
			    chocolate[l] = b;						  					  
		    }
		  
                    int cherry =0;
		    for(int m=0; m<aunNum; m++){
         	        for(int n=0;n<aunNum;n++){
			    if(chocolate[m][n] == ('#')){
			       cherry++;
			
                            }   
			}
                            
		    }
		  
                    if(cherry%2!=0){
		       System.out.println("NO");
		       continue;
		    }
		  
                    
                    
                    
                    
                    int auxCaso = 0;
		    for(int r=0;r<aunNum;r++){
		        for(int w=0;w<aunNum;w++){
                           if(chocolate[r][w] == '#'){
                             auxCaso++;
							     
			   }
			}
			
                    if( auxCaso == (cherry/2) ){
		 	  System.out.println("YES");
		       	  ready = true;
		          break;
		        }  
					      
		    }
		
                    
                    
                    
                    
                    
                    
                    auxCaso = 0;
		    if( ready ){						  
		    continue;
		    }
			
                    
                    
                    
                    
		    for( int o=0;o<aunNum;o++ ){
			for(int p=0;p<aunNum;p++){
			  if(chocolate[p][o]== '#'){
			  auxCaso++;
			  }
			}
					  	
			if( auxCaso == (cherry/2 )){
			   	  System.out.println("YES");
			    	  ready = true;
			       	  break;
			} 
		    }
		  
                    
                    
                    
                    
                    
                    if( ready){						  
		    continue;
		    }
		    System.out.println("NO");

                    
		}
	}
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;



public class MainD {
	
    
    public static void main(String[] args) throws FileNotFoundException  {
	Scanner sc;
	File doc = new File("Caso.txt");
		
	if(doc.exists())
		sc = new Scanner(doc);
	else
		sc = new Scanner(System.in);
		
		

	int num = Integer.parseInt( sc.nextLine() );
	if( 0 < num && num < 1000){
		for(int i=0;i<num;i++){
			
		    int aunNum = Integer.parseInt( sc.nextLine() );

                    boolean ready = false;
		    char chocolate[][] = new char [aunNum][aunNum];
		    for(int l=0; l<aunNum; l++){
        		    char[] b = sc.nextLine().toCharArray();
			    chocolate[l] = b;						  					  
		    }
		  
                    int cherry =0;
		    for(int m=0; m<aunNum; m++){
         	        for(int n=0;n<aunNum;n++){
			    if(chocolate[m][n] == ('#')){
			       cherry++;
			
                            }   
			}
                            
		    }
		  
                    if(cherry%2!=0){
		       System.out.println("NO");
		       continue;
		    }
		  
                    
                    
                    
                    
                    int auxCaso = 0;
		    for(int r=0;r<aunNum;r++){
		        for(int w=0;w<aunNum;w++){
                           if(chocolate[r][w] == '#'){
                             auxCaso++;
							     
			   }
			}
			
                    if( auxCaso == (cherry/2) ){
		 	  System.out.println("YES");
		       	  ready = true;
		          break;
		        }  
					      
		    }
		
                    
                    
                    
                    
                    
                    
                    auxCaso = 0;
		    if( ready ){						  
		    continue;
		    }
			
                    
                    
                    
                    
		    for( int o=0;o<aunNum;o++ ){
			for(int p=0;p<aunNum;p++){
			  if(chocolate[p][o]== '#'){
			  auxCaso++;
			  }
			}
					  	
			if( auxCaso == (cherry/2 )){
			   	  System.out.println("YES");
			    	  ready = true;
			       	  break;
			} 
		    }
		  
                    
                    
                    
                    
                    
                    if( ready){						  
		    continue;
		    }
		    System.out.println("NO");

                    
		}
	}
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;



public class MainD {
	
    
    public static void main(String[] args) throws FileNotFoundException  {
	Scanner sc;
	File doc = new File("Caso.txt");
		
	if(doc.exists())
		sc = new Scanner(doc);
	else
		sc = new Scanner(System.in);
		
		

	int num = Integer.parseInt( sc.nextLine() );
	if( 0 < num && num < 1000){
		for(int i=0;i<num;i++){
			
		    int aunNum = Integer.parseInt( sc.nextLine() );

                    boolean ready = false;
		    char chocolate[][] = new char [aunNum][aunNum];
		    for(int l=0; l<aunNum; l++){
        		    char[] b = sc.nextLine().toCharArray();
			    chocolate[l] = b;						  					  
		    }
		  
                    int cherry =0;
		    for(int m=0; m<aunNum; m++){
         	        for(int n=0;n<aunNum;n++){
			    if(chocolate[m][n] == ('#')){
			       cherry++;
			
                            }   
			}
                            
		    }
		  
                    if(cherry%2!=0){
		       System.out.println("NO");
		       continue;
		    }
		  
                    
                    
                    
                    
                    int auxCaso = 0;
		    for(int r=0;r<aunNum;r++){
		        for(int w=0;w<aunNum;w++){
                           if(chocolate[r][w] == '#'){
                             auxCaso++;
							     
			   }
			}
			
                    if( auxCaso == (cherry/2) ){
		 	  System.out.println("YES");
		       	  ready = true;
		          break;
		        }  
					      
		    }
		
                    
                    
                    
                    
                    
                    
                    auxCaso = 0;
		    if( ready ){						  
		    continue;
		    }
			
                    
                    
                    
                    
		    for( int o=0;o<aunNum;o++ ){
			for(int p=0;p<aunNum;p++){
			  if(chocolate[p][o]== '#'){
			  auxCaso++;
			  }
			}
					  	
			if( auxCaso == (cherry/2 )){
			   	  System.out.println("YES");
			    	  ready = true;
			       	  break;
			} 
		    }
		  
                    
                    
                    
                    
                    
                    if( ready){						  
		    continue;
		    }
		    System.out.println("NO");

                    
		}
	}
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package DOMJudge2;

import java.util.*;


public class MainC {
    public static class ListaEnlazada<T>{
   
    //Atributos
    private Nodo<T> primero;

    /**
     * Constructor por defecto
     */
    public ListaEnlazada(){
        listaVacia();
    }

    /**
     * Vacia la lista
     */
    private void listaVacia(){
        primero = null;
    }

    /**
     * Indica si la lista esta vacia o no
     * @return True = esta vacia
     */
    public boolean estaVacia(){
        return primero == null;
    }

    /**
     * Inserta un objeto al principio de la lista
     * @param t Dato insertado
     */
    public void insertarPrimero(T t){
        Nodo<T> nuevo = new Nodo<>(t);

        if (!estaVacia()){
            //Sino esta vacia, el primero actual pasa a ser
            // el siguiente de nuestro nuevo nodo
            nuevo.setSiguiente(primero);
        }
        
        //el primero apunta al nodo nuevo
        primero=nuevo;
        
    }

    /**
     * Inserta al final de la lista un objeto
     * @param t Dato insertado
     */
    public void insertarUltimo(T t){

        Nodo<T> aux = new Nodo<>(t);
        Nodo<T> rec_aux;

        if (estaVacia()) {
            insertarPrimero(t);
        }else {
            rec_aux = primero;
            
            //Buscamos el ultimo nodo
            while(rec_aux.getSiguiente() != null){
                rec_aux=rec_aux.getSiguiente();
            } 
                
            //Actualizamos el siguiente del ultimo
            rec_aux.setSiguiente(aux);
        }
    }

    /**
     * Quita el primer elemento de la lista
     */
    public void quitarPrimero(){
        Nodo<T> aux;
        if (!estaVacia()){
            aux=primero;
            primero = primero.getSiguiente();
            aux=null; //Lo marcamos para el recolector de basura
        }
    }

    /**
     * Quita el ultimo elemento de la lista
     */
    public void quitarUltimo(){
        Nodo<T> aux=primero;
        if(aux.getSiguiente()==null)
           //Aqi entra, si la lista tiene un elemento
           listaVacia();
        if(!estaVacia()) {
            aux=primero;
            
            //Buscamos el penultimo, por eso hay dos getSiguiente()
            while(aux.getSiguiente().getSiguiente() != null){
                aux=aux.getSiguiente();
            }
            
            //Marcamos el siguiente del antepenultimo como nulo, eliminando el ultimo
            aux.setSiguiente(null);
        }

    }        

    /**
     * Devuelve el último elemento de la lista
     * @return Último elemento
     */
    public T devolverUltimo(){
        T elemen = null;
        Nodo<T> aux;
        if (!estaVacia()){
            aux = primero;
            
            //Recorremos
            while(aux.getSiguiente() != null){
                aux = aux.getSiguiente();
            }
            elemen = aux.getDato();
        }
        return elemen;
    }

    /**
     * Devuelve el primer elemento de la lista
     * @return Primer elemento, null si esta vacia
     */
    public T devolverPrimero(){
        T elemen = null;
        if (!estaVacia()){
            elemen = primero.getDato();
        }
        return  elemen;
    }

    /**
     * Devuelve el número de elementos de la lista
     * @return Número de elementos
     */
    public int cuantosElementos(){
        Nodo<T> aux;
        int numElementos=0;
        aux = primero;

        //Recorremos
        while(aux != null){
            numElementos++;
            aux = aux.getSiguiente();
        }
        return numElementos;

    }
    
    /**
     * Devuelve el dato del nodo en la posicion pos
     * @param pos
     * @return dato del nodo en la posicion indicada
     */
    public T devolverDato(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        T dato=null;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Cogemos el dato
                    dato=aux.getDato();
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return dato;
        
    }
    
    /**
     * Devuelve el nodo de la posicion indicada
     * @param pos
     * @return Nodo de la posicion indicada
     */
    public Nodo<T> devolverNodo(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Devuelvo aux, con esto salimos de la función
                    return aux; 
                }
                
                //Actualizo el siguiente
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return aux;
        
    }
    
    /**
     * Inserta un nuevo nodo en la posicion indicada con el su dato
     * @param pos
     * @param dato 
     */
    public void introducirDato(int pos, T dato){
        Nodo<T> aux=primero;
        Nodo<T> auxDato=null; //Debemos crear un nodo para insetar el dato
        Nodo<T> anterior=primero; //Debemos crear un nodo para insetar el dato
        
        int contador=0;
        
        if(pos<0 || pos>cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            
            if(pos==0){
                insertarPrimero(dato);
            }else if(pos==cuantosElementos()){
                insertarUltimo(dato);
            }else{
                //Recorremos
                while(aux!=null){
                    if (pos == contador){
                        //Creo el nodo
                        auxDato=new Nodo<>(dato, aux);
                        //El siguiente del anterior a aux es auxDato
                        anterior.setSiguiente(auxDato);
                    }
                    
                    //Actualizo anterior
                    anterior=aux;
                    
                    contador++;
                    aux=aux.getSiguiente(); //Actualizo siguiente
                }
            }
        }
        
    }
    
    /**
     * Modifica el dato indicado en el nodo de la posicion indicada
     * @param pos
     * @param dato 
     */
    public void modificarDato(int pos, T dato){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //Recorremos
            while(aux!=null){
                if (pos == cont){
                    //Modificamos el dato directamente
                    aux.setDato(dato); 
                }
                cont++;
                aux=aux.getSiguiente(); //Actualizamos
            }
        }
        
    }

    /**
     * Borra un elemento de la lista
     * @param pos Posición de la lista que queremos borrar
     */
    public void borraPosicion(int pos){

        Nodo<T> aux=primero;
        Nodo<T> anterior=null;
        int contador=0;

        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == contador){
                    if (anterior==null){
                        primero = primero.getSiguiente();
                    }else {
                        //Actualizamos el anterior
                        anterior.setSiguiente(aux.getSiguiente());
                    }
                    aux=null;
                }else{
                    anterior=aux;
                    aux=aux.getSiguiente();
                    contador++;
                }
            }
        }
    }

    /**
     * Devuelve el primer el elemento y lo borra de la lista
     * @return Primer elemento
     */
    public T devolverYBorrarPrimero(){

        T dato=devolverPrimero();
        quitarPrimero();
        return dato;
    }

    /**
     * Indica la posición del primer dato que se encuentre
     * @param t dato buscado
     * @return Posición del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t){

       Nodo<T> aux=primero;
       if (estaVacia()){
            return -1;
       }else{
           int contador=0;
           boolean encontrado=false;
           
            //recorremos, cuando encontrado=true, sale del bucle
           while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //actualizamos
                    aux=aux.getSiguiente(); 
               }
           }
           if(encontrado){
                return contador;
           }else{
                //no se ha encontrado
                return -1;
           }
       }
    }
    
    /**
     * Indica la posición del primer dato desde la posicion indicada
     * @param t dato buscado
     * @param pos
     * @return Posición del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t, int pos){

       Nodo<T> aux;
       if (estaVacia()){
            return -1;
       }else{
           int contador=pos;
           boolean encontrado=false;
           
           //Empezamos desde el nodo correspondiente
           aux=devolverNodo(pos);
           
           //recorremos, cuando encontrado=true, sale del bucle
            while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //Actualizamos
                    aux=aux.getSiguiente();
               }
            }
            if(encontrado){
                return contador;
            }else{
                return -1;
            }
       }
    }

    /**
     * Indica si un dato existe en la lista
     * @param t Dato a comprobar
     * @return Si el dato existe, devuelve true
     */
    public boolean datoExistente(T t){

        boolean existe=false;

        Nodo<T> aux=primero;

        while(aux!=null && !existe){

            if(aux.getDato().equals(t)){
                existe=true;
            }
            
            //Actualizamos
            aux=aux.getSiguiente();
        }

        return existe;
    }
    
    /**
     * Muestra el contenido de la lista
     */
    public void mostrar(){
        System.out.println("Contenido de la lista");
        System.out.println("---------------------");
        
        Nodo<T> aux=primero;
        
        while(aux!=null){
            System.out.println(aux.getDato());//mostramos el dato
            aux=aux.getSiguiente();
        }
    }
    
    /**
     * Devuelve el contenido de la lista en un String
     * @return contenido de la lista
     */
    @Override
    public String toString(){
        
        String contenido="";
        Nodo<T> aux=primero;
        
        while(aux!=null){
            contenido=aux.getDato()+"\n"; //guardamos el dato
            aux=aux.getSiguiente();
        }
        
        return contenido;
    }

        
    
    
    
    
    public class Nodo<T> {
   
    private T dato;
    private Nodo<T> siguiente;

    /**
     * Constructor por defecto
     */
    public Nodo(){
        siguiente=null;
     }

    /**
     * Le pasamos un dato al nodo
     * @param p 
     */
    public Nodo(T p){
        siguiente=null;
        dato = p;
    }

    /**
     * Le pasamos un dato y su siguiente nodo al nodo
     * @param t Dato a insertar
     * @param siguiente Su sisguiente nodo
     */
    public Nodo(T t, Nodo<T> siguiente){
        this.siguiente=siguiente;
        dato = t;
    }
    
    public T getDato() {
        return dato;
    }

    public void setDato(T dato) {
        this.dato = dato;
    }

    public Nodo<T> getSiguiente() {
        return siguiente;
    }

    public void setSiguiente(Nodo<T> siguiente) {
        this.siguiente = siguiente;
    }
    
}


    
}
   

    public static void main(String[] args) {
        
    
        Scanner sc = new Scanner ( System.in );
        
        int nMujeres;
        int nCualidades;
        nCualidades = sc.nextInt();
        sc.nextLine();
        String cualidades = sc.nextLine();
        String[] cualiStrs = cualidades.split(" ");
        int[] cualiNumbers = new int[nCualidades];
        
        for ( int i = 0; i < cualiStrs.length; i++ ){
            cualiNumbers[i] = Integer.parseInt(cualiStrs[i]);
        }
       
        
        ListaEnlazada<Integer> listCualidades = new ListaEnlazada<>();
        for ( int i = 0; i < cualiNumbers.length; i++){
            listCualidades.add(cualiNumbers[i]);
            
        }
        
        
        
        nMujeres = sc.nextInt();
        sc.nextLine();
        int count = 0;
	
        ListaEnlazada<Integer> list = new ListaEnlazada<>();
        
        while ( nMujeres != 0 ){
            
        	int countAux = 0;     
            String cualiMujeres = sc.nextLine();
            String[] auxCualiMujeres = cualiMujeres.split(" ");
            int[] auxCualiMujeres2 = new int[((cualiMujeres.length())/2) + 1];
            
            for ( int i = 0; i < auxCualiMujeres.length; i++ ){
                auxCualiMujeres2[i] = Integer.parseInt(auxCualiMujeres[i]);
            }
            
            for ( int i = 0; i < auxCualiMujeres2.length; i++ ){
                list.add(i, auxCualiMujeres2[i]);
            }
            
      
            for(int e = 0; e<listCualidades.cuantosElementos() ;e++){
				for(int f =0; f<list.cuantosElementos();f++){
					if(listCualidades.devolverDato(e) == list.devolverDato(f)){
				
						countaux++;
					}	
				}	
			}

			
			if(countAux == listCualidades.cuantosElementos()){
				count++;
			}
            
                list.listaVacia();
        nMujeres--;
        }
        

        System.out.println(count);
    
    
    
   
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.*;


public class MainC {
    public static class ListaEnlazada<T>{
   
    //Atributos
    private Nodo<T> primero;

    /**
     * Constructor por defecto
     */
    public ListaEnlazada(){
        listaVacia();
    }

    /**
     * Vacia la lista
     */
    private void listaVacia(){
        primero = null;
    }

    /**
     * Indica si la lista esta vacia o no
     * @return True = esta vacia
     */
    public boolean estaVacia(){
        return primero == null;
    }

    /**
     * Inserta un objeto al principio de la lista
     * @param t Dato insertado
     */
    public void insertarPrimero(T t){
        Nodo<T> nuevo = new Nodo<>(t);

        if (!estaVacia()){
            //Sino esta vacia, el primero actual pasa a ser
            // el siguiente de nuestro nuevo nodo
            nuevo.setSiguiente(primero);
        }
        
        //el primero apunta al nodo nuevo
        primero=nuevo;
        
    }

    /**
     * Inserta al final de la lista un objeto
     * @param t Dato insertado
     */
    public void insertarUltimo(T t){

        Nodo<T> aux = new Nodo<>(t);
        Nodo<T> rec_aux;

        if (estaVacia()) {
            insertarPrimero(t);
        }else {
            rec_aux = primero;
            
            //Buscamos el ultimo nodo
            while(rec_aux.getSiguiente() != null){
                rec_aux=rec_aux.getSiguiente();
            } 
                
            //Actualizamos el siguiente del ultimo
            rec_aux.setSiguiente(aux);
        }
    }

    /**
     * Quita el primer elemento de la lista
     */
    public void quitarPrimero(){
        Nodo<T> aux;
        if (!estaVacia()){
            aux=primero;
            primero = primero.getSiguiente();
            aux=null; //Lo marcamos para el recolector de basura
        }
    }

    /**
     * Quita el ultimo elemento de la lista
     */
    public void quitarUltimo(){
        Nodo<T> aux=primero;
        if(aux.getSiguiente()==null)
           //Aqi entra, si la lista tiene un elemento
           listaVacia();
        if(!estaVacia()) {
            aux=primero;
            
            //Buscamos el penultimo, por eso hay dos getSiguiente()
            while(aux.getSiguiente().getSiguiente() != null){
                aux=aux.getSiguiente();
            }
            
            //Marcamos el siguiente del antepenultimo como nulo, eliminando el ultimo
            aux.setSiguiente(null);
        }

    }        

    /**
     * Devuelve el último elemento de la lista
     * @return Último elemento
     */
    public T devolverUltimo(){
        T elemen = null;
        Nodo<T> aux;
        if (!estaVacia()){
            aux = primero;
            
            //Recorremos
            while(aux.getSiguiente() != null){
                aux = aux.getSiguiente();
            }
            elemen = aux.getDato();
        }
        return elemen;
    }

    /**
     * Devuelve el primer elemento de la lista
     * @return Primer elemento, null si esta vacia
     */
    public T devolverPrimero(){
        T elemen = null;
        if (!estaVacia()){
            elemen = primero.getDato();
        }
        return  elemen;
    }

    /**
     * Devuelve el número de elementos de la lista
     * @return Número de elementos
     */
    public int cuantosElementos(){
        Nodo<T> aux;
        int numElementos=0;
        aux = primero;

        //Recorremos
        while(aux != null){
            numElementos++;
            aux = aux.getSiguiente();
        }
        return numElementos;

    }
    
    /**
     * Devuelve el dato del nodo en la posicion pos
     * @param pos
     * @return dato del nodo en la posicion indicada
     */
    public T devolverDato(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        T dato=null;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Cogemos el dato
                    dato=aux.getDato();
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return dato;
        
    }
    
    /**
     * Devuelve el nodo de la posicion indicada
     * @param pos
     * @return Nodo de la posicion indicada
     */
    public Nodo<T> devolverNodo(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Devuelvo aux, con esto salimos de la función
                    return aux; 
                }
                
                //Actualizo el siguiente
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return aux;
        
    }
    
    /**
     * Inserta un nuevo nodo en la posicion indicada con el su dato
     * @param pos
     * @param dato 
     */
    public void introducirDato(int pos, T dato){
        Nodo<T> aux=primero;
        Nodo<T> auxDato=null; //Debemos crear un nodo para insetar el dato
        Nodo<T> anterior=primero; //Debemos crear un nodo para insetar el dato
        
        int contador=0;
        
        if(pos<0 || pos>cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            
            if(pos==0){
                insertarPrimero(dato);
            }else if(pos==cuantosElementos()){
                insertarUltimo(dato);
            }else{
                //Recorremos
                while(aux!=null){
                    if (pos == contador){
                        //Creo el nodo
                        auxDato=new Nodo<>(dato, aux);
                        //El siguiente del anterior a aux es auxDato
                        anterior.setSiguiente(auxDato);
                    }
                    
                    //Actualizo anterior
                    anterior=aux;
                    
                    contador++;
                    aux=aux.getSiguiente(); //Actualizo siguiente
                }
            }
        }
        
    }
    
    /**
     * Modifica el dato indicado en el nodo de la posicion indicada
     * @param pos
     * @param dato 
     */
    public void modificarDato(int pos, T dato){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //Recorremos
            while(aux!=null){
                if (pos == cont){
                    //Modificamos el dato directamente
                    aux.setDato(dato); 
                }
                cont++;
                aux=aux.getSiguiente(); //Actualizamos
            }
        }
        
    }

    /**
     * Borra un elemento de la lista
     * @param pos Posición de la lista que queremos borrar
     */
    public void borraPosicion(int pos){

        Nodo<T> aux=primero;
        Nodo<T> anterior=null;
        int contador=0;

        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == contador){
                    if (anterior==null){
                        primero = primero.getSiguiente();
                    }else {
                        //Actualizamos el anterior
                        anterior.setSiguiente(aux.getSiguiente());
                    }
                    aux=null;
                }else{
                    anterior=aux;
                    aux=aux.getSiguiente();
                    contador++;
                }
            }
        }
    }

    /**
     * Devuelve el primer el elemento y lo borra de la lista
     * @return Primer elemento
     */
    public T devolverYBorrarPrimero(){

        T dato=devolverPrimero();
        quitarPrimero();
        return dato;
    }

    /**
     * Indica la posición del primer dato que se encuentre
     * @param t dato buscado
     * @return Posición del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t){

       Nodo<T> aux=primero;
       if (estaVacia()){
            return -1;
       }else{
           int contador=0;
           boolean encontrado=false;
           
            //recorremos, cuando encontrado=true, sale del bucle
           while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //actualizamos
                    aux=aux.getSiguiente(); 
               }
           }
           if(encontrado){
                return contador;
           }else{
                //no se ha encontrado
                return -1;
           }
       }
    }
    
    /**
     * Indica la posición del primer dato desde la posicion indicada
     * @param t dato buscado
     * @param pos
     * @return Posición del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t, int pos){

       Nodo<T> aux;
       if (estaVacia()){
            return -1;
       }else{
           int contador=pos;
           boolean encontrado=false;
           
           //Empezamos desde el nodo correspondiente
           aux=devolverNodo(pos);
           
           //recorremos, cuando encontrado=true, sale del bucle
            while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //Actualizamos
                    aux=aux.getSiguiente();
               }
            }
            if(encontrado){
                return contador;
            }else{
                return -1;
            }
       }
    }

    /**
     * Indica si un dato existe en la lista
     * @param t Dato a comprobar
     * @return Si el dato existe, devuelve true
     */
    public boolean datoExistente(T t){

        boolean existe=false;

        Nodo<T> aux=primero;

        while(aux!=null && !existe){

            if(aux.getDato().equals(t)){
                existe=true;
            }
            
            //Actualizamos
            aux=aux.getSiguiente();
        }

        return existe;
    }
    
    /**
     * Muestra el contenido de la lista
     */
    public void mostrar(){
        System.out.println("Contenido de la lista");
        System.out.println("---------------------");
        
        Nodo<T> aux=primero;
        
        while(aux!=null){
            System.out.println(aux.getDato());//mostramos el dato
            aux=aux.getSiguiente();
        }
    }
    
    /**
     * Devuelve el contenido de la lista en un String
     * @return contenido de la lista
     */
    @Override
    public String toString(){
        
        String contenido="";
        Nodo<T> aux=primero;
        
        while(aux!=null){
            contenido=aux.getDato()+"\n"; //guardamos el dato
            aux=aux.getSiguiente();
        }
        
        return contenido;
    }

        
    
    
    
    
    public class Nodo<T> {
   
    private T dato;
    private Nodo<T> siguiente;

    /**
     * Constructor por defecto
     */
    public Nodo(){
        siguiente=null;
     }

    /**
     * Le pasamos un dato al nodo
     * @param p 
     */
    public Nodo(T p){
        siguiente=null;
        dato = p;
    }

    /**
     * Le pasamos un dato y su siguiente nodo al nodo
     * @param t Dato a insertar
     * @param siguiente Su sisguiente nodo
     */
    public Nodo(T t, Nodo<T> siguiente){
        this.siguiente=siguiente;
        dato = t;
    }
    
    public T getDato() {
        return dato;
    }

    public void setDato(T dato) {
        this.dato = dato;
    }

    public Nodo<T> getSiguiente() {
        return siguiente;
    }

    public void setSiguiente(Nodo<T> siguiente) {
        this.siguiente = siguiente;
    }
    
}


    
}
   

    public static void main(String[] args) {
        
    
        Scanner sc = new Scanner ( System.in );
        
        int nMujeres;
        int nCualidades;
        nCualidades = sc.nextInt();
        sc.nextLine();
        String cualidades = sc.nextLine();
        String[] cualiStrs = cualidades.split(" ");
        int[] cualiNumbers = new int[nCualidades];
        
        for ( int i = 0; i < cualiStrs.length; i++ ){
            cualiNumbers[i] = Integer.parseInt(cualiStrs[i]);
        }
       
        
        ListaEnlazada<Integer> listCualidades = new ListaEnlazada<>();
        for ( int i = 0; i < cualiNumbers.length; i++){
            listCualidades.add(cualiNumbers[i]);
            
        }
        
        
        
        nMujeres = sc.nextInt();
        sc.nextLine();
        int count = 0;
	
        ListaEnlazada<Integer> list = new ListaEnlazada<>();
        
        while ( nMujeres != 0 ){
            
        	int countAux = 0;     
            String cualiMujeres = sc.nextLine();
            String[] auxCualiMujeres = cualiMujeres.split(" ");
            int[] auxCualiMujeres2 = new int[((cualiMujeres.length())/2) + 1];
            
            for ( int i = 0; i < auxCualiMujeres.length; i++ ){
                auxCualiMujeres2[i] = Integer.parseInt(auxCualiMujeres[i]);
            }
            
            for ( int i = 0; i < auxCualiMujeres2.length; i++ ){
                list.introducirDato(i, auxCualiMujeres2[i]);
            }
            
      
            for(int e = 0; e<listCualidades.cuantosElementos() ;e++){
				for(int f =0; f<list.cuantosElementos();f++){
					if(listCualidades.devolverDato(e) == list.devolverDato(f)){
				
						countaux++;
					}	
				}	
			}

			
			if(countAux == listCualidades.cuantosElementos()){
				count++;
			}
            
                list.listaVacia();
        nMujeres--;
        }
        

        System.out.println(count);
    
    
    
   
    }
}

    
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;


public class MainC {
    public static class ListaEnlazada<T>{
   
    //Atributos
    private Nodo<T> primero;

    /**
     * Constructor por defecto
     */
    public ListaEnlazada(){
        listaVacia();
    }

    /**
     * Vacia la lista
     */
    private void listaVacia(){
        primero = null;
    }

    /**
     * Indica si la lista esta vacia o no
     * @return True = esta vacia
     */
    public boolean estaVacia(){
        return primero == null;
    }

    /**
     * Inserta un objeto al principio de la lista
     * @param t Dato insertado
     */
    public void insertarPrimero(T t){
        Nodo<T> nuevo = new Nodo<>(t);

        if (!estaVacia()){
            //Sino esta vacia, el primero actual pasa a ser
            // el siguiente de nuestro nuevo nodo
            nuevo.setSiguiente(primero);
        }
        
        //el primero apunta al nodo nuevo
        primero=nuevo;
        
    }

    /**
     * Inserta al final de la lista un objeto
     * @param t Dato insertado
     */
    public void insertarUltimo(T t){

        Nodo<T> aux = new Nodo<>(t);
        Nodo<T> rec_aux;

        if (estaVacia()) {
            insertarPrimero(t);
        }else {
            rec_aux = primero;
            
            //Buscamos el ultimo nodo
            while(rec_aux.getSiguiente() != null){
                rec_aux=rec_aux.getSiguiente();
            } 
                
            //Actualizamos el siguiente del ultimo
            rec_aux.setSiguiente(aux);
        }
    }

    /**
     * Quita el primer elemento de la lista
     */
    public void quitarPrimero(){
        Nodo<T> aux;
        if (!estaVacia()){
            aux=primero;
            primero = primero.getSiguiente();
            aux=null; //Lo marcamos para el recolector de basura
        }
    }

    /**
     * Quita el ultimo elemento de la lista
     */
    public void quitarUltimo(){
        Nodo<T> aux=primero;
        if(aux.getSiguiente()==null)
           //Aqi entra, si la lista tiene un elemento
           listaVacia();
        if(!estaVacia()) {
            aux=primero;
            
            //Buscamos el penultimo, por eso hay dos getSiguiente()
            while(aux.getSiguiente().getSiguiente() != null){
                aux=aux.getSiguiente();
            }
            
            //Marcamos el siguiente del antepenultimo como nulo, eliminando el ultimo
            aux.setSiguiente(null);
        }

    }        

    /**
     * Devuelve el último elemento de la lista
     * @return Último elemento
     */
    public T devolverUltimo(){
        T elemen = null;
        Nodo<T> aux;
        if (!estaVacia()){
            aux = primero;
            
            //Recorremos
            while(aux.getSiguiente() != null){
                aux = aux.getSiguiente();
            }
            elemen = aux.getDato();
        }
        return elemen;
    }

    /**
     * Devuelve el primer elemento de la lista
     * @return Primer elemento, null si esta vacia
     */
    public T devolverPrimero(){
        T elemen = null;
        if (!estaVacia()){
            elemen = primero.getDato();
        }
        return  elemen;
    }

    /**
     * Devuelve el número de elementos de la lista
     * @return Número de elementos
     */
    public int cuantosElementos(){
        Nodo<T> aux;
        int numElementos=0;
        aux = primero;

        //Recorremos
        while(aux != null){
            numElementos++;
            aux = aux.getSiguiente();
        }
        return numElementos;

    }
    
    /**
     * Devuelve el dato del nodo en la posicion pos
     * @param pos
     * @return dato del nodo en la posicion indicada
     */
    public T devolverDato(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        T dato=null;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Cogemos el dato
                    dato=aux.getDato();
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return dato;
        
    }
    
    /**
     * Devuelve el nodo de la posicion indicada
     * @param pos
     * @return Nodo de la posicion indicada
     */
    public Nodo<T> devolverNodo(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Devuelvo aux, con esto salimos de la función
                    return aux; 
                }
                
                //Actualizo el siguiente
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return aux;
        
    }
    
    /**
     * Inserta un nuevo nodo en la posicion indicada con el su dato
     * @param pos
     * @param dato 
     */
    public void introducirDato(int pos, T dato){
        Nodo<T> aux=primero;
        Nodo<T> auxDato=null; //Debemos crear un nodo para insetar el dato
        Nodo<T> anterior=primero; //Debemos crear un nodo para insetar el dato
        
        int contador=0;
        
        if(pos<0 || pos>cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            
            if(pos==0){
                insertarPrimero(dato);
            }else if(pos==cuantosElementos()){
                insertarUltimo(dato);
            }else{
                //Recorremos
                while(aux!=null){
                    if (pos == contador){
                        //Creo el nodo
                        auxDato=new Nodo<>(dato, aux);
                        //El siguiente del anterior a aux es auxDato
                        anterior.setSiguiente(auxDato);
                    }
                    
                    //Actualizo anterior
                    anterior=aux;
                    
                    contador++;
                    aux=aux.getSiguiente(); //Actualizo siguiente
                }
            }
        }
        
    }
    
    /**
     * Modifica el dato indicado en el nodo de la posicion indicada
     * @param pos
     * @param dato 
     */
    public void modificarDato(int pos, T dato){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //Recorremos
            while(aux!=null){
                if (pos == cont){
                    //Modificamos el dato directamente
                    aux.setDato(dato); 
                }
                cont++;
                aux=aux.getSiguiente(); //Actualizamos
            }
        }
        
    }

    /**
     * Borra un elemento de la lista
     * @param pos Posición de la lista que queremos borrar
     */
    public void borraPosicion(int pos){

        Nodo<T> aux=primero;
        Nodo<T> anterior=null;
        int contador=0;

        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == contador){
                    if (anterior==null){
                        primero = primero.getSiguiente();
                    }else {
                        //Actualizamos el anterior
                        anterior.setSiguiente(aux.getSiguiente());
                    }
                    aux=null;
                }else{
                    anterior=aux;
                    aux=aux.getSiguiente();
                    contador++;
                }
            }
        }
    }

    /**
     * Devuelve el primer el elemento y lo borra de la lista
     * @return Primer elemento
     */
    public T devolverYBorrarPrimero(){

        T dato=devolverPrimero();
        quitarPrimero();
        return dato;
    }

    /**
     * Indica la posición del primer dato que se encuentre
     * @param t dato buscado
     * @return Posición del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t){

       Nodo<T> aux=primero;
       if (estaVacia()){
            return -1;
       }else{
           int contador=0;
           boolean encontrado=false;
           
            //recorremos, cuando encontrado=true, sale del bucle
           while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //actualizamos
                    aux=aux.getSiguiente(); 
               }
           }
           if(encontrado){
                return contador;
           }else{
                //no se ha encontrado
                return -1;
           }
       }
    }
    
    /**
     * Indica la posición del primer dato desde la posicion indicada
     * @param t dato buscado
     * @param pos
     * @return Posición del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t, int pos){

       Nodo<T> aux;
       if (estaVacia()){
            return -1;
       }else{
           int contador=pos;
           boolean encontrado=false;
           
           //Empezamos desde el nodo correspondiente
           aux=devolverNodo(pos);
           
           //recorremos, cuando encontrado=true, sale del bucle
            while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //Actualizamos
                    aux=aux.getSiguiente();
               }
            }
            if(encontrado){
                return contador;
            }else{
                return -1;
            }
       }
    }

    /**
     * Indica si un dato existe en la lista
     * @param t Dato a comprobar
     * @return Si el dato existe, devuelve true
     */
    public boolean datoExistente(T t){

        boolean existe=false;

        Nodo<T> aux=primero;

        while(aux!=null && !existe){

            if(aux.getDato().equals(t)){
                existe=true;
            }
            
            //Actualizamos
            aux=aux.getSiguiente();
        }

        return existe;
    }
    
    /**
     * Muestra el contenido de la lista
     */
    public void mostrar(){
        System.out.println("Contenido de la lista");
        System.out.println("---------------------");
        
        Nodo<T> aux=primero;
        
        while(aux!=null){
            System.out.println(aux.getDato());//mostramos el dato
            aux=aux.getSiguiente();
        }
    }
    
    /**
     * Devuelve el contenido de la lista en un String
     * @return contenido de la lista
     */
    @Override
    public String toString(){
        
        String contenido="";
        Nodo<T> aux=primero;
        
        while(aux!=null){
            contenido=aux.getDato()+"\n"; //guardamos el dato
            aux=aux.getSiguiente();
        }
        
        return contenido;
    }

        
    
    
    
    
    public class Nodo<T> {
   
    private T dato;
    private Nodo<T> siguiente;

    /**
     * Constructor por defecto
     */
    public Nodo(){
        siguiente=null;
     }

    /**
     * Le pasamos un dato al nodo
     * @param p 
     */
    public Nodo(T p){
        siguiente=null;
        dato = p;
    }

    /**
     * Le pasamos un dato y su siguiente nodo al nodo
     * @param t Dato a insertar
     * @param siguiente Su sisguiente nodo
     */
    public Nodo(T t, Nodo<T> siguiente){
        this.siguiente=siguiente;
        dato = t;
    }
    
    public T getDato() {
        return dato;
    }

    public void setDato(T dato) {
        this.dato = dato;
    }

    public Nodo<T> getSiguiente() {
        return siguiente;
    }

    public void setSiguiente(Nodo<T> siguiente) {
        this.siguiente = siguiente;
    }
    
}


    
}
   

    public static void main(String[] args) {
        
    
        Scanner sc = new Scanner ( System.in );
        
        int nMujeres;
        int nCualidades;
        nCualidades = sc.nextInt();
        sc.nextLine();
        String cualidades = sc.nextLine();
        String[] cualiStrs = cualidades.split(" ");
        int[] cualiNumbers = new int[nCualidades];
        
        for ( int i = 0; i < cualiStrs.length; i++ ){
            cualiNumbers[i] = Integer.parseInt(cualiStrs[i]);
        }
       
        
        ListaEnlazada<Integer> listCualidades = new ListaEnlazada<>();
        for ( int i = 0; i < cualiNumbers.length; i++){
            listCualidades.introducirDato(i,cualiNumbers[i]);
            
        }
        
        
        
        nMujeres = sc.nextInt();
        sc.nextLine();
        int count = 0;
	
        ListaEnlazada<Integer> list = new ListaEnlazada<>();
        
        while ( nMujeres != 0 ){
            
        	int countAux = 0;     
            String cualiMujeres = sc.nextLine();
            String[] auxCualiMujeres = cualiMujeres.split(" ");
            int[] auxCualiMujeres2 = new int[((cualiMujeres.length())/2) + 1];
            
            for ( int i = 0; i < auxCualiMujeres.length; i++ ){
                auxCualiMujeres2[i] = Integer.parseInt(auxCualiMujeres[i]);
            }
            
            for ( int i = 0; i < auxCualiMujeres2.length; i++ ){
                list.introducirDato(i, auxCualiMujeres2[i]);
            }
            
      
            for(int e = 0; e<listCualidades.cuantosElementos() ;e++){
				for(int f =0; f<list.cuantosElementos();f++){
					if(listCualidades.devolverDato(e) == list.devolverDato(f)){
				
						countaux++;
					}	
				}	
			}

			
			if(countAux == listCualidades.cuantosElementos()){
				count++;
			}
            
                list.listaVacia();
        nMujeres--;
        }
        

        System.out.println(count);
    
    
    
   
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package DOMJudge2;

import java.util.Scanner;

public class MainA {
    
    static public class ListaEnlazada {
    
        private Nodo cabeza;
        private int costoList = 0;
        private int costoArray = 0;
        public boolean auxBoolean = true;
        
        class Nodo {
            int data;
            Nodo next;
        }
    
    
        
        public int getCostoList(){
        return costoList;
        }
    
        int getCostoArray(){
        return costoArray;
        }
    
        public ListaEnlazada () {
        cabeza = null;
        }
        
        public int tamanno(){
        int auxTamano = 0;
        Nodo i = cabeza;
            while ( i!=null ){
                i = i.next;
                auxTamano++;
            }
        return auxTamano;
        }
        
        void definirArray( int[]array, int idx ){
            int []aux = new int[ idx*2 ];
            for(int i = 0; i < idx*2; i++ ){
                aux[i] = -1;
            }
        
            for(int i = 0; i < idx; i++ ){
                aux[i] = array[i];
            }
        array = aux;
        }
    
        void recorrerArray( int[]array, int posicion, int idx){
        int count = 0;
        for(int i = idx; i > posicion; i-- ){
           array[i] = array[i-1];
           count++;
           
        }
        costoArray = costoArray + ( count - 1 );
        }
        
        void eliminarArray(int[]array ,int posicion,int idx){
            if( ( posicion <= idx ) && ( posicion >= 0 ) ){
                int count = 0;
                for(int i= posicion; i < idx; i++ ){
                    array[i] = array[ i+1 ] ;
                    count++;
                }
                array[idx] = -1;
                if( posicion == 0 ){
                    costoArray = costoArray + (count);
                }
                else{
                    costoArray = costoArray + (count);
                }
            }
        }
        
        
        void buscarArray( int[]array, int dato, int idx ){
            int count = 0;
            for(int x = 0; x < idx; x++ ){
                count++;
                if( array[x] == dato ){
                    costoArray = costoArray + count;
                    x = idx;
                }
                if( array[x] != dato && x == ( idx - 1 ) ){
                    costoArray = costoArray + count;
                }
            }
        }
        
        
        
        void insertar (int dato, int posicion){   
            if (posicion <= tamanno() && posicion >= 0 ){
                Nodo nuevo = new Nodo ();
                nuevo.data = dato;
                if (posicion == 0){
                    nuevo.next = cabeza;
                    cabeza = nuevo;
                }else{
                    if (posicion == tamanno ()){
                        Nodo i = cabeza;
                   
                        while (i.next != null) {
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        i.next = nuevo;
                        nuevo.next = null;
                    }else{
                        Nodo i = cabeza;
                        for (int x = 1; x < posicion ; x++){
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        Nodo siguiente = i.next;
                        i.next = nuevo;
                        nuevo.next = siguiente;
                    }
                }
                System.out.println("insertar: posicion valida");
            }else{
            System.out.println("insertar: posicion invalida");
            }   
        }
        
        
        void buscar(int dato){
            int aux = 0;
            boolean auxBool = true;
            Nodo i = cabeza;
            while( i != null && i.data != dato){
                 i = i.next;
                 aux++;
            }
            if( i != null ){
                System.out.println("buscar: " + aux);
                costoList = costoList + (aux+1);
            }else{
                System.out.println("no existe numero");
                costoList = costoList + tamanno();
            }
        }
        
        
        
        void consultar(int posicion){
            Nodo i = cabeza;
            if( posicion < tamanno() && posicion >= 0 && cabeza != null ){
                for(int x=0;x<posicion;x++){
                    i=i.next;
                    costoList++;
                }
                System.out.println("consulta: "+i.data);
            }else{
                System.out.println("consulta: no encontrado");
            }
        }
        
        
        
    
        void eliminar(int posicion){
            Nodo i = cabeza;
            boolean auxBoolTwo = true;
            if(posicion == 0 && cabeza != null ){
                auxBoolean = false;
                cabeza = cabeza.next;
                System.out.println("eliminar: posicion valida");
                auxBoolTwo = false;
            }
            if(posicion < tamanno() && posicion > 0){
                for( int x = 1; x < posicion; x++ ){
                     i = i.next;
                     costoList++;
                }
                auxBoolean = false;
                Nodo siguiente = i.next;
                i.next = siguiente.next;
                System.out.println("eliminar: posicion valida");
            }else{
                if(auxBoolTwo == true){
                    System.out.println("eliminar: posicion invalida");
                }
            }
        }
    
    
}

    public static void main(String[] ar) {
        Scanner sc = new Scanner( System.in );
        int casos = sc.nextInt();
        String comando;
        
        for(int u = 0; u < casos; u++ ){
            System.out.println( "Caso #" + (u+1) + ":" );
            int instruccion = sc.nextInt();
            ListaEnlazada list = new ListaEnlazada();
            int indice = 0;
            int[] array = new int[10];
            int tamano;
            for( int i = 0; i < 10 ; i++ ){
            array[i] = -1;
            }
         
            
            for( int i=0 ; i < instruccion ; i++ ){
                comando = sc.next();
                if( "insertar".equals(comando) ){
                    int dato = sc.nextInt();
                    int posicion = sc.nextInt();
                    list.insertar( dato, posicion );
                    if( posicion <= list.tamanno() ){
                        indice++;
                        tamano =  array.length;
                        if( indice == tamano ){
                        list.definirArray( array, indice );
                        }
                        if( array[posicion] == -1 ){
                            array[posicion] = dato;
                        }
                        else{
                        list.recorrerArray( array, posicion, indice );
                        array[posicion] = dato;
                        }
                    }
                }
                if("buscar".equals(comando)){
                    int datoAux = sc.nextInt();
                    list.buscar( datoAux );
                    list.buscarArray( array, datoAux, indice );
                }
                if("eliminar".equals( comando )){
                    int posicionAux = sc.nextInt();
                    list.eliminar( posicionAux );
                    if( list.auxBoolean == false ){
                        indice--;
                        list.auxBoolean = true;
                    }
                    list.eliminarArray( array, posicionAux, indice );
                }
                if("consultar".equals( comando )){
                    int pos = sc.nextInt();
                    list.consultar( pos );
                }
                if("costo".equals( comando )){
                    System.out.println("costo: " + list.getCostoArray() + " " + list.getCostoList());
                }
            }
        }                    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
ï»¿
import java.util.*;


public class MainC {
    public static class ListaEnlazada<T>{
   
    //Atributos
    private Nodo<T> primero;

    /**
     * Constructor por defecto
     */
    public ListaEnlazada(){
        listaVacia();
    }

    /**
     * Vacia la lista
     */
    private void listaVacia(){
        primero = null;
    }

    /**
     * Indica si la lista esta vacia o no
     * @return True = esta vacia
     */
    public boolean estaVacia(){
        return primero == null;
    }

    /**
     * Inserta un objeto al principio de la lista
     * @param t Dato insertado
     */
    public void insertarPrimero(T t){
        Nodo<T> nuevo = new Nodo<>(t);

        if (!estaVacia()){
            //Sino esta vacia, el primero actual pasa a ser
            // el siguiente de nuestro nuevo nodo
            nuevo.setSiguiente(primero);
        }
        
        //el primero apunta al nodo nuevo
        primero=nuevo;
        
    }

    /**
     * Inserta al final de la lista un objeto
     * @param t Dato insertado
     */
    public void insertarUltimo(T t){

        Nodo<T> aux = new Nodo<>(t);
        Nodo<T> rec_aux;

        if (estaVacia()) {
            insertarPrimero(t);
        }else {
            rec_aux = primero;
            
            //Buscamos el ultimo nodo
            while(rec_aux.getSiguiente() != null){
                rec_aux=rec_aux.getSiguiente();
            } 
                
            //Actualizamos el siguiente del ultimo
            rec_aux.setSiguiente(aux);
        }
    }

    /**
     * Quita el primer elemento de la lista
     */
    public void quitarPrimero(){
        Nodo<T> aux;
        if (!estaVacia()){
            aux=primero;
            primero = primero.getSiguiente();
            aux=null; //Lo marcamos para el recolector de basura
        }
    }

    /**
     * Quita el ultimo elemento de la lista
     */
    public void quitarUltimo(){
        Nodo<T> aux=primero;
        if(aux.getSiguiente()==null)
           //Aqi entra, si la lista tiene un elemento
           listaVacia();
        if(!estaVacia()) {
            aux=primero;
            
            //Buscamos el penultimo, por eso hay dos getSiguiente()
            while(aux.getSiguiente().getSiguiente() != null){
                aux=aux.getSiguiente();
            }
            
            //Marcamos el siguiente del antepenultimo como nulo, eliminando el ultimo
            aux.setSiguiente(null);
        }

    }        

    /**
     * Devuelve el Ãºltimo elemento de la lista
     * @return Ãltimo elemento
     */
    public T devolverUltimo(){
        T elemen = null;
        Nodo<T> aux;
        if (!estaVacia()){
            aux = primero;
            
            //Recorremos
            while(aux.getSiguiente() != null){
                aux = aux.getSiguiente();
            }
            elemen = aux.getDato();
        }
        return elemen;
    }

    /**
     * Devuelve el primer elemento de la lista
     * @return Primer elemento, null si esta vacia
     */
    public T devolverPrimero(){
        T elemen = null;
        if (!estaVacia()){
            elemen = primero.getDato();
        }
        return  elemen;
    }

    /**
     * Devuelve el nÃºmero de elementos de la lista
     * @return NÃºmero de elementos
     */
    public int cuantosElementos(){
        Nodo<T> aux;
        int numElementos=0;
        aux = primero;

        //Recorremos
        while(aux != null){
            numElementos++;
            aux = aux.getSiguiente();
        }
        return numElementos;

    }
    
    /**
     * Devuelve el dato del nodo en la posicion pos
     * @param pos
     * @return dato del nodo en la posicion indicada
     */
    public T devolverDato(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        T dato=null;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Cogemos el dato
                    dato=aux.getDato();
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return dato;
        
    }
    
    /**
     * Devuelve el nodo de la posicion indicada
     * @param pos
     * @return Nodo de la posicion indicada
     */
    public Nodo<T> devolverNodo(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Devuelvo aux, con esto salimos de la funciÃ³n
                    return aux; 
                }
                
                //Actualizo el siguiente
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return aux;
        
    }
    
    /**
     * Inserta un nuevo nodo en la posicion indicada con el su dato
     * @param pos
     * @param dato 
     */
    public void introducirDato(int pos, T dato){
        Nodo<T> aux=primero;
        Nodo<T> auxDato=null; //Debemos crear un nodo para insetar el dato
        Nodo<T> anterior=primero; //Debemos crear un nodo para insetar el dato
        
        int contador=0;
        
        if(pos<0 || pos>cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            
            if(pos==0){
                insertarPrimero(dato);
            }else if(pos==cuantosElementos()){
                insertarUltimo(dato);
            }else{
                //Recorremos
                while(aux!=null){
                    if (pos == contador){
                        //Creo el nodo
                        auxDato=new Nodo<>(dato, aux);
                        //El siguiente del anterior a aux es auxDato
                        anterior.setSiguiente(auxDato);
                    }
                    
                    //Actualizo anterior
                    anterior=aux;
                    
                    contador++;
                    aux=aux.getSiguiente(); //Actualizo siguiente
                }
            }
        }
        
    }
    
    /**
     * Modifica el dato indicado en el nodo de la posicion indicada
     * @param pos
     * @param dato 
     */
    public void modificarDato(int pos, T dato){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //Recorremos
            while(aux!=null){
                if (pos == cont){
                    //Modificamos el dato directamente
                    aux.setDato(dato); 
                }
                cont++;
                aux=aux.getSiguiente(); //Actualizamos
            }
        }
        
    }

    /**
     * Borra un elemento de la lista
     * @param pos PosiciÃ³n de la lista que queremos borrar
     */
    public void borraPosicion(int pos){

        Nodo<T> aux=primero;
        Nodo<T> anterior=null;
        int contador=0;

        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == contador){
                    if (anterior==null){
                        primero = primero.getSiguiente();
                    }else {
                        //Actualizamos el anterior
                        anterior.setSiguiente(aux.getSiguiente());
                    }
                    aux=null;
                }else{
                    anterior=aux;
                    aux=aux.getSiguiente();
                    contador++;
                }
            }
        }
    }

    /**
     * Devuelve el primer el elemento y lo borra de la lista
     * @return Primer elemento
     */
    public T devolverYBorrarPrimero(){

        T dato=devolverPrimero();
        quitarPrimero();
        return dato;
    }

    /**
     * Indica la posiciÃ³n del primer dato que se encuentre
     * @param t dato buscado
     * @return PosiciÃ³n del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t){

       Nodo<T> aux=primero;
       if (estaVacia()){
            return -1;
       }else{
           int contador=0;
           boolean encontrado=false;
           
            //recorremos, cuando encontrado=true, sale del bucle
           while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //actualizamos
                    aux=aux.getSiguiente(); 
               }
           }
           if(encontrado){
                return contador;
           }else{
                //no se ha encontrado
                return -1;
           }
       }
    }
    
    /**
     * Indica la posiciÃ³n del primer dato desde la posicion indicada
     * @param t dato buscado
     * @param pos
     * @return PosiciÃ³n del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t, int pos){

       Nodo<T> aux;
       if (estaVacia()){
            return -1;
       }else{
           int contador=pos;
           boolean encontrado=false;
           
           //Empezamos desde el nodo correspondiente
           aux=devolverNodo(pos);
           
           //recorremos, cuando encontrado=true, sale del bucle
            while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //Actualizamos
                    aux=aux.getSiguiente();
               }
            }
            if(encontrado){
                return contador;
            }else{
                return -1;
            }
       }
    }

    /**
     * Indica si un dato existe en la lista
     * @param t Dato a comprobar
     * @return Si el dato existe, devuelve true
     */
    public boolean datoExistente(T t){

        boolean existe=false;

        Nodo<T> aux=primero;

        while(aux!=null && !existe){

            if(aux.getDato().equals(t)){
                existe=true;
            }
            
            //Actualizamos
            aux=aux.getSiguiente();
        }

        return existe;
    }
    
    /**
     * Muestra el contenido de la lista
     */
    public void mostrar(){
        System.out.println("Contenido de la lista");
        System.out.println("---------------------");
        
        Nodo<T> aux=primero;
        
        while(aux!=null){
            System.out.println(aux.getDato());//mostramos el dato
            aux=aux.getSiguiente();
        }
    }
    
    /**
     * Devuelve el contenido de la lista en un String
     * @return contenido de la lista
     */
    @Override
    public String toString(){
        
        String contenido="";
        Nodo<T> aux=primero;
        
        while(aux!=null){
            contenido=aux.getDato()+"\n"; //guardamos el dato
            aux=aux.getSiguiente();
        }
        
        return contenido;
    }

        
    
    
    
    
    public class Nodo<T> {
   
    private T dato;
    private Nodo<T> siguiente;

    /**
     * Constructor por defecto
     */
    public Nodo(){
        siguiente=null;
     }

    /**
     * Le pasamos un dato al nodo
     * @param p 
     */
    public Nodo(T p){
        siguiente=null;
        dato = p;
    }

    /**
     * Le pasamos un dato y su siguiente nodo al nodo
     * @param t Dato a insertar
     * @param siguiente Su sisguiente nodo
     */
    public Nodo(T t, Nodo<T> siguiente){
        this.siguiente=siguiente;
        dato = t;
    }
    
    public T getDato() {
        return dato;
    }

    public void setDato(T dato) {
        this.dato = dato;
    }

    public Nodo<T> getSiguiente() {
        return siguiente;
    }

    public void setSiguiente(Nodo<T> siguiente) {
        this.siguiente = siguiente;
    }
    
}


    
}
   

    public static void main(String[] args) {
        
    
        Scanner sc = new Scanner ( System.in );
        
        int nMujeres;
        int nCualidades;
        nCualidades = sc.nextInt();
        sc.nextLine();
        String cualidades = sc.nextLine();
        String[] cualiStrs = cualidades.split(" ");
        int[] cualiNumbers = new int[nCualidades];
        
        for ( int i = 0; i < cualiStrs.length; i++ ){
            cualiNumbers[i] = Integer.parseInt(cualiStrs[i]);
        }
       
        
        ListaEnlazada<Integer> listCualidades = new ListaEnlazada<>();
        for ( int i = 0; i < cualiNumbers.length; i++){
            listCualidades.introducirDato(i,cualiNumbers[i]);
            
        }
        
        
        
        nMujeres = sc.nextInt();
        sc.nextLine();
        int count = 0;
	
        ListaEnlazada<Integer> list = new ListaEnlazada<>();
        
        while ( nMujeres != 0 ){
            
        	int countAux = 0;     
            String cualiMujeres = sc.nextLine();
            String[] auxCualiMujeres = cualiMujeres.split(" ");
            int[] auxCualiMujeres2 = new int[((cualiMujeres.length())/2) + 1];
            
            for ( int i = 0; i < auxCualiMujeres.length; i++ ){
                auxCualiMujeres2[i] = Integer.parseInt(auxCualiMujeres[i]);
            }
            
            for ( int i = 0; i < auxCualiMujeres2.length; i++ ){
                list.introducirDato(i, auxCualiMujeres2[i]);
            }
            
      
            for(int e = 0; e<listCualidades.cuantosElementos() ;e++){
				for(int f =0; f<list.cuantosElementos();f++){
					if(listCualidades.devolverDato(e) == list.devolverDato(f)){
				
						countAux++;
					}	
				}	
			}

			
			if(countAux == listCualidades.cuantosElementos()){
				count++;
			}
            
                list.listaVacia();
        nMujeres--;
        }
        

        System.out.println(count);
    
    
    
   
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
ï»¿
import java.util.*;

public class MainB{
    
    public static class ListaEnlazada<T>{
   
    //Atributos
    private Nodo<T> primero;

    /**
     * Constructor por defecto
     */
    public ListaEnlazada(){
        listaVacia();
    }

    /**
     * Vacia la lista
     */
    private void listaVacia(){
        primero = null;
    }

    /**
     * Indica si la lista esta vacia o no
     * @return True = esta vacia
     */
    public boolean estaVacia(){
        return primero == null;
    }

    /**
     * Inserta un objeto al principio de la lista
     * @param t Dato insertado
     */
    public void insertarPrimero(T t){
        Nodo<T> nuevo = new Nodo<>(t);

        if (!estaVacia()){
            //Sino esta vacia, el primero actual pasa a ser
            // el siguiente de nuestro nuevo nodo
            nuevo.setSiguiente(primero);
        }
        
        //el primero apunta al nodo nuevo
        primero=nuevo;
        
    }

    /**
     * Inserta al final de la lista un objeto
     * @param t Dato insertado
     */
    public void insertarUltimo(T t){

        Nodo<T> aux = new Nodo<>(t);
        Nodo<T> rec_aux;

        if (estaVacia()) {
            insertarPrimero(t);
        }else {
            rec_aux = primero;
            
            //Buscamos el ultimo nodo
            while(rec_aux.getSiguiente() != null){
                rec_aux=rec_aux.getSiguiente();
            } 
                
            //Actualizamos el siguiente del ultimo
            rec_aux.setSiguiente(aux);
        }
    }

    /**
     * Quita el primer elemento de la lista
     */
    public void quitarPrimero(){
        Nodo<T> aux;
        if (!estaVacia()){
            aux=primero;
            primero = primero.getSiguiente();
            aux=null; //Lo marcamos para el recolector de basura
        }
    }

    /**
     * Quita el ultimo elemento de la lista
     */
    public void quitarUltimo(){
        Nodo<T> aux=primero;
        if(aux.getSiguiente()==null)
           //Aqi entra, si la lista tiene un elemento
           listaVacia();
        if(!estaVacia()) {
            aux=primero;
            
            //Buscamos el penultimo, por eso hay dos getSiguiente()
            while(aux.getSiguiente().getSiguiente() != null){
                aux=aux.getSiguiente();
            }
            
            //Marcamos el siguiente del antepenultimo como nulo, eliminando el ultimo
            aux.setSiguiente(null);
        }

    }        

    /**
     * Devuelve el Ãºltimo elemento de la lista
     * @return Ãltimo elemento
     */
    public T devolverUltimo(){
        T elemen = null;
        Nodo<T> aux;
        if (!estaVacia()){
            aux = primero;
            
            //Recorremos
            while(aux.getSiguiente() != null){
                aux = aux.getSiguiente();
            }
            elemen = aux.getDato();
        }
        return elemen;
    }

    /**
     * Devuelve el primer elemento de la lista
     * @return Primer elemento, null si esta vacia
     */
    public T devolverPrimero(){
        T elemen = null;
        if (!estaVacia()){
            elemen = primero.getDato();
        }
        return  elemen;
    }

    /**
     * Devuelve el nÃºmero de elementos de la lista
     * @return NÃºmero de elementos
     */
    public int cuantosElementos(){
        Nodo<T> aux;
        int numElementos=0;
        aux = primero;

        //Recorremos
        while(aux != null){
            numElementos++;
            aux = aux.getSiguiente();
        }
        return numElementos;

    }
    
    /**
     * Devuelve el dato del nodo en la posicion pos
     * @param pos
     * @return dato del nodo en la posicion indicada
     */
    public T devolverDato(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        T dato=null;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Cogemos el dato
                    dato=aux.getDato();
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return dato;
        
    }
    
    /**
     * Devuelve el nodo de la posicion indicada
     * @param pos
     * @return Nodo de la posicion indicada
     */
    public Nodo<T> devolverNodo(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //recorremos
            while(aux!=null){
                if (pos == cont){
                    //Devuelvo aux, con esto salimos de la funciÃ³n
                    return aux; 
                }
                
                //Actualizo el siguiente
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return aux;
        
    }
    
    /**
     * Inserta un nuevo nodo en la posicion indicada con el su dato
     * @param pos
     * @param dato 
     */
    public void introducirDato(int pos, T dato){
        Nodo<T> aux=primero;
        Nodo<T> auxDato=null; //Debemos crear un nodo para insetar el dato
        Nodo<T> anterior=primero; //Debemos crear un nodo para insetar el dato
        
        int contador=0;
        
        if(pos<0 || pos>cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            
            if(pos==0){
                insertarPrimero(dato);
            }else if(pos==cuantosElementos()){
                insertarUltimo(dato);
            }else{
                //Recorremos
                while(aux!=null){
                    if (pos == contador){
                        //Creo el nodo
                        auxDato=new Nodo<>(dato, aux);
                        //El siguiente del anterior a aux es auxDato
                        anterior.setSiguiente(auxDato);
                    }
                    
                    //Actualizo anterior
                    anterior=aux;
                    
                    contador++;
                    aux=aux.getSiguiente(); //Actualizo siguiente
                }
            }
        }
        
    }
    
    /**
     * Modifica el dato indicado en el nodo de la posicion indicada
     * @param pos
     * @param dato 
     */
    public void modificarDato(int pos, T dato){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            //Recorremos
            while(aux!=null){
                if (pos == cont){
                    //Modificamos el dato directamente
                    aux.setDato(dato); 
                }
                cont++;
                aux=aux.getSiguiente(); //Actualizamos
            }
        }
        
    }

    /**
     * Borra un elemento de la lista
     * @param pos PosiciÃ³n de la lista que queremos borrar
     */
    public void borraPosicion(int pos){

        Nodo<T> aux=primero;
        Nodo<T> anterior=null;
        int contador=0;

        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == contador){
                    if (anterior==null){
                        primero = primero.getSiguiente();
                    }else {
                        //Actualizamos el anterior
                        anterior.setSiguiente(aux.getSiguiente());
                    }
                    aux=null;
                }else{
                    anterior=aux;
                    aux=aux.getSiguiente();
                    contador++;
                }
            }
        }
    }

    /**
     * Devuelve el primer el elemento y lo borra de la lista
     * @return Primer elemento
     */
    public T devolverYBorrarPrimero(){

        T dato=devolverPrimero();
        quitarPrimero();
        return dato;
    }

    /**
     * Indica la posiciÃ³n del primer dato que se encuentre
     * @param t dato buscado
     * @return PosiciÃ³n del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t){

       Nodo<T> aux=primero;
       if (estaVacia()){
            return -1;
       }else{
           int contador=0;
           boolean encontrado=false;
           
            //recorremos, cuando encontrado=true, sale del bucle
           while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //actualizamos
                    aux=aux.getSiguiente(); 
               }
           }
           if(encontrado){
                return contador;
           }else{
                //no se ha encontrado
                return -1;
           }
       }
    }
    
    /**
     * Indica la posiciÃ³n del primer dato desde la posicion indicada
     * @param t dato buscado
     * @param pos
     * @return PosiciÃ³n del dato buscado, -1 si no se encuentra o esta vacia
     */
    public int indexOf (T t, int pos){

       Nodo<T> aux;
       if (estaVacia()){
            return -1;
       }else{
           int contador=pos;
           boolean encontrado=false;
           
           //Empezamos desde el nodo correspondiente
           aux=devolverNodo(pos);
           
           //recorremos, cuando encontrado=true, sale del bucle
            while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   //Cambiamos a true
                   encontrado=true;
               }else{
                    contador++;
                    //Actualizamos
                    aux=aux.getSiguiente();
               }
            }
            if(encontrado){
                return contador;
            }else{
                return -1;
            }
       }
    }

    /**
     * Indica si un dato existe en la lista
     * @param t Dato a comprobar
     * @return Si el dato existe, devuelve true
     */
    public boolean datoExistente(T t){

        boolean existe=false;

        Nodo<T> aux=primero;

        while(aux!=null && !existe){

            if(aux.getDato().equals(t)){
                existe=true;
            }
            
            //Actualizamos
            aux=aux.getSiguiente();
        }

        return existe;
    }
    
    /**
     * Muestra el contenido de la lista
     */
    public void mostrar(){
        System.out.println("Contenido de la lista");
        System.out.println("---------------------");
        
        Nodo<T> aux=primero;
        
        while(aux!=null){
            System.out.println(aux.getDato());//mostramos el dato
            aux=aux.getSiguiente();
        }
    }
    
    /**
     * Devuelve el contenido de la lista en un String
     * @return contenido de la lista
     */
    @Override
    public String toString(){
        
        String contenido="";
        Nodo<T> aux=primero;
        
        while(aux!=null){
            contenido=aux.getDato()+"\n"; //guardamos el dato
            aux=aux.getSiguiente();
        }
        
        return contenido;
    }

        
    
    
    
    
    public class Nodo<T> {
   
    private T dato;
    private Nodo<T> siguiente;

    /**
     * Constructor por defecto
     */
    public Nodo(){
        siguiente=null;
     }

    /**
     * Le pasamos un dato al nodo
     * @param p 
     */
    public Nodo(T p){
        siguiente=null;
        dato = p;
    }

    /**
     * Le pasamos un dato y su siguiente nodo al nodo
     * @param t Dato a insertar
     * @param siguiente Su sisguiente nodo
     */
    public Nodo(T t, Nodo<T> siguiente){
        this.siguiente=siguiente;
        dato = t;
    }
    
    public T getDato() {
        return dato;
    }

    public void setDato(T dato) {
        this.dato = dato;
    }

    public Nodo<T> getSiguiente() {
        return siguiente;
    }

    public void setSiguiente(Nodo<T> siguiente) {
        this.siguiente = siguiente;
    }
    
}


    
}
   

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
                int caso = sc.nextInt();
		ListaEnlazada<Integer> list = new ListaEnlazada<>();

		for(int i = 0; i < caso; i++){
			int ncartas = sc.nextInt();
			int jugadores = sc.nextInt();	

			int[] cartas = new int[ncartas];
			int[] nJugadores = new int [jugadores];

			for( int j=0; j < ncartas; j++ ){
				cartas[j] = sc.nextInt();
			}

			for( int p = 0; p < ncartas; p++ ){
				list.introducirDato(p,cartas[p] );
			}

			int aux1 = 0;
			
			while( !list.estaVacia()){
				int nPrimero = list.devolverPrimero();
				int nUltimo = list.devolverUltimo();
				int mayor;
				if( nPrimero > nUltimo ){
					mayor = nPrimero;
					list.quitarPrimero();
							
				}else {
					mayor = nUltimo;
					list.quitarUltimo();
					
				}
				int count = ( aux1 % jugadores );
					nJugadores[count] = nJugadores[count] + mayor;
				aux1++;
			}	

			int auxMayor = 0;
			for(int j = 0; j < nJugadores.length; j++ ){
				if( auxMayor < nJugadores[j] ){
					auxMayor = nJugadores[j];
				}
			}				
			
			int []array = new int[jugadores];
			int count = 0;
			for (int h = 0; h < jugadores ; h++ ){
				if (auxMayor == nJugadores[h] ){
					array[count] = h+1 ;
					count++;
				}
			}
			System.out.println("Caso #"+ (i+1) + ":");
			int newSizeArray = array.length - 1 ;
			int aux = 0;
			while ( newSizeArray >= 0 ){
				if ( array[aux] != 0 ){
					System.out.print( array[aux] );
				}
				if( aux != array.length  && array[aux] != 0){
					System.out.print(" ");
				}
					
				
				aux++;
				newSizeArray--;
			}
			System.out.println("");
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
ï»¿


import java.util.*;


public class MainB{
    
    public static class ListaEnlazada<T>{
   
    private Nodo<T> primero;

    public ListaEnlazada(){
        listaVacia();
    }

    private void listaVacia(){
        primero = null;
    }

    public boolean estaVacia(){
        return primero == null;
    }

    public void insertarPrimero(T t){
        Nodo<T> nuevo = new Nodo<>(t);

        if (!estaVacia()){
            nuevo.setSiguiente(primero);
        }
        
        primero=nuevo;
        
    }

    public void insertarUltimo(T t){

        Nodo<T> aux = new Nodo<>(t);
        Nodo<T> rec_aux;

        if (estaVacia()) {
            insertarPrimero(t);
        }else {
            rec_aux = primero;
            
            while(rec_aux.getSiguiente() != null){
                rec_aux=rec_aux.getSiguiente();
            } 
                
            rec_aux.setSiguiente(aux);
        }
    }

    public void quitarPrimero(){
        Nodo<T> aux;
        if (!estaVacia()){
            aux=primero;
            primero = primero.getSiguiente();
            aux=null; 
        }
    }

    public void quitarUltimo(){
        Nodo<T> aux=primero;
        if(aux.getSiguiente()==null)
           listaVacia();
        if(!estaVacia()) {
            aux=primero;
            
            while(aux.getSiguiente().getSiguiente() != null){
                aux=aux.getSiguiente();
            }
            
            aux.setSiguiente(null);
        }

    }        

    public T devolverUltimo(){
        T elemen = null;
        Nodo<T> aux;
        if (!estaVacia()){
            aux = primero;
            
            while(aux.getSiguiente() != null){
                aux = aux.getSiguiente();
            }
            elemen = aux.getDato();
        }
        return elemen;
    }

    public T devolverPrimero(){
        T elemen = null;
        if (!estaVacia()){
            elemen = primero.getDato();
        }
        return  elemen;
    }

    public int cuantosElementos(){
        Nodo<T> aux;
        int numElementos=0;
        aux = primero;

        while(aux != null){
            numElementos++;
            aux = aux.getSiguiente();
        }
        return numElementos;

    }
    
    public T devolverDato(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        T dato=null;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    dato=aux.getDato();
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return dato;
        
    }
    
    public Nodo<T> devolverNodo(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    return aux; 
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return aux;
        
    }
    
    public void introducirDato(int pos, T dato){
        Nodo<T> aux=primero;
        Nodo<T> auxDato=null;
        Nodo<T> anterior=primero; 
        
        int contador=0;
        
        if(pos<0 || pos>cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            
            if(pos==0){
                insertarPrimero(dato);
            }else if(pos==cuantosElementos()){
                insertarUltimo(dato);
            }else{
                while(aux!=null){
                    if (pos == contador){
                        auxDato=new Nodo<>(dato, aux);
                        anterior.setSiguiente(auxDato);
                    }
                    
                    anterior=aux;
                    
                    contador++;
                    aux=aux.getSiguiente();
                }
            }
        }
        
    }
    
    public void modificarDato(int pos, T dato){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    aux.setDato(dato); 
                }
                cont++;
                aux=aux.getSiguiente(); 
            }
        }
        
    }

    public void borraPosicion(int pos){

        Nodo<T> aux=primero;
        Nodo<T> anterior=null;
        int contador=0;

        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == contador){
                    if (anterior==null){
                        primero = primero.getSiguiente();
                    }else {
                        anterior.setSiguiente(aux.getSiguiente());
                    }
                    aux=null;
                }else{
                    anterior=aux;
                    aux=aux.getSiguiente();
                    contador++;
                }
            }
        }
    }

    public T devolverYBorrarPrimero(){

        T dato=devolverPrimero();
        quitarPrimero();
        return dato;
    }

    public int indexOf (T t){

       Nodo<T> aux=primero;
       if (estaVacia()){
            return -1;
       }else{
           int contador=0;
           boolean encontrado=false;
           
           while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   encontrado=true;
               }else{
                    contador++;
                    aux=aux.getSiguiente(); 
               }
           }
           if(encontrado){
                return contador;
           }else{
                return -1;
           }
       }
    }
    
  
    public int indexOf (T t, int pos){

       Nodo<T> aux;
       if (estaVacia()){
            return -1;
       }else{
           int contador=pos;
           boolean encontrado=false;
           
           aux=devolverNodo(pos);
           
            while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   encontrado=true;
               }else{
                    contador++;
                    aux=aux.getSiguiente();
               }
            }
            if(encontrado){
                return contador;
            }else{
                return -1;
            }
       }
    }

    public boolean datoExistente(T t){

        boolean existe=false;

        Nodo<T> aux=primero;

        while(aux!=null && !existe){

            if(aux.getDato().equals(t)){
                existe=true;
            }
            
            aux=aux.getSiguiente();
        }

        return existe;
    }
    
    public void mostrar(){
        System.out.println("Contenido de la lista");
        System.out.println("---------------------");
        
        Nodo<T> aux=primero;
        
        while(aux!=null){
            System.out.println(aux.getDato());//mostramos el dato
            aux=aux.getSiguiente();
        }
    }
    
    @Override
    public String toString(){
        
        String contenido="";
        Nodo<T> aux=primero;
        
        while(aux!=null){
            contenido=aux.getDato()+"\n"; 
            aux=aux.getSiguiente();
        }
        
        return contenido;
    }

        
    
    
    
    
    public class Nodo<T> {
   
    private T dato;
    private Nodo<T> siguiente;

    public Nodo(){
        siguiente=null;
     }

    public Nodo(T p){
        siguiente=null;
        dato = p;
    }

   
    public Nodo(T t, Nodo<T> siguiente){
        this.siguiente=siguiente;
        dato = t;
    }
    
    public T getDato() {
        return dato;
    }

    public void setDato(T dato) {
        this.dato = dato;
    }

    public Nodo<T> getSiguiente() {
        return siguiente;
    }

    public void setSiguiente(Nodo<T> siguiente) {
        this.siguiente = siguiente;
    }
    
}


    
}
   

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
                int caso = sc.nextInt();
		ListaEnlazada<Integer> list = new ListaEnlazada<>();

		for(int i = 0; i < caso; i++){
			int ncartas = sc.nextInt();
			int jugadores = sc.nextInt();	

			int[] cartas = new int[ncartas];
			int[] nJugadores = new int [jugadores];

			for( int j=0; j < ncartas; j++ ){
				cartas[j] = sc.nextInt();
			}

			for( int p = 0; p < ncartas; p++ ){
				list.introducirDato(p,cartas[p] );
			}

			int aux1 = 0;
			
			while( !list.estaVacia()){
				int nPrimero = list.devolverPrimero();
				int nUltimo = list.devolverUltimo();
				int mayor;
				if( nPrimero > nUltimo ){
					mayor = nPrimero;
					list.quitarPrimero();
							
				}else {
					mayor = nUltimo;
					list.quitarUltimo();
					
				}
				int count = ( aux1 % jugadores );
					nJugadores[count] = nJugadores[count] + mayor;
				aux1++;
			}	

			int auxMayor = 0;
			for(int j = 0; j < nJugadores.length; j++ ){
				if( auxMayor < nJugadores[j] ){
					auxMayor = nJugadores[j];
				}
			}				
			
			int []array = new int[jugadores];
			int count = 0;
			for (int h = 0; h < jugadores ; h++ ){
				if (auxMayor == nJugadores[h] ){
					array[count] = h+1 ;
					count++;
				}
			}
			System.out.println("Caso #"+ (i+1) + ":");
			int newSizeArray = array.length - 1 ;
			int aux = 0;
			while ( newSizeArray >= 0 ){
				if ( array[aux] != 0 ){
					System.out.print( array[aux] );
				}
				if( aux != array.length  && array[aux] != 0){
					System.out.print(" ");
				}
					
				
				aux++;
				newSizeArray--;
			}
			System.out.println("");
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.*;
public class MainC {
       public static class ListaEnlazada<T>{
   
    private Nodo<T> primero;

    public ListaEnlazada(){
        listaVacia();
    }

    private void listaVacia(){
        primero = null;
    }

    public boolean estaVacia(){
        return primero == null;
    }

    public void insertarPrimero(T t){
        Nodo<T> nuevo = new Nodo<>(t);

        if (!estaVacia()){
            nuevo.setSiguiente(primero);
        }
        
        primero=nuevo;
        
    }

    public void insertarUltimo(T t){

        Nodo<T> aux = new Nodo<>(t);
        Nodo<T> rec_aux;

        if (estaVacia()) {
            insertarPrimero(t);
        }else {
            rec_aux = primero;
            
            while(rec_aux.getSiguiente() != null){
                rec_aux=rec_aux.getSiguiente();
            } 
                
            rec_aux.setSiguiente(aux);
        }
    }

    public void quitarPrimero(){
        Nodo<T> aux;
        if (!estaVacia()){
            aux=primero;
            primero = primero.getSiguiente();
            aux=null; 
        }
    }

    public void quitarUltimo(){
        Nodo<T> aux=primero;
        if(aux.getSiguiente()==null)
           listaVacia();
        if(!estaVacia()) {
            aux=primero;
            
            while(aux.getSiguiente().getSiguiente() != null){
                aux=aux.getSiguiente();
            }
            
            aux.setSiguiente(null);
        }

    }        

    public T devolverUltimo(){
        T elemen = null;
        Nodo<T> aux;
        if (!estaVacia()){
            aux = primero;
            
            while(aux.getSiguiente() != null){
                aux = aux.getSiguiente();
            }
            elemen = aux.getDato();
        }
        return elemen;
    }

    public T devolverPrimero(){
        T elemen = null;
        if (!estaVacia()){
            elemen = primero.getDato();
        }
        return  elemen;
    }

    public int cuantosElementos(){
        Nodo<T> aux;
        int numElementos=0;
        aux = primero;

        while(aux != null){
            numElementos++;
            aux = aux.getSiguiente();
        }
        return numElementos;

    }
    
    public T devolverDato(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        T dato=null;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    dato=aux.getDato();
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return dato;
        
    }
    
    public Nodo<T> devolverNodo(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    return aux; 
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return aux;
        
    }
    
    public void introducirDato(int pos, T dato){
        Nodo<T> aux=primero;
        Nodo<T> auxDato=null;
        Nodo<T> anterior=primero; 
        
        int contador=0;
        
        if(pos<0 || pos>cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            
            if(pos==0){
                insertarPrimero(dato);
            }else if(pos==cuantosElementos()){
                insertarUltimo(dato);
            }else{
                while(aux!=null){
                    if (pos == contador){
                        auxDato=new Nodo<>(dato, aux);
                        anterior.setSiguiente(auxDato);
                    }
                    
                    anterior=aux;
                    
                    contador++;
                    aux=aux.getSiguiente();
                }
            }
        }
        
    }
    
    public void modificarDato(int pos, T dato){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    aux.setDato(dato); 
                }
                cont++;
                aux=aux.getSiguiente(); 
            }
        }
        
    }

    public void borraPosicion(int pos){

        Nodo<T> aux=primero;
        Nodo<T> anterior=null;
        int contador=0;

        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == contador){
                    if (anterior==null){
                        primero = primero.getSiguiente();
                    }else {
                        anterior.setSiguiente(aux.getSiguiente());
                    }
                    aux=null;
                }else{
                    anterior=aux;
                    aux=aux.getSiguiente();
                    contador++;
                }
            }
        }
    }

    public T devolverYBorrarPrimero(){

        T dato=devolverPrimero();
        quitarPrimero();
        return dato;
    }

    public int indexOf (T t){

       Nodo<T> aux=primero;
       if (estaVacia()){
            return -1;
       }else{
           int contador=0;
           boolean encontrado=false;
           
           while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   encontrado=true;
               }else{
                    contador++;
                    aux=aux.getSiguiente(); 
               }
           }
           if(encontrado){
                return contador;
           }else{
                return -1;
           }
       }
    }
    
  
    public int indexOf (T t, int pos){

       Nodo<T> aux;
       if (estaVacia()){
            return -1;
       }else{
           int contador=pos;
           boolean encontrado=false;
           
           aux=devolverNodo(pos);
           
            while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   encontrado=true;
               }else{
                    contador++;
                    aux=aux.getSiguiente();
               }
            }
            if(encontrado){
                return contador;
            }else{
                return -1;
            }
       }
    }

    public boolean datoExistente(T t){

        boolean existe=false;

        Nodo<T> aux=primero;

        while(aux!=null && !existe){

            if(aux.getDato().equals(t)){
                existe=true;
            }
            
            aux=aux.getSiguiente();
        }

        return existe;
    }
    
    public void mostrar(){
        System.out.println("Contenido de la lista");
        System.out.println("---------------------");
        
        Nodo<T> aux=primero;
        
        while(aux!=null){
            System.out.println(aux.getDato());
            aux=aux.getSiguiente();
        }
    }
    
    @Override
    public String toString(){
        
        String contenido="";
        Nodo<T> aux=primero;
        
        while(aux!=null){
            contenido=aux.getDato()+"\n"; 
            aux=aux.getSiguiente();
        }
        
        return contenido;
    }

        
    
    
    
    
    public class Nodo<T> {
   
    private T dato;
    private Nodo<T> siguiente;

    public Nodo(){
        siguiente=null;
     }

    public Nodo(T p){
        siguiente=null;
        dato = p;
    }

   
    public Nodo(T t, Nodo<T> siguiente){
        this.siguiente=siguiente;
        dato = t;
    }
    
    public T getDato() {
        return dato;
    }

    public void setDato(T dato) {
        this.dato = dato;
    }

    public Nodo<T> getSiguiente() {
        return siguiente;
    }

    public void setSiguiente(Nodo<T> siguiente) {
        this.siguiente = siguiente;
    }
    
}


    
}
   

    public static void main(String[] args) {
        
    
        Scanner sc = new Scanner ( System.in );
        
        int nMujeres;
        int nCualidades;
        nCualidades = sc.nextInt();
        sc.nextLine();
        String cualidades = sc.nextLine();
        String[] cualiStrs = cualidades.split(" ");
        int[] cualiNumbers = new int[nCualidades];
        
        for ( int i = 0; i < cualiStrs.length; i++ ){
            cualiNumbers[i] = Integer.parseInt(cualiStrs[i]);
        }
       
        
        ListaEnlazada<Integer> listCualidades = new ListaEnlazada<>();
        for ( int i = 0; i < cualiNumbers.length; i++){
            listCualidades.introducirDato(i,cualiNumbers[i]);
            
        }
        
        
        
        nMujeres = sc.nextInt();
        sc.nextLine();
        int count = 0;
	
        ListaEnlazada<Integer> list = new ListaEnlazada<>();
        
        while ( nMujeres != 0 ){
            
        	int countAux = 0;     
            String cualiMujeres = sc.nextLine();
            String[] auxCualiMujeres = cualiMujeres.split(" ");
            int[] auxCualiMujeres2 = new int[((cualiMujeres.length())/2) + 1];
            
            for ( int i = 0; i < auxCualiMujeres.length; i++ ){
                auxCualiMujeres2[i] = Integer.parseInt(auxCualiMujeres[i]);
            }
            
            for ( int i = 0; i < auxCualiMujeres2.length; i++ ){
                list.introducirDato(i, auxCualiMujeres2[i]);
            }
            
      
            for(int e = 0; e<listCualidades.cuantosElementos() ;e++){
				for(int f =0; f<list.cuantosElementos();f++){
					if(listCualidades.devolverDato(e) == list.devolverDato(f)){
				
						countAux++;
					}	
				}	
			}

			
			if(countAux == listCualidades.cuantosElementos()){
				count++;
			}
            
                list.listaVacia();
        nMujeres--;
        }
        

        System.out.println(count);
    
    
    
   
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>



import java.util.*;
public class MainB{
    
    public static class ListaEnlazada<T>{
   
    private Nodo<T> primero;

    public ListaEnlazada(){
        listaVacia();
    }

    private void listaVacia(){
        primero = null;
    }

    public boolean estaVacia(){
        return primero == null;
    }

    public void insertarPrimero(T t){
        Nodo<T> nuevo = new Nodo<>(t);

        if (!estaVacia()){
            nuevo.setSiguiente(primero);
        }
        
        primero=nuevo;
        
    }

    public void insertarUltimo(T t){

        Nodo<T> aux = new Nodo<>(t);
        Nodo<T> rec_aux;

        if (estaVacia()) {
            insertarPrimero(t);
        }else {
            rec_aux = primero;
            
            while(rec_aux.getSiguiente() != null){
                rec_aux=rec_aux.getSiguiente();
            } 
                
            rec_aux.setSiguiente(aux);
        }
    }

    public void quitarPrimero(){
        Nodo<T> aux;
        if (!estaVacia()){
            aux=primero;
            primero = primero.getSiguiente();
            aux=null; 
        }
    }

    public void quitarUltimo(){
        Nodo<T> aux=primero;
        if(aux.getSiguiente()==null)
           listaVacia();
        if(!estaVacia()) {
            aux=primero;
            
            while(aux.getSiguiente().getSiguiente() != null){
                aux=aux.getSiguiente();
            }
            
            aux.setSiguiente(null);
        }

    }        

    public T devolverUltimo(){
        T elemen = null;
        Nodo<T> aux;
        if (!estaVacia()){
            aux = primero;
            
            while(aux.getSiguiente() != null){
                aux = aux.getSiguiente();
            }
            elemen = aux.getDato();
        }
        return elemen;
    }

    public T devolverPrimero(){
        T elemen = null;
        if (!estaVacia()){
            elemen = primero.getDato();
        }
        return  elemen;
    }

    public int cuantosElementos(){
        Nodo<T> aux;
        int numElementos=0;
        aux = primero;

        while(aux != null){
            numElementos++;
            aux = aux.getSiguiente();
        }
        return numElementos;

    }
    
    public T devolverDato(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        T dato=null;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    dato=aux.getDato();
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return dato;
        
    }
    
    public Nodo<T> devolverNodo(int pos){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    return aux; 
                }
                
                aux=aux.getSiguiente();
                cont++;
                
            }
        }
        
        return aux;
        
    }
    
    public void introducirDato(int pos, T dato){
        Nodo<T> aux=primero;
        Nodo<T> auxDato=null;
        Nodo<T> anterior=primero; 
        
        int contador=0;
        
        if(pos<0 || pos>cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            
            if(pos==0){
                insertarPrimero(dato);
            }else if(pos==cuantosElementos()){
                insertarUltimo(dato);
            }else{
                while(aux!=null){
                    if (pos == contador){
                        auxDato=new Nodo<>(dato, aux);
                        anterior.setSiguiente(auxDato);
                    }
                    
                    anterior=aux;
                    
                    contador++;
                    aux=aux.getSiguiente();
                }
            }
        }
        
    }
    
    public void modificarDato(int pos, T dato){
        Nodo<T> aux=primero;
        int cont=0;
        
        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == cont){
                    aux.setDato(dato); 
                }
                cont++;
                aux=aux.getSiguiente(); 
            }
        }
        
    }

    public void borraPosicion(int pos){

        Nodo<T> aux=primero;
        Nodo<T> anterior=null;
        int contador=0;

        if(pos<0 || pos>=cuantosElementos()){
            System.out.println("La posicion insertada no es correcta");
        }else{
            while(aux!=null){
                if (pos == contador){
                    if (anterior==null){
                        primero = primero.getSiguiente();
                    }else {
                        anterior.setSiguiente(aux.getSiguiente());
                    }
                    aux=null;
                }else{
                    anterior=aux;
                    aux=aux.getSiguiente();
                    contador++;
                }
            }
        }
    }

    public T devolverYBorrarPrimero(){

        T dato=devolverPrimero();
        quitarPrimero();
        return dato;
    }

    public int indexOf (T t){

       Nodo<T> aux=primero;
       if (estaVacia()){
            return -1;
       }else{
           int contador=0;
           boolean encontrado=false;
           
           while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   encontrado=true;
               }else{
                    contador++;
                    aux=aux.getSiguiente(); 
               }
           }
           if(encontrado){
                return contador;
           }else{
                return -1;
           }
       }
    }
    
  
    public int indexOf (T t, int pos){

       Nodo<T> aux;
       if (estaVacia()){
            return -1;
       }else{
           int contador=pos;
           boolean encontrado=false;
           
           aux=devolverNodo(pos);
           
            while(aux!=null && !encontrado){
               if(t.equals(aux.getDato())){
                   encontrado=true;
               }else{
                    contador++;
                    aux=aux.getSiguiente();
               }
            }
            if(encontrado){
                return contador;
            }else{
                return -1;
            }
       }
    }

    public boolean datoExistente(T t){

        boolean existe=false;

        Nodo<T> aux=primero;

        while(aux!=null && !existe){

            if(aux.getDato().equals(t)){
                existe=true;
            }
            
            aux=aux.getSiguiente();
        }

        return existe;
    }
    
    public void mostrar(){
        System.out.println("Contenido de la lista");
        System.out.println("---------------------");
        
        Nodo<T> aux=primero;
        
        while(aux!=null){
            System.out.println(aux.getDato());//mostramos el dato
            aux=aux.getSiguiente();
        }
    }
    
    @Override
    public String toString(){
        
        String contenido="";
        Nodo<T> aux=primero;
        
        while(aux!=null){
            contenido=aux.getDato()+"\n"; 
            aux=aux.getSiguiente();
        }
        
        return contenido;
    }

        
    
    
    
    
    public class Nodo<T> {
   
    private T dato;
    private Nodo<T> siguiente;

    public Nodo(){
        siguiente=null;
     }

    public Nodo(T p){
        siguiente=null;
        dato = p;
    }

   
    public Nodo(T t, Nodo<T> siguiente){
        this.siguiente=siguiente;
        dato = t;
    }
    
    public T getDato() {
        return dato;
    }

    public void setDato(T dato) {
        this.dato = dato;
    }

    public Nodo<T> getSiguiente() {
        return siguiente;
    }

    public void setSiguiente(Nodo<T> siguiente) {
        this.siguiente = siguiente;
    }
    
}


    
}
   

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
                int caso = sc.nextInt();
		ListaEnlazada<Integer> list = new ListaEnlazada<>();

		for(int i = 0; i < caso; i++){
			int ncartas = sc.nextInt();
			int jugadores = sc.nextInt();	

			int[] cartas = new int[ncartas];
			int[] nJugadores = new int [jugadores];

			for( int j=0; j < ncartas; j++ ){
				cartas[j] = sc.nextInt();
			}

			for( int p = 0; p < ncartas; p++ ){
				list.introducirDato(p,cartas[p] );
			}

			int aux1 = 0;
			
			while( !list.estaVacia()){
				int nPrimero = list.devolverPrimero();
				int nUltimo = list.devolverUltimo();
				int mayor;
				if( nPrimero > nUltimo ){
					mayor = nPrimero;
					list.quitarPrimero();
							
				}else {
					mayor = nUltimo;
					list.quitarUltimo();
					
				}
				int count = ( aux1 % jugadores );
					nJugadores[count] = nJugadores[count] + mayor;
				aux1++;
			}	

			int auxMayor = 0;
			for(int j = 0; j < nJugadores.length; j++ ){
				if( auxMayor < nJugadores[j] ){
					auxMayor = nJugadores[j];
				}
			}				
			
			int []array = new int[jugadores];
			int count = 0;
			for (int h = 0; h < jugadores ; h++ ){
				if (auxMayor == nJugadores[h] ){
					array[count] = h+1 ;
					count++;
				}
			}
			System.out.println("Caso #"+ (i+1) + ":");
			int newSizeArray = array.length - 1 ;
			int aux = 0;
			while ( newSizeArray >= 0 ){
				if ( array[aux] != 0 ){
					System.out.print( array[aux] );
				}
				if( aux != array.length  && array[aux] != 0){
					System.out.print(" ");
				}
					
				
				aux++;
				newSizeArray--;
			}
			System.out.println("");
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.Scanner;

public class MainA {
    
    static public class ListaEnlazada {
    
        private Nodo cabeza;
        private int costoList = 0;
        private int costoArray = 0;
        public boolean auxBoolean = true;
        
        class Nodo {
            int data;
            Nodo next;
        }
    
    
        
        public int getCostoList(){
        return costoList;
        }
    
        int getCostoArray(){
        return costoArray;
        }
    
        public ListaEnlazada () {
        cabeza = null;
        }
        
        public int tamanno(){
        int auxTamano = 0;
        Nodo i = cabeza;
            while ( i!=null ){
                i = i.next;
                auxTamano++;
            }
        return auxTamano;
        }
        
        void definirArray( int[]array, int idx ){
            int []aux = new int[ idx*2 ];
            for(int i = 0; i < idx*2; i++ ){
                aux[i] = -1;
            }
        
            for(int i = 0; i < idx; i++ ){
                aux[i] = array[i];
            }
        array = aux;
        }
    
        void recorrerArray( int[]array, int posicion, int idx){
        int count = 0;
        for(int i = idx; i > posicion; i-- ){
           array[i] = array[i-1];
           count++;
           
        }
        costoArray = costoArray + ( count - 1 );
        }
        
        void eliminarArray(int[]array ,int posicion,int idx){
            if( ( posicion <= idx ) && ( posicion >= 0 ) ){
                int count = 0;
                for(int i= posicion; i < idx; i++ ){
                    array[i] = array[ i+1 ] ;
                    count++;
                }
                array[idx] = -1;
                if( posicion == 0 ){
                    costoArray = costoArray + (count);
                }
                else{
                    costoArray = costoArray + (count);
                }
            }
        }
        
        
        void buscarArray( int[]array, int dato, int idx ){
            int count = 0;
            for(int x = 0; x < idx; x++ ){
                count++;
                if( array[x] == dato ){
                    costoArray = costoArray + count;
                    x = idx;
                }
                if( array[x] != dato && x == ( idx - 1 ) ){
                    costoArray = costoArray + count;
                }
            }
        }
        
        
        
        void insertar (int dato, int posicion){   
            if (posicion <= tamanno() && posicion >= 0 ){
                Nodo nuevo = new Nodo ();
                nuevo.data = dato;
                if (posicion == 0){
                    nuevo.next = cabeza;
                    cabeza = nuevo;
                }else{
                    if (posicion == tamanno ()){
                        Nodo i = cabeza;
                   
                        while (i.next != null) {
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        i.next = nuevo;
                        nuevo.next = null;
                    }else{
                        Nodo i = cabeza;
                        for (int x = 1; x < posicion ; x++){
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        Nodo siguiente = i.next;
                        i.next = nuevo;
                        nuevo.next = siguiente;
                    }
                }
                System.out.println("insertar: posicion valida");
            }else{
            System.out.println("insertar: posicion invalida");
            }   
        }
        
        
        void buscar(int dato){
            int aux = 0;
            boolean auxBool = true;
            Nodo i = cabeza;
            while( i != null && i.data != dato){
                 i = i.next;
                 aux++;
            }
            if( i != null ){
                System.out.println("buscar: " + aux);
                costoList = costoList + (aux+1);
            }else{
                System.out.println("no existe numero");
                costoList = costoList + tamanno();
            }
        }
        
        
        
        void consultar(int posicion){
            Nodo i = cabeza;
            if( posicion < tamanno() && posicion >= 0 && cabeza != null ){
                for(int x=0;x<posicion;x++){
                    i=i.next;
                    costoList++;
                }
                System.out.println("consulta: "+i.data);
            }else{
                System.out.println("consulta: no encontrado");
            }
        }
        
        
        
    
        void eliminar(int posicion){
            Nodo i = cabeza;
            boolean auxBoolTwo = true;
            if(posicion == 0 && cabeza != null ){
                auxBoolean = false;
                cabeza = cabeza.next;
                System.out.println("eliminar: posicion valida");
                auxBoolTwo = false;
            }
            if(posicion < tamanno() && posicion > 0){
                for( int x = 1; x < posicion; x++ ){
                     i = i.next;
                     costoList++;
                }
                auxBoolean = false;
                Nodo siguiente = i.next;
                i.next = siguiente.next;
                System.out.println("eliminar: posicion valida");
            }else{
                if(auxBoolTwo == true){
                    System.out.println("eliminar: posicion invalida");
                }
            }
        }
    
    
}

    public static void main(String[] ar) {
        Scanner sc = new Scanner( System.in );
        int casos = sc.nextInt();
        String comando;
        
        for(int u = 0; u < casos; u++ ){
            System.out.println( "Caso #" + (u+1) + ":" );
            int instruccion = sc.nextInt();
            ListaEnlazada list = new ListaEnlazada();
            int indice = 0;
            int[] array = new int[20];
            int tamano;
            for( int i = 0; i < 20 ; i++ ){
            array[i] = -1;
            }
         
            
            for( int i=0 ; i < instruccion ; i++ ){
                comando = sc.next();
                if( "insertar".equals(comando) ){
                    int dato = sc.nextInt();
                    int posicion = sc.nextInt();
                    list.insertar( dato, posicion );
                    if( posicion <= list.tamanno() ){
                        indice++;
                        tamano =  array.length;
                        if( indice == tamano ){
                        list.definirArray( array, indice );
                        }
                        if( array[posicion] == -1 ){
                            array[posicion] = dato;
                        }
                        else{
                        list.recorrerArray( array, posicion, indice );
                        array[posicion] = dato;
                        }
                    }
                }
                if("buscar".equals(comando)){
                    int datoAux = sc.nextInt();
                    list.buscar( datoAux );
                    list.buscarArray( array, datoAux, indice );
                }
                if("eliminar".equals( comando )){
                    int posicionAux = sc.nextInt();
                    list.eliminar( posicionAux );
                    if( list.auxBoolean == false ){
                        indice--;
                        list.auxBoolean = true;
                    }
                    list.eliminarArray( array, posicionAux, indice );
                }
                if("consultar".equals( comando )){
                    int pos = sc.nextInt();
                    list.consultar( pos );
                }
                if("costo".equals( comando )){
                    System.out.println("costo: " + list.getCostoArray() + " " + list.getCostoList());
                }
            }
        }                    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.Scanner;

public class MainA {
    
    static public class ListaEnlazada {
    
        private Nodo cabeza;
        private int costoList = 0;
        private int costoArray = 0;
        public boolean auxBoolean = true;
        
        class Nodo {
            int data;
            Nodo next;
        }
    
    
        
        public int getCostoList(){
        return costoList;
        }
    
        int getCostoArray(){
        return costoArray;
        }
    
        public ListaEnlazada () {
        cabeza = null;
        }
        
        public int tamanno(){
        int auxTamano = 0;
        Nodo i = cabeza;
            while ( i!=null ){
                i = i.next;
                auxTamano++;
            }
        return auxTamano;
        }
        
        void definirArray( int[]array, int idx ){
            int []aux = new int[ idx*2 ];
            for(int i = 0; i < idx*2; i++ ){
                aux[i] = -1;
            }
        
            for(int i = 0; i < idx; i++ ){
                aux[i] = array[i];
            }
        array = aux;
        }
    
        void recorrerArray( int[]array, int posicion, int idx){
        int count = 0;
        for(int i = idx; i > posicion; i-- ){
           array[i] = array[i-1];
           count++;
           
        }
        costoArray = costoArray + ( count - 1 );
        }
        
        void eliminarArray(int[]array ,int posicion,int idx){
            if( ( posicion <= idx ) && ( posicion >= 0 ) ){
                int count = 0;
                for(int i= posicion; i < idx; i++ ){
                    array[i] = array[ i+1 ] ;
                    count++;
                }
                array[idx] = -1;
                if( posicion == 0 ){
                    costoArray = costoArray + (count);
                }
                else{
                    costoArray = costoArray + (count);
                }
            }
        }
        
        
        void buscarArray( int[]array, int dato, int idx ){
            int count = 0;
            for(int x = 0; x < idx; x++ ){
                count++;
                if( array[x] == dato ){
                    costoArray = costoArray + count;
                    x = idx;
                }
                if( array[x] != dato && x == ( idx - 1 ) ){
                    costoArray = costoArray + count;
                }
            }
        }
        
        
        
        void insertar (int dato, int posicion){   
            if (posicion <= tamanno() && posicion >= 0 ){
                Nodo nuevo = new Nodo ();
                nuevo.data = dato;
                if (posicion == 0){
                    nuevo.next = cabeza;
                    cabeza = nuevo;
                }else{
                    if (posicion == tamanno ()){
                        Nodo i = cabeza;
                   
                        while (i.next != null) {
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        i.next = nuevo;
                        nuevo.next = null;
                    }else{
                        Nodo i = cabeza;
                        for (int x = 1; x < posicion ; x++){
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        Nodo siguiente = i.next;
                        i.next = nuevo;
                        nuevo.next = siguiente;
                    }
                }
                System.out.println("insertar: posicion valida");
            }else{
            System.out.println("insertar: posicion invalida");
            }   
        }
        
        
        void buscar(int dato){
            int aux = 0;
            boolean auxBool = true;
            Nodo i = cabeza;
            while( i != null && i.data != dato){
                 i = i.next;
                 aux++;
            }
            if( i != null ){
                System.out.println("buscar: " + aux);
                costoList = costoList + (aux+1);
            }else{
                System.out.println("no existe numero");
                costoList = costoList + tamanno();
            }
        }
        
        
        
        void consultar(int posicion){
            Nodo i = cabeza;
            if( posicion < tamanno() && posicion >= 0 && cabeza != null ){
                for(int x=0;x<posicion;x++){
                    i=i.next;
                    costoList++;
                }
                System.out.println("consulta: "+i.data);
            }else{
                System.out.println("consulta: no encontrado");
            }
        }
        
        
        
    
        void eliminar(int posicion){
            Nodo i = cabeza;
            boolean auxBoolTwo = true;
            if(posicion == 0 && cabeza != null ){
                auxBoolean = false;
                cabeza = cabeza.next;
                System.out.println("eliminar: posicion valida");
                auxBoolTwo = false;
            }
            if(posicion < tamanno() && posicion > 0){
                for( int x = 1; x < posicion; x++ ){
                     i = i.next;
                     costoList++;
                }
                auxBoolean = false;
                Nodo siguiente = i.next;
                i.next = siguiente.next;
                System.out.println("eliminar: posicion valida");
            }else{
                if(auxBoolTwo == true){
                    System.out.println("eliminar: posicion invalida");
                }
            }
        }
    
    
}

    public static void main(String[] ar) {
        Scanner sc = new Scanner( System.in );
        int casos = sc.nextInt();
        String comando;
        
        for(int u = 0; u < casos; u++ ){
            System.out.println( "Caso #" + (u+1) + ":" );
            int instruccion = sc.nextInt();
            ListaEnlazada list = new ListaEnlazada();
            int indice = 0;
            int[] array = new int[100];
            int tamano;
            for( int i = 0; i < 100 ; i++ ){
            array[i] = -1;
            }
         
            
            for( int i=0 ; i < instruccion ; i++ ){
                comando = sc.next();
                if( "insertar".equals(comando) ){
                    int dato = sc.nextInt();
                    int posicion = sc.nextInt();
                    list.insertar( dato, posicion );
                    if( posicion <= list.tamanno() ){
                        indice++;
                        tamano =  array.length;
                        if( indice == tamano ){
                        list.definirArray( array, indice );
                        }
                        if( array[posicion] == -1 ){
                            array[posicion] = dato;
                        }
                        else{
                        list.recorrerArray( array, posicion, indice );
                        array[posicion] = dato;
                        }
                    }
                }
                if("buscar".equals(comando)){
                    int datoAux = sc.nextInt();
                    list.buscar( datoAux );
                    list.buscarArray( array, datoAux, indice );
                }
                if("eliminar".equals( comando )){
                    int posicionAux = sc.nextInt();
                    list.eliminar( posicionAux );
                    if( list.auxBoolean == false ){
                        indice--;
                        list.auxBoolean = true;
                    }
                    list.eliminarArray( array, posicionAux, indice );
                }
                if("consultar".equals( comando )){
                    int pos = sc.nextInt();
                    list.consultar( pos );
                }
                if("costo".equals( comando )){
                    System.out.println("costo: " + list.getCostoArray() + " " + list.getCostoList());
                }
            }
        }                    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;

public class PuntoB {
    
    
    

	public static void main(String[] args) {

		
		Scanner sc = new Scanner(System.in);
		int n= sc.nextInt();
		for(int b=1; b<=n; b++){
			 
		int intCartas;
                int nJugadores;
		intCartas = sc.nextInt();
		
                nJugadores = sc.nextInt();
		
                int[] nCartas= new int[nJugadores];
                int[] cartas = new int[intCartas];
                int[] numeroCartas = new int[intCartas];
                
		for(int i=0; i<intCartas; i++){
			cartas[i]=sc.nextInt();
		}
		 int cj = 0;
		 int ct = 0;
		 int ch = intCartas-1;
                 
		for(int i=0; i<intCartas; i++){
			
			if(cartas[ch]>=cartas[ct]){
				nCartas[cj]=nCartas[cj]+cartas[ch];
				ch--;
			}else{
				nCartas[cj]=nCartas[cj]+cartas[ct];
				ct++;
			}
			cj++;
			if(cj>=nJugadores){
				cj=0;
			};
			if(ch<ct){
				break;
			}
		}
		int maximo=0;
                int i = 0;
		while( i<nJugadores ){
			if(nCartas[i]>maximo){
				maximo=nCartas[i];
			}
                        i++;
		}
		
		System.out.println("Caso #"+b+":");
		int m=1;
		for(int k=0; k<nJugadores; k++){
			if(nCartas[k]==maximo){
				System.out.print(m+" ");
			}
			m++;
		}
		System.out.println();
		
		

	}
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;

public class MainE {
public static class Persona{

	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}
public static class Registrada {
	private long cedula;
	private int entradas;
	public Registrada(long cedula){
		this.cedula=cedula;
		this.entradas=1; 
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	public int getEntradas() {
		return entradas;
	}
	public void setEntradas(int entradas) {
		this.entradas = entradas;
	} 

}

public static void remove(long cedula,LinkedList<LinkedList<Persona>> gimnacio ){
	String nom;
	loop:
		for (int i = 0; i < gimnacio.size(); i++) {
		int j = 0;	
                    while ( j < gimnacio.get(i).size() ) {
				if(!gimnacio.get(i).isEmpty()){
					if(gimnacio.get(i).get(j).getCedula()==cedula){
						nom=gimnacio.get(i).get(j).getNombre();
						System.out.println(nom);
						gimnacio.get(i).remove(j);
						break loop;
					}
				}
			j++;	
			}
		}
	}
	
public static void add(LinkedList<LinkedList<Persona>> gimnacio, double[] tamanno, String nombre, long cedula,String apellido, 
																					LinkedList<Registrada> registro){
		
		boolean registrado=false; 
		double[] cap= new double[tamanno.length];
		for (int i = 0; i < gimnacio.size(); i++) {
			cap[i]=(gimnacio.get(i).size())/tamanno[i];
		}
		double cargaMin=cap[0];
                int i = 1; 
		while(i < gimnacio.size() ) {
			if(cargaMin>cap[i]){
				cargaMin=cap[i]; 
			}
		
                
                i++;
                }
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int i = 0; i < gimnacio.size(); i++) {
				if(cargaMin==cap[i]){
					int j = 0;
					while ( j < registro.size() ) {
						if(registro.get(j).getCedula()==cedula){
							if (registro.get(j).getEntradas()==3) {
								System.out.println("ingreso denegado");
								registrado=true;
								break;
							}else{
								gimnacio.get(i).push( new Persona(nombre, apellido, cedula));
								System.out.println((i+1)+" "+gimnacio.get(i).size());
								registro.get(j).setEntradas(registro.get(j).getEntradas()+1); 
								registrado=true;
								break;
							}
						}
					
                                        j++;
                                        
                                        }
					if(!registrado){
						gimnacio.get(i).push( new Persona(nombre, apellido, cedula));
						System.out.println((i+1)+" "+gimnacio.get(i).size());
						registro.add(new Registrada(cedula)); 
					}
					break;
				}
			}
		
		}
		
	}


public static void main(String[] args) {
		Scanner sc =new  Scanner(System.in); 
                
               boolean falso = false; 
	       int casos= sc.nextInt();
	       for(int  i=0; i<casos;i++){
	    	   System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<Registrada> registro= new LinkedList<Registrada>();  
	    	  LinkedList<LinkedList<Persona>> gym= new LinkedList<LinkedList<Persona>>(); ;
	    	  int nCub= sc.nextInt();
	    	  sc.nextLine();
                  
	    	  StringTokenizer stringCapacidad= new StringTokenizer(sc.nextLine());
	    	  double[] tM = new double[stringCapacidad.toString().length()]; 
	    	  int capacidad=0;
	    	  for (int j = 0; j < nCub; j++) {
	    		  gym.add(new LinkedList<Persona>()); 
	    		  tM[j]=Integer.valueOf(stringCapacidad.nextToken());
	    	  }
	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
	    	  
	    	  int comandos=sc.nextInt(); 
	    	  sc.nextLine();
                  int j = 0;
	    	  while ( j < comandos ) {
	    		  
	    		   stringCapacidad= new  StringTokenizer(sc.nextLine()); 
	    		   String comando=stringCapacidad.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=stringCapacidad.nextToken();
	    			 apellido=stringCapacidad.nextToken();
	    			 cedula= Integer.valueOf(stringCapacidad.nextToken()); 
	    			 add(gym,tM,nombre,cedula,apellido,registro); 
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(stringCapacidad.nextToken());
	    			  remove(exit, gym);
	    		  }
	    	  
                  j++;
                  }
	       
                  
                  
                  
                  
                  
                  
	       }

	}
	

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;

public class MainE {
public static class Persona{

	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}
public static class Registrada {
	private long cedula;
	private int entradas;
	public Registrada(long cedula){
		this.cedula=cedula;
		this.entradas=1; 
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	public int getEntradas() {
		return entradas;
	}
	public void setEntradas(int entradas) {
		this.entradas = entradas;
	} 

}

public static void remove(long cedula,LinkedList<LinkedList<Persona>> gimnacio ){
	String nom;
	loop:
		for (int i = 0; i < gimnacio.size(); i++) {
		int j = 0;	
                    while ( j < gimnacio.get(i).size() ) {
				if(!gimnacio.get(i).isEmpty()){
					if(gimnacio.get(i).get(j).getCedula()==cedula){
						nom=gimnacio.get(i).get(j).getNombre();
						System.out.println(nom);
						gimnacio.get(i).remove(j);
						break loop;
					}
				}
			j++;	
			}
		}
	}
	
public static void add(LinkedList<LinkedList<Persona>> gimnacio, double[] tamanno, String nombre, long cedula,String apellido, 
																					LinkedList<Registrada> registro){
		
		boolean registrado=false; 
		double[] cap= new double[tamanno.length];
		for (int i = 0; i < gimnacio.size(); i++) {
			cap[i]=(gimnacio.get(i).size())/tamanno[i];
		}
		double cargaMin=cap[0];
                int i = 1; 
		while(i < gimnacio.size() ) {
			if(cargaMin>cap[i]){
				cargaMin=cap[i]; 
			}
		
                
                i++;
                }
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int l = 0; l < gimnacio.size(); l++) {
				if(cargaMin==cap[l]){
					int j = 0;
					while ( j < registro.size() ) {
						if(registro.get(j).getCedula()==cedula){
							if (registro.get(j).getEntradas()==3) {
								System.out.println("ingreso denegado");
								registrado=true;
								break;
							}else{
								gimnacio.get(l).push( new Persona(nombre, apellido, cedula));
								System.out.println((l+1)+" "+gimnacio.get(l).size());
								registro.get(j).setEntradas(registro.get(j).getEntradas()+1); 
								registrado=true;
								break;
							}
						}
					
                                        j++;
                                        
                                        }
					if(!registrado){
						gimnacio.get(l).push( new Persona(nombre, apellido, cedula));
						System.out.println((l+1)+" "+gimnacio.get(l).size());
						registro.add(new Registrada(cedula)); 
					}
					break;
				}
			}
		
		}
		
	}


public static void main(String[] args) {
		Scanner sc =new  Scanner(System.in); 
                
               boolean falso = false; 
	       int casos= sc.nextInt();
	       for(int  i=0; i<casos;i++){
	    	   System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<Registrada> registro= new LinkedList<Registrada>();  
	    	  LinkedList<LinkedList<Persona>> gym= new LinkedList<LinkedList<Persona>>(); ;
	    	  int nCub= sc.nextInt();
	    	  sc.nextLine();
                  
	    	  StringTokenizer stringCapacidad= new StringTokenizer(sc.nextLine());
	    	  double[] tM = new double[stringCapacidad.toString().length()]; 
	    	  int capacidad=0;
	    	  for (int j = 0; j < nCub; j++) {
	    		  gym.add(new LinkedList<Persona>()); 
	    		  tM[j]=Integer.valueOf(stringCapacidad.nextToken());
	    	  }
	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
	    	  
	    	  int comandos=sc.nextInt(); 
	    	  sc.nextLine();
                  int j = 0;
	    	  while ( j < comandos ) {
	    		  
	    		   stringCapacidad= new  StringTokenizer(sc.nextLine()); 
	    		   String comando=stringCapacidad.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=stringCapacidad.nextToken();
	    			 apellido=stringCapacidad.nextToken();
	    			 cedula= Integer.valueOf(stringCapacidad.nextToken()); 
	    			 add(gym,tM,nombre,cedula,apellido,registro); 
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(stringCapacidad.nextToken());
	    			  remove(exit, gym);
	    		  }
	    	  
                  j++;
                  }
	       
                  
                  
                  
                  
                  
                  
	       }

	}
	

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;

public class MainE {
public static class Persona{

	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}
public static class Registrada {
	private long cedula;
	private int entradas;
	public Registrada(long cedula){
		this.cedula=cedula;
		this.entradas=1; 
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	public int getEntradas() {
		return entradas;
	}
	public void setEntradas(int entradas) {
		this.entradas = entradas;
	} 

}

public static void remove(long cedula,LinkedList<LinkedList<Persona>> gym ){
	String nom;
	loop:
		for (int i = 0; i < gym.size(); i++) {
			for (int j = 0; j < gym.get(i).size(); j++) {
				if(!gym.get(i).isEmpty()){
					if(gym.get(i).get(j).getCedula()==cedula){
						nom=gym.get(i).get(j).getNombre();
						System.out.println(nom);
						gym.get(i).remove(j);
						break loop;
					}
				}
				
			}
		}
	}
	
public static void add(LinkedList<LinkedList<Persona>> gym, double[] tM, String nombre, long cedula,String apellido, LinkedList<Registrada> registro){
		
		boolean registrado=false; 
		double[] cap= new double[tM.length];
		for (int i = 0; i < gym.size(); i++) {
			cap[i]=(gym.get(i).size())/tM[i];
		}
		double cargaMin=cap[0];
		for (int i = 1; i < gym.size(); i++) {
			if(cargaMin>cap[i]){
				cargaMin=cap[i]; 
			}
		}
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int i = 0; i < gym.size(); i++) {
				if(cargaMin==cap[i]){
					
					for (int j = 0; j < registro.size(); j++) {
						if(registro.get(j).getCedula()==cedula){
							if (registro.get(j).getEntradas()==3) {
								System.out.println("ingreso denegado");
								registrado=true;
								break;
							}else{
								gym.get(i).push( new Persona(nombre, apellido, cedula));
								System.out.println((i+1)+" "+gym.get(i).size());
								registro.get(j).setEntradas(registro.get(j).getEntradas()+1); 
								registrado=true;
								break;
							}
						}
					}
					if(!registrado){
						gym.get(i).push( new Persona(nombre, apellido, cedula));
						System.out.println((i+1)+" "+gym.get(i).size());
						registro.add(new Registrada(cedula)); 
					}
					break;
				}
			}
		
		}
		
	}


public static void main(String[] args) {
		Scanner sc =new  Scanner(System.in); 
                
               boolean falso = false; 
	       int casos= sc.nextInt();
	       for(int  i=0; i<casos;i++){
	    	   System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<Registrada> registro= new LinkedList<Registrada>();  
	    	  LinkedList<LinkedList<Persona>> gym= new LinkedList<LinkedList<Persona>>(); ;
	    	  int nCub= sc.nextInt();
	    	  sc.nextLine();
                  
	    	  StringTokenizer stringCapacidad= new StringTokenizer(sc.nextLine());
	    	  double[] tM = new double[stringCapacidad.toString().length()]; 
	    	  int capacidad=0;
	    	  for (int j = 0; j < nCub; j++) {
	    		  gym.add(new LinkedList<Persona>()); 
	    		  tM[j]=Integer.valueOf(stringCapacidad.nextToken());
	    	  }
	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
	    	  
	    	  int comandos=sc.nextInt(); 
	    	  sc.nextLine();
                  int j = 0;
	    	  while ( j < comandos ) {
	    		  
	    		   stringCapacidad= new  StringTokenizer(sc.nextLine()); 
	    		   String comando=stringCapacidad.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=stringCapacidad.nextToken();
	    			 apellido=stringCapacidad.nextToken();
	    			 cedula= Integer.valueOf(stringCapacidad.nextToken()); 
	    			 add(gym,tM,nombre,cedula,apellido,registro); 
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(stringCapacidad.nextToken());
	    			  remove(exit, gym);
	    		  }
	    	  
                  j++;
                  }
	       
                  
	       }

	}
	

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.Scanner;

public class MainA {
    
    static public class ListaEnlazada {
    
        private Nodo cabeza;
        private int costoList = 0;
        private int costoArray = 0;
        public boolean auxBoolean = true;
        
        class Nodo {
            int data;
            Nodo next;
        }
    
    
        
        public int getCostoList(){
        return costoList;
        }
    
        int getCostoArray(){
        return costoArray;
        }
    
        public ListaEnlazada () {
        cabeza = null;
        }
        
        public int tamanno(){
        int auxTamano = 0;
        Nodo i = cabeza;
            while ( i!=null ){
                i = i.next;
                auxTamano++;
            }
        return auxTamano;
        }
        
        void definirArray( int[]array, int idx ){
            int []aux = new int[ idx*2 ];
            for(int i = 0; i < idx*2; i++ ){
                aux[i] = -1;
            }
        
            for(int i = 0; i < idx; i++ ){
                aux[i] = array[i];
            }
        array = aux;
        }
    
        void recorrerArray( int[]array, int posicion, int idx){
        int count = 0;
        for(int i = idx; i > posicion; i-- ){
           array[i] = array[i-1];
           count++;
           
        }
        costoArray = costoArray + ( count - 1 );
        }
        
        void eliminarArray(int[]array ,int posicion,int idx){
            if( ( posicion <= idx ) && ( posicion >= 0 ) ){
                int count = 0;
                for(int i= posicion; i < idx; i++ ){
                    array[i] = array[ i+1 ] ;
                    count++;
                }
                array[idx] = -1;
                if( posicion == 0 ){
                    costoArray = costoArray + (count);
                }
                else{
                    costoArray = costoArray + (count);
                }
            }
        }
        
        
        void buscarArray( int[]array, int dato, int idx ){
            int count = 0;
            for(int x = 0; x < idx; x++ ){
                count++;
                if( array[x] == dato ){
                    costoArray = costoArray + count;
                    x = idx;
                }
                if( array[x] != dato && x == ( idx - 1 ) ){
                    costoArray = costoArray + count;
                }
            }
        }
        
        
        
        void insertar (int dato, int posicion){   
            if (posicion <= tamanno() && posicion >= 0 ){
                Nodo nuevo = new Nodo ();
                nuevo.data = dato;
                if (posicion == 0){
                    nuevo.next = cabeza;
                    cabeza = nuevo;
                }else{
                    if (posicion == tamanno ()){
                        Nodo i = cabeza;
                   
                        while (i.next != null) {
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        i.next = nuevo;
                        nuevo.next = null;
                    }else{
                        Nodo i = cabeza;
                        for (int x = 1; x < posicion ; x++){
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        Nodo siguiente = i.next;
                        i.next = nuevo;
                        nuevo.next = siguiente;
                    }
                }
                System.out.println("insertar: posicion valida");
            }else{
            System.out.println("insertar: posicion invalida");
            }   
        }
        
        
        void buscar(int dato){
            int aux = 0;
            boolean auxBool = true;
            Nodo i = cabeza;
            while( i != null && i.data != dato){
                 i = i.next;
                 aux++;
            }
            if( i != null ){
                System.out.println("buscar: " + aux);
                costoList = costoList + (aux+1);
            }else{
                System.out.println("no existe numero");
                costoList = costoList + tamanno();
            }
        }
        
        
        
        void consultar(int posicion){
            Nodo i = cabeza;
            if( posicion < tamanno() && posicion >= 0 && cabeza != null ){
                for(int x=0;x<posicion;x++){
                    i=i.next;
                    costoList++;
                }
                System.out.println("consulta: "+i.data);
            }else{
                System.out.println("consulta: no encontrado");
            }
        }
        
        
        
    
        void eliminar(int posicion){
            Nodo i = cabeza;
            boolean auxBoolTwo = true;
            if(posicion == 0 && cabeza != null ){
                auxBoolean = false;
                cabeza = cabeza.next;
                System.out.println("eliminar: posicion valida");
                auxBoolTwo = false;
            }
            if(posicion < tamanno() && posicion > 0){
                for( int x = 1; x < posicion; x++ ){
                     i = i.next;
                     costoList++;
                }
                auxBoolean = false;
                Nodo siguiente = i.next;
                i.next = siguiente.next;
                System.out.println("eliminar: posicion valida");
            }else{
                if(auxBoolTwo == true){
                    System.out.println("eliminar: posicion invalida");
                }
            }
        }
    
    
}

    public static void main(String[] ar) {
        Scanner sc = new Scanner( System.in );
        int casos = sc.nextInt();
        String comando;
        
        for(int u = 0; u < casos; u++ ){
            System.out.println( "Caso #" + (u+1) + ":" );
            int instruccion = sc.nextInt();
            ListaEnlazada list = new ListaEnlazada();
            int indice = 0;
            int[] array = new int[1000];
            int tamano;
            for( int i = 0; i < 1000 ; i++ ){
            array[i] = -1;
            }
         
            
            for( int i=0 ; i < instruccion ; i++ ){
                comando = sc.next();
                if( "insertar".equals(comando) ){
                    int dato = sc.nextInt();
                    int posicion = sc.nextInt();
                    list.insertar( dato, posicion );
                    if( posicion <= list.tamanno() ){
                        indice++;
                        tamano =  array.length;
                        if( indice == tamano ){
                        list.definirArray( array, indice );
                        }
                        if( array[posicion] == -1 ){
                            array[posicion] = dato;
                        }
                        else{
                        list.recorrerArray( array, posicion, indice );
                        array[posicion] = dato;
                        }
                    }
                }
                if("buscar".equals(comando)){
                    int datoAux = sc.nextInt();
                    list.buscar( datoAux );
                    list.buscarArray( array, datoAux, indice );
                }
                if("eliminar".equals( comando )){
                    int posicionAux = sc.nextInt();
                    list.eliminar( posicionAux );
                    if( list.auxBoolean == false ){
                        indice--;
                        list.auxBoolean = true;
                    }
                    list.eliminarArray( array, posicionAux, indice );
                }
                if("consultar".equals( comando )){
                    int pos = sc.nextInt();
                    list.consultar( pos );
                }
                if("costo".equals( comando )){
                    System.out.println("costo: " + list.getCostoArray() + " " + list.getCostoList());
                }
            }
        }                    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.Scanner;

public class MainA {
    
    static public class ListaEnlazada {
    
        private Nodo cabeza;
        private int costoList = 0;
        private int costoArray = 0;
        public boolean auxBoolean = true;
        
        class Nodo {
            int data;
            Nodo next;
        }
    
    
        
        public int getCostoList(){
        return costoList;
        }
    
        int getCostoArray(){
        return costoArray;
        }
    
        public ListaEnlazada () {
        cabeza = null;
        }
        
        public int tamanno(){
        int auxTamano = 0;
        Nodo i = cabeza;
            while ( i!=null ){
                i = i.next;
                auxTamano++;
            }
        return auxTamano;
        }
        
        void definirArray( int[]array, int idx ){
            int []aux = new int[ idx*2 ];
            for(int i = 0; i < idx*2; i++ ){
                aux[i] = -1;
            }
        
            for(int i = 0; i < idx; i++ ){
                aux[i] = array[i];
            }
        array = aux;
        }
    
        void recorrerArray( int[]array, int posicion, int idx){
        int count = 0;
        for(int i = idx; i < posicion; i++ ){
           array[i] = array[i-1];
           count++;
           
        }
        costoArray = costoArray + ( count - 1 );
        }
        
        void eliminarArray(int[]array ,int posicion,int idx){
            if( ( posicion <= idx ) && ( posicion >= 0 ) ){
                int count = 0;
                for(int i= posicion; i < idx; i++ ){
                    array[i] = array[ i+1 ] ;
                    count++;
                }
                array[idx] = -1;
                if( posicion == 0 ){
                    costoArray = costoArray + (count);
                }
                else{
                    costoArray = costoArray + (count);
                }
            }
        }
        
        
        void buscarArray( int[]array, int dato, int idx ){
            int count = 0;
            for(int x = 0; x < idx; x++ ){
                count++;
                if( array[x] == dato ){
                    costoArray = costoArray + count;
                    x = idx;
                }
                if( array[x] != dato && x == ( idx - 1 ) ){
                    costoArray = costoArray + count;
                }
            }
        }
        
        
        
        void insertar (int dato, int posicion){   
            if (posicion <= tamanno() && posicion >= 0 ){
                Nodo nuevo = new Nodo ();
                nuevo.data = dato;
                if (posicion == 0){
                    nuevo.next = cabeza;
                    cabeza = nuevo;
                }else{
                    if (posicion == tamanno ()){
                        Nodo i = cabeza;
                   
                        while (i.next != null) {
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        i.next = nuevo;
                        nuevo.next = null;
                    }else{
                        Nodo i = cabeza;
                        for (int x = 1; x < posicion ; x++){
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        Nodo siguiente = i.next;
                        i.next = nuevo;
                        nuevo.next = siguiente;
                    }
                }
                System.out.println("insertar: posicion valida");
            }else{
            System.out.println("insertar: posicion invalida");
            }   
        }
        
        
        void buscar(int dato){
            int aux = 0;
            boolean auxBool = true;
            Nodo i = cabeza;
            while( i != null && i.data != dato){
                 i = i.next;
                 aux++;
            }
            if( i != null ){
                System.out.println("buscar: " + aux);
                costoList = costoList + (aux+1);
            }else{
                System.out.println("no existe numero");
                costoList = costoList + tamanno();
            }
        }
        
        
        
        void consultar(int posicion){
            Nodo i = cabeza;
            if( posicion < tamanno() && posicion >= 0 && cabeza != null ){
                for(int x=0;x<posicion;x++){
                    i=i.next;
                    costoList++;
                }
                System.out.println("consulta: "+i.data);
            }else{
                System.out.println("consulta: no encontrado");
            }
        }
        
        
        
    
        void eliminar(int posicion){
            Nodo i = cabeza;
            boolean auxBoolTwo = true;
            if(posicion == 0 && cabeza != null ){
                auxBoolean = false;
                cabeza = cabeza.next;
                System.out.println("eliminar: posicion valida");
                auxBoolTwo = false;
            }
            if(posicion < tamanno() && posicion > 0){
                for( int x = 1; x < posicion; x++ ){
                     i = i.next;
                     costoList++;
                }
                auxBoolean = false;
                Nodo siguiente = i.next;
                i.next = siguiente.next;
                System.out.println("eliminar: posicion valida");
            }else{
                if(auxBoolTwo == true){
                    System.out.println("eliminar: posicion invalida");
                }
            }
        }
    
    
}

    public static void main(String[] ar) {
        Scanner sc = new Scanner( System.in );
        int casos = sc.nextInt();
        String comando;
        
        for(int u = 0; u < casos; u++ ){
            System.out.println( "Caso #" + (u+1) + ":" );
            int instruccion = sc.nextInt();
            ListaEnlazada list = new ListaEnlazada();
            int indice = 0;
            int[] array = new int[10];
            int tamano;
            for( int i = 0; i < 10 ; i++ ){
            array[i] = -1;
            }
         
            
            for( int i=0 ; i < instruccion ; i++ ){
                comando = sc.next();
                if( "insertar".equals(comando) ){
                    int dato = sc.nextInt();
                    int posicion = sc.nextInt();
                    list.insertar( dato, posicion );
                    if( posicion <= list.tamanno() ){
                        indice++;
                        tamano =  array.length;
                        if( indice == tamano ){
                        list.definirArray( array, indice );
                        }
                        if( array[posicion] == -1 ){
                            array[posicion] = dato;
                        }
                        else{
                        list.recorrerArray( array, posicion, indice );
                        array[posicion] = dato;
                        }
                    }
                }
                if("buscar".equals(comando)){
                    int datoAux = sc.nextInt();
                    list.buscar( datoAux );
                    list.buscarArray( array, datoAux, indice );
                }
                if("eliminar".equals( comando )){
                    int posicionAux = sc.nextInt();
                    list.eliminar( posicionAux );
                    if( list.auxBoolean == false ){
                        indice--;
                        list.auxBoolean = true;
                    }
                    list.eliminarArray( array, posicionAux, indice );
                }
                if("consultar".equals( comando )){
                    int pos = sc.nextInt();
                    list.consultar( pos );
                }
                if("costo".equals( comando )){
                    System.out.println("costo: " + list.getCostoArray() + " " + list.getCostoList());
                }
            }
        }                    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.Scanner;

public class MainA {
    
    static public class ListaEnlazada {
    
        private Nodo cabeza;
        private int costoList = 0;
        private int costoArray = 0;
        public boolean auxBoolean = true;
        
        class Nodo {
            int data;
            Nodo next;
        }
    
    
        
        public int getCostoList(){
        return costoList;
        }
    
        int getCostoArray(){
        return costoArray;
        }
    
        public ListaEnlazada () {
        cabeza = null;
        }
        
        public int tamanno(){
        int auxTamano = 0;
        Nodo i = cabeza;
            while ( i!=null ){
                i = i.next;
                auxTamano++;
            }
        return auxTamano;
        }
        
        void definirArray( int[]array, int idx ){
            int []aux = new int[ idx*2 ];
            for(int i = 0; i < idx*2; i++ ){
                aux[i] = -1;
            }
        
            for(int i = 0; i < idx; i++ ){
                aux[i] = array[i];
            }
        array = aux;
        }
    
        void recorrerArray( int[]array, int posicion, int idx){
        int count = 0;
        for(int i = idx; i < 0; i-- ){
           array[i] = array[i-1];
           count++;
           
        }
        costoArray = costoArray + ( count - 1 );
        }
        
        void eliminarArray(int[]array ,int posicion,int idx){
            if( ( posicion <= idx ) && ( posicion >= 0 ) ){
                int count = 0;
                for(int i= posicion; i < idx; i++ ){
                    array[i] = array[ i+1 ] ;
                    count++;
                }
                array[idx] = -1;
                if( posicion == 0 ){
                    costoArray = costoArray + (count);
                }
                else{
                    costoArray = costoArray + (count);
                }
            }
        }
        
        
        void buscarArray( int[]array, int dato, int idx ){
            int count = 0;
            for(int x = 0; x < idx; x++ ){
                count++;
                if( array[x] == dato ){
                    costoArray = costoArray + count;
                    x = idx;
                }
                if( array[x] != dato && x == ( idx - 1 ) ){
                    costoArray = costoArray + count;
                }
            }
        }
        
        
        
        void insertar (int dato, int posicion){   
            if (posicion <= tamanno() && posicion >= 0 ){
                Nodo nuevo = new Nodo ();
                nuevo.data = dato;
                if (posicion == 0){
                    nuevo.next = cabeza;
                    cabeza = nuevo;
                }else{
                    if (posicion == tamanno ()){
                        Nodo i = cabeza;
                   
                        while (i.next != null) {
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        i.next = nuevo;
                        nuevo.next = null;
                    }else{
                        Nodo i = cabeza;
                        for (int x = 1; x < posicion ; x++){
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        Nodo siguiente = i.next;
                        i.next = nuevo;
                        nuevo.next = siguiente;
                    }
                }
                System.out.println("insertar: posicion valida");
            }else{
            System.out.println("insertar: posicion invalida");
            }   
        }
        
        
        void buscar(int dato){
            int aux = 0;
            boolean auxBool = true;
            Nodo i = cabeza;
            while( i != null && i.data != dato){
                 i = i.next;
                 aux++;
            }
            if( i != null ){
                System.out.println("buscar: " + aux);
                costoList = costoList + (aux+1);
            }else{
                System.out.println("no existe numero");
                costoList = costoList + tamanno();
            }
        }
        
        
        
        void consultar(int posicion){
            Nodo i = cabeza;
            if( posicion < tamanno() && posicion >= 0 && cabeza != null ){
                for(int x=0;x<posicion;x++){
                    i=i.next;
                    costoList++;
                }
                System.out.println("consulta: "+i.data);
            }else{
                System.out.println("consulta: no encontrado");
            }
        }
        
        
        
    
        void eliminar(int posicion){
            Nodo i = cabeza;
            boolean auxBoolTwo = true;
            if(posicion == 0 && cabeza != null ){
                auxBoolean = false;
                cabeza = cabeza.next;
                System.out.println("eliminar: posicion valida");
                auxBoolTwo = false;
            }
            if(posicion < tamanno() && posicion > 0){
                for( int x = 1; x < posicion; x++ ){
                     i = i.next;
                     costoList++;
                }
                auxBoolean = false;
                Nodo siguiente = i.next;
                i.next = siguiente.next;
                System.out.println("eliminar: posicion valida");
            }else{
                if(auxBoolTwo == true){
                    System.out.println("eliminar: posicion invalida");
                }
            }
        }
    
    
}

    public static void main(String[] ar) {
        Scanner sc = new Scanner( System.in );
        int casos = sc.nextInt();
        String comando;
        
        for(int u = 0; u < casos; u++ ){
            System.out.println( "Caso #" + (u+1) + ":" );
            int instruccion = sc.nextInt();
            ListaEnlazada list = new ListaEnlazada();
            int indice = 0;
            int[] array = new int[100];
            int tamano;
            for( int i = 0; i < 100 ; i++ ){
            array[i] = -1;
            }
         
            
            for( int i=0 ; i < instruccion ; i++ ){
                comando = sc.next();
                if( "insertar".equals(comando) ){
                    int dato = sc.nextInt();
                    int posicion = sc.nextInt();
                    list.insertar( dato, posicion );
                    if( posicion <= list.tamanno() ){
                        indice++;
                        tamano =  array.length;
                        if( indice == tamano ){
                        list.definirArray( array, indice );
                        }
                        if( array[posicion] == -1 ){
                            array[posicion] = dato;
                        }
                        else{
                        list.recorrerArray( array, posicion, indice );
                        array[posicion] = dato;
                        }
                    }
                }
                if("buscar".equals(comando)){
                    int datoAux = sc.nextInt();
                    list.buscar( datoAux );
                    list.buscarArray( array, datoAux, indice );
                }
                if("eliminar".equals( comando )){
                    int posicionAux = sc.nextInt();
                    list.eliminar( posicionAux );
                    if( list.auxBoolean == false ){
                        indice--;
                        list.auxBoolean = true;
                    }
                    list.eliminarArray( array, posicionAux, indice );
                }
                if("consultar".equals( comando )){
                    int pos = sc.nextInt();
                    list.consultar( pos );
                }
                if("costo".equals( comando )){
                    System.out.println("costo: " + list.getCostoArray() + " " + list.getCostoList());
                }
            }
        }                    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.LinkedList;
import java.util.Scanner;
import java.util.Stack;
import java.util.StringTokenizer;

public class MainD {

    	public static void remove(long cedula,LinkedList<LinkedList<Persona>> gimnacio ){
	
        String monbre;
	loop:
		for (int i = 0; i < gimnacio.size(); i++) {
			for (int j = 0; j < gimnacio.get(i).size(); j++) {
				if(!gimnacio.get(i).isEmpty()){
					if(gimnacio.get(i).get(j).getCedula()==cedula){
						monbre=gimnacio.get(i).get(j).getNombre();
						System.out.println(monbre);
						gimnacio.get(i).remove(j);
						break loop;
					}
				}
				
			}
		}
	}
	
	public static void addLinked(LinkedList<LinkedList<Persona>> gimnacio, double[] tamanno, String nombre, long cedula,String apellido){
		double[] cap= new double[tamanno.length];
		for (int i = 0; i < gimnacio.size(); i++) {
			cap[i]=(gimnacio.get(i).size())/tamanno[i];
		}
		double cargaMin=cap[0];
                int j = 1;
		while ( j < gimnacio.size() ) {
			if(cargaMin>cap[j]){
				cargaMin=cap[j]; 
			}
		j++;
                }
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int i = 0; i < gimnacio.size(); i++) {
				if(cargaMin==cap[i]){
					gimnacio.get(i).push( new Persona(nombre, apellido, cedula));
					System.out.println((i+1)+" "+gimnacio.get(i).size());
					break;
				}
			}
		
		}
		
	}

        public static class Persona{
	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}

	public static void main(String[] args) {
		Scanner sc =new  Scanner(System.in); 
                int casos= sc.nextInt();
                for(int  i=0; i<casos;i++){
	    	  
                   System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<LinkedList<Persona>> gimnacio= new LinkedList<LinkedList<Persona>>(); ;
	    	  
                  int nCub= sc.nextInt();
	    	  sc.nextLine();
	    	 
                  StringTokenizer capaci= new StringTokenizer(sc.nextLine());
	    	  double[] tamanno = new double[capaci.toString().length()]; 
	    	  int capcaitidad=0;
	    	  for (int j = 0; j < nCub; j++) {
	    		  gimnacio.add(new LinkedList<Persona>()); 
	    		  tamanno[j]=Integer.valueOf(capaci.nextToken());
	    	  }
	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
                  int entrar;
	    	  int comandos=sc.nextInt(); 
	    	  sc.nextLine();
                  int j = 0;
	    	  while ( j < comandos ) {
	    		  
	    		   capaci= new  StringTokenizer(sc.nextLine()); 
	    		   String comando=capaci.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=capaci.nextToken();
	    			 apellido=capaci.nextToken();
	    			 cedula= Integer.valueOf(capaci.nextToken()); 
	    			 addLinked(gimnacio,tamanno,nombre,cedula,apellido); 
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(capaci.nextToken());
	    			  remove(exit, gimnacio);
	    		  }
	    	  j++;
                  }
	       
	       }
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class MainD {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int [] newArray = new int[10];
		for ( int a = 0; a < 10; a++){


			newArray[i] = i;
		}
		int t = sc.nextInt();
		sc.nextLine();
		if(0<t && t<1000){   
			int auxCasos =0;
			for (int i = 0; i < t; i++) {
				auxCasos++;
				System.out.println("Caso #"+auxCasos+":");
				int n = sc.nextInt();
				sc.nextLine();
				int fila = 0;

				int [][] columna = new int [2][n];

				String cubiculos = sc.nextLine();
				String arrayCubiculos [] = cubiculos.split(" ");

				if(1<=n && n<=1000){                    
					int m = 0;
					while ( m < arrayCubiculos.length ) {
						int k = Integer.parseInt(arrayCubiculos[j]) ;
						if(1<=k && k<=1000){
							columna [0][fila] = k;
							fila++;                       
						}                        
					m++;
					}

					int numeroDeCasilleros = 0;
					String[][] matrixCasillero = new String [fila][];
					
					for (int j = 0; j < fila ; j++) {

						matrixCasillero [j] = new String [columna[0][j]];                        
					}    
					n = sc.nextInt();
					sc.nextLine();
					
					if (1<=n && n<=10000){
						for (int j = 0; j < n; j++) {
							cubiculos = sc.nextLine();
							arrayCubiculos = cubiculos.split(" ");
							if(cubiculos.contains("ingresar")){
								double numeroMenor = 1;
								double numeroPromedio ;
								int desocupado = 0;
								for (int k = 0; k < fila; k++) {
									double date1 =columna[1][k];
									double date2 =columna[0][k];
									numeroPromedio =(date1/date2);

									if (numeroPromedio < numeroMenor){
										numeroMenor = numeroPromedio;
										desocupado = k;

									}
								}
								if(numeroMenor==1){
									System.out.println("limite alcanzado");                                   
								}else{               
									int h = 0;
									while( h < columna[0][desocupado]) {

										if(matrixCasillero[desocupado][h] == null){

											matrixCasillero[desocupado][h] = cubiculos;
											System.out.println((desocupado+1)+" "+(h+1));

											columna[1][desocupado]= columna[1][desocupado] + 1;
											break;
										}                                        
										h++;
									}

								}                               
							}else if(cubiculos.contains("salir")){
								int jump =0;
								String cedula = arrayCubiculos[1];
								for (int k = 0; k < matrixCasillero.length; k++) {
									for (int l = 0; l < matrixCasillero[k].length; l++) {
										if(matrixCasillero[k][l]!=null){
											if(matrixCasillero[k][l].contains(cedula)){
												arrayCubiculos = matrixCasillero[k][l].split(" ");
												System.out.println(arrayCubiculos[1]);
												matrixCasillero[k][l] = null;
												columna[1][k] = columna[1][k]-1;
												jump++;
												break;
											}
										}

									}
									if (jump != 0) {
										break;
									}
								}
							}
						}
					}
				}
			}
		}

	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class MainD {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int [] newArray = new int[10];
		for ( int a = 0; a < 10; a++){


			newArray[a] = a;
		}
		int t = sc.nextInt();
		sc.nextLine();
		if(0<t && t<1000){   
			int auxCasos =0;
			for (int i = 0; i < t; i++) {
				auxCasos++;
				System.out.println("Caso #"+auxCasos+":");
				int n = sc.nextInt();
				sc.nextLine();
				int fila = 0;

				int [][] columna = new int [2][n];

				String cubiculos = sc.nextLine();
				String arrayCubiculos [] = cubiculos.split(" ");

				if(1<=n && n<=1000){                    
					int m = 0;
					while ( m < arrayCubiculos.length ) {
						int k = Integer.parseInt(arrayCubiculos[m]) ;
						if(1<=k && k<=1000){
							columna [0][fila] = k;
							fila++;                       
						}                        
					m++;
					}

					int numeroDeCasilleros = 0;
					String[][] matrixCasillero = new String [fila][];
					
					for (int j = 0; j < fila ; j++) {

						matrixCasillero [j] = new String [columna[0][j]];                        
					}    
					n = sc.nextInt();
					sc.nextLine();
					
					if (1<=n && n<=10000){
						for (int j = 0; j < n; j++) {
							cubiculos = sc.nextLine();
							arrayCubiculos = cubiculos.split(" ");
							if(cubiculos.contains("ingresar")){
								double numeroMenor = 1;
								double numeroPromedio ;
								int desocupado = 0;
								for (int k = 0; k < fila; k++) {
									double date1 =columna[1][k];
									double date2 =columna[0][k];
									numeroPromedio =(date1/date2);

									if (numeroPromedio < numeroMenor){
										numeroMenor = numeroPromedio;
										desocupado = k;

									}
								}
								if(numeroMenor==1){
									System.out.println("limite alcanzado");                                   
								}else{               
									int h = 0;
									while( h < columna[0][desocupado]) {

										if(matrixCasillero[desocupado][h] == null){

											matrixCasillero[desocupado][h] = cubiculos;
											System.out.println((desocupado+1)+" "+(h+1));

											columna[1][desocupado]= columna[1][desocupado] + 1;
											break;
										}                                        
										h++;
									}

								}                               
							}else if(cubiculos.contains("salir")){
								int jump =0;
								String cedula = arrayCubiculos[1];
								for (int k = 0; k < matrixCasillero.length; k++) {
									for (int l = 0; l < matrixCasillero[k].length; l++) {
										if(matrixCasillero[k][l]!=null){
											if(matrixCasillero[k][l].contains(cedula)){
												arrayCubiculos = matrixCasillero[k][l].split(" ");
												System.out.println(arrayCubiculos[1]);
												matrixCasillero[k][l] = null;
												columna[1][k] = columna[1][k]-1;
												jump++;
												break;
											}
										}

									}
									if (jump != 0) {
										break;
									}
								}
							}
						}
					}
				}
			}
		}

	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;

public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the tree.
     */
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }



    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }


    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
        int compareResult = x.compareTo( aux.element );
            while ( aux.element != x ){
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        // If both n1 and n2 are smaller than root, then LCA lies in left
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        // If both n1 and n2 are greater than root, then LCA lies in right
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        // If both n1 and n2 are smaller than root, then LCA lies in left
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        // If both n1 and n2 are greater than root, then LCA lies in right
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        
        
        BinaryNode(  )
        {
        }

        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        
        while ( casos > 0 ){
            
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int n1 = Integer.parseInt(arrayComando[ 1 ]);
                    int n2 = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.contains(n1) && tree.contains(n2)) System.out.println("distancia: "  + (tree.distancia(tree.root, n1, n2) + tree.distancia(tree.root, n2, n1)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.contains(n1) && tree.contains(n2)) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                
                numComandos--;
            }    
            
            casos--;
            
        }
        
        
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;

public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the tree.
     */
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }



    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }


    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        // If both n1 and n2 are smaller than root, then LCA lies in left
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        // If both n1 and n2 are greater than root, then LCA lies in right
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        // If both n1 and n2 are smaller than root, then LCA lies in left
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        // If both n1 and n2 are greater than root, then LCA lies in right
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        
        
        BinaryNode(  )
        {
        }

        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int n1 = Integer.parseInt(arrayComando[ 1 ]);
                    int n2 = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.contains(n1) && tree.contains(n2)) System.out.println("distancia: "  + (tree.distancia(tree.root, n2, n1) + tree.distancia(tree.root, n1, n2)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.contains(n1) && tree.contains(n2)) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                
                numComandos--;
            }    
            
            casos--;
            n++;
        }
        
        
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    private static class BinaryNode<AnyType>
    {
    
        
        
        BinaryNode(  )
        {
        }

        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int n1 = Integer.parseInt(arrayComando[ 1 ]);
                    int n2 = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.contains(n1) && tree.contains(n2)) System.out.println("distancia: "  + (tree.distancia(tree.root, n2, n1) + tree.distancia(tree.root, n1, n2)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.contains(n1) && tree.contains(n2)) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                
                numComandos--;
            }    
            
            casos--;
            n++;
        }
        
        
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    private static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int n1 = Integer.parseInt(arrayComando[ 1 ]);
                    int n2 = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.contains(n1) && tree.contains(n2)) System.out.println("distancia: "  + (tree.distancia(tree.root, n2, n1) + tree.distancia(tree.root, n1, n2)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.contains(n1) && tree.contains(n2)) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                
                numComandos--;
            }    
            
            casos--;
            n++;
        }
        
        
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    private static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int n1 = Integer.parseInt(arrayComando[ 1 ]);
                    int n2 = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.contains(n1) && tree.contains(n2)) System.out.println("distancia: "  + (tree.distancia(tree.root, n2, n1) + tree.distancia(tree.root, n1, n2)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.contains(n1) && tree.contains(n2)) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           if ( !tree.contains(x)) tree.insert(x);
                       }
                    }
                }
                
                numComandos--;
            }    
            
            casos--;
            n++;
        }
        
        
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    private static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.contains(x) && tree.contains(y)) System.out.println("distancia: "  + (tree.distancia(tree.root, y, x) + tree.distancia(tree.root, x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.contains(n1) && tree.contains(n2)) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           if ( !tree.contains(x)) tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoB {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public int contar (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        int conut = 0;
        while(!c.isEmpty()){
            aux = c.poll();
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
            conut++;
        }
        return conut - 1;
    }
    
    
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    private static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int X = Integer.parseInt(arrayComando[ 1 ]);
                    int Y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.contains(X) && tree.contains(Y)) System.out.println("distancia: "  + (tree.distancia(tree.root, Y, X) + tree.distancia(tree.root, X, Y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int U = Integer.parseInt(arrayComando[ 1 ]);
                        int V = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.contains(U) && tree.contains(V)) System.out.println("ancestro: " + tree.lca(tree.root, U, V));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int X = Integer.parseInt(arrayComando[ 1 ]);
                           if ( !tree.contains(X)) tree.insert(X);
                       }else{
                           if ( arrayComando[ 0 ].equals("contar")){
                           int U = Integer.parseInt(arrayComando[ 1 ]);
                           if ( tree.contains(U) ) System.out.println("contar: " + tree.contar(tree.AncestorNode(tree.root, U, U)));
                           else System.out.println( "contar: -1" );
                           }
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoD {
    
    public static class AvlTree<AnyType extends Comparable<? super AnyType>>{
    
    public AvlTree( AvlNode<AnyType> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<AnyType> getRoot() {
          return root;
    }

    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }


    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<AnyType> balance( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<AnyType> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
        
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<AnyType> findMin( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<AnyType> findMax( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( AnyType x, AvlNode<AnyType> t )
    {
        while( t != null )
        {
            int compareResult = x.compareTo( t.element );
            
            if( compareResult < 0 )
                t = t.left;
            else if( compareResult > 0 )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<AnyType> getNode( AnyType x, AvlNode<AnyType> t )
    {
        while( t != null )
        {
            int compareResult = x.compareTo( t.element );
            
            if( compareResult < 0 )
                t = t.left;
            else if( compareResult > 0 )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<AnyType> getNode( AnyType x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<AnyType> printTree( AvlNode<AnyType> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element );
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<AnyType> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 )
    {
        AvlNode<AnyType> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 )
    {
        AvlNode<AnyType> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<AnyType> root;
    private ArrayList<AnyType> array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( AnyType theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        AnyType           element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public AnyType getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r) throws Exception{
        
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                 for ( int i = 0; i < list.size(); i++){
                     if ( list.get(i).getIdx() == idx){
                         list.get(i).insert(x);
                     }
                 }
                 }
            }
            
            
            if ( arrayComando[ 0 ].equals("unir")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                            unir(list.get(i), list.get(j));
                        }
                    }
                }
                }
            }
            
            if ( arrayComando[ 0 ].equals("contiene")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                            
                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                int count = 0;
                                for ( int k = 0; k < arrayAux1.size(); k++){
                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                        count++;
                                    }
                                }
                                if ( count == arrayAux2.size()){
                                    System.out.println("contiene: Yes");
                                }
                                
                            }else{
                                System.out.println("contiene: No");
                            }
                        }
                    }
                    }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("ocurrencia")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    if ( !list.get(i).isEmpty()){
                        if ( list.get(i).getIdx() == idx ){ 
                            if ( list.get(i).getNode(x) != null){
                                System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                            }else{
                                System.out.println("ocurrencia: 0");   
                            }
                       }
                    }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("crear")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                int aux = -1; 
                if ( !list.isEmpty()){
                    for ( int i = 0; i < list.size(); i++){
                        if ( list.get(i).equals(tree)){
                        aux = 1;
                        }    
                    }
                }
                if ( aux == -1 ){
                    list.add(tree);
                }
            }
            numComandos--;
        }
        
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoD {
    
    public static class AvlTree<AnyType extends Comparable<? super AnyType>>{
    
    public AvlTree( AvlNode<AnyType> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<AnyType> getRoot() {
          return root;
    }

    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }


    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<AnyType> balance( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<AnyType> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
        
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<AnyType> findMin( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<AnyType> findMax( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( AnyType x, AvlNode<AnyType> t )
    {
        while( t != null )
        {
            int compareResult = x.compareTo( t.element );
            
            if( compareResult < 0 )
                t = t.left;
            else if( compareResult > 0 )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<AnyType> getNode( AnyType x, AvlNode<AnyType> t )
    {
        while( t != null )
        {
            int compareResult = x.compareTo( t.element );
            
            if( compareResult < 0 )
                t = t.left;
            else if( compareResult > 0 )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<AnyType> getNode( AnyType x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<AnyType> printTree( AvlNode<AnyType> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element );
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<AnyType> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 )
    {
        AvlNode<AnyType> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 )
    {
        AvlNode<AnyType> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<AnyType> root;
    private ArrayList<AnyType> array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( AnyType theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        AnyType           element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public AnyType getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r) throws Exception{
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                 for ( int i = 0; i < list.size(); i++){
                     if ( list.get(i).getIdx() == idx){
                         list.get(i).insert(x);
                     }
                 }
                 }
            }
            
            
            if ( arrayComando[ 0 ].equals("unir")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                            unir(list.get(i), list.get(j));
                            list.remove(j);
                        }
                    }
                }
                }
            }
            
            if ( arrayComando[ 0 ].equals("contiene")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                            
                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                int count = 0;
                                for ( int k = 0; k < arrayAux1.size(); k++){
                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                        count++;
                                    }
                                }
                                if ( count == arrayAux2.size()){
                                    System.out.println("contiene: Yes");
                                }
                                
                            }else{
                                System.out.println("contiene: No");
                            }
                        }
                    }
                    }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("ocurrencia")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    if ( !list.get(i).isEmpty()){
                        if ( list.get(i).getIdx() == idx ){ 
                            if ( list.get(i).getNode(x) != null){
                                System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                            }else{
                                System.out.println("ocurrencia: 0");   
                            }
                       }
                    }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("crear")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                int aux = -1; 
                if ( !list.isEmpty()){
                    for ( int i = 0; i < list.size(); i++){
                        if ( list.get(i).equals(tree)){
                        aux = 1;
                        }    
                    }
                }
                if ( aux == -1 ){
                    list.add(tree);
                }
            }
            numComandos--;
        }
        
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r) throws Exception{
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                 for ( int i = 0; i < list.size(); i++){
                     if ( list.get(i).getIdx() == idx){
                         list.get(i).insert(x);
                     }
                 }
                 }
            }
            
            
            if ( arrayComando[ 0 ].equals("unir")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                            unir(list.get(i), list.get(j));
                            list.remove(j);
                        }
                    }
                }
                }
            }
            
            if ( arrayComando[ 0 ].equals("contiene")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                            
                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                int count = 0;
                                for ( int k = 0; k < arrayAux1.size(); k++){
                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                        count++;
                                    }
                                }
                                if ( count == arrayAux2.size()){
                                    System.out.println("contiene: Yes");
                                }
                                
                            }else{
                                System.out.println("contiene: No");
                            }
                        }
                    }
                    }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("ocurrencia")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    if ( !list.get(i).isEmpty()){
                        if ( list.get(i).getIdx() == idx ){ 
                            if ( list.get(i).getNode(x) != null){
                                System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                            }else{
                                System.out.println("ocurrencia: 0");   
                            }
                       }
                    }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("crear")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                int aux = -1; 
                if ( !list.isEmpty()){
                    for ( int i = 0; i < list.size(); i++){
                        if ( list.get(i).equals(tree)){
                        aux = 1;
                        }    
                    }
                }
                if ( aux == -1 ){
                    list.add(tree);
                }
            }
            numComandos--;
        }
        
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    private static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.contains(x) && tree.contains(y) && tree.root != null) System.out.println("distancia: "  + (tree.distancia(tree.root, y, x) + tree.distancia(tree.root, x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.contains(n1) && tree.contains(n2) && tree.root != null) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           if ( !tree.contains(x) && tree.root != null) tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    private static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

        public BinaryNode<AnyType> getRoot() {
            return root;
        }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) && tree.contains(y) ) System.out.println("distancia: "  + (tree.distancia(tree.root, y, x) + tree.distancia(tree.root, x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("Ancestro: -1");
                        else if ( tree.contains(n1) && tree.contains(n2) ) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           if ( !tree.contains(x)) tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    private static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

        public BinaryNode<AnyType> getRoot() {
            return root;
        }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) && tree.contains(y) ) System.out.println("distancia: "  + (tree.distancia(tree.root, y, x) + tree.distancia(tree.root, x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("Ancestro: -1");
                        else if ( tree.contains(n1) && tree.contains(n2) ) System.out.println("ancestro: " + tree.lca(tree.root, n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    public static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

        public BinaryNode<AnyType> getRoot() {
            return root;
        }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) && tree.contains(y) ) System.out.println("distancia: "  + (tree.distancia(tree.root, y, x) + tree.distancia(tree.root, x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("Ancestro: -1");
                        else if ( tree.contains(n1) && tree.contains(n2) ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<AnyType> t, AnyType x , AnyType y ){
        
        BinaryNode<AnyType> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                int compareResult = x.compareTo( aux.element );
                if ( compareResult < 0) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<AnyType> AncestorNode( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public AnyType lca( BinaryNode<AnyType> node, AnyType n1, AnyType n2 ) {
        if (node == null) {
            return null;
        }
        int compareResultn1 = n1.compareTo( node.element );
        int compareResultn2 = n2.compareTo( node.element );
        
        if (compareResultn1 < 0 && compareResultn2 < 0) {
            return lca(node.left, n1, n2);
        }
 
        
        if (compareResultn1 > 0 && compareResultn2 > 0) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    public static class BinaryNode<AnyType>
    {
    
        BinaryNode(AnyType theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

    public BinaryNode<AnyType> getRoot() {
          return root;
    }


      
    private BinaryNode<AnyType> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("Ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<Interger>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<Interger> insert( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        
            
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<Interger> remove( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return t;   
            
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<Interger> findMin( BinaryNode<Interger> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<Interger> findMax( BinaryNode<Interger> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return false;
            
        if( x < t.element )
            return contains( x, t.left );
        else if( x > t.element )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<Interger> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<Interger> t, int x , int y ){
        
        BinaryNode<Interger> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                if ( x < aux.element) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<Interger> AncestorNode( BinaryNode<Interger> node, int n1, int n2 ) {
        if (node == null) {
            return null;
        }
       
        if (n1 < node.element && n2 < node.element) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public int lca( BinaryNode<Interger> node, int n1, int n2 ) {

        
        if (n1 < node.element && n2 < node.element) {
            return lca(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    public static class BinaryNode<AnyType>
    {
    
        BinaryNode(int theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( int theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        int element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

    public BinaryNode<Interger> getRoot() {
          return root;
    }


      
    private BinaryNode<Interger> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("Ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<Interger>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<Interger> insert( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        
            
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<Interger> remove( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return t;   
            
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<Interger> findMin( BinaryNode<Interger> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<Interger> findMax( BinaryNode<Interger> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return false;
            
        if( x < t.element )
            return contains( x, t.left );
        else if( x > t.element )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<Interger> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<Interger> t, int x , int y ){
        
        BinaryNode<Interger> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                if ( x < aux.element) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<Interger> AncestorNode( BinaryNode<Interger> node, int n1, int n2 ) {
        if (node == null) {
            return null;
        }
       
        if (n1 < node.element && n2 < node.element) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public int lca( BinaryNode<Interger> node, int n1, int n2 ) {

        
        if (n1 < node.element && n2 < node.element) {
            return lca(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    public static class BinaryNode<AnyType>
    {
    
        BinaryNode(int theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( int theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        int element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

    public BinaryNode<Interger> getRoot() {
          return root;
    }


      
    private BinaryNode<Interger> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoEAux {

    public static class BinarySearchTree<Interger>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<Interger> insert( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        
            
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<Interger> remove( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return t;   
            
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<Interger> findMin( BinaryNode<Interger> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<Interger> findMax( BinaryNode<Interger> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return false;
            
        if( x < t.element )
            return contains( x, t.left );
        else if( x > t.element )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<Interger> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public int contar (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        int conut = 0;
        while(!c.isEmpty()){
            aux = c.poll();
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
            conut++;
        }
        return conut - 1;
    }
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<Interger> t, int x , int y ){
        
        BinaryNode<Interger> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                if ( x < aux.element) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<Interger> AncestorNode( BinaryNode<Interger> node, int n1, int n2 ) {
        if (node == null) {
            return null;
        }
       
        if (n1 < node.element && n2 < node.element) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public int lca( BinaryNode<Interger> node, int n1, int n2 ) {

        
        if (n1 < node.element && n2 < node.element) {
            return lca(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    public static class BinaryNode<AnyType>
    {
    
        BinaryNode(int theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( int theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        int element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

    public BinaryNode<Interger> getRoot() {
          return root;
    }


      
    private BinaryNode<Interger> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }else{
                           if ( arrayComando[ 0 ].equals("contar")){
                           int U = Integer.parseInt(arrayComando[ 1 ]);
                           if ( tree.getRoot() == null ) System.out.println("contar: -1");
                           if ( tree.contains(U) ) System.out.println("contar: " + tree.contar(tree.AncestorNode(tree.root, U, U)));
                           else System.out.println( "contar: -1" );
                           }
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoEAux {

    public static class BinarySearchTree<Interger>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<Interger> insert( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        
            
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<Interger> remove( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return t;   
            
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<Interger> findMin( BinaryNode<Interger> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<Interger> findMax( BinaryNode<Interger> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return false;
            
        if( x < t.element )
            return contains( x, t.left );
        else if( x > t.element )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<Interger> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public int contar (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        int conut = 0;
        while(!c.isEmpty()){
            aux = c.poll();
            if(aux.left != null) {
                c.add(aux.left);
                conut++;
            }
            if(aux.right != null){
                c.add(aux.right);
                conut++;
            }
            
        }
        return conut ;
    }
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<Interger> t, int x , int y ){
        
        BinaryNode<Interger> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                if ( x < aux.element) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<Interger> AncestorNode( BinaryNode<Interger> node, int n1, int n2 ) {
        if (node == null) {
            return null;
        }
       
        if (n1 < node.element && n2 < node.element) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public int lca( BinaryNode<Interger> node, int n1, int n2 ) {

        
        if (n1 < node.element && n2 < node.element) {
            return lca(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    public static class BinaryNode<AnyType>
    {
    
        BinaryNode(int theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( int theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        int element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

    public BinaryNode<Interger> getRoot() {
          return root;
    }


      
    private BinaryNode<Interger> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }else{
                           if ( arrayComando[ 0 ].equals("contar")){
                           int U = Integer.parseInt(arrayComando[ 1 ]);
                           if ( tree.getRoot() == null ) System.out.println("contar: -1");
                           if ( tree.contains(U) ) System.out.println("contar: " + tree.contar(tree.AncestorNode(tree.getRoot(), U, U)));
                           else System.out.println( "contar: -1" );
                           }
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoEAux {
    public static class BinarySearchTree<Interger>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<Interger> insert( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        
            
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<Interger> remove( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return t;   
            
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<Interger> findMin( BinaryNode<Interger> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<Interger> findMax( BinaryNode<Interger> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return false;
            
        if( x < t.element )
            return contains( x, t.left );
        else if( x > t.element )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<Interger> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
        /**
         *
         * @param a
         * @return
         */
        public int contar (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = new BinaryNode();
        c.add(a);
        int conut = 0;
        while(!c.isEmpty()){
            aux = c.poll();
            if(aux.left != null) {
                c.add(aux.left);
                conut++;
            }
            if(aux.right != null){
                c.add(aux.right);
                conut++;
            }
            
        }
        return conut ;
    }
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<Interger> t, int x , int y ){
        
        BinaryNode<Interger> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                if ( x < aux.element) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<Interger> AncestorNode( BinaryNode<Interger> node, int n1, int n2 ) {
        if (node == null) {
            return null;
        }
       
        if (n1 < node.element && n2 < node.element) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public int lca( BinaryNode<Interger> node, int n1, int n2 ) {

        
        if (n1 < node.element && n2 < node.element) {
            return lca(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    public BinaryNode<Integer> getNode( int x, BinaryNode<Integer> t ){
        
        while( t != null )
        {
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public BinaryNode<Integer> getNode( int x )
    {
        return getNode(x, root);
    }
    
    
    public static class BinaryNode<Integer>
    {

        public BinaryNode() {
        }
    
        
        
        BinaryNode(int theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( int theElement, BinaryNode<Integer> lt, BinaryNode<Integer> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        int element;            
        BinaryNode<Integer> left;   
        BinaryNode<Integer> right;  
    }

    
    
    public BinaryNode<Interger> getRoot() {
          return root;
    }

    private BinaryNode root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }else{
                           if ( arrayComando[ 0 ].equals("contar")){
                           int U = Integer.parseInt(arrayComando[ 1 ]);
                           if ( tree.getRoot() == null ) System.out.println("contar: -1");
                           if ( tree.contains(U) ) System.out.println("contar: " + tree.contar(tree.getNode(U)));
                           else System.out.println( "contar: -1" );
                           }
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoEAux {
    public static class BinarySearchTree<Interger>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<Interger> insert( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        
            
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<Interger> remove( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return t;   
            
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<Interger> findMin( BinaryNode<Interger> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<Interger> findMax( BinaryNode<Interger> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return false;
            
        if( x < t.element )
            return contains( x, t.left );
        else if( x > t.element )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<Interger> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
        /**
         *
         * @param a
         * @return
         */
        public int contar (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = new BinaryNode();
        c.add(a);
        int conut = 0;
        while(!c.isEmpty()){
            aux = c.poll();
            if(aux.left != null) {
                c.add(aux.left);
                conut++;
            }
            if(aux.right != null){
                c.add(aux.right);
                conut++;
            }
            
        }
        return conut ;
    }
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<Interger> t, int x , int y ){
        
        BinaryNode<Interger> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                if ( x < aux.element) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<Interger> AncestorNode( BinaryNode<Interger> node, int n1, int n2 ) {
        if (node == null) {
            return null;
        }
       
        if (n1 < node.element && n2 < node.element) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public int lca( BinaryNode<Interger> node, int n1, int n2 ) {

        
        if (n1 < node.element && n2 < node.element) {
            return lca(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    public BinaryNode<Integer> getNode( int x, BinaryNode<Integer> t ){
        
        while( t != null )
        {
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public BinaryNode<Integer> getNode( int x )
    {
        return getNode(x, root);
    }
    
    
    public static class BinaryNode<Integer>
    {

        public BinaryNode() {
        }
    
        
        
        BinaryNode(int theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( int theElement, BinaryNode<Integer> lt, BinaryNode<Integer> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        int element;            
        BinaryNode<Integer> left;   
        BinaryNode<Integer> right;  
    }

    
    
    public BinaryNode<Interger> getRoot() {
          return root;
    }

    private BinaryNode root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }else{
                           if ( arrayComando[ 0 ].equals("contar")){
                           int U = Integer.parseInt(arrayComando[ 1 ]);
                           if ( tree.getRoot() == null ) System.out.println("contar: -1");
                           else if ( tree.contains(U) ) System.out.println("contar: " + tree.contar(tree.getNode(U)));
                           else System.out.println( "contar: -1" );
                           }
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r) throws Exception{
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                 for ( int i = 0; i < list.size(); i++){
                     if ( list.get(i).getRoot() != null)
                     {
                         if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                     }
                     
                 }
                 }
            }
            
            
            if ( arrayComando[ 0 ].equals("unir")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                        if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null)
                        {
                            if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                            unir(list.get(i), list.get(j));
                            list.remove(j);
                        }
                    }
                }
                }
            }
            }
            
            if ( arrayComando[ 0 ].equals("contiene")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                            
                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                int count = 0;
                                for ( int k = 0; k < arrayAux1.size(); k++){
                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                        count++;
                                    }
                                }
                                if ( count == arrayAux2.size()){
                                    System.out.println("contiene: Yes");
                                }
                                
                            }else{
                                System.out.println("contiene: No");
                            }
                        }
                    }
                    }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("ocurrencia")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    if (list.get(i).getRoot() != null){
                    if ( !list.get(i).isEmpty()){
                        if ( list.get(i).getIdx() == idx ){ 
                            if ( list.get(i).getNode(x) != null){
                                System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                            }else{
                                System.out.println("ocurrencia: 0");   
                            }
                       }
                    }
                }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("crear")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                int aux = -1; 
                if ( !list.isEmpty()){
                    for ( int i = 0; i < list.size(); i++){
                        if ( list.get(i).equals(tree)){
                        aux = 1;
                        }    
                    }
                }
                if ( aux == -1 ){
                    list.add(tree);
                }
            }
            numComandos--;
        }
        
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r) throws Exception{
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                 for ( int i = 0; i < list.size(); i++){
                     if ( list.get(i).getRoot() != null)
                     {
                         if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                     }
                     
                 }
                 }
            }
            
            
            if ( arrayComando[ 0 ].equals("unir")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                        if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null)
                        {
                            if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                            unir(list.get(i), list.get(j));
                            list.remove(j);
                        }
                    }
                }
                }
            }
            }
            
            if ( arrayComando[ 0 ].equals("contiene")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                            
                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                int count = 0;
                                for ( int k = 0; k < arrayAux1.size(); k++){
                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                        count++;
                                    }
                                }
                                if ( count == arrayAux2.size()){
                                    System.out.println("contiene: Yes");
                                }
                                
                            }else{
                                System.out.println("contiene: No");
                            }
                        }
                    }
                    }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("ocurrencia")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    if (list.get(i).getRoot() != null){
                    if ( !list.get(i).isEmpty()){
                        if ( list.get(i).getIdx() == idx ){ 
                            if ( list.get(i).getNode(x) != null){
                                System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                            }else{
                                System.out.println("ocurrencia: 0");   
                            }
                       }
                    }
                }
                }
                }
            }
            
            
            if ( arrayComando[ 0 ].equals("crear")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                int aux = -1; 
                if ( !list.isEmpty()){
                    for ( int i = 0; i < list.size(); i++){
                        if ( list.get(i).getRoot() != null){
                        if ( list.get(i).equals(tree)){
                        aux = 1;
                        }
                    }
                    }
                }
                if ( aux == -1 ){
                    list.add(tree);
                }
            }
            numComandos--;
        }
        
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                 for ( int i = 0; i < list.size(); i++){
                     if ( list.get(i).getRoot() != null)
                     {
                         if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                     }
                     
                 }
                 }
            }else{
            
            
            if ( arrayComando[ 0 ].equals("unir")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                        if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null)
                        {
                            if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                            unir(list.get(i), list.get(j));
                            list.remove(j);
                        }
                    }
                }
                }
            }
            }else{
            
            if ( arrayComando[ 0 ].equals("contiene")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int idy = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    for ( int j = 0; j < list.size(); j++){
                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                            
                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                int count = 0;
                                for ( int k = 0; k < arrayAux1.size(); k++){
                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                        count++;
                                    }
                                }
                                if ( count == arrayAux2.size()){
                                    System.out.println("contiene: Yes");
                                }
                                
                            }else{
                                System.out.println("contiene: No");
                            }
                        }
                    }
                    }
                }
                }
            }else{
            
            
            if ( arrayComando[ 0 ].equals("ocurrencia")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                if ( !list.isEmpty()){
                for ( int i = 0; i < list.size(); i++){
                    if (list.get(i).getRoot() != null){
                    if ( !list.get(i).isEmpty()){
                        if ( list.get(i).getIdx() == idx ){ 
                            if ( list.get(i).getNode(x) != null){
                                System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                            }else{
                                System.out.println("ocurrencia: 0");   
                            }
                       }
                    }
                }
                }
                }
            }else{
            
            
            if ( arrayComando[ 0 ].equals("crear")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                int aux = -1; 
                if ( !list.isEmpty()){
                    for ( int i = 0; i < list.size(); i++){
                        if ( list.get(i).getRoot() != null){
                        if ( list.get(i).equals(tree)){
                        aux = 1;
                        }
                    }
                    }
                }
                if ( aux == -1 ){
                    list.add(tree);
                }
            }
            
            }
            }
            }
        }
            numComandos--;
        }
        
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            /*if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            */
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
//}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
               /* if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{*/
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
//}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                    /*if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{*/
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
//}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        /*if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{*/
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
//}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            /*if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }*/
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                /*if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }*/
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            /*}else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                   */ }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        //}
                    //}
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                /*}else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                   */ }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        //}
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                /*if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                   */ if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        //}
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                /*if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                   */ if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                            if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( arrayAux1.equals(arrayAux2)){
                                            /*if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                                */System.out.println("contiene: Yes");
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        //}
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                /*if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                   */ if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( !list.get(i).isEmpty() && !list.get(j).isEmpty()  ){ 
                                        if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                           // if ( list.get(i).contains(list.get(j).getRoot().getElement())){
                                            ArrayList arrayAux1 = list.get(i).printTree(list.get(i).getNode(list.get(j).getRoot().getElement()));
                                            ArrayList arrayAux2 = list.get(j).printTree(list.get(j).getRoot());
                                            if ( arrayAux1.equals(arrayAux2)){
                                            /*if ( !arrayAux1.isEmpty() && !arrayAux2.isEmpty() && arrayAux1.size() == arrayAux2.size()){
                                                int count = 0;
                                                for ( int k = 0; k < arrayAux1.size(); k++){
                                                    if (arrayAux1.get(k) == arrayAux2.get(k)){
                                                        count++;
                                                    }
                                                }
                                                if ( count == arrayAux2.size()){
                                                    System.out.println("contiene: Yes");
                                                }
                                                */System.out.println("contiene: Yes");
                                            }else{
                                                System.out.println("contiene: No");
                                            }
                                          //  }else{
                                            //    System.out.println("contiene: No");
                                            //}
                                        }
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        //}
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{
    
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contine( AvlTree<Integer> t ,AvlTree<Integer> r){
        if ( t.contains(r.root.element)){
            if ( t.printTree(r.root) == r.printTree(r.root) ){
                System.out.println("contiene: Yes");
            }
        }else{
            System.out.println("contiene: No");
        }
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                /*if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                   */ if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                for ( int j = 0; j < list.size(); j++){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy  ){ 
                                        contine(list.get(i), list.get(j));
                                    }
                                }
                            }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        //}
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        while ( !r.isEmpty()){
        while ( r.getNode(r.findMin()).getOcurrencia() > 0){
        t.insert(r.findMin());
        r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
        }
        r.remove(r.findMin());
        }
        
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contine( AvlTree<Integer> t ,AvlTree<Integer> r){
        if ( t.contains(r.root.element)){
            if ( t.printTree(r.root) == r.printTree(r.root) ){
                System.out.println("contiene: Yes");
            }
        }else{
            System.out.println("contiene: No");
        }
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                /*if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            for ( int j = 0; j < list.size(); j++){
                                if ( list.get(i).getRoot() != null && list.get(j).getRoot() != null){
                                    if ( list.get(i).getIdx() == idx && list.get(j).getIdx() == idy ){
                                        unir(list.get(i), list.get(j));
                                        list.remove(j);
                                    }
                                }
                            }
                        }
                    }
                }else{
            
                   */ if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                            contine(treeIdx, treeIdy);
                        }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        //}
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contine( AvlTree<Integer> t ,AvlTree<Integer> r){
        
        if ( t.contains(r.root.element)){
            if ( t.printTree(r.root) == r.printTree(r.root) ){
                System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        }else{
            System.out.println("contiene: No");
        }
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    AvlTree<Integer> treeIdx = null;
                    AvlTree<Integer> treeIdy = null;
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            if ( list.get(i).getIdx() == idx){
                                treeIdx = list.get(i);
                            }
                            if ( list.get(i).getIdx() == idy){
                                treeIdy = list.get(i);
                            }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                              unir(treeIdx, treeIdy);
                              list.remove(treeIdy);
                        }
                    }
                            
                        
                    
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                            contine(treeIdx, treeIdy);
                        }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contine( AvlTree<Integer> t ,AvlTree<Integer> r){
        
        if ( t.contains(r.root.element)){
            if ( t.printTree(r.root).equals(r.printTree(r.root) )){
                System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        }else{
            System.out.println("contiene: No");
        }
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    AvlTree<Integer> treeIdx = null;
                    AvlTree<Integer> treeIdy = null;
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            if ( list.get(i).getIdx() == idx){
                                treeIdx = list.get(i);
                            }
                            if ( list.get(i).getIdx() == idy){
                                treeIdy = list.get(i);
                            }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                              unir(treeIdx, treeIdy);
                              list.remove(treeIdy);
                        }
                    }
                            
                        
                    
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                            contine(treeIdx, treeIdy);
                        }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contiene( AvlTree<Integer> t ,AvlTree<Integer> r){
        t.printTree(r.root);
        r.printTree(r.root);
        if ( t.contains(r.root.element)){
            if ( t.printTree(r.root).equals(r.printTree(r.root)) ){
                   System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        }else{
            System.out.println("contiene: No");
        }
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    AvlTree<Integer> treeIdx = null;
                    AvlTree<Integer> treeIdy = null;
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            if ( list.get(i).getIdx() == idx){
                                treeIdx = list.get(i);
                            }
                            if ( list.get(i).getIdx() == idy){
                                treeIdy = list.get(i);
                            }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                              unir(treeIdx, treeIdy);
                              list.remove(treeIdy);
                        }
                    }
                            
                        
                    
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                            contiene(treeIdx, treeIdy);
                        }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
            return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contiene( AvlTree<Integer> t ,AvlTree<Integer> r){

           t.printTree(r.root);
           r.printTree(r.root);
        if ( t.contains(r.root.element)){
            if ( t.printTree(r.root).equals(r.printTree(r.root)) ){
                   System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        }else{
            System.out.println("contiene: No");
        }
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    AvlTree<Integer> treeIdx = null;
                    AvlTree<Integer> treeIdy = null;
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            if ( list.get(i).getIdx() == idx){
                                treeIdx = list.get(i);
                            }
                            if ( list.get(i).getIdx() == idy){
                                treeIdy = list.get(i);
                            }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                              unir(treeIdx, treeIdy);
                              list.remove(treeIdy);
                        }
                    }
                            
                        
                    
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                            contiene(treeIdx, treeIdy);
                        }
                        }
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList<>();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
        return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    private boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode<Integer> t )
    {
        
        if( t != null )
        {
            printTree( t.left );
            array.add(t.element);
            printTree( t.right );
        }
        return array;
        
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contiene( AvlTree<Integer> t ,AvlTree<Integer> r){
        
        ArrayList<Integer> listT = new ArrayList<>();
        listT.add(-1);
        if ( t.getNode(r.root.element) != null){
          listT =  t.printTree(r.root);
        }
        ArrayList listR =  r.printTree(r.root);
            if ( listT.equals(listR) ){
                System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    AvlTree<Integer> treeIdx = null;
                    AvlTree<Integer> treeIdy = null;
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            if ( list.get(i).getIdx() == idx){
                                treeIdx = list.get(i);
                            }
                            if ( list.get(i).getIdx() == idy){
                                treeIdy = list.get(i);
                            }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                              unir(treeIdx, treeIdy);
                              list.remove(treeIdy);
                        }
                    }
                            
                        
                    
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        
                        if (treeIdx != null && treeIdy != null ){ 
                            contiene(treeIdx, treeIdy);
                        }
                        }
                        
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoA {

    public static class BinarySearchTree<Interger>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<Interger> insert( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        
            
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<Interger> remove( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return t;   
            
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<Interger> findMin( BinaryNode<Interger> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<Interger> findMax( BinaryNode<Interger> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return false;
            
        if( x < t.element )
            return contains( x, t.left );
        else if( x > t.element )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<Interger> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<Interger> t, int x , int y ){
        
        BinaryNode<Interger> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                if ( x < aux.element) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<Interger> AncestorNode( BinaryNode<Interger> node, int n1, int n2 ) {
        if (node == null) {
            return null;
        }
       
        if (n1 < node.element && n2 < node.element) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public int lca( BinaryNode<Interger> node, int n1, int n2 ) {

        
        if (n1 < node.element && n2 < node.element) {
            return lca(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    
    public static class BinaryNode<AnyType>
    {
    
        BinaryNode(int theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( int theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        int element;            
        BinaryNode<AnyType> left;   
        BinaryNode<AnyType> right;  
    }

    public BinaryNode<Interger> getRoot() {
          return root;
    }


      
    private BinaryNode<Interger> root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.*;
public class PuntoEAux {
    public static class BinarySearchTree<Interger>{
    
    public BinarySearchTree( )
    {
        root = null;
    }

    
    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    public int findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }




    public BinaryNode<Interger> insert( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        
            
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
            ;  
        return t;
    }

    
    public BinaryNode<Interger> remove( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return t;   
            
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) 
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    
    public BinaryNode<Interger> findMin( BinaryNode<Interger> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    
    public BinaryNode<Interger> findMax( BinaryNode<Interger> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    
    public boolean contains( int x, BinaryNode<Interger> t )
    {
        if( t == null )
            return false;
            
        if( x < t.element )
            return contains( x, t.left );
        else if( x > t.element )
            return contains( x, t.right );
        else
            return true;    
    }


    
    public int height( BinaryNode<Interger> t )
    {
        if( t == null )
            return -1;
        else
            return   1 + Math.max( height( t.left ) , height( t.right )) ;    
    }
    
    public void preOrden (BinaryNode x){

        if(x != null){
        System.out.print(x.element);
        preOrden(x.left);
        preOrden(x.right);
        }
    }    
    
    public void postOrden (BinaryNode x){

        if(x != null){
        postOrden(x.left);
        postOrden(x.right);
        System.out.print(x.element);
        }
    } 
    
        /**
         *
         * @param a
         * @return
         */
        public int contar (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = new BinaryNode();
        c.add(a);
        int conut = 0;
        while(!c.isEmpty()){
            aux = c.poll();
            if(aux.left != null) {
                c.add(aux.left);
                conut++;
            }
            if(aux.right != null){
                c.add(aux.right);
                conut++;
            }
            
        }
        return conut ;
    }
    
    public void inOrden (BinaryNode x){

        if(x != null){
        inOrden(x.left);
        System.out.print(x.element);
        inOrden(x.right);
        }   
    } 
    
    public void niveles (BinaryNode a){
        Queue<BinaryNode> c = new LinkedList<>(); 
        BinaryNode aux = null;
        c.add(a);
        while(!c.isEmpty()){
            aux = c.poll();
            System.out.print(aux.element + " ");
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }
    }
    
    public int distancia ( BinaryNode<Interger> t, int x , int y ){
        
        BinaryNode<Interger> aux = AncestorNode(t, x, y);
        int count = 0;
            while ( aux.element != x ){
                if ( x < aux.element) aux = aux.left;
                else aux = aux.right;
             count++;
            }
        return count;
    
    }
    
    public BinaryNode<Interger> AncestorNode( BinaryNode<Interger> node, int n1, int n2 ) {
        if (node == null) {
            return null;
        }
       
        if (n1 < node.element && n2 < node.element) {
            return AncestorNode(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return AncestorNode(node.right, n1, n2);
        }
 
        return node;
    }
    
    public int lca( BinaryNode<Interger> node, int n1, int n2 ) {

        
        if (n1 < node.element && n2 < node.element) {
            return lca(node.left, n1, n2);
        }
 
        
        if (n1 > node.element && n2 > node.element) {
            return lca(node.right, n1, n2);
        }
 
        return node.element;
    }
    
    public BinaryNode<Integer> getNode( int x, BinaryNode<Integer> t ){
        
        while( t != null )
        {
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public BinaryNode<Integer> getNode( int x )
    {
        return getNode(x, root);
    }
    
    
    public static class BinaryNode<Integer>
    {

        public BinaryNode() {
        }
    
        
        
        BinaryNode(int theElement)
        {
             this( theElement, null, null );
        }

        BinaryNode( int theElement, BinaryNode<Integer> lt, BinaryNode<Integer> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        int element;            
        BinaryNode<Integer> left;   
        BinaryNode<Integer> right;  
    }

    
    
    public BinaryNode<Interger> getRoot() {
          return root;
    }

    private BinaryNode root;


   
}
    
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int n = 1;
        while ( casos > 0 ){
            System.out.println("Caso #"+n+":");
            BinarySearchTree< Integer > tree = new BinarySearchTree<>();
            int numComandos = sc.nextInt();
            sc.nextLine();
            while ( numComandos > 0 ){
            
                String comando = sc.nextLine();
                String[ ] arrayComando = comando.split(" ");
                                
                if ( arrayComando[ 0 ].equals("distancia")){
                    
                    int x = Integer.parseInt(arrayComando[ 1 ]);
                    int y = Integer.parseInt(arrayComando[ 2 ]);
                    if ( tree.getRoot() == null ) System.out.println("distancia: -1");
                    else if ( tree.contains(x) == true && tree.contains(y) == true ) System.out.println("distancia: "  + (tree.distancia(tree.getRoot(), y, x) + tree.distancia(tree.getRoot(), x, y)) );
                    else System.out.println("distancia: -1");
                }else{
                    if ( arrayComando[ 0 ].equals("ancestro")  ){
                        int n1 = Integer.parseInt(arrayComando[ 1 ]);
                        int n2 = Integer.parseInt(arrayComando[ 2 ]);
                        if ( tree.getRoot() == null ) System.out.println("ancestro: -1");
                        else if ( tree.contains(n1) == true && tree.contains(n2) == true ) System.out.println("ancestro: " + tree.lca(tree.getRoot(), n1, n2));
                        else System.out.println("ancestro: -1");
                    }else{
                       if ( arrayComando[ 0 ].equals("agregar")  ){
                           int x = Integer.parseInt(arrayComando[ 1 ]);
                           tree.insert(x);
                       }else{
                           if ( arrayComando[ 0 ].equals("contar")){
                           int U = Integer.parseInt(arrayComando[ 1 ]);
                           if ( tree.getRoot() == null ) System.out.println("contar: -1");
                           else if ( tree.contains(U) ) System.out.println("contar: " + tree.contar(tree.getNode(U)));
                           else System.out.println( "contar: -1" );
                           }
                       }
                    }
                }
                numComandos--;
            }    
            casos--;
            n++;
        }
    }
    
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.lang.reflect.Array;
import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList<Integer> printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
        return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    public boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList<Integer> printTree( AvlNode t )
    {
        if(t != null){
        printTree(t.left);
        array.add(t.element);
        printTree(t.right);
        }   
        return array;
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array = new ArrayList();
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contiene( AvlTree<Integer> t ,AvlTree<Integer> r){
        
        if ( t.contains(r.root.element)){
        ArrayList<Integer> listT =  t.printTree(t.getNode(r.root.element));
        ArrayList<Integer> listR =  r.printTree();
        
            if ( listT.equals(listR) ){
                System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        }else{
            System.out.println("contiene: No");
        }
        
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    AvlTree<Integer> treeIdx = null;
                    AvlTree<Integer> treeIdy = null;
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            if ( list.get(i).getIdx() == idx){
                                treeIdx = list.get(i);
                            }
                            if ( list.get(i).getIdx() == idy){
                                treeIdy = list.get(i);
                            }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                              unir(treeIdx, treeIdy);
                              list.remove(treeIdy);
                        }
                    }
                            
                        
                    
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        
                        if (treeIdx != null && treeIdy != null ){ 
                            contiene(treeIdx, treeIdy);
                        }
                        }
                        
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.lang.reflect.Array;
import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
        return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    public boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList printTree( AvlNode t )
    {
        ArrayList e = new ArrayList();
        Queue<AvlNode> c = new LinkedList<>(); 
        AvlNode aux = null;
        c.add(t);
        while(!c.isEmpty()){
            aux = c.poll();
            e.add(aux.element);
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }   
        return e;
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contiene( AvlTree<Integer> t ,AvlTree<Integer> r){
        
        
        if ( t.contains(r.root.element)){
        ArrayList<Integer> listT =  t.printTree(t.getNode(r.root.element));
        ArrayList<Integer> listR =  r.printTree();
            System.out.println(listT);
            System.out.println(listR);
        
            if ( listT.equals(listR) ){
                System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        }else{
            System.out.println("contiene: No");
        }
        
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    AvlTree<Integer> treeIdx = null;
                    AvlTree<Integer> treeIdy = null;
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            if ( list.get(i).getIdx() == idx){
                                treeIdx = list.get(i);
                            }
                            if ( list.get(i).getIdx() == idy){
                                treeIdy = list.get(i);
                            }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                              unir(treeIdx, treeIdy);
                              list.remove(treeIdy);
                        }
                    }
                            
                        
                    
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        
                        if (treeIdx != null && treeIdy != null ){ 
                            contiene(treeIdx, treeIdy);
                        }
                        }
                        
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoDAux {
    
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
        return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    public boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList printTree( AvlNode t )
    {
        ArrayList e = new ArrayList();
        Queue<AvlNode> c = new LinkedList<>(); 
        AvlNode aux = null;
        c.add(t);
        while(!c.isEmpty()){
            aux = c.poll();
            e.add(aux.element);
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }   
        return e;
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contiene( AvlTree<Integer> t ,AvlTree<Integer> r){
        
        
        if ( t.contains(r.root.element)){
        ArrayList<Integer> listT =  t.printTree(t.getNode(r.root.element));
        ArrayList<Integer> listR =  r.printTree();
        
            if ( listT.equals(listR) ){
                System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        }else{
            System.out.println("contiene: No");
        }
        
    }
    
    public static void main(String[] args) throws Exception {
        
        Scanner sc = new Scanner ( System.in );
        int numComandos = sc.nextInt();
        sc.nextLine();
        ArrayList< AvlTree< Integer > > list = new ArrayList<>();
        while ( numComandos > 0 ){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");
            
            if ( arrayComando[ 0 ].equals("insertar")){
                 int idx = Integer.parseInt(arrayComando[ 1 ]);
                 int x = Integer.parseInt(arrayComando[ 2 ]);
                 if ( !list.isEmpty() ){
                    for ( int i = 0; i < list.size(); i++){
                        if ( !list.get(i).isEmpty() ){
                             if ( list.get(i).getIdx() == idx) list.get(i).insert(x);
                        }
                     
                    }
                 }
            }else{
            
                if ( arrayComando[ 0 ].equals("unir")){
                    int idx = Integer.parseInt(arrayComando[ 1 ]);
                    int idy = Integer.parseInt(arrayComando[ 2 ]);
                    AvlTree<Integer> treeIdx = null;
                    AvlTree<Integer> treeIdy = null;
                    if ( !list.isEmpty()){
                        for ( int i = 0; i < list.size(); i++){
                            if ( list.get(i).getIdx() == idx){
                                treeIdx = list.get(i);
                            }
                            if ( list.get(i).getIdx() == idy){
                                treeIdy = list.get(i);
                            }
                        }
                        if (treeIdx != null && treeIdy != null ){ 
                              unir(treeIdx, treeIdy);
                              list.remove(treeIdy);
                        }
                    }
                            
                        
                    
                }else{
            
                    if ( arrayComando[ 0 ].equals("contiene")){
                        int idx = Integer.parseInt(arrayComando[ 1 ]);
                        int idy = Integer.parseInt(arrayComando[ 2 ]);
                        AvlTree<Integer> treeIdx = null;
                        AvlTree<Integer> treeIdy = null;
                        if ( !list.isEmpty()){
                            for ( int i = 0; i < list.size(); i++){
                                if ( list.get(i).getIdx() == idx){
                                    treeIdx = list.get(i);
                                }
                                if ( list.get(i).getIdx() == idy){
                                    treeIdy = list.get(i);
                                }
                        }
                        
                        if (treeIdx != null && treeIdy != null ){ 
                            contiene(treeIdx, treeIdy);
                        }
                        }
                        
                    }else{
            
                        if ( arrayComando[ 0 ].equals("ocurrencia")){
                            int idx = Integer.parseInt(arrayComando[ 1 ]);
                            int x = Integer.parseInt(arrayComando[ 2 ]);
                            if ( !list.isEmpty()){
                                for ( int i = 0; i < list.size(); i++){
                                    if (list.get(i).getRoot() != null){
                                        if ( !list.get(i).isEmpty()){
                                            if ( list.get(i).getIdx() == idx ){ 
                                                if ( list.get(i).getNode(x) != null){
                                                    System.out.println("ocurrencia: " + ocurrencia(list.get(i), x) );
                                                }else{
                                                    System.out.println("ocurrencia: 0");   
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }else{
            
                            if ( arrayComando[ 0 ].equals("crear")){
                                int idx = Integer.parseInt(arrayComando[ 1 ]);
                                int x = Integer.parseInt(arrayComando[ 2 ]);
                                AvlTree< Integer > tree = new AvlTree<>( new AvlNode<Integer>(x), idx);
                                int aux = -1; 
                                if ( !list.isEmpty()){
                                    for ( int i = 0; i < list.size(); i++){
                                        if ( list.get(i).getRoot() != null){
                                            if ( list.get(i).equals(tree)){
                                                aux = 1;
                                            }
                                        }
                                    }
                                }
                                if ( aux == -1 ){
                                    list.add(tree);
                                }
                            }
                        }
                    }
                }
            }
            numComandos--;
        }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
      
    public static class AvlTree<Integer>{

        public AvlTree() {
        }
    
        
        
    public AvlTree( AvlNode<Integer> root, int idx )
    {
        this.root = root;
        this.idx = idx;
        this.array = new ArrayList();
               
    }

    public int getIdx() {
        return idx;
    }

    public AvlNode<Integer> getRoot() {
          return root;
    }

    
    
    public void insert( int x )
    {
        root = insert( x, root );
    }

    public void remove( int x )
    {
        root = remove( x, root );
    }

    private AvlNode<Integer> remove( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return t;   
            
        if( x < t.element )
            t.left = remove( x, t.left );
        else if( x > t.element )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null )
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    

    public int findMin( ) 
    {

        return findMin( root ).element;
    }


    public int findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }


    public boolean contains( int x )
    {
        return contains( x, root );
    }


    public void makeEmpty( )
    {
        root = null;
    }


    public boolean isEmpty( )
    {
        return root == null;
    }

    
    public ArrayList printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        
        return printTree( root );
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    
    private AvlNode<Integer> balance( AvlNode<Integer> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<Integer> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    

    private AvlNode<Integer> insert( int x, AvlNode<Integer> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        if( x < t.element )
            t.left = insert( x, t.left );
        else if( x > t.element )
            t.right = insert( x, t.right );
        else
                t.ocurrencia++;  
            
        return balance( t );
    }


    private AvlNode<Integer> findMin( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }


    private AvlNode<Integer> findMax( AvlNode<Integer> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }


    public boolean contains( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return true;
        }

        return false;   
    }

    private AvlNode<Integer> getNode( int x, AvlNode<Integer> t )
    {
        while( t != null )
        {
            
            
            if( x < t.element )
                t = t.left;
            else if( x > t.element )
                t = t.right;
            else
                return t;
        }

        return null;   
    }

    public AvlNode<Integer> getNode( int x )
    {
        return getNode(x, root );
    }
    
    public ArrayList printTree( AvlNode t )
    {
        ArrayList e = new ArrayList();
        Queue<AvlNode> c = new LinkedList<>(); 
        AvlNode aux = null;
        c.add(t);
        while(!c.isEmpty()){
            aux = c.poll();
            e.add(aux.element);
            if(aux.left != null) c.add(aux.left);
            if(aux.right != null) c.add(aux.right);
        }   
        return e;
    }


    private int height( AvlNode<Integer> t )
    {
        return t == null ? -1 : t.height;
    }


    private AvlNode<Integer> rotateWithLeftChild( AvlNode<Integer> k2 )
    {
        AvlNode<Integer> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }


    private AvlNode<Integer> rotateWithRightChild( AvlNode<Integer> k1 )
    {
        AvlNode<Integer> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }


    private AvlNode<Integer> doubleWithLeftChild( AvlNode<Integer> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }


    private AvlNode<Integer> doubleWithRightChild( AvlNode<Integer> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }



    private int idx;
    private AvlNode<Integer> root;
    private ArrayList array;
    
}
    
    public static class AvlNode<AnyType>
    {

        public AvlNode() {
            this.ocurrencia = 1;
        }
            
        
        
        AvlNode( int theElement )
        {
            this( theElement, null, null );
            this.ocurrencia = 1;
        }

        AvlNode( int theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            height   = 0;
            ocurrencia = 1;
        }

        int               element;      
        AvlNode<AnyType>  left;         
        AvlNode<AnyType>  right;        
        int               height;
        int               ocurrencia;

        public int getElement() {
            return element;
        }

        public void setOcurrencia(int ocurrencia) {
            this.ocurrencia = ocurrencia;
        }

        
        
        public int getOcurrencia() {
             return ocurrencia;
        }
        
    }
    
   
    public static void unir( AvlTree<Integer> t, AvlTree<Integer> r){
        
        if ( !r.isEmpty() && !t.isEmpty()){
            while ( !r.isEmpty()){
                while ( r.getNode(r.findMin()).getOcurrencia() > 0){
                    t.insert(r.findMin());
                    r.getNode(r.findMin()).setOcurrencia(r.getNode(r.findMin()).getOcurrencia() - 1);
                }
                r.remove(r.findMin());
            }
        }
        
    }
    
    public static int ocurrencia( AvlTree<Integer> t , int x){
        
        if ( !t.isEmpty() ){
        return t.getNode(x).getOcurrencia();
        }
        return -1;
    }
    
    public static void contiene( AvlTree<Integer> t ,AvlTree<Integer> r){
        
        
        if ( t.contains(r.root.element)){
        ArrayList<Integer> listT =  t.printTree(t.getNode(r.root.element));
        ArrayList<Integer> listR =  r.printTree();
        
            if ( listT.equals(listR) ){
                System.out.println("contiene: Yes");
            }else{
                System.out.println("contiene: No");
            }
        }else{
            System.out.println("contiene: No");
        }
        
    }
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            Queue < Integer > cola = new LinkedList<>();
            AvlTree< Integer > tree = new AvlTree<>();
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                tree.insert(nNumeros);
                if ( cola.isEmpty() ) cola.add( nNumeros);
                else if ( !cola.contains(nNumeros) ) cola.add( nNumeros);
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            while ( !cola.isEmpty() ){
                System.out.println( cola.peek() + " " + ocurrencia(tree, cola.peek()) );
                cola.poll();
            }
            
            casos--;
            i++;
        }
            
        
        
    }
    
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoCHeap {
    
    public static class SegmentTree {

        int start, end;
        SegmentTree leftTree, rightTree;
        int maxValue , multiplicar;

        public SegmentTree(int start, int end) {
            this.start = start;
            this.end = end;
            this.maxValue = Integer.MIN_VALUE;
            this.multiplicar = Integer.MAX_VALUE;
            if(start == end) { 
                leftTree = rightTree = null;
                return;
            }

        int mid = (start + end) / 2;
        leftTree = new SegmentTree(start, mid);
        rightTree = new SegmentTree(mid + 1, end);
        }

        public void set(int pos, int value) {
            // es una hoja, CASO BASE
            if(start == end) {
                maxValue = value;
                multiplicar = value;
                return;
            }
            int mid = (start + end) / 2;
            if(pos <= mid)
                leftTree.set(pos, value);
            else
                rightTree.set(pos, value);

            maxValue = Math.max(leftTree.maxValue, rightTree.maxValue);
            multiplicar = leftTree.multiplicar * rightTree.multiplicar;
            
        }

        public int getMax(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return maxValue;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMax(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMax(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            int leftMax = leftTree.getMax(low, mid);
            int rightMax = rightTree.getMax(mid+1, high);
            return Math.max(leftMax, rightMax);
        }
        
        public int getMul(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return multiplicar;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMul(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMul(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            int leftMax = leftTree.getMul(low, mid);
            int rightMax = rightTree.getMul(mid+1, high);
            return leftMax * rightMax;
        }
    }
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner(System.in);
        
        int casos = sc.nextInt();
        int l = 1;
        
        while ( casos > 0 ){
            
            int n = sc.nextInt();
            int k = sc.nextInt();
            SegmentTree st = new SegmentTree(0, n - 1);

            for ( int i = 0; i < n; i++ ){
                int xi = sc.nextInt();
                st.set(i, xi);
            }
            System.out.println("Caso #" + l +":");
            while ( k > -1){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");

            if ( arrayComando[ 0 ].equals("cambio")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                st.set(idx - 1, x);
                
            }else{
                if ( arrayComando[ 0 ].equals("multiplicar")){
                    int j = Integer.parseInt(arrayComando[ 1 ]);
                    int h = Integer.parseInt(arrayComando[ 2 ]);
                    int multi = st.getMul(j - 1, h - 1);
                    if ( multi < 0 ) System.out.println("-");
                    else if ( multi == 0 ) System.out.println("0");
                    else System.out.println("+");
                }
            }
            k--;
            }
            l++;
            casos--;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoDHeap {
       
    public static class SegmentTree {

        int start, end;
        SegmentTree leftTree, rightTree;
        double maxValue , multiplicar ,minValue;

        public SegmentTree(int start, int end) {
            this.start = start;
            this.end = end;
            this.maxValue = Double.MIN_VALUE;
            this.multiplicar = Double.MAX_VALUE;
            this.minValue = Double.MAX_VALUE;
            if(start == end) { 
                leftTree = rightTree = null;
                return;
            }

        int mid = (start + end) / 2;
        leftTree = new SegmentTree(start, mid);
        rightTree = new SegmentTree(mid + 1, end);
        }

        public void set(int pos, double value) {
            // es una hoja, CASO BASE
            if(start == end) {
                maxValue = value;
                multiplicar = value;
                minValue = value;
                return;
            }
            int mid = (start + end) / 2;
            if(pos <= mid)
                leftTree.set(pos, value);
            else
                rightTree.set(pos, value);

            maxValue = Math.max(leftTree.maxValue, rightTree.maxValue);
            minValue = Math.min(leftTree.minValue, rightTree.minValue);
            multiplicar = leftTree.multiplicar * rightTree.multiplicar;
            
        }

        public double getMax(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return maxValue;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMax(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMax(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            double leftMax = leftTree.getMax(low, mid);
            double rightMax = rightTree.getMax(mid+1, high);
            return Math.max(leftMax, rightMax);
        }
        
        public double getMin(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return minValue;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMin(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMin(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            double leftMin = leftTree.getMin(low, mid);
            double rightMin = rightTree.getMin(mid+1, high);
            return Math.min(leftMin, rightMin);
        }
        
        public double getMul(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return multiplicar;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMul(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMul(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            double leftMax = leftTree.getMul(low, mid);
            double rightMax = rightTree.getMul(mid+1, high);
            return leftMax * rightMax;
        }
    }
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner(System.in);
        
        int casos = sc.nextInt();
        int l = 1;
        
        while ( casos > 0 ){
            
            int n = sc.nextInt();
            sc.nextLine();
            ArrayList< Double > list = new ArrayList<>();

            for ( int i = 0; i < n; i++ ){
                String  xi = sc.nextLine();
                String[ ] arrayXI = xi.split(" ");
                for ( int g = 0; g < arrayXI.length; g++){
                    list.add(Double.parseDouble(arrayXI[ g ]));
                }
            }
            
            SegmentTree st = new SegmentTree(0, list.size() - 1);
            for ( int g = 0; g < list.size(); g++){
                st.set(g, list.get(g));
            }            
            
            System.out.println("Caso #" + l +":");
            int k = sc.nextInt();
            sc.nextLine();

            while ( k > 0){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");

            if ( arrayComando[ 0 ].equals("cambiar")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                double x = Double.parseDouble(arrayComando[ 2 ]);
                st.set(idx , x);
                
            }else{
                if ( arrayComando[ 0 ].equals("consultar")){
                    int j = Integer.parseInt(arrayComando[ 1 ]);
                    int h = Integer.parseInt(arrayComando[ 2 ]);
                    String strMax = Double.toString(st.getMax(j, h));
                    String strMin = Double.toString(st.getMin(j, h));
                    int max = 0;
                    int min = 0;
                    if ( strMax.contains(".0")) {
                        max = (int)Double.parseDouble(strMax);
                        if ( strMin.contains(".0") ){
                           min = (int)Double.parseDouble(strMin);
                           System.out.println(max + " " + min);
                        }else{
                           System.out.println(max + " " + st.getMin(j, h));
                        }
                    }else{
                        if ( strMin.contains(".0") ) {
                            min = (int)Double.parseDouble(strMin);
                            System.out.println(st.getMax(j, h) + " " + min);
                            
                        }else{
                            
                            System.out.println(st.getMax(j, h) +" " + st.getMin(j, h));
                            
                        }
                    }
                }
            }
            k--;
            }
            l++;
            casos--;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoAHeap {

  public static class MaxPQ<Key> {
    private Key[] pq;                
    private int N;                   
    private Comparator<Key> comparator;  

    public MaxPQ(int initCapacity) {
        pq = (Key[]) new Object[initCapacity + 1];
        N = 0;
    }

    public MaxPQ() {
        this(1);
    }

    public MaxPQ(int initCapacity, Comparator<Key> comparator) {
        this.comparator = comparator;
        pq = (Key[]) new Object[initCapacity + 1];
        N = 0;
    }

    public MaxPQ(Comparator<Key> comparator) {
        this(1, comparator);
    }

    public MaxPQ(Key[] keys) {
        N = keys.length;
        pq = (Key[]) new Object[keys.length + 1]; 
        for (int i = 0; i < N; i++)
            pq[i+1] = keys[i];
        for (int k = N/2; k >= 1; k--)
            sink(k);
        assert isMaxHeap();
    }
      
    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
        return pq[1];
    }
    
    public Key max2() {
        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");

        return pq[2];
    }
    
    public Key max5() {
        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
        return pq[5];
    }
    
    public Key max3() {
        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
        return pq[3];
    }
    
    private void resize(int capacity) {
        assert capacity > N;
        Key[] temp = (Key[]) new Object[capacity];
        for (int i = 1; i <= N; i++) {
            temp[i] = pq[i];
        }
        pq = temp;
    }


    public void insert(Key x) {

        if (N >= pq.length - 1) resize(2 * pq.length);
        if ( pq.length > 4 ){
        if ( Math.pow(2, N-1) <= pq.length && pq.length <= (Math.pow(2, N-1) + Math.pow(2, N-2) - 1)){
        int compare = ((Comparable<Key>) x ).compareTo(pq[ 3 ]);
        int compare2 = ((Comparable<Key>) pq[ 2 ] ).compareTo(pq[ 3 ]);
        if ( compare > 0 && compare2 > 0){
            Key aux = pq[ 2 ];
            pq[ 2 ] = pq[ 3 ];
            pq[ 3 ] = aux;
        }
        }else{
            
          int compare = ((Comparable<Key>) x ).compareTo(pq[ 3 ]);
          int compare2 = ((Comparable<Key>) pq[ 3 ] ).compareTo(pq[ 2 ]);
          if ( compare > 0 && compare2 > 0){
            Key aux = pq[ 2 ];
            pq[ 2 ] = pq[ 3 ];
            pq[ 3 ] = aux;
        }
        }
        
        }
        
        pq[++N] = x;
        swim(N);
        assert isMaxHeap();
        
    }

    public Key delMax() {
        if (isEmpty()) throw new NoSuchElementException("Priority queue underflow");
        Key max = pq[1];
        exch(1, N--);
        sink(1);
        pq[N+1] = null;    
        if ((N > 0) && (N == (pq.length - 1) / 4)) resize(pq.length / 2);
        assert isMaxHeap();
        return max;
    }


    private void swim(int k) {
        while (k > 1 && less(k/2, k)) {
            exch(k, k/2);
            k = k/2;
        }
    }

    private void sink(int k) {
        while (2*k <= N) {
            int j = 2*k;
            if (j < N && less(j, j+1)) j++;
            if (!less(k, j)) break;
            exch(k, j);
            k = j;
        }
    }

    private boolean less(int i, int j) {
        if (comparator == null) {
            return ((Comparable<Key>) pq[i]).compareTo(pq[j]) < 0;
        }
        else {
            return comparator.compare(pq[i], pq[j]) < 0;
        }
    }

    private void exch(int i, int j) {
        Key swap = pq[i];
        pq[i] = pq[j];
        pq[j] = swap;
    }

    private boolean isMaxHeap() {
        return isMaxHeap(1);
    }

    private boolean isMaxHeap(int k) {
        if (k > N) return true;
        int left = 2*k, right = 2*k + 1;
        if (left  <= N && less(k, left))  return false;
        if (right <= N && less(k, right)) return false;
        return isMaxHeap(left) && isMaxHeap(right);
    }
  }
  public static class SegmentTree {

        int start, end;
        SegmentTree leftTree, rightTree;
        int maxValue, minValue;

        public SegmentTree(int start, int end) {
            this.start = start;
            this.end = end;
            this.maxValue = Integer.MIN_VALUE;
            this.minValue = Integer.MAX_VALUE;
            if(start == end) { 
                leftTree = rightTree = null;
                return;
            }

        int mid = (start + end) / 2;
        leftTree = new SegmentTree(start, mid);
        rightTree = new SegmentTree(mid + 1, end);
        }

        
        public void set(int pos, int value) {
            // es una hoja, CASO BASE
            if(start == end) {
                maxValue = value;
                minValue = value;
                return;
            }
            int mid = (start + end) / 2;
            if(pos <= mid)
                leftTree.set(pos, value);
            else
                rightTree.set(pos, value);

            maxValue = Math.max(leftTree.maxValue, rightTree.maxValue);
            minValue = Math.min(leftTree.maxValue, rightTree.maxValue);
        }

        public int getMax(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return maxValue;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMax(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMax(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            int leftMax = leftTree.getMax(low, mid);
            int rightMax = rightTree.getMax(mid+1, high);
            return Math.max(leftMax, rightMax);
        }
       
        public int getMax2(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return minValue;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMax2(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMax2(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            int leftMax = leftTree.getMax2(low, mid);
            int rightMax = rightTree.getMax2(mid+1, high);
            return Math.max(leftMax, rightMax);
        }
    }
    
    public static void main (String[] args){
     
		Scanner sc = new Scanner(System.in);
                MaxPQ< Integer > pq = new MaxPQ<>();
                int nArreglo = sc.nextInt();
                SegmentTree st = new SegmentTree(0, nArreglo - 1);
                                
		int[] a = new int[nArreglo];
                for ( int i = 0; i < a.length; i++){
                    a[ i ] = sc.nextInt();
                    st.set(i, a[i]);
                    pq.insert(a[ i ]);
                    if ( i < 2){
                        System.out.println("-1");
                    }else{

                        System.out.println( pq.max() * pq.max2() * pq.max3() );
                    }
                    
                }
                
                
                
                
                
                
                
                
		
		
 
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoCHeap {
    
    public static class SegmentTree {

        int start, end;
        SegmentTree leftTree, rightTree;
        int maxValue , multiplicar;

        public SegmentTree(int start, int end) {
            this.start = start;
            this.end = end;
            this.maxValue = Integer.MIN_VALUE;
            this.multiplicar = Integer.MAX_VALUE;
            if(start == end) { 
                leftTree = rightTree = null;
                return;
            }

        int mid = (start + end) / 2;
        leftTree = new SegmentTree(start, mid);
        rightTree = new SegmentTree(mid + 1, end);
        }

        public void set(int pos, int value) {
            // es una hoja, CASO BASE
            if(start == end) {
                maxValue = value;
                multiplicar = value;
                return;
            }
            int mid = (start + end) / 2;
            if(pos <= mid)
                leftTree.set(pos, value);
            else
                rightTree.set(pos, value);

            maxValue = Math.max(leftTree.maxValue, rightTree.maxValue);
            multiplicar = leftTree.multiplicar * rightTree.multiplicar;
            
        }

        public int getMax(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return maxValue;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMax(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMax(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            int leftMax = leftTree.getMax(low, mid);
            int rightMax = rightTree.getMax(mid+1, high);
            return Math.max(leftMax, rightMax);
        }
        
        public int getMul(int low, int high) {
            // [low,high] = [start,end]
            if(start == low && end == high)
                return multiplicar;
    
            int mid = (start + end) / 2;
            // [low,high] totalmente incluido en [start,mid]
            if(high <= mid)
                return leftTree.getMul(low, high);
           
            // [low,high] totalmente incluido en [mid+1,end]
            if(low > mid)
                return rightTree.getMul(low, high);

            // debemos dividir el intervalo en [low,mid] y [mid+1,high]
            int leftMax = leftTree.getMul(low, mid);
            int rightMax = rightTree.getMul(mid+1, high);
            return leftMax * rightMax;
        }
    }
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner(System.in);
        
        int casos = sc.nextInt();
        int l = 1;
        
        while ( casos > 0 ){
            
            int n = sc.nextInt();
            int k = sc.nextInt();
            SegmentTree st = new SegmentTree(0, n - 1);

            for ( int i = 0; i < n; i++ ){
                int xi = sc.nextInt();
                st.set(i, xi);
            }
            System.out.println("Caso #" + l +":");
            while ( k > -1){
            String comando = sc.nextLine();
            String[ ] arrayComando = comando.split(" ");

            if ( arrayComando[ 0 ].equals("cambio")){
                int idx = Integer.parseInt(arrayComando[ 1 ]);
                int x = Integer.parseInt(arrayComando[ 2 ]);
                st.set(idx - 1, x);
                
            }else{
                if ( arrayComando[ 0 ].equals("multiplicar")){
                    int j = Integer.parseInt(arrayComando[ 1 ]);
                    int h = Integer.parseInt(arrayComando[ 2 ]);
                    int multi = st.getMul(j - 1, h - 1);
                    if ( multi < 0 ) System.out.println("-");
                    else if ( multi == 0 ) System.out.println("0");
                    else System.out.println("+");
                }
            }
            k--;
            }
            l++;
            casos--;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            Stack < Integer > pila = new Stack<>();
            HashMap< Integer , Integer > tabla = new HashMap<>();
            
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                if ( tabla.isEmpty() ) {
                    tabla.put(nNumeros, 1);
                }
                else{ 
                    if ( tabla.containsKey(nNumeros) ) {
                        tabla.replace(nNumeros, tabla.get(nNumeros) + 1);
                    }else tabla.put(nNumeros, 1);
                }
                
                
                
                if ( pila.isEmpty() ) pila.push (nNumeros);
                else if ( !pila.contains(nNumeros) ) pila.push( nNumeros);
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            int k = 0;
            while ( k < pila.size() ){
                System.out.println( pila.get(k) + " " + tabla.get(pila.get(k)) );
                k++;
            }
            
            casos--;
            i++;
        }
            
        
        
    }
    
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            Stack < Integer > pila = new Stack<>();
            HashMap< Integer , Integer > tabla = new HashMap<>();
            
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                if ( tabla.isEmpty() ) {
                    tabla.put(nNumeros, 1);
                }
                else{ 
                    if ( tabla.containsKey(nNumeros) ) {
                        tabla.replace(nNumeros, (tabla.get(nNumeros) + 1));
                    }else tabla.put(nNumeros, 1);
                }
                
                
                
                if ( pila.isEmpty() ) pila.push (nNumeros);
                else if ( !pila.contains(nNumeros) ) pila.push( nNumeros);
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            int k = 0;
            while ( k < pila.size() ){
                System.out.println( pila.get(k) + " " + tabla.get(pila.get(k)) );
                k++;
            }
            
            casos--;
            i++;
        }
            
        
        
    }
    
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            Stack < Integer > pila = new Stack<>();
            HashMap< Integer , Integer > tabla = new HashMap<>();
            
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                if ( tabla.isEmpty() ) {
                    tabla.put(nNumeros, 1);
                }
                else{ 
                    if ( tabla.containsKey(nNumeros) ) {
                        tabla.put(nNumeros, (tabla.get(nNumeros) + 1));
                    }else tabla.put(nNumeros, 1);
                }
                
                
                
                if ( pila.isEmpty() ) pila.push (nNumeros);
                else if ( !pila.contains(nNumeros) ) pila.push( nNumeros);
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            int k = 0;
            while ( k < pila.size() ){
                System.out.println( pila.get(k) + " " + tabla.get(pila.get(k)) );
                k++;
            }
            
            casos--;
            i++;
        }
            
        
        
    }
    
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;
public class PuntoC {
	public static  class NodoArbol {
	      int dato;
	      int valor;
	      NodoArbol hijoIzquierdo;
	      NodoArbol hijoDerecho;
	      
	      public NodoArbol(int n, int v){
	    	  this.dato = n;
	    	  this.valor = v;
	    	  this.hijoDerecho = null;
	    	  this.hijoIzquierdo = null;
	      }
	      
	      public int mostrarValor(){
	    	  return valor;
	      }
	      public int mostrarDato(){
	    	  return dato;
	      }
	}
	public static class arbolBinario{
		NodoArbol raiz;
		
		public arbolBinario(NodoArbol raiz){
			this.raiz = raiz;
		}
		public boolean estaVacio(){
			return raiz == null;
		}
		
		public  int lvlOrder(NodoArbol r){
	        Queue<NodoArbol> cola = new LinkedList<NodoArbol>();
	        int sum = 0;
	        cola.add(r);
	         while(!cola.isEmpty()){
	        	 NodoArbol temp = cola.poll();
	        	 sum = sum + temp.valor;
	        	if(temp.hijoIzquierdo != null)
	        		cola.add(temp.hijoIzquierdo);
	        	 if(temp.hijoDerecho != null)
	        		 cola.add(temp.hijoDerecho);
	         }
	         return sum;
	     }
	}
	public static void enlazarIzquierda(NodoArbol a, NodoArbol b){
		if(a.hijoIzquierdo == null){
			a.hijoIzquierdo = b;
		}else if(a.hijoIzquierdo != null){
			a.hijoDerecho = b;
		}
	  }
	
public static void DFS(int numNodos, arbolBinario arbol, boolean [] visitados, int sum){
		Stack <NodoArbol> pila  = new Stack<NodoArbol>();
		Stack <Integer> comparar = new Stack<Integer>();
		 pila.push(arbol.raiz);
		 visitados[arbol.raiz.dato] = true;
		  while( !pila.isEmpty()){
			  NodoArbol aux = pila.peek();
			 if(aux.hijoIzquierdo != null && !visitados[aux.hijoIzquierdo.dato] ){
				 visitados[aux.hijoIzquierdo.dato] = true;
			     pila.push(aux.hijoIzquierdo);
			 }else if(aux.hijoDerecho != null && !visitados[aux.hijoDerecho.dato]){
				 visitados[aux.hijoDerecho.dato] = true;
				 pila.push(aux.hijoDerecho);
			 }else{
				 int temp = arbol.lvlOrder(pila.pop());
				 int resta = Math.abs(sum - 2*(temp));
				   if(comparar.isEmpty()){
					   comparar.push(resta);
				   }else{
					   if(comparar.peek() > resta){
						   comparar.pop();
						   comparar.push(resta);
					   }
				    }
				 }
		     }
		  System.out.println(comparar.peek());
	}
	
public static void main(String [] args){
	Scanner entrada = new Scanner(System.in);
	int numCasos = entrada.nextInt();
	for(int i = 0; i < numCasos; i++){
		 int suma = 0;
		 System.out.println("Caso #"+(i+1)+":");
		   int numNodos = entrada.nextInt();
		   NodoArbol array [] = new NodoArbol[numNodos];
		   boolean visitados [] = new boolean[numNodos];
	         for(int j = 0; j < numNodos; j++){
	             int value = entrada.nextInt();
	             suma = suma+value;
	        	 NodoArbol node = new NodoArbol(j,value);
	        	 array[j] = node;
	         }
	         for(int k = 0;k < numNodos-1; k++){
	        	 int a = entrada.nextInt();
	        	 int b = entrada.nextInt();
	        	 enlazarIzquierda(array[a-1], array[b-1]);
	        }
	         arbolBinario arbol = new arbolBinario(array[0]);
	        //System.out.println(arbol.lvlOrder(arbol.raiz));
	         for( int t = 0; t < visitados.length; t++){
	        	 visitados[t] = false;
	         }
	       DFS(numNodos, arbol, visitados, suma);
	      } 
	  }
  }
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            int[ ] pila = new int[ n ];
            HashMap< Integer , Integer > tabla = new HashMap<>();
            int count = 0;
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                if ( !tabla.containsKey(nNumeros) ) {
                    tabla.put(nNumeros, 1);
                    pila[ count++ ] = nNumeros;
                    
                }
                else{ 
                        tabla.put(nNumeros, (tabla.get(nNumeros) + 1));
                    
                }
                
                
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            int k = 0;
            while ( k < pila.length ){
                System.out.println( pila[ k ] + " " + tabla.get(pila[ k ]) );
                k++;
            }
            
            casos--;
            i++;
        }
            
        
        
    }
    
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            int[ ] pila = new int[ n ];
            HashMap< Integer , Integer > tabla = new HashMap<>();
            int count = 0;
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                if ( !tabla.containsKey(nNumeros) ) {
                    tabla.put(nNumeros, 1);
                    pila[ count++ ] = nNumeros;
                    
                }
                else{ 
                        tabla.put(nNumeros, (tabla.get(nNumeros) + 1));
                    
                }
                
                
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            for (int j = 0 ; j < count; j++)				
		System.out.println( pila[j] + " " + tabla.get(pila[j]));
			
		}
            
            casos--;
            i++;
        }
            
        
        
    }
    
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;
import java.util.LinkedList;
public class heapProblemaB2 {
	public static class Work{
		int priority;
		int index;
		
		public Work(int priority, int index){
			this.index = index;
			this.priority = priority;
		}
	}
	
public static void priorityQ(LinkedList<Work> lista,int nodos,int pos,
	int c9,int c8,int c7,int c6,int c5,int c4,int c3,int c2,int c1,boolean flag,int fflag){
	int count = 0;
	int co = 0;
    if(c9 != 0){
    	while(c9 != 0){
    		if(lista.peek().priority == 9){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c9--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(c8 != 0){
    	while(c8 != 0){
    		if(lista.peek().priority == 8){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c8--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(c7 != 0){
    	while(c7 != 0){
    		if(lista.peek().priority == 7){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c7--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(c6 != 0){
    	while(c6 != 0){
    		if(lista.peek().priority == 6){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c6--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(c5 != 0){
    	while(c5 != 0){
    		if(lista.peek().priority == 5){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c5--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(c4 != 0){
    	while(c4 != 0){
    		if(lista.peek().priority == 4){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c4--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(c3 != 0){
    	while(c3 != 0){
    		if(lista.peek().priority == 3){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c3--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(c2 != 0){
    	while(c2 != 0){
    		if(lista.peek().priority == 2){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c2--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(c1 != 0){
    	while(c1 != 0){
    		if(lista.peek().priority == 1){
    			if(lista.peek().index == pos){
    				count++;
    				co = count;
    			}
    			lista.poll();
    			  c1--; count++;
    		}else{
    			Work temp = lista.poll();
    			lista.addLast(temp);
    		}
    	}
    }
    if(flag == true){
    	System.out.println(co+fflag);
    }else{
    	System.out.println(co);
    }
  }
public static void main(String[] args) {
	Scanner entrada = new Scanner(System.in);
	int casos = entrada.nextInt();
	for(int i = 0; i < casos; i++){
		boolean flag = false;
		int fflag = 0;
		LinkedList <Work> trabajos = new LinkedList<Work>();
		int nodos = entrada.nextInt();
		int pos = entrada.nextInt();
		int c9=0;int c8=0;int c7=0;int c6=0;int c5=0;int c4=0;int c3=0;int c2=0;int c1=0;		
	 for(int j = 0; j < nodos; j++){
		 int prio = entrada.nextInt();
		 	if(prio > 9){flag = true; fflag++;}
	          if(prio == 9){c9++;}
		 else if(prio == 8){c8++ ;}
		 else if(prio == 7){c7++ ;}
		 else if(prio == 6){c6++ ;}
		 else if(prio == 5){c5++ ;}
		 else if(prio == 4){c4++ ;}
		 else if(prio == 3){c3++ ;}
		 else if(prio == 2){c2++ ;}
		 else if(prio == 1){c1++ ;}
		Work temp = new Work(prio, j);
	    trabajos.add(temp); }
	priorityQ(trabajos,nodos,pos,c9,c8,c7,c6,c5,c4,c3,c2,c1,flag,fflag);
	}
  }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            int[ ] pila = new int[ n ];
            HashMap< Integer , Integer > tabla = new HashMap<>();
            int count = 0;
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                if ( !tabla.containsKey(nNumeros) ) {
                    tabla.put(nNumeros, 1);
                    pila[ count++ ] = nNumeros;
                    
                }
                else{ 
                        tabla.put(nNumeros, (tabla.get(nNumeros) + 1));
                    
                }
                
                
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            for (int j = 0 ; j < count; j++)				
		System.out.println( pila[j] + " " + tabla.get(pila[j]));
			
            }
            
            casos--;
            i++;
        }
            
        
        
    }
    



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            int[ ] pila = new int[ n ];
            HashMap< Integer , Integer > tabla = new HashMap<>();
            int count = 0;
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                if ( !tabla.containsKey(nNumeros) ) {
                    tabla.put(nNumeros, 1);
                    pila[ count++ ] = nNumeros;
                    
                }
                else{ 
                        tabla.put(nNumeros, (tabla.get(nNumeros) + 1));
                    
                }
                
                
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            for (int j = 0 ; j < pila.length; j++)				
		System.out.println( pila[j] + " " + tabla.get(pila[j]));
			
            }
            
            casos--;
            i++;
        }
            
        
        
    }
    



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*; 
public class PuntoBHash {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner ( System.in );
        int casos = sc.nextInt();
        sc.nextLine();
        int i = 1;
        
        while ( casos > 0){
            
            int n = sc.nextInt();
            int[ ] pila = new int[ n ];
            HashMap< Integer , Integer > tabla = new HashMap<>();
            int count = 0;
            
            while( n > 0){
                int nNumeros = sc.nextInt();
                if ( tabla.isEmpty() ) {
                    tabla.put(nNumeros, 1);
                    pila[ count++ ] = nNumeros;
                    
                }else{
                    if ( tabla.containsKey(nNumeros)){
                        tabla.put(nNumeros, (tabla.get(nNumeros) + 1));
                    }else{
                     tabla.put(nNumeros, 1);
                    pila[ count++ ] = nNumeros;
                    }
                    
                    
                }
                
                
                n--;
            }
            
            System.out.println("Caso #" + i + ":");
            for (int j = 0 ; j < pila.length; j++)				
		System.out.println( pila[j] + " " + tabla.get(pila[j]));
			
            }
            
            casos--;
            i++;
        }
            
        
        
    }
    



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.*;

public class hashProblemaB {

	public static void main(String[] args) {
		Scanner entrada = new Scanner(System.in);
		int T = entrada.nextInt();
		for (int i = 0; i < T; i++) {
			System.out.println("Caso #" + (i + 1) + ":");
			Map<Integer, Integer> mapa = new HashMap<Integer, Integer>();		
			int num = entrada.nextInt();
			int [] n = new int [num];
			int cont = 0;
			for (int j = 0; j < num; j++) {
				int sec = entrada.nextInt();
				if (!mapa.containsKey(sec)){
					mapa.put(sec, 1);
					n[cont++] = sec;
				}
				else {
					int c = mapa.get(sec);
					mapa.put(sec, ++c);
				}
			}
			for (int j = 0 ; j < cont; j++)				
				System.out.println( n[j] + " " + mapa.get(n[j]));
			
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
