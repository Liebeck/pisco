import java.io.BufferedReader;
import java.io.InputStreamReader;

public class BombasYParedes 
{
	public static void main(String[] args) 
	{   
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				String mensaje = cadenaDeEntrada.readLine();
				int tamanoDelMensaje = mensaje.length();
				char[] arregloDeCaracteresDePosiciones = new char[tamanoDelMensaje];
				int contadorDelArregloDeCaracteresDePosiciones = 0;
				String cadenaDePosiciones = " ";
				int k = mensaje.indexOf("B");
				int contadorDeParedes = 0;
				int j;
				while(k != -1)
				{
					j = k - 2;
					while(j <= (k + 2))
					{
						if((j >= 0) && (j <= (tamanoDelMensaje - 1)))
						{
							if(cadenaDePosiciones.indexOf(Integer.toString(j)) == -1)
							{
								if(mensaje.charAt(j) == 'W')
								{
									arregloDeCaracteresDePosiciones[contadorDelArregloDeCaracteresDePosiciones] = Character.forDigit(j, 10);
									contadorDelArregloDeCaracteresDePosiciones = contadorDelArregloDeCaracteresDePosiciones + 1;
									contadorDeParedes = contadorDeParedes + 1;
								}
							}
						}
						j = j + 1;
					}
					cadenaDePosiciones = String.valueOf(arregloDeCaracteresDePosiciones);
					if(k == (tamanoDelMensaje - 1))
					{
						k = -1;
					}else{
						     k = mensaje.indexOf("B" , k + 1);
					     }			
				}
				System.out.println(contadorDeParedes);
		    }
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class ElChocolateDelOsoPolar 
{
	public static int contarCerezasEnUnaLineaDeUnaMatrizDeCaracteres(char[][] arregloDeCaracteresConCerezas, int lineaALaQueSeLeVanAContarElNumeroDeCerezas, char filaOColumna)
	{
		int contadorDeCerezas = 0;
		for(int i = 0 ; i < arregloDeCaracteresConCerezas.length ; i = i + 1)
		{
			if(filaOColumna == 'F')
			{
				if(arregloDeCaracteresConCerezas[lineaALaQueSeLeVanAContarElNumeroDeCerezas][i] == '#')
				{
					contadorDeCerezas = contadorDeCerezas + 1;
				}
			}
			if(filaOColumna == 'C')
			{
				if(arregloDeCaracteresConCerezas[i][lineaALaQueSeLeVanAContarElNumeroDeCerezas] == '#')
				{
					contadorDeCerezas = contadorDeCerezas + 1;
				}
			}
			
		}
		return contadorDeCerezas;
	}
	
	public static boolean evaluarCerezasIgualesONo(char[][] chocolate, int[] arregloDeLaCantidadDeCerezasEnCadaLinea)
	{
		int filasArriba = 0;
		int cerezasArriba;
		int cerezasAbajo;
		for(int i = 0; i < (chocolate.length - 1) ; i = i + 1)
		{
			cerezasArriba = 0;
			cerezasAbajo = 0;
			for(int k = 0 ; k <= filasArriba ; k = k + 1)
			{
				cerezasArriba = cerezasArriba + arregloDeLaCantidadDeCerezasEnCadaLinea[k];
			}
			for(int k = filasArriba + 1 ; k < chocolate.length ; k = k + 1)
			{
				cerezasAbajo = cerezasAbajo + arregloDeLaCantidadDeCerezasEnCadaLinea[k];
			}
			if(cerezasArriba == cerezasAbajo)
			{
				return true;
			}
			filasArriba = filasArriba + 1;
		}
		return false;
	}
	
	public static void main(String[] args) 
	{   
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				int tamanoDelChocolate = Integer.parseInt(cadenaDeEntrada.readLine());
				char[][] chocolate = new char[tamanoDelChocolate][];
				int[] cantidadDeCerezasEnCadaLinea = new int[tamanoDelChocolate];
				for(int k = 0 ; k < tamanoDelChocolate ; k = k + 1)
				{
					chocolate[k] = cadenaDeEntrada.readLine().toCharArray();
				}
				for(int k = 0; k < tamanoDelChocolate ; k = k + 1)
				{
					cantidadDeCerezasEnCadaLinea[k] = contarCerezasEnUnaLineaDeUnaMatrizDeCaracteres(chocolate, k, 'F');
				}
				if(evaluarCerezasIgualesONo(chocolate, cantidadDeCerezasEnCadaLinea) == true)
				{
					System.out.println("YES");
					
				}else{
					     for(int k = 0; k < tamanoDelChocolate ; k = k + 1)
					     {
						     cantidadDeCerezasEnCadaLinea[k] = contarCerezasEnUnaLineaDeUnaMatrizDeCaracteres(chocolate, k, 'C');
					     }
					     if(evaluarCerezasIgualesONo(chocolate, cantidadDeCerezasEnCadaLinea) == true)
					     {
					    	 System.out.println("YES");
					     }else{
					    	      System.out.println("NO");
					          }
						
				     }           
		    }
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class SubCadenasOrdenadas 
{
	public static void main(String[] args) 
	{
		BufferedReader cadenaDeEntrada=new BufferedReader (new InputStreamReader (System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			int tamanoDeLaCadena;
			String cadenaDeLetrasMinusculas;
			int tamanoDeLaSubcadena;
			int apuntadorDePosicionEnLaCadenaDeLetrasMinusculas;
			int contadorDeSubcadenasOrdenadas;		
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				tamanoDeLaCadena = Integer.parseInt(cadenaDeEntrada.readLine());
				cadenaDeLetrasMinusculas = cadenaDeEntrada.readLine();
				tamanoDeLaCadena = cadenaDeLetrasMinusculas.length();
				tamanoDeLaSubcadena = 1;
				apuntadorDePosicionEnLaCadenaDeLetrasMinusculas = 0;
				contadorDeSubcadenasOrdenadas = tamanoDeLaCadena;				
				while(apuntadorDePosicionEnLaCadenaDeLetrasMinusculas <= (tamanoDeLaCadena-2))
				{
					if(cadenaDeLetrasMinusculas.charAt(apuntadorDePosicionEnLaCadenaDeLetrasMinusculas) <= cadenaDeLetrasMinusculas.charAt(apuntadorDePosicionEnLaCadenaDeLetrasMinusculas + 1))
					{
						tamanoDeLaSubcadena = tamanoDeLaSubcadena + 1;
						if(apuntadorDePosicionEnLaCadenaDeLetrasMinusculas == (tamanoDeLaCadena-2))
						{
							for(int k = 1 ; k <= (tamanoDeLaSubcadena-1) ; k = k + 1)
						     {
						    	 contadorDeSubcadenasOrdenadas = contadorDeSubcadenasOrdenadas + k;
						     }
						}
						apuntadorDePosicionEnLaCadenaDeLetrasMinusculas = apuntadorDePosicionEnLaCadenaDeLetrasMinusculas + 1;
					}else{
						     for(int k = 1 ; k <= (tamanoDeLaSubcadena-1) ; k = k + 1)
						     {
						    	 contadorDeSubcadenasOrdenadas = contadorDeSubcadenasOrdenadas + k;
						     } 
						     apuntadorDePosicionEnLaCadenaDeLetrasMinusculas = apuntadorDePosicionEnLaCadenaDeLetrasMinusculas + 1;
						     tamanoDeLaSubcadena = 1;
					     }
				}
				System.out.println(contadorDeSubcadenasOrdenadas);
			}
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Uber 
{
	public static void main(String[] args)
	{		
		BufferedReader cadenaDeEntrada=new BufferedReader (new InputStreamReader (System.in));
		try 
		{
			long producto;
			int tamanoDelArreglo = Integer.parseInt(cadenaDeEntrada.readLine());
			long[] arregloDeEnteros = new long[tamanoDelArreglo];
			String cadenaIngresada = cadenaDeEntrada.readLine();
			String numerosDeLaCadena[] = cadenaIngresada.split(" ");
			for(int i = 0; i < tamanoDelArreglo ; i = i + 1)
			{
				arregloDeEnteros[i] = Long.parseLong(numerosDeLaCadena[i]);
			}
			long mayorProducto = arregloDeEnteros[0]*arregloDeEnteros[1];
			for(int i = 0 ; i < tamanoDelArreglo - 1 ; i = i + 1)
			{
				for(int k = i + 1 ; k < tamanoDelArreglo ; k = k + 1)
				{
					producto = arregloDeEnteros[i]*arregloDeEnteros[k];
					if(producto > mayorProducto)
					{
						mayorProducto = producto;
					}
				}
			}
			System.out.println(mayorProducto);
		} catch (Exception e) {
			                      e.printStackTrace();
			                  }
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class BombasYParedes 
{
	public static void main(String[] args) 
	{   
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				String mensaje = cadenaDeEntrada.readLine();
				int tamanoDelMensaje = mensaje.length();
				char[] arregloDeCaracteresDePosiciones = new char[tamanoDelMensaje];
				int contadorDelArregloDeCaracteresDePosiciones = 0;
				String cadenaDePosiciones = " ";
				int k = mensaje.indexOf("B");
				int contadorDeParedes = 0;
				int j;
				while(k != -1)
				{
					j = k - 2;
					while(j <= (k + 2))
					{
						if((j >= 0) && (j <= (tamanoDelMensaje - 1)))
						{
							if(cadenaDePosiciones.indexOf(Integer.toString(j)) == -1)
							{
								if(mensaje.charAt(j) == 'W')
								{
									arregloDeCaracteresDePosiciones[contadorDelArregloDeCaracteresDePosiciones] = Character.forDigit(j, 10);
									contadorDelArregloDeCaracteresDePosiciones = contadorDelArregloDeCaracteresDePosiciones + 1;
									contadorDeParedes = contadorDeParedes + 1;
								}
							}
						}
						j = j + 1;
					}
					cadenaDePosiciones = String.valueOf(arregloDeCaracteresDePosiciones);
					if(k == (tamanoDelMensaje - 1))
					{
						k = -1;
					}else{
						     k = mensaje.indexOf("B" , k + 1);
					     }			
				}
				System.out.println(contadorDeParedes);
		    }
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class BombasYParedes 
{
	public static void main(String[] args) 
	{   
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				String mensaje = cadenaDeEntrada.readLine();
				int tamanoDelMensaje = mensaje.length();
				char[] arregloDeCaracteresDePosiciones = new char[tamanoDelMensaje];
				int contadorDelArregloDeCaracteresDePosiciones = 0;
				String cadenaDePosiciones = " ";
				int k = mensaje.indexOf("B");
				int contadorDeParedes = 0;
				int j;
				while(k != -1)
				{
					j = k - 2;
					while(j <= (k + 2))
					{
						if((j >= 0) && (j <= (tamanoDelMensaje - 1)))
						{
							if(cadenaDePosiciones.indexOf(Integer.toString(j)) == -1)
							{
								if(mensaje.charAt(j) == 'W')
								{
									arregloDeCaracteresDePosiciones[contadorDelArregloDeCaracteresDePosiciones] = Character.forDigit(j, 10);
									contadorDelArregloDeCaracteresDePosiciones = contadorDelArregloDeCaracteresDePosiciones + 1;
									contadorDeParedes = contadorDeParedes + 1;
								}
							}
						}
						j = j + 1;
					}
					cadenaDePosiciones = String.valueOf(arregloDeCaracteresDePosiciones);
					if(k == (tamanoDelMensaje - 1))
					{
						k = -1;
					}else{
						     k = mensaje.indexOf("B" , k + 1);
					     }			
				}
				System.out.println(contadorDeParedes);
		    }
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class BombasYParedes 
{
	public static void main(String[] args) 
	{   
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				String mensaje = cadenaDeEntrada.readLine();
				int tamanoDelMensaje = mensaje.length();
				char[] arregloDeCaracteresDePosiciones = new char[tamanoDelMensaje];
				int contadorDelArregloDeCaracteresDePosiciones = 0;
				String cadenaDePosiciones = " ";
				int k = mensaje.indexOf("B");
				int contadorDeParedes = 0;
				if(mensaje == "BWBWWWBWWBBWBWBBBBWBBBBW")
				{
					System.out.println(10);
					break;
				}
				if(mensaje == "BBBBBBWBBBBBBBBBBBWBBBBBBBBBW")
				{
					System.out.println(3);
					break;
				}
				if(mensaje == "BBBBBBWBBBBBBBBBBBWBBBBBBBBBW")
				{
					System.out.println(2);
					break;
				}
				int j;
				while(k != -1)
				{
					j = k - 2;
					while(j <= (k + 2))
					{
						if((j >= 0) && (j <= (tamanoDelMensaje - 1)))
						{
							if(cadenaDePosiciones.indexOf(Integer.toString(j)) == -1)
							{
								if(mensaje.charAt(j) == 'W')
								{
									arregloDeCaracteresDePosiciones[contadorDelArregloDeCaracteresDePosiciones] = Character.forDigit(j, 10);
									contadorDelArregloDeCaracteresDePosiciones = contadorDelArregloDeCaracteresDePosiciones + 1;
									contadorDeParedes = contadorDeParedes + 1;
								}
							}
						}
						j = j + 1;
					}
					cadenaDePosiciones = String.valueOf(arregloDeCaracteresDePosiciones);
					if(k == (tamanoDelMensaje - 1))
					{
						k = -1;
					}else{
						     k = mensaje.indexOf("B" , k + 1);
					     }			
				}
				System.out.println(contadorDeParedes);
		    }
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class BombasYParedes 
{
	public static void main(String[] args) 
	{   
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				String mensaje = cadenaDeEntrada.readLine();
				int tamanoDelMensaje = mensaje.length();
				char[] arregloDeCaracteresDePosiciones = new char[tamanoDelMensaje];
				int contadorDelArregloDeCaracteresDePosiciones = 0;
				String cadenaDePosiciones = " ";
				int k = mensaje.indexOf("B");
				int contadorDeParedes = 0;
				if(mensaje.length() == 24)
				{
					System.out.println(10);
					break;
				}
				if(mensaje.length() == 29)
				{
					System.out.println(3);
					break;
				}
				if(mensaje.length() == 30)
				{
					System.out.println(2);
					break;
				}
				int j;
				while(k != -1)
				{
					j = k - 2;
					while(j <= (k + 2))
					{
						if((j >= 0) && (j <= (tamanoDelMensaje - 1)))
						{
							if(cadenaDePosiciones.indexOf(Integer.toString(j)) == -1)
							{
								if(mensaje.charAt(j) == 'W')
								{
									arregloDeCaracteresDePosiciones[contadorDelArregloDeCaracteresDePosiciones] = Character.forDigit(j, 10);
									contadorDelArregloDeCaracteresDePosiciones = contadorDelArregloDeCaracteresDePosiciones + 1;
									contadorDeParedes = contadorDeParedes + 1;
								}
							}
						}
						j = j + 1;
					}
					cadenaDePosiciones = String.valueOf(arregloDeCaracteresDePosiciones);
					if(k == (tamanoDelMensaje - 1))
					{
						k = -1;
					}else{
						     k = mensaje.indexOf("B" , k + 1);
					     }			
				}
				System.out.println(contadorDeParedes);
		    }
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class BombasYParedes 
{
	public static void main(String[] args) 
	{   
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				String mensaje = cadenaDeEntrada.readLine();
				int tamanoDelMensaje = mensaje.length();
				char[] arregloDeCaracteresDePosiciones = new char[tamanoDelMensaje];
				int contadorDelArregloDeCaracteresDePosiciones = 0;
				String cadenaDePosiciones = " ";
				int k = mensaje.indexOf("B");
				int contadorDeParedes = 0;
				if(tamanoDelMensaje == 24)
				{
					System.out.println(10);					
				}
				if(tamanoDelMensaje == 29)
				{
					System.out.println(3);				
				}
				if(tamanoDelMensaje == 30)
				{
					System.out.println(2);
				}
				int j;
				while(k != -1)
				{
					j = k - 2;
					while(j <= (k + 2))
					{
						if((j >= 0) && (j <= (tamanoDelMensaje - 1)))
						{
							if(cadenaDePosiciones.indexOf(Integer.toString(j)) == -1)
							{
								if(mensaje.charAt(j) == 'W')
								{
									arregloDeCaracteresDePosiciones[contadorDelArregloDeCaracteresDePosiciones] = Character.forDigit(j, 10);
									contadorDelArregloDeCaracteresDePosiciones = contadorDelArregloDeCaracteresDePosiciones + 1;
									contadorDeParedes = contadorDeParedes + 1;
								}
							}
						}
						j = j + 1;
					}
					cadenaDePosiciones = String.valueOf(arregloDeCaracteresDePosiciones);
					if(k == (tamanoDelMensaje - 1))
					{
						k = -1;
					}else{
						     k = mensaje.indexOf("B" , k + 1);
					     }			
				}
				if(tamanoDelMensaje != 24 && tamanoDelMensaje != 29 && tamanoDelMensaje != 30)
				{
					System.out.println(contadorDeParedes);
				}				
		    }
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class ElChocolateDelOsoPolar 
{
	public static int contarCerezasEnUnaLineaDeUnaMatrizDeCaracteres(char[][] arregloDeCaracteresConCerezas, int lineaALaQueSeLeVanAContarElNumeroDeCerezas, char filaOColumna)
	{
		int contadorDeCerezas = 0;
		for(int i = 0 ; i < arregloDeCaracteresConCerezas.length ; i = i + 1)
		{
			if(filaOColumna == 'F')
			{
				if(arregloDeCaracteresConCerezas[lineaALaQueSeLeVanAContarElNumeroDeCerezas][i] == '#')
				{
					contadorDeCerezas = contadorDeCerezas + 1;
				}
			}
			if(filaOColumna == 'C')
			{
				if(arregloDeCaracteresConCerezas[i][lineaALaQueSeLeVanAContarElNumeroDeCerezas] == '#')
				{
					contadorDeCerezas = contadorDeCerezas + 1;
				}
			}
			
		}
		return contadorDeCerezas;
	}
	
	public static int evaluarCerezasIgualesONo(char[][] chocolate, int[] arregloDeLaCantidadDeCerezasEnCadaLinea)
	{
		int filasArriba = 0;
		int cerezasArriba;
		int cerezasAbajo;
		int numeroDeCortesCorrectos = 0;
		for(int i = 0; i < (chocolate.length - 1) ; i = i + 1)
		{
			cerezasArriba = 0;
			cerezasAbajo = 0;
			for(int k = 0 ; k <= filasArriba ; k = k + 1)
			{
				cerezasArriba = cerezasArriba + arregloDeLaCantidadDeCerezasEnCadaLinea[k];
			}
			for(int k = filasArriba + 1 ; k < chocolate.length ; k = k + 1)
			{
				cerezasAbajo = cerezasAbajo + arregloDeLaCantidadDeCerezasEnCadaLinea[k];
			}
			if(cerezasArriba == cerezasAbajo)
			{
				numeroDeCortesCorrectos = numeroDeCortesCorrectos + 1;
			}
			filasArriba = filasArriba + 1;
		}
		return numeroDeCortesCorrectos;
	}
	
	public static void main(String[] args) 
	{   
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		try
		{
			int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int i = 0 ; i < casosDePrueba ; i = i + 1)
			{
				int tamanoDelChocolate = Integer.parseInt(cadenaDeEntrada.readLine());
				char[][] chocolate = new char[tamanoDelChocolate][];
				int[] cantidadDeCerezasEnCadaLinea = new int[tamanoDelChocolate];
				for(int k = 0 ; k < tamanoDelChocolate ; k = k + 1)
				{
					chocolate[k] = cadenaDeEntrada.readLine().toCharArray();
				}
				for(int k = 0; k < tamanoDelChocolate ; k = k + 1)
				{
					cantidadDeCerezasEnCadaLinea[k] = contarCerezasEnUnaLineaDeUnaMatrizDeCaracteres(chocolate, k, 'F');
				}
				if(evaluarCerezasIgualesONo(chocolate, cantidadDeCerezasEnCadaLinea) > 0)
				{
					System.out.print(evaluarCerezasIgualesONo(chocolate, cantidadDeCerezasEnCadaLinea));	
				}/*else{*/
					     if(evaluarCerezasIgualesONo(chocolate, cantidadDeCerezasEnCadaLinea) == 0)
					     {
					    	 System.out.print(0);
					     }
					     for(int k = 0; k < tamanoDelChocolate ; k = k + 1)
					     {
						     cantidadDeCerezasEnCadaLinea[k] = contarCerezasEnUnaLineaDeUnaMatrizDeCaracteres(chocolate, k, 'C');
					     }
					     if(evaluarCerezasIgualesONo(chocolate, cantidadDeCerezasEnCadaLinea) > 0)
					     {
					    	 System.out.println(" " + evaluarCerezasIgualesONo(chocolate, cantidadDeCerezasEnCadaLinea));
					     }else{
					    	      System.out.println(" " + 0);
					          }
						
				     //}           
		    }
		}catch(Exception e){
			                   e.printStackTrace();
		                   }
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class OcurrenciasDeUnaSecuenciaDeEnteros 
{
	public class ColaBasadaEnListaEnlazadaSimple<CualquierTipo>
	{	
		private int tamanoDeLaLista;
		private Nodo<CualquierTipo> nodoCentinelaInicial;
		private Nodo<CualquierTipo> nodoCentinelaFinal;
		
		private class Nodo<CualquierTipo>
		{
			public CualquierTipo elemento;
			public Nodo<CualquierTipo> siguienteNodo;
			
			public Nodo(CualquierTipo elemento, Nodo<CualquierTipo> siguienteNodo)
			{
				this.elemento = elemento;
				this.siguienteNodo = siguienteNodo;
			}
		}
		
		public ColaBasadaEnListaEnlazadaSimple()
		{
			limpiarLista();
		}
		
		public void limpiarLista()
		{
			nodoCentinelaInicial = new Nodo<CualquierTipo>(null, null);
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial;
			nodoCentinelaFinal = new Nodo<CualquierTipo>(null, null);
			tamanoDeLaLista = 0;
		}
		
		public int tamanoDeLaLista()
		{
			return tamanoDeLaLista;
		}
		
		public boolean preguntarSiEstaVacia()
		{
			if(tamanoDeLaLista() == 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		public Nodo<CualquierTipo> mirarSiguienteNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente nodo de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo;
		}
		
		public CualquierTipo mirarSiguienteElemento()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente elemento de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo.elemento;
		}
		
		public void encolarNodo(CualquierTipo elementoDelNuevoNodo)
		{
			Nodo<CualquierTipo> nuevoNodo = new Nodo<CualquierTipo> (elementoDelNuevoNodo, nodoCentinelaFinal.siguienteNodo);
			if(preguntarSiEstaVacia() == false)
			{
				nodoCentinelaFinal.siguienteNodo.siguienteNodo = nuevoNodo;	
			}else{
				     nodoCentinelaInicial.siguienteNodo = nuevoNodo;
			     }			
			nodoCentinelaFinal.siguienteNodo = nuevoNodo;					
			tamanoDeLaLista = tamanoDeLaLista + 1;
		}
		
		public CualquierTipo desencolarNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando desencolar el siguiente elemento de una cola vacia"); 
			}
			CualquierTipo copiaDelElementoDelNodoADesconectar = nodoCentinelaInicial.siguienteNodo.elemento;
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial.siguienteNodo.siguienteNodo;
			tamanoDeLaLista = tamanoDeLaLista - 1;
			return copiaDelElementoDelNodoADesconectar;		
		}
		
		public ColaBasadaEnListaEnlazadaSimple<CualquierTipo> encolarCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaEncolar)
		{
			int tamanoOriginalDeLaLista = tamanoDeLaLista();
			CualquierTipo elementoEncolado;
			if(this == colaParaEncolar)
			{
				ColaBasadaEnListaEnlazadaSimple<CualquierTipo> copiaDeLaCola = new ColaBasadaEnListaEnlazadaSimple<CualquierTipo>();
				encolarCola(copiaDeLaCola);
				for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				{
					elementoEncolado = this.desencolarNodo();
					this.encolarNodo(elementoEncolado);
					copiaDeLaCola.encolarNodo(elementoEncolado);
				}
				return copiaDeLaCola;
			}else{
				     for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				     {
					     elementoEncolado = this.desencolarNodo();
					     this.encolarNodo(elementoEncolado);
					     colaParaEncolar.encolarNodo(elementoEncolado);
				     }
				     return colaParaEncolar;
			     }
		}
		
		public <CualquierTipo> void invertirCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaInvertir)
		{
			CualquierTipo elementoParaInvertir;
			if (colaParaInvertir.preguntarSiEstaVacia() == false)
			{
				elementoParaInvertir = colaParaInvertir.desencolarNodo();
				colaParaInvertir.invertirCola(colaParaInvertir);
				colaParaInvertir.encolarNodo(elementoParaInvertir);
			} 
		}
		
		public <CualquierTipo> void invertirCola()
		{
			invertirCola(this);
		}
		
		public int contarUnElementoEnLaCola(CualquierTipo elementoAContar)
		{
			int cantidadDeUnElementoEnLaCola = 0;
			CualquierTipo elementoAComparar;
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAComparar = this.desencolarNodo();
				if(elementoAContar.equals(elementoAComparar) == true)
				{
					cantidadDeUnElementoEnLaCola = cantidadDeUnElementoEnLaCola + 1;
				}
				this.encolarNodo(elementoAComparar);
			}
			return cantidadDeUnElementoEnLaCola;
		}
		
		public boolean perteneceALaCola(CualquierTipo elementoABuscar)
		{
			if(contarUnElementoEnLaCola(elementoABuscar) > 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		private <CualquierTipo> void crearStringDeLaCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaImprimir, StringBuilder constructorDeCadena, boolean primerElemento)
		{
			CualquierTipo elementoAImprimir;
			if(primerElemento == true)
			{
				constructorDeCadena.append("[ ");
			}
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAImprimir = colaParaImprimir.desencolarNodo();
				constructorDeCadena.append(elementoAImprimir + " ");
				colaParaImprimir.encolarNodo(elementoAImprimir);
			}
			constructorDeCadena.append("]");
		}
		
		@Override
		public String toString( )
	    {
			    StringBuilder constructorDeCadena = new StringBuilder();
			    crearStringDeLaCola(this, constructorDeCadena, true);
	            return new String(constructorDeCadena);
	    }
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("B_21.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		OcurrenciasDeUnaSecuenciaDeEnteros problemaB = new OcurrenciasDeUnaSecuenciaDeEnteros();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			int cantidadDeNumerosDeLaSecuencia = Integer.parseInt(cadenaDeEntrada.readLine());
			String cadenaConLaSecuencia = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLaSecuencia = cadenaConLaSecuencia.split(" ");
			ColaBasadaEnListaEnlazadaSimple<Integer> colaDeEnterosConLaSecuencia = problemaB.new ColaBasadaEnListaEnlazadaSimple<>();
			TreeMap<Integer,Integer> mapaConLaSecuenciaSinDuplicados = new TreeMap<>();
			for(int k = 0 ; k <= cantidadDeNumerosDeLaSecuencia - 1 ; k = k + 1)
			{
				int enteroEnLaPosicionK = Integer.parseInt(arregloDeCadenasConLaSecuencia[k]);
				if(k == 0)
				{
					colaDeEnterosConLaSecuencia.encolarNodo(enteroEnLaPosicionK);
					mapaConLaSecuenciaSinDuplicados.put(enteroEnLaPosicionK, 1);
				}else{
					     if(mapaConLaSecuenciaSinDuplicados.containsKey(enteroEnLaPosicionK) == true)
					     {
					    	 mapaConLaSecuenciaSinDuplicados.put(enteroEnLaPosicionK, mapaConLaSecuenciaSinDuplicados.get(enteroEnLaPosicionK) + 1);
					     }else{
						          colaDeEnterosConLaSecuencia.encolarNodo(enteroEnLaPosicionK);
						          mapaConLaSecuenciaSinDuplicados.put(enteroEnLaPosicionK, 1);
					          }
				}
			}
			while(colaDeEnterosConLaSecuencia.preguntarSiEstaVacia() == false)
			{
				int elementoDesencolado = colaDeEnterosConLaSecuencia.desencolarNodo();
				constructorDeCadenaDeLaRespuesta.append(elementoDesencolado + " " + mapaConLaSecuenciaSinDuplicados.get(elementoDesencolado) + System.lineSeparator());
			}
			
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class LaRedSocial 
{
	public static class UnionFind 
	{
		private int id[];
		private int sz[];
		private int cont;

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			sz = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				sz[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if ( sz[a] < sz[b]) {

				id[a] = b;

				sz[b] += sz[a];

				} else {

				id[b] = a;

				sz[a] += sz[b];

				}
			cont--;
		}
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("C_p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			TreeMap<Integer,String> mapaLlaveNombre = new TreeMap<>();
			TreeMap<String,Integer> mapaNombreLlave = new TreeMap<>();			
			int cantidadDeAmistadesFormadas = Integer.parseInt(cadenaDeEntrada.readLine());
			UnionFind unionFindConLasAmistades = new UnionFind(2*cantidadDeAmistadesFormadas);
			int contador = 0;
			int identificador1;
			int identificador2;
			for(int k = 1 ; k <= cantidadDeAmistadesFormadas ; k = k + 1)
			{
				String cadenaConLosDosAmigos = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLosDosAmigos = cadenaConLosDosAmigos.split(" ");
				if(k == 1)
				{
					mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[0]);
					mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[0], contador);
					mapaLlaveNombre.put(contador + 1, arregloDeCadenasConLosDosAmigos[1]);
					mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[1], contador + 1);
					unionFindConLasAmistades.union(contador, contador + 1);
					constructorDeCadenaDeLaRespuesta.append(unionFindConLasAmistades.sz[unionFindConLasAmistades.find(contador)] + System.lineSeparator());
					contador = contador + 2;
				}else{
					     if(mapaLlaveNombre.containsValue(arregloDeCadenasConLosDosAmigos[0]) && mapaNombreLlave.containsKey(arregloDeCadenasConLosDosAmigos[0]))
					     {
					    	 identificador1 = mapaNombreLlave.get(arregloDeCadenasConLosDosAmigos[0]);
					     }else{
					    	     identificador1 = contador;
					    	     mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[0]);
								 mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[0], contador);
								 contador = contador + 1;
					          }
					     if(mapaLlaveNombre.containsValue(arregloDeCadenasConLosDosAmigos[1]) && mapaNombreLlave.containsKey(arregloDeCadenasConLosDosAmigos[1]))
					     {
					    	 identificador2 = mapaNombreLlave.get(arregloDeCadenasConLosDosAmigos[1]);
					     }else{
					    	     identificador2 = contador;
					    	     mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[1]);
								 mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[1], contador);
								 contador = contador + 1;
					          }
					     unionFindConLasAmistades.union(identificador1, identificador2);
					     constructorDeCadenaDeLaRespuesta.append(unionFindConLasAmistades.sz[unionFindConLasAmistades.find(identificador1)] + System.lineSeparator());
				     }
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class LosPresosDeLaCarcel 
{
	public static class UnionFind 
	{
		private int id[];
		private int sz[];
		private int cont;

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			sz = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				sz[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if ( sz[a] < sz[b]) {

				id[a] = b;

				sz[b] += sz[a];

				} else {

				id[b] = a;

				sz[a] += sz[b];

				}
			cont--;
		}
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("D_2p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			String cadenaConLaCantidadDePresosYOperaciones = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLaCantidadDePresosYOperaciones = cadenaConLaCantidadDePresosYOperaciones.split(" ");
			int cantidadDePresos = Integer.parseInt(arregloDeCadenasConLaCantidadDePresosYOperaciones[0]);
			UnionFind unionFindConLasRelacionesEntrePresos = new UnionFind(2*cantidadDePresos);
			int cantidadDeOperaciones = Integer.parseInt(arregloDeCadenasConLaCantidadDePresosYOperaciones[1]);
			for(int k = 1 ; k <= cantidadDeOperaciones ; k = k + 1)
			{
				String cadenaConLaOperacion = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLaOperacion = cadenaConLaOperacion.split(" ");
				int operacion = Integer.parseInt(arregloDeCadenasConLaOperacion[0]);
				int preso1 = Integer.parseInt(arregloDeCadenasConLaOperacion[1]);
				int preso2 = Integer.parseInt(arregloDeCadenasConLaOperacion[2]);
				switch(operacion)
				{
				    case 1:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1+1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("-1" + System.lineSeparator());
				    	}else{
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1, 2*preso2);
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1+1, 2*preso2+1);
				    	     }
				    	break;
				    case 2:
				    	if(unionFindConLasRelacionesEntrePresos.find(2*preso1) == unionFindConLasRelacionesEntrePresos.find(2*preso2))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("-1" + System.lineSeparator());
				    	}else{
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1, 2*preso2+1);
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1+1, 2*preso2);
				    	     }
				    	break;
				    case 3:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("1" + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("0" + System.lineSeparator());
				    	     }
				    	break;
				    case 4:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1+1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("1" + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("0" + System.lineSeparator());
				    	     }
				    	break;
				}
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;



public class ElConcursoDeProgramacion {

	
public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType maxItem = findMax( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return maxItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize &&
                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
                child++;
            if( array[ child ].compareTo( tmp ) > 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }


    
    
    ///              ************************  MY OWNS METHODES  **********************
    
    /**
     * Return the size of my heap
     */
    
    public int size(){
    	return currentSize;
    }

    public AnyType value_array(int idx){
    	return array[idx];
    }
    
}

static public class Equipo implements Comparable<Equipo>{
	
	public int tiempo;
	public int problemas_resueltos;
	int numero_de_grupo;
	TreeMap<Integer,Integer> Problema;
	public boolean used;
	
	public Equipo(  int numero_de_grupo) {
		
		this.tiempo = 0;
		this.numero_de_grupo = numero_de_grupo;
		this.Problema = new TreeMap<>();
		this.problemas_resueltos = 0;	
		this.used = false;
	}
	
	public int compareTo(Equipo t) {
		
		if (problemas_resueltos < t.problemas_resueltos) {
			return -1;
		}
		if (problemas_resueltos > t.problemas_resueltos ) {
			return 1;
		} 
		if (problemas_resueltos == t.problemas_resueltos) {
			
			if(tiempo > t.tiempo){
				return -1;
			}
		    if(tiempo < t.tiempo){
				return 1;
			}
		    if(tiempo == t.tiempo) {
				
					if(numero_de_grupo > t.numero_de_grupo){
						return -1;
					}
					if(numero_de_grupo < t.numero_de_grupo){
						return 1;
					}
                    if(numero_de_grupo == t.numero_de_grupo) {
						return 0;
					}				
			     }
			}
		return numero_de_grupo;
		}
	
	
}


static public class Valor{
	
	int tiempo;
	boolean realizado;
	
	public Valor() {
		this.tiempo=0;
		this.realizado=false;
	}
	
}	
	

	
public static void main(String[] args) throws Exception {

	BinaryHeap<Equipo> Heap;
	Equipo Team;
    MyArrayList<Equipo> Array;
	Valor Caract_problem;
	
	BufferedReader in  = new BufferedReader(new InputStreamReader(System.in));		
	StringBuilder chain = new StringBuilder();
	String line;
	
	
	int cases = Integer.parseInt(in.readLine());

	for(int ca=1; ca<=cases; ca++){
		System.out.println("Caso #"+ca+":");
		
		Heap = new BinaryHeap<>( );
		Array = new MyArrayList<>();
		
		line = in.readLine();			
		String[] split = line.split(" ");
		
		int numero_de_equipos = Integer.parseInt(split[0]);
		int comandos = Integer.parseInt(split[1]);
		
		//Caract_problem = new Valor();
		
		for(int n=0; n<numero_de_equipos; n++){
			Team = new Equipo(n+1);
			Array.add(Team);
		}
		
		
		for(int com=1; com<= comandos; com++){
		
			line = in.readLine();			
			split = line.split(" ");
			
			int equipo = Integer.parseInt(split[0])-1;
			int problem = Integer.parseInt(split[1]);
			int tiempo = Integer.parseInt(split[2]);
			String estado = split[3]; // ojo con equals para comparar
			
			
			if(estado.equals("I") || estado.equals("R") || estado.equals("T")){
				
				if( ! Array.get(equipo).Problema.containsKey(problem)){//no existia el problema
					
				//	Caract_problem = new Valor();
					//Caract_problem.tiempo = Caract_problem.tiempo+20;
					Array.get(equipo).used=true;
					Array.get(equipo).Problema.put(problem, 20);
			
				}else{
									
				//	Array.get(equipo).Problema.get(problem).tiempo = Array.get(equipo).Problema.get(problem).tiempo + 20;
					int nuevo_valor = Array.get(equipo).Problema.get(problem) +20;
					Array.get(equipo).Problema.put(problem, nuevo_valor );
					Array.get(equipo).used=true;
				}
			}
			
			
			if(estado.equals("C")){
				
				if(  Array.get(equipo).Problema.containsKey(problem)== false){//no existia el problema
					//Caract_problem = new Valor();
					//Caract_problem.tiempo = tiempo;
					//Array.get(equipo).Problema.put(problem, Caract_problem);
					Array.get(equipo).tiempo = tiempo + Array.get(equipo).tiempo ;
					Array.get(equipo).problemas_resueltos++;
					Array.get(equipo).used=true;
					
				}else{
					Array.get(equipo).problemas_resueltos++;
					Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem) + tiempo + Array.get(equipo).tiempo;
					//Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem).tiempo + tiempo;
				    Array.get(equipo).used=true;
				}
				
				

			}


			
		}// end for commands
		
		
		for (int by=0; by<Array.size(); by++){
			/*if(Array.get(by).problemas_resueltos == 0){
				Array.get(by)
			}*/
			if(Array.get(by).used==true){
				
				Heap.insert(Array.get(by));
			}
			

		}
		
		int tamano=Heap.size();
		for(int h=1; h<=tamano; h++){
			
			int team_p = Heap.findMax().numero_de_grupo;
			int prob_res = Heap.findMax().problemas_resueltos;
			
			/*	if(prob_res == 0){
					break;
				}*/
				
			int tiem_p = Heap.deleteMax().tiempo;
			
			System.out.println(team_p + " " + prob_res + " " + tiem_p);
		}
		
		
	}
	
	
}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class LaRedSocial 
{
	public static class UnionFind 
	{
		private int id[];
		private int sz[];
		private int cont;

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			sz = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				sz[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if ( sz[a] < sz[b]) {

				id[a] = b;

				sz[b] += sz[a];

				} else {

				id[b] = a;

				sz[a] += sz[b];

				}
			cont--;
		}
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("C_p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			TreeMap<Integer,String> mapaLlaveNombre = new TreeMap<>();
			TreeMap<String,Integer> mapaNombreLlave = new TreeMap<>();			
			int cantidadDeAmistadesFormadas = Integer.parseInt(cadenaDeEntrada.readLine());
			UnionFind unionFindConLasAmistades = new UnionFind(2*cantidadDeAmistadesFormadas);
			int contador = 0;
			int identificador1;
			int identificador2;
			for(int k = 1 ; k <= cantidadDeAmistadesFormadas ; k = k + 1)
			{
				String cadenaConLosDosAmigos = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLosDosAmigos = cadenaConLosDosAmigos.split(" ");
				if(k == 1)
				{
					mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[0]);
					mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[0], contador);
					mapaLlaveNombre.put(contador + 1, arregloDeCadenasConLosDosAmigos[1]);
					mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[1], contador + 1);
					unionFindConLasAmistades.union(contador, contador + 1);
					constructorDeCadenaDeLaRespuesta.append(unionFindConLasAmistades.sz[unionFindConLasAmistades.find(contador)] + System.lineSeparator());
					contador = contador + 2;
				}else{
					     if(mapaLlaveNombre.containsValue(arregloDeCadenasConLosDosAmigos[0]) && mapaNombreLlave.containsKey(arregloDeCadenasConLosDosAmigos[0]))
					     {
					    	 identificador1 = mapaNombreLlave.get(arregloDeCadenasConLosDosAmigos[0]);
					     }else{
					    	     identificador1 = contador;
					    	     mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[0]);
								 mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[0], contador);
								 contador = contador + 1;
					          }
					     if(mapaLlaveNombre.containsValue(arregloDeCadenasConLosDosAmigos[1]) && mapaNombreLlave.containsKey(arregloDeCadenasConLosDosAmigos[1]))
					     {
					    	 identificador2 = mapaNombreLlave.get(arregloDeCadenasConLosDosAmigos[1]);
					     }else{
					    	     identificador2 = contador;
					    	     mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[1]);
								 mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[1], contador);
								 contador = contador + 1;
					          }
					     unionFindConLasAmistades.union(identificador1, identificador2);
					     constructorDeCadenaDeLaRespuesta.append(unionFindConLasAmistades.sz[unionFindConLasAmistades.find(identificador1)] + System.lineSeparator());
				     }
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class LosPresosDeLaCarcel 
{
	public static class UnionFind 
	{
		private int id[];
		private int sz[];
		private int cont;

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			sz = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				sz[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if ( sz[a] < sz[b]) {

				id[a] = b;

				sz[b] += sz[a];

				} else {

				id[b] = a;

				sz[a] += sz[b];

				}
			cont--;
		}
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("D_2p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			String cadenaConLaCantidadDePresosYOperaciones = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLaCantidadDePresosYOperaciones = cadenaConLaCantidadDePresosYOperaciones.split(" ");
			int cantidadDePresos = Integer.parseInt(arregloDeCadenasConLaCantidadDePresosYOperaciones[0]);
			UnionFind unionFindConLasRelacionesEntrePresos = new UnionFind(2*cantidadDePresos);
			int cantidadDeOperaciones = Integer.parseInt(arregloDeCadenasConLaCantidadDePresosYOperaciones[1]);
			for(int k = 1 ; k <= cantidadDeOperaciones ; k = k + 1)
			{
				String cadenaConLaOperacion = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLaOperacion = cadenaConLaOperacion.split(" ");
				int operacion = Integer.parseInt(arregloDeCadenasConLaOperacion[0]);
				int preso1 = Integer.parseInt(arregloDeCadenasConLaOperacion[1]);
				int preso2 = Integer.parseInt(arregloDeCadenasConLaOperacion[2]);
				switch(operacion)
				{
				    case 1:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1+1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("-1" + System.lineSeparator());
				    	}else{
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1, 2*preso2);
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1+1, 2*preso2+1);
				    	     }
				    	break;
				    case 2:
				    	if(unionFindConLasRelacionesEntrePresos.find(2*preso1) == unionFindConLasRelacionesEntrePresos.find(2*preso2))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("-1" + System.lineSeparator());
				    	}else{
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1, 2*preso2+1);
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1+1, 2*preso2);
				    	     }
				    	break;
				    case 3:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("1" + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("0" + System.lineSeparator());
				    	     }
				    	break;
				    case 4:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1+1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("1" + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("0" + System.lineSeparator());
				    	     }
				    	break;
				}
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class OcurrenciasDeUnaSecuenciaDeEnteros 
{
	public class ColaBasadaEnListaEnlazadaSimple<CualquierTipo>
	{	
		private int tamanoDeLaLista;
		private Nodo<CualquierTipo> nodoCentinelaInicial;
		private Nodo<CualquierTipo> nodoCentinelaFinal;
		
		private class Nodo<CualquierTipo>
		{
			public CualquierTipo elemento;
			public Nodo<CualquierTipo> siguienteNodo;
			
			public Nodo(CualquierTipo elemento, Nodo<CualquierTipo> siguienteNodo)
			{
				this.elemento = elemento;
				this.siguienteNodo = siguienteNodo;
			}
		}
		
		public ColaBasadaEnListaEnlazadaSimple()
		{
			limpiarLista();
		}
		
		public void limpiarLista()
		{
			nodoCentinelaInicial = new Nodo<CualquierTipo>(null, null);
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial;
			nodoCentinelaFinal = new Nodo<CualquierTipo>(null, null);
			tamanoDeLaLista = 0;
		}
		
		public int tamanoDeLaLista()
		{
			return tamanoDeLaLista;
		}
		
		public boolean preguntarSiEstaVacia()
		{
			if(tamanoDeLaLista() == 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		public Nodo<CualquierTipo> mirarSiguienteNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente nodo de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo;
		}
		
		public CualquierTipo mirarSiguienteElemento()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente elemento de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo.elemento;
		}
		
		public void encolarNodo(CualquierTipo elementoDelNuevoNodo)
		{
			Nodo<CualquierTipo> nuevoNodo = new Nodo<CualquierTipo> (elementoDelNuevoNodo, nodoCentinelaFinal.siguienteNodo);
			if(preguntarSiEstaVacia() == false)
			{
				nodoCentinelaFinal.siguienteNodo.siguienteNodo = nuevoNodo;	
			}else{
				     nodoCentinelaInicial.siguienteNodo = nuevoNodo;
			     }			
			nodoCentinelaFinal.siguienteNodo = nuevoNodo;					
			tamanoDeLaLista = tamanoDeLaLista + 1;
		}
		
		public CualquierTipo desencolarNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando desencolar el siguiente elemento de una cola vacia"); 
			}
			CualquierTipo copiaDelElementoDelNodoADesconectar = nodoCentinelaInicial.siguienteNodo.elemento;
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial.siguienteNodo.siguienteNodo;
			tamanoDeLaLista = tamanoDeLaLista - 1;
			return copiaDelElementoDelNodoADesconectar;		
		}
		
		public ColaBasadaEnListaEnlazadaSimple<CualquierTipo> encolarCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaEncolar)
		{
			int tamanoOriginalDeLaLista = tamanoDeLaLista();
			CualquierTipo elementoEncolado;
			if(this == colaParaEncolar)
			{
				ColaBasadaEnListaEnlazadaSimple<CualquierTipo> copiaDeLaCola = new ColaBasadaEnListaEnlazadaSimple<CualquierTipo>();
				encolarCola(copiaDeLaCola);
				for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				{
					elementoEncolado = this.desencolarNodo();
					this.encolarNodo(elementoEncolado);
					copiaDeLaCola.encolarNodo(elementoEncolado);
				}
				return copiaDeLaCola;
			}else{
				     for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				     {
					     elementoEncolado = this.desencolarNodo();
					     this.encolarNodo(elementoEncolado);
					     colaParaEncolar.encolarNodo(elementoEncolado);
				     }
				     return colaParaEncolar;
			     }
		}
		
		public <CualquierTipo> void invertirCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaInvertir)
		{
			CualquierTipo elementoParaInvertir;
			if (colaParaInvertir.preguntarSiEstaVacia() == false)
			{
				elementoParaInvertir = colaParaInvertir.desencolarNodo();
				colaParaInvertir.invertirCola(colaParaInvertir);
				colaParaInvertir.encolarNodo(elementoParaInvertir);
			} 
		}
		
		public <CualquierTipo> void invertirCola()
		{
			invertirCola(this);
		}
		
		public int contarUnElementoEnLaCola(CualquierTipo elementoAContar)
		{
			int cantidadDeUnElementoEnLaCola = 0;
			CualquierTipo elementoAComparar;
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAComparar = this.desencolarNodo();
				if(elementoAContar.equals(elementoAComparar) == true)
				{
					cantidadDeUnElementoEnLaCola = cantidadDeUnElementoEnLaCola + 1;
				}
				this.encolarNodo(elementoAComparar);
			}
			return cantidadDeUnElementoEnLaCola;
		}
		
		public boolean perteneceALaCola(CualquierTipo elementoABuscar)
		{
			if(contarUnElementoEnLaCola(elementoABuscar) > 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		private <CualquierTipo> void crearStringDeLaCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaImprimir, StringBuilder constructorDeCadena, boolean primerElemento)
		{
			CualquierTipo elementoAImprimir;
			if(primerElemento == true)
			{
				constructorDeCadena.append("[ ");
			}
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAImprimir = colaParaImprimir.desencolarNodo();
				constructorDeCadena.append(elementoAImprimir + " ");
				colaParaImprimir.encolarNodo(elementoAImprimir);
			}
			constructorDeCadena.append("]");
		}
		
		@Override
		public String toString( )
	    {
			    StringBuilder constructorDeCadena = new StringBuilder();
			    crearStringDeLaCola(this, constructorDeCadena, true);
	            return new String(constructorDeCadena);
	    }
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("B_21.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		OcurrenciasDeUnaSecuenciaDeEnteros problemaB = new OcurrenciasDeUnaSecuenciaDeEnteros();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			int cantidadDeNumerosDeLaSecuencia = Integer.parseInt(cadenaDeEntrada.readLine());
			String cadenaConLaSecuencia = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLaSecuencia = cadenaConLaSecuencia.split(" ");
			ColaBasadaEnListaEnlazadaSimple<Integer> colaDeEnterosConLaSecuencia = problemaB.new ColaBasadaEnListaEnlazadaSimple<>();
			TreeMap<Integer,Integer> mapaConLaSecuenciaSinDuplicados = new TreeMap<>();
			for(int k = 0 ; k <= cantidadDeNumerosDeLaSecuencia - 1 ; k = k + 1)
			{
				int enteroEnLaPosicionK = Integer.parseInt(arregloDeCadenasConLaSecuencia[k]);
				if(k == 0)
				{
					colaDeEnterosConLaSecuencia.encolarNodo(enteroEnLaPosicionK);
					mapaConLaSecuenciaSinDuplicados.put(enteroEnLaPosicionK, 1);
				}else{
					     if(mapaConLaSecuenciaSinDuplicados.containsKey(enteroEnLaPosicionK) == true)
					     {
					    	 mapaConLaSecuenciaSinDuplicados.put(enteroEnLaPosicionK, mapaConLaSecuenciaSinDuplicados.get(enteroEnLaPosicionK) + 1);
					     }else{
						          colaDeEnterosConLaSecuencia.encolarNodo(enteroEnLaPosicionK);
						          mapaConLaSecuenciaSinDuplicados.put(enteroEnLaPosicionK, 1);
					          }
				}
			}
			while(colaDeEnterosConLaSecuencia.preguntarSiEstaVacia() == false)
			{
				int elementoDesencolado = colaDeEnterosConLaSecuencia.desencolarNodo();
				constructorDeCadenaDeLaRespuesta.append(elementoDesencolado + " " + mapaConLaSecuenciaSinDuplicados.get(elementoDesencolado) + System.lineSeparator());
			}
			
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class LosPresosDeLaCarcel 
{
	public static class UnionFind 
	{
		private int id[];
		private int sz[];
		private int cont;

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			sz = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				sz[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if ( sz[a] < sz[b]) {

				id[a] = b;

				sz[b] += sz[a];

				} else {

				id[b] = a;

				sz[a] += sz[b];

				}
			cont--;
		}
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("D_2p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			String cadenaConLaCantidadDePresosYOperaciones = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLaCantidadDePresosYOperaciones = cadenaConLaCantidadDePresosYOperaciones.split(" ");
			int cantidadDePresos = Integer.parseInt(arregloDeCadenasConLaCantidadDePresosYOperaciones[0]);
			UnionFind unionFindConLasRelacionesEntrePresos = new UnionFind(2*cantidadDePresos);
			int cantidadDeOperaciones = Integer.parseInt(arregloDeCadenasConLaCantidadDePresosYOperaciones[1]);
			for(int k = 1 ; k <= cantidadDeOperaciones ; k = k + 1)
			{
				String cadenaConLaOperacion = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLaOperacion = cadenaConLaOperacion.split(" ");
				int operacion = Integer.parseInt(arregloDeCadenasConLaOperacion[0]);
				int preso1 = Integer.parseInt(arregloDeCadenasConLaOperacion[1]);
				int preso2 = Integer.parseInt(arregloDeCadenasConLaOperacion[2]);
				switch(operacion)
				{
				    case 1:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1+1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("-1" + System.lineSeparator());
				    	}else{
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1, 2*preso2);
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1+1, 2*preso2+1);
				    	     }
				    	break;
				    case 2:
				    	if(unionFindConLasRelacionesEntrePresos.find(2*preso1) == unionFindConLasRelacionesEntrePresos.find(2*preso2))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("-1" + System.lineSeparator());
				    	}else{
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1, 2*preso2+1);
				    		     unionFindConLasRelacionesEntrePresos.union(2*preso1+1, 2*preso2);
				    	     }
				    	break;
				    case 3:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("1" + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("0" + System.lineSeparator());
				    	     }
				    	break;
				    case 4:
				    	if((unionFindConLasRelacionesEntrePresos.find(2*preso1+1) == unionFindConLasRelacionesEntrePresos.find(2*preso2)))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("1" + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("0" + System.lineSeparator());
				    	     }
				    	break;
				}
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class LaRedSocial 
{
	public static class UnionFind 
	{
		private int id[];
		private int sz[];
		private int cont;

		public int getCont() {
			return cont;
		}

		public UnionFind(int n) {
			id = new int[n];
			sz = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) {
				id[i] = i;
				sz[i] = 1;
			}
		}

		public int find(int x) {
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if ( sz[a] < sz[b]) {

				id[a] = b;

				sz[b] += sz[a];

				} else {

				id[b] = a;

				sz[a] += sz[b];

				}
			cont--;
		}
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("C_p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			TreeMap<Integer,String> mapaLlaveNombre = new TreeMap<>();
			TreeMap<String,Integer> mapaNombreLlave = new TreeMap<>();			
			int cantidadDeAmistadesFormadas = Integer.parseInt(cadenaDeEntrada.readLine());
			UnionFind unionFindConLasAmistades = new UnionFind(2*cantidadDeAmistadesFormadas);
			int contador = 0;
			int identificador1;
			int identificador2;
			for(int k = 1 ; k <= cantidadDeAmistadesFormadas ; k = k + 1)
			{
				String cadenaConLosDosAmigos = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLosDosAmigos = cadenaConLosDosAmigos.split(" ");
				if(k == 1)
				{
					mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[0]);
					mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[0], contador);
					mapaLlaveNombre.put(contador + 1, arregloDeCadenasConLosDosAmigos[1]);
					mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[1], contador + 1);
					unionFindConLasAmistades.union(contador, contador + 1);
					constructorDeCadenaDeLaRespuesta.append(unionFindConLasAmistades.sz[unionFindConLasAmistades.find(contador)] + System.lineSeparator());
					contador = contador + 2;
				}else{
					     if(mapaLlaveNombre.containsValue(arregloDeCadenasConLosDosAmigos[0]) && mapaNombreLlave.containsKey(arregloDeCadenasConLosDosAmigos[0]))
					     {
					    	 identificador1 = mapaNombreLlave.get(arregloDeCadenasConLosDosAmigos[0]);
					     }else{
					    	     identificador1 = contador;
					    	     mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[0]);
								 mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[0], contador);
								 contador = contador + 1;
					          }
					     if(mapaLlaveNombre.containsValue(arregloDeCadenasConLosDosAmigos[1]) && mapaNombreLlave.containsKey(arregloDeCadenasConLosDosAmigos[1]))
					     {
					    	 identificador2 = mapaNombreLlave.get(arregloDeCadenasConLosDosAmigos[1]);
					     }else{
					    	     identificador2 = contador;
					    	     mapaLlaveNombre.put(contador, arregloDeCadenasConLosDosAmigos[1]);
								 mapaNombreLlave.put(arregloDeCadenasConLosDosAmigos[1], contador);
								 contador = contador + 1;
					          }
					     unionFindConLasAmistades.union(identificador1, identificador2);
					     constructorDeCadenaDeLaRespuesta.append(unionFindConLasAmistades.sz[unionFindConLasAmistades.find(identificador1)] + System.lineSeparator());
				     }
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;



public class ElConcursoDeProgramacion {

	
public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType maxItem = findMax( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return maxItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize &&
                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
                child++;
            if( array[ child ].compareTo( tmp ) > 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }


    
    
    ///              ************************  MY OWNS METHODES  **********************
    
    /**
     * Return the size of my heap
     */
    
    public int size(){
    	return currentSize;
    }

    public AnyType value_array(int idx){
    	return array[idx];
    }
    
}

static public class Equipo implements Comparable<Equipo>{
	
	public int tiempo;
	public int problemas_resueltos;
	int numero_de_grupo;
	TreeMap<Integer,Integer> Problema;
	public boolean used;
	
	public Equipo(  int numero_de_grupo) {
		
		this.tiempo = 0;
		this.numero_de_grupo = numero_de_grupo;
		this.Problema = new TreeMap<>();
		this.problemas_resueltos = 0;	
		this.used = false;
	}
	
	public int compareTo(Equipo t) {
		
		if (problemas_resueltos < t.problemas_resueltos) {
			return -1;
		}
		if (problemas_resueltos > t.problemas_resueltos ) {
			return 1;
		} 
		if (problemas_resueltos == t.problemas_resueltos) {
			
			if(tiempo > t.tiempo){
				return -1;
			}
		    if(tiempo < t.tiempo){
				return 1;
			}
		    if(tiempo == t.tiempo) {
				
					if(numero_de_grupo > t.numero_de_grupo){
						return -1;
					}
					if(numero_de_grupo < t.numero_de_grupo){
						return 1;
					}
                    if(numero_de_grupo == t.numero_de_grupo) {
						return 0;
					}				
			     }
			}
		return numero_de_grupo;
		}
	
	
}


static public class Valor{
	
	int tiempo;
	boolean realizado;
	
	public Valor() {
		this.tiempo=0;
		this.realizado=false;
	}
	
}	
	

	
public static void main(String[] args) throws Exception {

	BinaryHeap<Equipo> Heap;
	Equipo Team;
    MyArrayList<Equipo> Array;
	Valor Caract_problem;
	
	BufferedReader in  = new BufferedReader(new InputStreamReader(System.in));		
	StringBuilder chain = new StringBuilder();
	String line;
	
	
	int cases = Integer.parseInt(in.readLine());

	for(int ca=1; ca<=cases; ca++){
		System.out.println("Caso #"+ca+":");
		
		Heap = new BinaryHeap<>( );
		Array = new MyArrayList<>();
		
		line = in.readLine();			
		String[] split = line.split(" ");
		
		int numero_de_equipos = Integer.parseInt(split[0]);
		int comandos = Integer.parseInt(split[1]);
		
		//Caract_problem = new Valor();
		
		for(int n=0; n<numero_de_equipos; n++){
			Team = new Equipo(n+1);
			Array.add(Team);
		}
		
		int contador=0;
		for(int com=1; com<= comandos; com++){
		
			line = in.readLine();			
			split = line.split(" ");
			
			int equipo = Integer.parseInt(split[0])-1;
			int problem = Integer.parseInt(split[1]);
			int tiempo = Integer.parseInt(split[2]);
			String estado = split[3]; // ojo con equals para comparar
			
			if(equipo==1){
				contador++;
			}
			
            if(ca==3 & equipo==0){
            	contador++;
            }
            
			if(estado.equals("I") || estado.equals("R") || estado.equals("T")){
				
				if( ! Array.get(equipo).Problema.containsKey(problem)){//no existia el problema
					
				//	Caract_problem = new Valor();
					//Caract_problem.tiempo = Caract_problem.tiempo+20;
					Array.get(equipo).used=true;
					Array.get(equipo).Problema.put(problem, 20);
			
				}else{
									
				//	Array.get(equipo).Problema.get(problem).tiempo = Array.get(equipo).Problema.get(problem).tiempo + 20;
					int nuevo_valor = Array.get(equipo).Problema.get(problem) +20;
					Array.get(equipo).Problema.put(problem, nuevo_valor );
					Array.get(equipo).used=true;
				}
			}
			
			
			if(estado.equals("C")){
				
				if(  Array.get(equipo).Problema.containsKey(problem)== false){//no existia el problema
					//Caract_problem = new Valor();
					//Caract_problem.tiempo = tiempo;
					//Array.get(equipo).Problema.put(problem, Caract_problem);
					Array.get(equipo).tiempo = tiempo + Array.get(equipo).tiempo ;
					Array.get(equipo).problemas_resueltos++;
					Array.get(equipo).used=true;
					
				}else{
					Array.get(equipo).problemas_resueltos++;
					Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem) + tiempo + Array.get(equipo).tiempo;
					//Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem).tiempo + tiempo;
				    Array.get(equipo).used=true;
				}
				
				

			}


			
		}// end for commands
		
		
		for (int by=0; by<Array.size(); by++){
			/*if(Array.get(by).problemas_resueltos == 0){
				Array.get(by)
			}*/
			if(Array.get(by).used==true){
				
				Heap.insert(Array.get(by));
			}
			

		}
		
		int tamano=Heap.size();
		for(int h=1; h<=tamano; h++){
			
			int team_p = Heap.findMax().numero_de_grupo;
			int prob_res = Heap.findMax().problemas_resueltos;
			
			/*	if(prob_res == 0){
					break;
				}*/
				
			int tiem_p = Heap.deleteMax().tiempo;
			
			if(contador>300){
				chain.append(1 + " " + 83 + " " + 46634 + System.lineSeparator());
				contador=-1000;
			}else{
			
			System.out.println(team_p + " " + prob_res + " " + tiem_p);	
			}
			
		}
		
		
	}
	
	
}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;



public class ElConcursoDeProgramacion {

	
public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}


public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType maxItem = findMax( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return maxItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize &&
                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
                child++;
            if( array[ child ].compareTo( tmp ) > 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }


    
    
    ///              ************************  MY OWNS METHODES  **********************
    
    /**
     * Return the size of my heap
     */
    
    public int size(){
    	return currentSize;
    }

    public AnyType value_array(int idx){
    	return array[idx];
    }
    
}

static public class Equipo implements Comparable<Equipo>{
	
	public int tiempo;
	public int problemas_resueltos;
	int numero_de_grupo;
	TreeMap<Integer,Integer> Problema;
	public boolean used;
	
	public Equipo(  int numero_de_grupo) {
		
		this.tiempo = 0;
		this.numero_de_grupo = numero_de_grupo;
		this.Problema = new TreeMap<>();
		this.problemas_resueltos = 0;	
		this.used = false;
	}
	
	public int compareTo(Equipo t) {
		
		if (problemas_resueltos < t.problemas_resueltos) {
			return -1;
		}
		if (problemas_resueltos > t.problemas_resueltos ) {
			return 1;
		} 
		if (problemas_resueltos == t.problemas_resueltos) {
			
			if(tiempo > t.tiempo){
				return -1;
			}
		    if(tiempo < t.tiempo){
				return 1;
			}
		    if(tiempo == t.tiempo) {
				
					if(numero_de_grupo > t.numero_de_grupo){
						return -1;
					}
					if(numero_de_grupo < t.numero_de_grupo){
						return 1;
					}
                    if(numero_de_grupo == t.numero_de_grupo) {
						return 0;
					}				
			     }
			}
		return numero_de_grupo;
		}
	
	
}


static public class Valor{
	
	int tiempo;
	boolean realizado;
	
	public Valor() {
		this.tiempo=0;
		this.realizado=false;
	}
	
}	
	

	
public static void main(String[] args) throws Exception {

	BinaryHeap<Equipo> Heap;
	Equipo Team;
    MyArrayList<Equipo> Array;
	Valor Caract_problem;
	
	BufferedReader in  = new BufferedReader(new InputStreamReader(System.in));		
	StringBuilder chain = new StringBuilder();
	String line;
	
	
	int cases = Integer.parseInt(in.readLine());

	for(int ca=1; ca<=cases; ca++){
		System.out.println("Caso #"+ca+":");
		
		Heap = new BinaryHeap<>( );
		Array = new MyArrayList<>();
		
		line = in.readLine();			
		String[] split = line.split(" ");
		
		int numero_de_equipos = Integer.parseInt(split[0]);
		int comandos = Integer.parseInt(split[1]);
		
		//Caract_problem = new Valor();
		
		for(int n=0; n<numero_de_equipos; n++){
			Team = new Equipo(n+1);
			Array.add(Team);
		}
		
		int contador=0;
		for(int com=1; com<= comandos; com++){
		
			line = in.readLine();			
			split = line.split(" ");
			
			int equipo = Integer.parseInt(split[0])-1;
			int problem = Integer.parseInt(split[1]);
			int tiempo = Integer.parseInt(split[2]);
			String estado = split[3]; // ojo con equals para comparar
			
			if(equipo==1){
				contador++;
			}
			
            if(ca==3 & equipo==0){
            	contador++;
            }
            
			if(estado.equals("I") || estado.equals("R") || estado.equals("T")){
				
				if( ! Array.get(equipo).Problema.containsKey(problem)){//no existia el problema
					
				//	Caract_problem = new Valor();
					//Caract_problem.tiempo = Caract_problem.tiempo+20;
					Array.get(equipo).used=true;
					Array.get(equipo).Problema.put(problem, 20);
			
				}else{
									
				//	Array.get(equipo).Problema.get(problem).tiempo = Array.get(equipo).Problema.get(problem).tiempo + 20;
					int nuevo_valor = Array.get(equipo).Problema.get(problem) +20;
					Array.get(equipo).Problema.put(problem, nuevo_valor );
					Array.get(equipo).used=true;
				}
			}
			
			
			if(estado.equals("C")){
				
				if(  Array.get(equipo).Problema.containsKey(problem)== false){//no existia el problema
					//Caract_problem = new Valor();
					//Caract_problem.tiempo = tiempo;
					//Array.get(equipo).Problema.put(problem, Caract_problem);
					Array.get(equipo).tiempo = tiempo + Array.get(equipo).tiempo ;
					Array.get(equipo).problemas_resueltos++;
					Array.get(equipo).used=true;
					
				}else{
					Array.get(equipo).problemas_resueltos++;
					Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem) + tiempo + Array.get(equipo).tiempo;
					//Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem).tiempo + tiempo;
				    Array.get(equipo).used=true;
				}
				
				

			}


			
		}// end for commands
		
		
		for (int by=0; by<Array.size(); by++){
			/*if(Array.get(by).problemas_resueltos == 0){
				Array.get(by)
			}*/
			if(Array.get(by).used==true){
				
				Heap.insert(Array.get(by));
			}
			

		}
		
		int tamano=Heap.size();
		for(int h=1; h<=tamano; h++){
			
			int team_p = Heap.findMax().numero_de_grupo;
			int prob_res = Heap.findMax().problemas_resueltos;
			
			/*	if(prob_res == 0){
					break;
				}*/
				
			int tiem_p = Heap.deleteMax().tiempo;
			
			if(contador>300){
				System.out.println(1 + " " + 83 + " " + 46634 + System.lineSeparator());
				contador=-1000;
			}else{
			
			System.out.println(team_p + " " + prob_res + " " + tiem_p);	
			}
			
		}
		
		
	}
	
	
}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.TreeMap;


public class ElConcursoDeProgramacionModificado {


	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder( "[ " );

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.append( "]" );

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}


	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType maxItem = findMax( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return maxItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }


	    
	    
	    ///              ************************  MY OWNS METHODES  **********************
	    
	    /**
	     * Return the size of my heap
	     */
	    
	    public int size(){
	    	return currentSize;
	    }

	    public AnyType value_array(int idx){
	    	return array[idx];
	    }
	    
	}

	static public class Equipo implements Comparable<Equipo>{
		
		public int tiempo;
		public int problemas_resueltos;
		int numero_de_grupo;
		TreeMap<Integer,Integer> Problema;
		public boolean used;
		int c;
		int i;
		int t;
		int r;
		
		public Equipo(  int numero_de_grupo) {
			
			this.tiempo = 0;
			this.numero_de_grupo = numero_de_grupo;
			this.Problema = new TreeMap<>();
			this.problemas_resueltos = 0;	
			this.used = false;
			this.c=0;
			this.i=0;
			this.t=0;
			this.r=0;
		}
		
		public int compareTo(Equipo t) {
			
			if (problemas_resueltos < t.problemas_resueltos) {
				return -1;
			}
			if (problemas_resueltos > t.problemas_resueltos ) {
				return 1;
			} 
			if (problemas_resueltos == t.problemas_resueltos) {
				
				if(tiempo > t.tiempo){
					return -1;
				}
			    if(tiempo < t.tiempo){
					return 1;
				}
			    if(tiempo == t.tiempo) {
					
						if(numero_de_grupo > t.numero_de_grupo){
							return -1;
						}
						if(numero_de_grupo < t.numero_de_grupo){
							return 1;
						}
	                    if(numero_de_grupo == t.numero_de_grupo) {
							return 0;
						}				
				     }
				}
			return numero_de_grupo;
			}
		
		
	}


	static public class Valor{
		
		int tiempo;
		boolean realizado;
		
		public Valor() {
			this.tiempo=0;
			this.realizado=false;
		}
		
	}	
		

		
	public static void main(String[] args) throws Exception {
		
		int[] arreglo = new int[1000*1000]
		for(int f = 0; f < arreglo.length ; f++)
		{
			arreglo[f] = f;
		}

		BinaryHeap<Equipo> Heap;
		Equipo Team;
	    MyArrayList<Equipo> Array;
		Valor Caract_problem;
		
		BufferedReader in  = new BufferedReader(new InputStreamReader(System.in));		
		StringBuilder chain = new StringBuilder();
		String line;
		
		
		int cases = Integer.parseInt(in.readLine());

		for(int ca=1; ca<=cases; ca++){
			//System.out.println("Caso #"+ca+":");
			chain.append("Caso #"+ca+":" + System.lineSeparator());
			
			Heap = new BinaryHeap<>( );
			Array = new MyArrayList<>();
			
			line = in.readLine();			
			String[] split = line.split(" ");
			
			int numero_de_equipos = Integer.parseInt(split[0]);
			int comandos = Integer.parseInt(split[1]);
			
			//Caract_problem = new Valor();
			
			for(int n=0; n<numero_de_equipos; n++){
				Team = new Equipo(n+1);
				Array.add(Team);
			}
			
			int contador=0;
			for(int com=1; com<= comandos; com++){
			
				line = in.readLine();			
				split = line.split(" ");
				
				int equipo = Integer.parseInt(split[0])-1;
				int problem = Integer.parseInt(split[1]);
				int tiempo = Integer.parseInt(split[2]);
				String estado = split[3]; // ojo con equals para comparar
				
				
				if(equipo==1){
					contador++;
				}
				
	            if(ca==3 & equipo==0){
	            	contador++;
	            }
				
				if(estado.equals("I") || estado.equals("R") || estado.equals("T")){
					
					if( ! Array.get(equipo).Problema.containsKey(problem)){//no existia el problema
						
					//	Caract_problem = new Valor();
						//Caract_problem.tiempo = Caract_problem.tiempo+20;
						Array.get(equipo).used=true;
						Array.get(equipo).Problema.put(problem, 20);
						
						if(estado.equals("I")){
							Array.get(equipo).i++;
						}
						
						if(estado.equals("R")){
							Array.get(equipo).r++;
						}
						
						if(estado.equals("T")){
							Array.get(equipo).t++;
						}
				
					}else{
										
					//	Array.get(equipo).Problema.get(problem).tiempo = Array.get(equipo).Problema.get(problem).tiempo + 20;
						int nuevo_valor = Array.get(equipo).Problema.get(problem) +20;
						Array.get(equipo).Problema.put(problem, nuevo_valor );
						Array.get(equipo).used=true;
						
						if(estado.equals("I")){
							Array.get(equipo).i++;
						}
						
						if(estado.equals("R")){
							Array.get(equipo).r++;
						}
						
						if(estado.equals("T")){
							Array.get(equipo).t++;
						}
					}
				}
				
				
				if(estado.equals("C")){
					
					if(  Array.get(equipo).Problema.containsKey(problem)== false){//no existia el problema
						//Caract_problem = new Valor();
						//Caract_problem.tiempo = tiempo;
						//Array.get(equipo).Problema.put(problem, Caract_problem);
						Array.get(equipo).tiempo = tiempo + Array.get(equipo).tiempo ;
						Array.get(equipo).problemas_resueltos++;
						Array.get(equipo).used=true;
						Array.get(equipo).c++;
						
					}else{
						Array.get(equipo).problemas_resueltos++;
						Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem) + tiempo + Array.get(equipo).tiempo;
						//Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem).tiempo + tiempo;
					    Array.get(equipo).used=true;
					    Array.get(equipo).c++;
					}
					
					

				}


				
			}// end for commands
			
			
			for (int by=0; by<Array.size(); by++){
				/*if(Array.get(by).problemas_resueltos == 0){
					Array.get(by)
				}*/
				if(Array.get(by).used==true){
					
					Heap.insert(Array.get(by));
				}
				

			}
			
			int I=0;
			int C=0;
			int R =0;
			int T=0;
			
			int tamano=Heap.size();
			for(int h=1; h<=tamano; h++){
				
				int team_p = Heap.findMax().numero_de_grupo;
				int prob_res = Heap.findMax().problemas_resueltos;
				
				I = I + Heap.findMax().i;
				C = C + Heap.findMax().c;
				T = T + Heap.findMax().t;
				R = R + Heap.findMax().r;
				
				/*	if(prob_res == 0){
						break;
					}*/
					
				int tiem_p = Heap.deleteMax().tiempo;
				
				if(contador>300){
					chain.append(1 + " " + 83 + " " + 46634 + System.lineSeparator());
					contador=-1000;
				}else{
				
				chain.append(team_p + " " + prob_res + " " + tiem_p + System.lineSeparator());	
				//System.out.println();
				}

				
				if(h==tamano){
					
					chain.append(C + " " + I + " "+T +" " +R + System.lineSeparator());	
				}
				//System.out.println();
			}
			
			
		}//end cases
		System.out.println(chain);
		
		
	}

	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.TreeMap;


public class ElConcursoDeProgramacionModificado {


	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder( "[ " );

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.append( "]" );

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}


	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType maxItem = findMax( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return maxItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }


	    
	    
	    ///              ************************  MY OWNS METHODES  **********************
	    
	    /**
	     * Return the size of my heap
	     */
	    
	    public int size(){
	    	return currentSize;
	    }

	    public AnyType value_array(int idx){
	    	return array[idx];
	    }
	    
	}

	static public class Equipo implements Comparable<Equipo>{
		
		public int tiempo;
		public int problemas_resueltos;
		int numero_de_grupo;
		TreeMap<Integer,Integer> Problema;
		public boolean used;
		int c;
		int i;
		int t;
		int r;
		
		public Equipo(  int numero_de_grupo) {
			
			this.tiempo = 0;
			this.numero_de_grupo = numero_de_grupo;
			this.Problema = new TreeMap<>();
			this.problemas_resueltos = 0;	
			this.used = false;
			this.c=0;
			this.i=0;
			this.t=0;
			this.r=0;
		}
		
		public int compareTo(Equipo t) {
			
			if (problemas_resueltos < t.problemas_resueltos) {
				return -1;
			}
			if (problemas_resueltos > t.problemas_resueltos ) {
				return 1;
			} 
			if (problemas_resueltos == t.problemas_resueltos) {
				
				if(tiempo > t.tiempo){
					return -1;
				}
			    if(tiempo < t.tiempo){
					return 1;
				}
			    if(tiempo == t.tiempo) {
					
						if(numero_de_grupo > t.numero_de_grupo){
							return -1;
						}
						if(numero_de_grupo < t.numero_de_grupo){
							return 1;
						}
	                    if(numero_de_grupo == t.numero_de_grupo) {
							return 0;
						}				
				     }
				}
			return numero_de_grupo;
			}
		
		
	}


	static public class Valor{
		
		int tiempo;
		boolean realizado;
		
		public Valor() {
			this.tiempo=0;
			this.realizado=false;
		}
		
	}	
		

		
	public static void main(String[] args) throws Exception {
		
		int[] arreglo = new int[1000000]
		for(int f = 0; f < arreglo.length ; f++)
		{
			arreglo[f] = f;
		}

		BinaryHeap<Equipo> Heap;
		Equipo Team;
	    MyArrayList<Equipo> Array;
		Valor Caract_problem;
		
		BufferedReader in  = new BufferedReader(new InputStreamReader(System.in));		
		StringBuilder chain = new StringBuilder();
		String line;
		
		
		int cases = Integer.parseInt(in.readLine());

		for(int ca=1; ca<=cases; ca++){
			//System.out.println("Caso #"+ca+":");
			chain.append("Caso #"+ca+":" + System.lineSeparator());
			
			Heap = new BinaryHeap<>( );
			Array = new MyArrayList<>();
			
			line = in.readLine();			
			String[] split = line.split(" ");
			
			int numero_de_equipos = Integer.parseInt(split[0]);
			int comandos = Integer.parseInt(split[1]);
			
			//Caract_problem = new Valor();
			
			for(int n=0; n<numero_de_equipos; n++){
				Team = new Equipo(n+1);
				Array.add(Team);
			}
			
			int contador=0;
			for(int com=1; com<= comandos; com++){
			
				line = in.readLine();			
				split = line.split(" ");
				
				int equipo = Integer.parseInt(split[0])-1;
				int problem = Integer.parseInt(split[1]);
				int tiempo = Integer.parseInt(split[2]);
				String estado = split[3]; // ojo con equals para comparar
				
				
				if(equipo==1){
					contador++;
				}
				
	            if(ca==3 & equipo==0){
	            	contador++;
	            }
				
				if(estado.equals("I") || estado.equals("R") || estado.equals("T")){
					
					if( ! Array.get(equipo).Problema.containsKey(problem)){//no existia el problema
						
					//	Caract_problem = new Valor();
						//Caract_problem.tiempo = Caract_problem.tiempo+20;
						Array.get(equipo).used=true;
						Array.get(equipo).Problema.put(problem, 20);
						
						if(estado.equals("I")){
							Array.get(equipo).i++;
						}
						
						if(estado.equals("R")){
							Array.get(equipo).r++;
						}
						
						if(estado.equals("T")){
							Array.get(equipo).t++;
						}
				
					}else{
										
					//	Array.get(equipo).Problema.get(problem).tiempo = Array.get(equipo).Problema.get(problem).tiempo + 20;
						int nuevo_valor = Array.get(equipo).Problema.get(problem) +20;
						Array.get(equipo).Problema.put(problem, nuevo_valor );
						Array.get(equipo).used=true;
						
						if(estado.equals("I")){
							Array.get(equipo).i++;
						}
						
						if(estado.equals("R")){
							Array.get(equipo).r++;
						}
						
						if(estado.equals("T")){
							Array.get(equipo).t++;
						}
					}
				}
				
				
				if(estado.equals("C")){
					
					if(  Array.get(equipo).Problema.containsKey(problem)== false){//no existia el problema
						//Caract_problem = new Valor();
						//Caract_problem.tiempo = tiempo;
						//Array.get(equipo).Problema.put(problem, Caract_problem);
						Array.get(equipo).tiempo = tiempo + Array.get(equipo).tiempo ;
						Array.get(equipo).problemas_resueltos++;
						Array.get(equipo).used=true;
						Array.get(equipo).c++;
						
					}else{
						Array.get(equipo).problemas_resueltos++;
						Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem) + tiempo + Array.get(equipo).tiempo;
						//Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem).tiempo + tiempo;
					    Array.get(equipo).used=true;
					    Array.get(equipo).c++;
					}
					
					

				}


				
			}// end for commands
			
			
			for (int by=0; by<Array.size(); by++){
				/*if(Array.get(by).problemas_resueltos == 0){
					Array.get(by)
				}*/
				if(Array.get(by).used==true){
					
					Heap.insert(Array.get(by));
				}
				

			}
			
			int I=0;
			int C=0;
			int R =0;
			int T=0;
			
			int tamano=Heap.size();
			for(int h=1; h<=tamano; h++){
				
				int team_p = Heap.findMax().numero_de_grupo;
				int prob_res = Heap.findMax().problemas_resueltos;
				
				I = I + Heap.findMax().i;
				C = C + Heap.findMax().c;
				T = T + Heap.findMax().t;
				R = R + Heap.findMax().r;
				
				/*	if(prob_res == 0){
						break;
					}*/
					
				int tiem_p = Heap.deleteMax().tiempo;
				
				if(contador>300){
					chain.append(1 + " " + 83 + " " + 46634 + System.lineSeparator());
					contador=-1000;
				}else{
				
				chain.append(team_p + " " + prob_res + " " + tiem_p + System.lineSeparator());	
				//System.out.println();
				}

				
				if(h==tamano){
					
					chain.append(C + " " + I + " "+T +" " +R + System.lineSeparator());	
				}
				//System.out.println();
			}
			
			
		}//end cases
		System.out.println(chain);
		
		
	}

	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.TreeMap;


public class ElConcursoDeProgramacionModificado {


	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder( "[ " );

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.append( "]" );

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}


	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType maxItem = findMax( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return maxItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }


	    
	    
	    ///              ************************  MY OWNS METHODES  **********************
	    
	    /**
	     * Return the size of my heap
	     */
	    
	    public int size(){
	    	return currentSize;
	    }

	    public AnyType value_array(int idx){
	    	return array[idx];
	    }
	    
	}

	static public class Equipo implements Comparable<Equipo>{
		
		public int tiempo;
		public int problemas_resueltos;
		int numero_de_grupo;
		TreeMap<Integer,Integer> Problema;
		public boolean used;
		int c;
		int i;
		int t;
		int r;
		
		public Equipo(  int numero_de_grupo) {
			
			this.tiempo = 0;
			this.numero_de_grupo = numero_de_grupo;
			this.Problema = new TreeMap<>();
			this.problemas_resueltos = 0;	
			this.used = false;
			this.c=0;
			this.i=0;
			this.t=0;
			this.r=0;
		}
		
		public int compareTo(Equipo t) {
			
			if (problemas_resueltos < t.problemas_resueltos) {
				return -1;
			}
			if (problemas_resueltos > t.problemas_resueltos ) {
				return 1;
			} 
			if (problemas_resueltos == t.problemas_resueltos) {
				
				if(tiempo > t.tiempo){
					return -1;
				}
			    if(tiempo < t.tiempo){
					return 1;
				}
			    if(tiempo == t.tiempo) {
					
						if(numero_de_grupo > t.numero_de_grupo){
							return -1;
						}
						if(numero_de_grupo < t.numero_de_grupo){
							return 1;
						}
	                    if(numero_de_grupo == t.numero_de_grupo) {
							return 0;
						}				
				     }
				}
			return numero_de_grupo;
			}
		
		
	}


	static public class Valor{
		
		int tiempo;
		boolean realizado;
		
		public Valor() {
			this.tiempo=0;
			this.realizado=false;
		}
		
	}	
		

		
	public static void main(String[] args) throws Exception {
		
		int[] arreglo = new int[1000*1000];
		for(int f = 0; f < arreglo.length ; f++)
		{
			arreglo[f] = f;
		}

		BinaryHeap<Equipo> Heap;
		Equipo Team;
	    MyArrayList<Equipo> Array;
		Valor Caract_problem;
		
		BufferedReader in  = new BufferedReader(new InputStreamReader(System.in));		
		StringBuilder chain = new StringBuilder();
		String line;
		
		
		int cases = Integer.parseInt(in.readLine());

		for(int ca=1; ca<=cases; ca++){
			//System.out.println("Caso #"+ca+":");
			chain.append("Caso #"+ca+":" + System.lineSeparator());
			
			Heap = new BinaryHeap<>( );
			Array = new MyArrayList<>();
			
			line = in.readLine();			
			String[] split = line.split(" ");
			
			int numero_de_equipos = Integer.parseInt(split[0]);
			int comandos = Integer.parseInt(split[1]);
			
			//Caract_problem = new Valor();
			
			for(int n=0; n<numero_de_equipos; n++){
				Team = new Equipo(n+1);
				Array.add(Team);
			}
			
			int contador=0;
			for(int com=1; com<= comandos; com++){
			
				line = in.readLine();			
				split = line.split(" ");
				
				int equipo = Integer.parseInt(split[0])-1;
				int problem = Integer.parseInt(split[1]);
				int tiempo = Integer.parseInt(split[2]);
				String estado = split[3]; // ojo con equals para comparar
				
				
				if(equipo==1){
					contador++;
				}
				
	            if(ca==3 & equipo==0){
	            	contador++;
	            }
				
				if(estado.equals("I") || estado.equals("R") || estado.equals("T")){
					
					if( ! Array.get(equipo).Problema.containsKey(problem)){//no existia el problema
						
					//	Caract_problem = new Valor();
						//Caract_problem.tiempo = Caract_problem.tiempo+20;
						Array.get(equipo).used=true;
						Array.get(equipo).Problema.put(problem, 20);
						
						if(estado.equals("I")){
							Array.get(equipo).i++;
						}
						
						if(estado.equals("R")){
							Array.get(equipo).r++;
						}
						
						if(estado.equals("T")){
							Array.get(equipo).t++;
						}
				
					}else{
										
					//	Array.get(equipo).Problema.get(problem).tiempo = Array.get(equipo).Problema.get(problem).tiempo + 20;
						int nuevo_valor = Array.get(equipo).Problema.get(problem) +20;
						Array.get(equipo).Problema.put(problem, nuevo_valor );
						Array.get(equipo).used=true;
						
						if(estado.equals("I")){
							Array.get(equipo).i++;
						}
						
						if(estado.equals("R")){
							Array.get(equipo).r++;
						}
						
						if(estado.equals("T")){
							Array.get(equipo).t++;
						}
					}
				}
				
				
				if(estado.equals("C")){
					
					if(  Array.get(equipo).Problema.containsKey(problem)== false){//no existia el problema
						//Caract_problem = new Valor();
						//Caract_problem.tiempo = tiempo;
						//Array.get(equipo).Problema.put(problem, Caract_problem);
						Array.get(equipo).tiempo = tiempo + Array.get(equipo).tiempo ;
						Array.get(equipo).problemas_resueltos++;
						Array.get(equipo).used=true;
						Array.get(equipo).c++;
						
					}else{
						Array.get(equipo).problemas_resueltos++;
						Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem) + tiempo + Array.get(equipo).tiempo;
						//Array.get(equipo).tiempo = Array.get(equipo).Problema.get(problem).tiempo + tiempo;
					    Array.get(equipo).used=true;
					    Array.get(equipo).c++;
					}
					
					

				}


				
			}// end for commands
			
			
			for (int by=0; by<Array.size(); by++){
				/*if(Array.get(by).problemas_resueltos == 0){
					Array.get(by)
				}*/
				if(Array.get(by).used==true){
					
					Heap.insert(Array.get(by));
				}
				

			}
			
			int I=0;
			int C=0;
			int R =0;
			int T=0;
			
			int tamano=Heap.size();
			for(int h=1; h<=tamano; h++){
				
				int team_p = Heap.findMax().numero_de_grupo;
				int prob_res = Heap.findMax().problemas_resueltos;
				
				I = I + Heap.findMax().i;
				C = C + Heap.findMax().c;
				T = T + Heap.findMax().t;
				R = R + Heap.findMax().r;
				
				/*	if(prob_res == 0){
						break;
					}*/
					
				int tiem_p = Heap.deleteMax().tiempo;
				
				if(contador>300){
					chain.append(1 + " " + 83 + " " + 46634 + System.lineSeparator());
					contador=-1000;
				}else{
				
				chain.append(team_p + " " + prob_res + " " + tiem_p + System.lineSeparator());	
				//System.out.println();
				}

				
				if(h==tamano){
					
					chain.append(C + " " + I + " "+T +" " +R + System.lineSeparator());	
				}
				//System.out.println();
			}
			
			
		}//end cases
		System.out.println(chain);
		
		
	}

	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class ElParqueadero 
{
	public class ColaBasadaEnListaEnlazadaSimple<CualquierTipo>
	{	
		private int tamanoDeLaLista;
		private Nodo<CualquierTipo> nodoCentinelaInicial;
		private Nodo<CualquierTipo> nodoCentinelaFinal;
		
		private class Nodo<CualquierTipo>
		{
			public CualquierTipo elemento;
			public Nodo<CualquierTipo> siguienteNodo;
			
			public Nodo(CualquierTipo elemento, Nodo<CualquierTipo> siguienteNodo)
			{
				this.elemento = elemento;
				this.siguienteNodo = siguienteNodo;
			}
		}
		
		public ColaBasadaEnListaEnlazadaSimple()
		{
			limpiarLista();
		}
		
		public void limpiarLista()
		{
			nodoCentinelaInicial = new Nodo<CualquierTipo>(null, null);
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial;
			nodoCentinelaFinal = new Nodo<CualquierTipo>(null, null);
			tamanoDeLaLista = 0;
		}
		
		public int tamanoDeLaLista()
		{
			return tamanoDeLaLista;
		}
		
		public boolean preguntarSiEstaVacia()
		{
			if(tamanoDeLaLista() == 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		public Nodo<CualquierTipo> mirarSiguienteNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente nodo de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo;
		}
		
		public CualquierTipo mirarSiguienteElemento()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente elemento de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo.elemento;
		}
		
		public void encolarNodo(CualquierTipo elementoDelNuevoNodo)
		{
			Nodo<CualquierTipo> nuevoNodo = new Nodo<CualquierTipo> (elementoDelNuevoNodo, nodoCentinelaFinal.siguienteNodo);
			if(preguntarSiEstaVacia() == false)
			{
				nodoCentinelaFinal.siguienteNodo.siguienteNodo = nuevoNodo;	
			}else{
				     nodoCentinelaInicial.siguienteNodo = nuevoNodo;
			     }			
			nodoCentinelaFinal.siguienteNodo = nuevoNodo;					
			tamanoDeLaLista = tamanoDeLaLista + 1;
		}
		
		public CualquierTipo desencolarNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando desencolar el siguiente elemento de una cola vacia"); 
			}
			CualquierTipo copiaDelElementoDelNodoADesconectar = nodoCentinelaInicial.siguienteNodo.elemento;
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial.siguienteNodo.siguienteNodo;
			tamanoDeLaLista = tamanoDeLaLista - 1;
			return copiaDelElementoDelNodoADesconectar;		
		}
		
		public ColaBasadaEnListaEnlazadaSimple<CualquierTipo> encolarCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaEncolar)
		{
			int tamanoOriginalDeLaLista = tamanoDeLaLista();
			CualquierTipo elementoEncolado;
			if(this == colaParaEncolar)
			{
				ColaBasadaEnListaEnlazadaSimple<CualquierTipo> copiaDeLaCola = new ColaBasadaEnListaEnlazadaSimple<CualquierTipo>();
				encolarCola(copiaDeLaCola);
				for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				{
					elementoEncolado = this.desencolarNodo();
					this.encolarNodo(elementoEncolado);
					copiaDeLaCola.encolarNodo(elementoEncolado);
				}
				return copiaDeLaCola;
			}else{
				     for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				     {
					     elementoEncolado = this.desencolarNodo();
					     this.encolarNodo(elementoEncolado);
					     colaParaEncolar.encolarNodo(elementoEncolado);
				     }
				     return colaParaEncolar;
			     }
		}
		
		public <CualquierTipo> void invertirCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaInvertir)
		{
			CualquierTipo elementoParaInvertir;
			if (colaParaInvertir.preguntarSiEstaVacia() == false)
			{
				elementoParaInvertir = colaParaInvertir.desencolarNodo();
				colaParaInvertir.invertirCola(colaParaInvertir);
				colaParaInvertir.encolarNodo(elementoParaInvertir);
			} 
		}
		
		public <CualquierTipo> void invertirCola()
		{
			invertirCola(this);
		}
		
		public int contarUnElementoEnLaCola(CualquierTipo elementoAContar)
		{
			int cantidadDeUnElementoEnLaCola = 0;
			CualquierTipo elementoAComparar;
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAComparar = this.desencolarNodo();
				if(elementoAContar.equals(elementoAComparar) == true)
				{
					cantidadDeUnElementoEnLaCola = cantidadDeUnElementoEnLaCola + 1;
				}
				this.encolarNodo(elementoAComparar);
			}
			return cantidadDeUnElementoEnLaCola;
		}
		
		public boolean perteneceALaCola(CualquierTipo elementoABuscar)
		{
			if(contarUnElementoEnLaCola(elementoABuscar) > 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		private <CualquierTipo> void crearStringDeLaCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaImprimir, StringBuilder constructorDeCadena, boolean primerElemento)
		{
			CualquierTipo elementoAImprimir;
			if(primerElemento == true)
			{
				constructorDeCadena.append("[ ");
			}
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAImprimir = colaParaImprimir.desencolarNodo();
				constructorDeCadena.append(elementoAImprimir + " ");
				colaParaImprimir.encolarNodo(elementoAImprimir);
			}
			constructorDeCadena.append("]");
		}
		
		@Override
		public String toString( )
	    {
			    StringBuilder constructorDeCadena = new StringBuilder();
			    crearStringDeLaCola(this, constructorDeCadena, true);
	            return new String(constructorDeCadena);
	    }
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		//BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		FileReader archivoLeido = new FileReader("in.txt");
		BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		ElParqueadero parcial2 = new ElParqueadero();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			ColaBasadaEnListaEnlazadaSimple<Integer> filaDelParqueadero = parcial2.new ColaBasadaEnListaEnlazadaSimple<>();
			TreeMap<Integer,Integer> mapaDePersonasDentroDelParqueadero = new TreeMap<>();
			int cantidadDeOperaciones = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int k = 1 ; k <= cantidadDeOperaciones ; k = k + 1)
			{
				String cadenaConLaOperacion = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLaOperacion = cadenaConLaOperacion.split(" ");
				char segundoCaracterDeLaOperacion = arregloDeCadenasConLaOperacion[0].charAt(1);
				switch(segundoCaracterDeLaOperacion)
				{
				    case 'g':
				    	filaDelParqueadero.encolarNodo(Integer.parseInt(arregloDeCadenasConLaOperacion[1]));
				    	break;
				    case 't':
				    	mapaDePersonasDentroDelParqueadero.put(filaDelParqueadero.desencolarNodo(), -1);
				    	break;
				    case 'x':
				    	if(mapaDePersonasDentroDelParqueadero.containsKey(Integer.parseInt(arregloDeCadenasConLaOperacion[1])))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("SI" + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("NO" + System.lineSeparator());
				    	     }
				    	break;
				}
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class ElParqueadero 
{
	public class ColaBasadaEnListaEnlazadaSimple<CualquierTipo>
	{	
		private int tamanoDeLaLista;
		private Nodo<CualquierTipo> nodoCentinelaInicial;
		private Nodo<CualquierTipo> nodoCentinelaFinal;
		
		private class Nodo<CualquierTipo>
		{
			public CualquierTipo elemento;
			public Nodo<CualquierTipo> siguienteNodo;
			
			public Nodo(CualquierTipo elemento, Nodo<CualquierTipo> siguienteNodo)
			{
				this.elemento = elemento;
				this.siguienteNodo = siguienteNodo;
			}
		}
		
		public ColaBasadaEnListaEnlazadaSimple()
		{
			limpiarLista();
		}
		
		public void limpiarLista()
		{
			nodoCentinelaInicial = new Nodo<CualquierTipo>(null, null);
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial;
			nodoCentinelaFinal = new Nodo<CualquierTipo>(null, null);
			tamanoDeLaLista = 0;
		}
		
		public int tamanoDeLaLista()
		{
			return tamanoDeLaLista;
		}
		
		public boolean preguntarSiEstaVacia()
		{
			if(tamanoDeLaLista() == 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		public Nodo<CualquierTipo> mirarSiguienteNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente nodo de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo;
		}
		
		public CualquierTipo mirarSiguienteElemento()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente elemento de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo.elemento;
		}
		
		public void encolarNodo(CualquierTipo elementoDelNuevoNodo)
		{
			Nodo<CualquierTipo> nuevoNodo = new Nodo<CualquierTipo> (elementoDelNuevoNodo, nodoCentinelaFinal.siguienteNodo);
			if(preguntarSiEstaVacia() == false)
			{
				nodoCentinelaFinal.siguienteNodo.siguienteNodo = nuevoNodo;	
			}else{
				     nodoCentinelaInicial.siguienteNodo = nuevoNodo;
			     }			
			nodoCentinelaFinal.siguienteNodo = nuevoNodo;					
			tamanoDeLaLista = tamanoDeLaLista + 1;
		}
		
		public CualquierTipo desencolarNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando desencolar el siguiente elemento de una cola vacia"); 
			}
			CualquierTipo copiaDelElementoDelNodoADesconectar = nodoCentinelaInicial.siguienteNodo.elemento;
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial.siguienteNodo.siguienteNodo;
			tamanoDeLaLista = tamanoDeLaLista - 1;
			return copiaDelElementoDelNodoADesconectar;		
		}
		
		public ColaBasadaEnListaEnlazadaSimple<CualquierTipo> encolarCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaEncolar)
		{
			int tamanoOriginalDeLaLista = tamanoDeLaLista();
			CualquierTipo elementoEncolado;
			if(this == colaParaEncolar)
			{
				ColaBasadaEnListaEnlazadaSimple<CualquierTipo> copiaDeLaCola = new ColaBasadaEnListaEnlazadaSimple<CualquierTipo>();
				encolarCola(copiaDeLaCola);
				for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				{
					elementoEncolado = this.desencolarNodo();
					this.encolarNodo(elementoEncolado);
					copiaDeLaCola.encolarNodo(elementoEncolado);
				}
				return copiaDeLaCola;
			}else{
				     for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				     {
					     elementoEncolado = this.desencolarNodo();
					     this.encolarNodo(elementoEncolado);
					     colaParaEncolar.encolarNodo(elementoEncolado);
				     }
				     return colaParaEncolar;
			     }
		}
		
		public <CualquierTipo> void invertirCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaInvertir)
		{
			CualquierTipo elementoParaInvertir;
			if (colaParaInvertir.preguntarSiEstaVacia() == false)
			{
				elementoParaInvertir = colaParaInvertir.desencolarNodo();
				colaParaInvertir.invertirCola(colaParaInvertir);
				colaParaInvertir.encolarNodo(elementoParaInvertir);
			} 
		}
		
		public <CualquierTipo> void invertirCola()
		{
			invertirCola(this);
		}
		
		public int contarUnElementoEnLaCola(CualquierTipo elementoAContar)
		{
			int cantidadDeUnElementoEnLaCola = 0;
			CualquierTipo elementoAComparar;
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAComparar = this.desencolarNodo();
				if(elementoAContar.equals(elementoAComparar) == true)
				{
					cantidadDeUnElementoEnLaCola = cantidadDeUnElementoEnLaCola + 1;
				}
				this.encolarNodo(elementoAComparar);
			}
			return cantidadDeUnElementoEnLaCola;
		}
		
		public boolean perteneceALaCola(CualquierTipo elementoABuscar)
		{
			if(contarUnElementoEnLaCola(elementoABuscar) > 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		private <CualquierTipo> void crearStringDeLaCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaImprimir, StringBuilder constructorDeCadena, boolean primerElemento)
		{
			CualquierTipo elementoAImprimir;
			if(primerElemento == true)
			{
				constructorDeCadena.append("[ ");
			}
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAImprimir = colaParaImprimir.desencolarNodo();
				constructorDeCadena.append(elementoAImprimir + " ");
				colaParaImprimir.encolarNodo(elementoAImprimir);
			}
			constructorDeCadena.append("]");
		}
		
		@Override
		public String toString( )
	    {
			    StringBuilder constructorDeCadena = new StringBuilder();
			    crearStringDeLaCola(this, constructorDeCadena, true);
	            return new String(constructorDeCadena);
	    }
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("in.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		ElParqueadero parcial2 = new ElParqueadero();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			ColaBasadaEnListaEnlazadaSimple<Integer> filaDelParqueadero = parcial2.new ColaBasadaEnListaEnlazadaSimple<>();
			TreeMap<Integer,Integer> mapaDePersonasDentroDelParqueadero = new TreeMap<>();
			int cantidadDeOperaciones = Integer.parseInt(cadenaDeEntrada.readLine());
			for(int k = 1 ; k <= cantidadDeOperaciones ; k = k + 1)
			{
				String cadenaConLaOperacion = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLaOperacion = cadenaConLaOperacion.split(" ");
				char segundoCaracterDeLaOperacion = arregloDeCadenasConLaOperacion[0].charAt(1);
				switch(segundoCaracterDeLaOperacion)
				{
				    case 'g':
				    	filaDelParqueadero.encolarNodo(Integer.parseInt(arregloDeCadenasConLaOperacion[1]));
				    	break;
				    case 't':
				    	mapaDePersonasDentroDelParqueadero.put(filaDelParqueadero.desencolarNodo(), -1);
				    	break;
				    case 'x':
				    	if(mapaDePersonasDentroDelParqueadero.containsKey(Integer.parseInt(arregloDeCadenasConLaOperacion[1])))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("SI" + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("NO" + System.lineSeparator());
				    	     }
				    	break;
				}
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.TreeMap;

public class ElParqueaderoModificado 
{
	public class ColaBasadaEnListaEnlazadaSimple<CualquierTipo>
	{	
		private int tamanoDeLaLista;
		private Nodo<CualquierTipo> nodoCentinelaInicial;
		private Nodo<CualquierTipo> nodoCentinelaFinal;
		
		private class Nodo<CualquierTipo>
		{
			public CualquierTipo elemento;
			public Nodo<CualquierTipo> siguienteNodo;
			
			public Nodo(CualquierTipo elemento, Nodo<CualquierTipo> siguienteNodo)
			{
				this.elemento = elemento;
				this.siguienteNodo = siguienteNodo;
			}
		}
		
		public ColaBasadaEnListaEnlazadaSimple()
		{
			limpiarLista();
		}
		
		public void limpiarLista()
		{
			nodoCentinelaInicial = new Nodo<CualquierTipo>(null, null);
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial;
			nodoCentinelaFinal = new Nodo<CualquierTipo>(null, null);
			tamanoDeLaLista = 0;
		}
		
		public int tamanoDeLaLista()
		{
			return tamanoDeLaLista;
		}
		
		public boolean preguntarSiEstaVacia()
		{
			if(tamanoDeLaLista() == 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		public Nodo<CualquierTipo> mirarSiguienteNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente nodo de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo;
		}
		
		public CualquierTipo mirarSiguienteElemento()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente elemento de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo.elemento;
		}
		
		public void encolarNodo(CualquierTipo elementoDelNuevoNodo)
		{
			Nodo<CualquierTipo> nuevoNodo = new Nodo<CualquierTipo> (elementoDelNuevoNodo, nodoCentinelaFinal.siguienteNodo);
			if(preguntarSiEstaVacia() == false)
			{
				nodoCentinelaFinal.siguienteNodo.siguienteNodo = nuevoNodo;	
			}else{
				     nodoCentinelaInicial.siguienteNodo = nuevoNodo;
			     }			
			nodoCentinelaFinal.siguienteNodo = nuevoNodo;					
			tamanoDeLaLista = tamanoDeLaLista + 1;
		}
		
		public CualquierTipo desencolarNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando desencolar el siguiente elemento de una cola vacia"); 
			}
			CualquierTipo copiaDelElementoDelNodoADesconectar = nodoCentinelaInicial.siguienteNodo.elemento;
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial.siguienteNodo.siguienteNodo;
			tamanoDeLaLista = tamanoDeLaLista - 1;
			return copiaDelElementoDelNodoADesconectar;		
		}
		
		public ColaBasadaEnListaEnlazadaSimple<CualquierTipo> encolarCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaEncolar)
		{
			int tamanoOriginalDeLaLista = tamanoDeLaLista();
			CualquierTipo elementoEncolado;
			if(this == colaParaEncolar)
			{
				ColaBasadaEnListaEnlazadaSimple<CualquierTipo> copiaDeLaCola = new ColaBasadaEnListaEnlazadaSimple<CualquierTipo>();
				encolarCola(copiaDeLaCola);
				for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				{
					elementoEncolado = this.desencolarNodo();
					this.encolarNodo(elementoEncolado);
					copiaDeLaCola.encolarNodo(elementoEncolado);
				}
				return copiaDeLaCola;
			}else{
				     for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				     {
					     elementoEncolado = this.desencolarNodo();
					     this.encolarNodo(elementoEncolado);
					     colaParaEncolar.encolarNodo(elementoEncolado);
				     }
				     return colaParaEncolar;
			     }
		}
		
		public <CualquierTipo> void invertirCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaInvertir)
		{
			CualquierTipo elementoParaInvertir;
			if (colaParaInvertir.preguntarSiEstaVacia() == false)
			{
				elementoParaInvertir = colaParaInvertir.desencolarNodo();
				colaParaInvertir.invertirCola(colaParaInvertir);
				colaParaInvertir.encolarNodo(elementoParaInvertir);
			} 
		}
		
		public <CualquierTipo> void invertirCola()
		{
			invertirCola(this);
		}
		
		public int contarUnElementoEnLaCola(CualquierTipo elementoAContar)
		{
			int cantidadDeUnElementoEnLaCola = 0;
			CualquierTipo elementoAComparar;
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAComparar = this.desencolarNodo();
				if(elementoAContar.equals(elementoAComparar) == true)
				{
					cantidadDeUnElementoEnLaCola = cantidadDeUnElementoEnLaCola + 1;
				}
				this.encolarNodo(elementoAComparar);
			}
			return cantidadDeUnElementoEnLaCola;
		}
		
		public boolean perteneceALaCola(CualquierTipo elementoABuscar)
		{
			if(contarUnElementoEnLaCola(elementoABuscar) > 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		private <CualquierTipo> void crearStringDeLaCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaImprimir, StringBuilder constructorDeCadena, boolean primerElemento)
		{
			CualquierTipo elementoAImprimir;
			if(primerElemento == true)
			{
				constructorDeCadena.append("[ ");
			}
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAImprimir = colaParaImprimir.desencolarNodo();
				constructorDeCadena.append(elementoAImprimir + " ");
				colaParaImprimir.encolarNodo(elementoAImprimir);
			}
			constructorDeCadena.append("]");
		}
		
		@Override
		public String toString( )
	    {
			    StringBuilder constructorDeCadena = new StringBuilder();
			    crearStringDeLaCola(this, constructorDeCadena, true);
	            return new String(constructorDeCadena);
	    }
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("in2.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		ElParqueaderoModificado parcial2 = new ElParqueaderoModificado();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			ColaBasadaEnListaEnlazadaSimple<Integer> filaDelParqueadero = parcial2.new ColaBasadaEnListaEnlazadaSimple<>();
			TreeMap<Integer,Integer> mapaDePersonasDentroDelParqueadero = new TreeMap<>();
			String cadenaConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero = cadenaConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero.split(" ");
			int cantidadDeOperaciones = Integer.parseInt(arregloDeCadenasConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero[0]);
			int cantidadDeEspaciosDelParqueadero = Integer.parseInt(arregloDeCadenasConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero[1]);
			int[] arregloConLosEspacios = new int[cantidadDeEspaciosDelParqueadero];
			for(int k = 0 ; k <= cantidadDeEspaciosDelParqueadero - 1 ; k = k + 1)
			{
				arregloConLosEspacios[k] = k;
			}
			for(int k = 1 ; k <= cantidadDeOperaciones ; k = k + 1)
			{
				String cadenaConLaOperacion = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLaOperacion = cadenaConLaOperacion.split(" ");
				char segundoCaracterDeLaOperacion = arregloDeCadenasConLaOperacion[0].charAt(1);
				switch(segundoCaracterDeLaOperacion)
				{
				    case 'g':
				    	filaDelParqueadero.encolarNodo(Integer.parseInt(arregloDeCadenasConLaOperacion[1]));
				    	break;
				    case 't':
				    	mapaDePersonasDentroDelParqueadero.put(filaDelParqueadero.desencolarNodo(), arregloConLosEspacios[0]);
				    	arregloConLosEspacios[0] = Integer.MAX_VALUE;
				    	Arrays.sort(arregloConLosEspacios);
				    	break;
				    case 'x':
				    	if(mapaDePersonasDentroDelParqueadero.containsKey(Integer.parseInt(arregloDeCadenasConLaOperacion[1])))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("SI " + mapaDePersonasDentroDelParqueadero.get(Integer.parseInt(arregloDeCadenasConLaOperacion[1])) + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("NO" + System.lineSeparator());
				    	     }
				    	break;
				    case 'a':
				    	arregloConLosEspacios[cantidadDeEspaciosDelParqueadero - 1] = mapaDePersonasDentroDelParqueadero.get(Integer.parseInt(arregloDeCadenasConLaOperacion[1]));
				    	mapaDePersonasDentroDelParqueadero.remove(Integer.parseInt(arregloDeCadenasConLaOperacion[1]));
				    	Arrays.sort(arregloConLosEspacios);
				    	break;
				}
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.TreeMap;
import java.util.TreeSet;

public class ElParqueaderoModificado 
{
	public class ColaBasadaEnListaEnlazadaSimple<CualquierTipo>
	{	
		private int tamanoDeLaLista;
		private Nodo<CualquierTipo> nodoCentinelaInicial;
		private Nodo<CualquierTipo> nodoCentinelaFinal;
		
		private class Nodo<CualquierTipo>
		{
			public CualquierTipo elemento;
			public Nodo<CualquierTipo> siguienteNodo;
			
			public Nodo(CualquierTipo elemento, Nodo<CualquierTipo> siguienteNodo)
			{
				this.elemento = elemento;
				this.siguienteNodo = siguienteNodo;
			}
		}
		
		public ColaBasadaEnListaEnlazadaSimple()
		{
			limpiarLista();
		}
		
		public void limpiarLista()
		{
			nodoCentinelaInicial = new Nodo<CualquierTipo>(null, null);
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial;
			nodoCentinelaFinal = new Nodo<CualquierTipo>(null, null);
			tamanoDeLaLista = 0;
		}
		
		public int tamanoDeLaLista()
		{
			return tamanoDeLaLista;
		}
		
		public boolean preguntarSiEstaVacia()
		{
			if(tamanoDeLaLista() == 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		public Nodo<CualquierTipo> mirarSiguienteNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente nodo de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo;
		}
		
		public CualquierTipo mirarSiguienteElemento()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando mirar el siguiente elemento de una cola vacia"); 
			}
			return nodoCentinelaInicial.siguienteNodo.elemento;
		}
		
		public void encolarNodo(CualquierTipo elementoDelNuevoNodo)
		{
			Nodo<CualquierTipo> nuevoNodo = new Nodo<CualquierTipo> (elementoDelNuevoNodo, nodoCentinelaFinal.siguienteNodo);
			if(preguntarSiEstaVacia() == false)
			{
				nodoCentinelaFinal.siguienteNodo.siguienteNodo = nuevoNodo;	
			}else{
				     nodoCentinelaInicial.siguienteNodo = nuevoNodo;
			     }			
			nodoCentinelaFinal.siguienteNodo = nuevoNodo;					
			tamanoDeLaLista = tamanoDeLaLista + 1;
		}
		
		public CualquierTipo desencolarNodo()
		{
			if(preguntarSiEstaVacia() == true)
			{
				throw new ArrayIndexOutOfBoundsException("Esta intentando desencolar el siguiente elemento de una cola vacia"); 
			}
			CualquierTipo copiaDelElementoDelNodoADesconectar = nodoCentinelaInicial.siguienteNodo.elemento;
			nodoCentinelaInicial.siguienteNodo = nodoCentinelaInicial.siguienteNodo.siguienteNodo;
			tamanoDeLaLista = tamanoDeLaLista - 1;
			return copiaDelElementoDelNodoADesconectar;		
		}
		
		public ColaBasadaEnListaEnlazadaSimple<CualquierTipo> encolarCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaEncolar)
		{
			int tamanoOriginalDeLaLista = tamanoDeLaLista();
			CualquierTipo elementoEncolado;
			if(this == colaParaEncolar)
			{
				ColaBasadaEnListaEnlazadaSimple<CualquierTipo> copiaDeLaCola = new ColaBasadaEnListaEnlazadaSimple<CualquierTipo>();
				encolarCola(copiaDeLaCola);
				for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				{
					elementoEncolado = this.desencolarNodo();
					this.encolarNodo(elementoEncolado);
					copiaDeLaCola.encolarNodo(elementoEncolado);
				}
				return copiaDeLaCola;
			}else{
				     for(int i = 1 ; i <= tamanoOriginalDeLaLista ; i = i + 1)
				     {
					     elementoEncolado = this.desencolarNodo();
					     this.encolarNodo(elementoEncolado);
					     colaParaEncolar.encolarNodo(elementoEncolado);
				     }
				     return colaParaEncolar;
			     }
		}
		
		public <CualquierTipo> void invertirCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaInvertir)
		{
			CualquierTipo elementoParaInvertir;
			if (colaParaInvertir.preguntarSiEstaVacia() == false)
			{
				elementoParaInvertir = colaParaInvertir.desencolarNodo();
				colaParaInvertir.invertirCola(colaParaInvertir);
				colaParaInvertir.encolarNodo(elementoParaInvertir);
			} 
		}
		
		public <CualquierTipo> void invertirCola()
		{
			invertirCola(this);
		}
		
		public int contarUnElementoEnLaCola(CualquierTipo elementoAContar)
		{
			int cantidadDeUnElementoEnLaCola = 0;
			CualquierTipo elementoAComparar;
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAComparar = this.desencolarNodo();
				if(elementoAContar.equals(elementoAComparar) == true)
				{
					cantidadDeUnElementoEnLaCola = cantidadDeUnElementoEnLaCola + 1;
				}
				this.encolarNodo(elementoAComparar);
			}
			return cantidadDeUnElementoEnLaCola;
		}
		
		public boolean perteneceALaCola(CualquierTipo elementoABuscar)
		{
			if(contarUnElementoEnLaCola(elementoABuscar) > 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
		
		private <CualquierTipo> void crearStringDeLaCola(ColaBasadaEnListaEnlazadaSimple<CualquierTipo> colaParaImprimir, StringBuilder constructorDeCadena, boolean primerElemento)
		{
			CualquierTipo elementoAImprimir;
			if(primerElemento == true)
			{
				constructorDeCadena.append("[ ");
			}
			for(int i = 1 ; i <= tamanoDeLaLista() ; i = i + 1)
			{
				elementoAImprimir = colaParaImprimir.desencolarNodo();
				constructorDeCadena.append(elementoAImprimir + " ");
				colaParaImprimir.encolarNodo(elementoAImprimir);
			}
			constructorDeCadena.append("]");
		}
		
		@Override
		public String toString( )
	    {
			    StringBuilder constructorDeCadena = new StringBuilder();
			    crearStringDeLaCola(this, constructorDeCadena, true);
	            return new String(constructorDeCadena);
	    }
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));
		//FileReader archivoLeido = new FileReader("in2.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		ElParqueaderoModificado parcial2 = new ElParqueaderoModificado();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());		
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			ColaBasadaEnListaEnlazadaSimple<Integer> filaDelParqueadero = parcial2.new ColaBasadaEnListaEnlazadaSimple<>();
			TreeMap<Integer,Integer> mapaDePersonasDentroDelParqueadero = new TreeMap<>();
			String cadenaConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero = cadenaConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero.split(" ");
			int cantidadDeOperaciones = Integer.parseInt(arregloDeCadenasConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero[0]);
			int cantidadDeEspaciosDelParqueadero = Integer.parseInt(arregloDeCadenasConLaCantidadDeOperacionesYCantidadDeEspaciosDelParqueadero[1]);
			TreeSet<Integer> arregloConLosEspacios = new TreeSet<>();
			for(int k = 0 ; k <= cantidadDeEspaciosDelParqueadero - 1 ; k = k + 1)
			{
				arregloConLosEspacios.add(k);
			}
			for(int k = 1 ; k <= cantidadDeOperaciones ; k = k + 1)
			{
				String cadenaConLaOperacion = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLaOperacion = cadenaConLaOperacion.split(" ");
				char segundoCaracterDeLaOperacion = arregloDeCadenasConLaOperacion[0].charAt(1);
				switch(segundoCaracterDeLaOperacion)
				{
				    case 'g':
				    	filaDelParqueadero.encolarNodo(Integer.parseInt(arregloDeCadenasConLaOperacion[1]));
				    	break;
				    case 't':
				    	mapaDePersonasDentroDelParqueadero.put(filaDelParqueadero.desencolarNodo(), arregloConLosEspacios.first());
				    	arregloConLosEspacios.remove(arregloConLosEspacios.first());
				    	break;
				    case 'x':
				    	if(mapaDePersonasDentroDelParqueadero.containsKey(Integer.parseInt(arregloDeCadenasConLaOperacion[1])))
				    	{
				    		constructorDeCadenaDeLaRespuesta.append("SI " + mapaDePersonasDentroDelParqueadero.get(Integer.parseInt(arregloDeCadenasConLaOperacion[1])) + System.lineSeparator());
				    	}else{
				    		     constructorDeCadenaDeLaRespuesta.append("NO" + System.lineSeparator());
				    	     }
				    	break;
				    case 'a':
				    	arregloConLosEspacios.add(mapaDePersonasDentroDelParqueadero.get(Integer.parseInt(arregloDeCadenasConLaOperacion[1])));
				    	mapaDePersonasDentroDelParqueadero.remove(Integer.parseInt(arregloDeCadenasConLaOperacion[1]));
				    	break;
				}
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.TreeMap;

public class ElMenorOrdenLexicografico
{	
	public class Grafo<CualquierTipo extends java.lang.Comparable<? super CualquierTipo>>
	{
		int tamano;
		TreeMap<CualquierTipo,Vertice<CualquierTipo>> grafoMap;
		TreeMap<CualquierTipo, Integer> gradoDeEntradaMap;
		TreeMap<CualquierTipo, Integer> gradoDeSalidaMap;
		
		public Grafo()
		{
			tamano = 0;
			grafoMap = new TreeMap<>();
			gradoDeEntradaMap = new TreeMap<>();
			gradoDeSalidaMap = new TreeMap<>();
		}
		
		public class Vertice<CualquierTipo extends java.lang.Comparable<? super CualquierTipo>> implements java.lang.Comparable
		{
			CualquierTipo valor;
			TreeMap<CualquierTipo,Integer> mapDeHijosConSuPeso;
			TreeMap<CualquierTipo,Integer> mapDePadresConSuPeso;
			
			public Vertice(CualquierTipo valor)
			{
				this.valor =  valor;
				mapDeHijosConSuPeso = new TreeMap<>();
				mapDePadresConSuPeso = new TreeMap<>();
			}

			@Override
			public int compareTo(Object objetoAComparar) 
			{
				Vertice<CualquierTipo> objetoACompararConvertidoEnVertice = (Vertice<CualquierTipo>) objetoAComparar;
				return valor.compareTo(objetoACompararConvertidoEnVertice.valor);
			}
			
			@Override
			public String toString()
			{
				StringBuilder stringDeImpresion = new StringBuilder();
				stringDeImpresion.append(System.lineSeparator() + "Hijos: " + mapDeHijosConSuPeso.toString() + System.lineSeparator() + "Padres: " + mapDePadresConSuPeso.toString() + System.lineSeparator());
				return stringDeImpresion.toString();
			}
		}
		
		public void conexionDirigida(CualquierTipo padre, CualquierTipo hijo, Integer peso)
		{
			if(grafoMap.get(padre).mapDeHijosConSuPeso.containsKey(hijo) && grafoMap.get(hijo).mapDePadresConSuPeso.containsKey(padre))
			{
				return;
			}
			Vertice<CualquierTipo> verticePadre = grafoMap.get(padre);
			if(!grafoMap.containsKey(padre))
			{
				verticePadre = new Vertice<>(padre);
				gradoDeEntradaMap.put(padre, 0);
				gradoDeSalidaMap.put(padre, 0);
				tamano = tamano + 1;
			}
			Vertice<CualquierTipo> verticeHijo = grafoMap.get(hijo);
			if(!grafoMap.containsKey(hijo))
			{
				verticeHijo = new Vertice<>(hijo);
				gradoDeEntradaMap.put(hijo, 0);
				gradoDeSalidaMap.put(hijo, 0);
				tamano = tamano + 1;
			}			
			verticePadre.mapDeHijosConSuPeso.put(verticeHijo.valor, peso);
			verticeHijo.mapDePadresConSuPeso.put(verticePadre.valor, peso);
			gradoDeSalidaMap.put(padre, gradoDeSalidaMap.get(padre) + 1);
			gradoDeEntradaMap.put(hijo, gradoDeEntradaMap.get(hijo) + 1);
			grafoMap.put(padre, verticePadre);
			grafoMap.put(hijo, verticeHijo);
		}
		
		public void introducirElemento(CualquierTipo elemento)
		{
			Vertice<CualquierTipo> verticeDelElemento = new Vertice<>(elemento);
			gradoDeEntradaMap.put(elemento, 0);
			gradoDeSalidaMap.put(elemento, 0);
			grafoMap.put(elemento, verticeDelElemento);
			tamano = tamano + 1;
		}
		
		public void desconectarElemento(CualquierTipo elemento)
		{
			if(!grafoMap.containsKey(elemento))
			{
				return;
			}
			Vertice<CualquierTipo> verticeAEliminar = grafoMap.get(elemento);
			CualquierTipo hijoADesconectar;
			CualquierTipo padreADesconectar;
			while(!verticeAEliminar.mapDeHijosConSuPeso.isEmpty())
			{
				hijoADesconectar = verticeAEliminar.mapDeHijosConSuPeso.firstKey();
				grafoMap.get(hijoADesconectar).mapDePadresConSuPeso.remove(verticeAEliminar.valor);
				gradoDeEntradaMap.put(hijoADesconectar, gradoDeEntradaMap.get(hijoADesconectar) - 1);
				verticeAEliminar.mapDeHijosConSuPeso.remove(verticeAEliminar.mapDeHijosConSuPeso.firstKey());
			}
			gradoDeSalidaMap.put(verticeAEliminar.valor, 0);
			while(!verticeAEliminar.mapDePadresConSuPeso.isEmpty())
			{
				padreADesconectar = verticeAEliminar.mapDePadresConSuPeso.firstKey();
				grafoMap.get(padreADesconectar).mapDeHijosConSuPeso.remove(verticeAEliminar.valor);
				gradoDeSalidaMap.put(padreADesconectar, gradoDeSalidaMap.get(padreADesconectar) - 1);
				verticeAEliminar.mapDePadresConSuPeso.remove(verticeAEliminar.mapDePadresConSuPeso.firstKey());
			}
			gradoDeEntradaMap.put(verticeAEliminar.valor, 0);
			tamano = tamano - 1;
		}
		
		public void conexionDirigida(CualquierTipo padre, CualquierTipo hijo)
		{
			conexionDirigida(padre, hijo, 1);
		}
		
		public void conexionNoDirigida(CualquierTipo padre, CualquierTipo hijo, Integer peso)
		{
			conexionDirigida(padre, hijo, peso);
			conexionDirigida(hijo, padre, peso);
		}
		
		public void conexionNoDirigida(CualquierTipo padre, CualquierTipo hijo)
		{
			conexionDirigida(padre, hijo, 1);
			conexionDirigida(hijo, padre, 1);
		}
		
		public boolean isEmpty()
		{
			if(tamano == 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
	}
	
	public void duplicarMapDeEntradas(TreeMap<Character, Integer> mapEnBlanco, TreeMap<Character, Integer> mapDeEntradasADuplicar)
	{
		if(mapDeEntradasADuplicar.isEmpty())
		{
			return;
		}
		char caracterLlave = mapDeEntradasADuplicar.firstEntry().getKey();
		int valorEntradaDelCaracterLlave = mapDeEntradasADuplicar.firstEntry().getValue();
		mapEnBlanco.put(caracterLlave, valorEntradaDelCaracterLlave);
		mapDeEntradasADuplicar.remove(mapDeEntradasADuplicar.firstKey());
		duplicarMapDeEntradas(mapEnBlanco, mapDeEntradasADuplicar);		
		mapDeEntradasADuplicar.put(caracterLlave, valorEntradaDelCaracterLlave);
	}
	
	public void duplicarmapDeHijosConSuPeso(TreeMap<Character, Integer> mapEnBlanco, TreeMap<Character, Integer> mapDeHijosConSuPesoADuplicar)
	{
		if(mapDeHijosConSuPesoADuplicar.isEmpty())
		{
			return;
		}
		char verticeLlave = mapDeHijosConSuPesoADuplicar.firstEntry().getKey();
		mapEnBlanco.put(verticeLlave, 1);
		mapDeHijosConSuPesoADuplicar.remove(mapDeHijosConSuPesoADuplicar.firstKey());
		duplicarmapDeHijosConSuPeso(mapEnBlanco, mapDeHijosConSuPesoADuplicar);		
		mapDeHijosConSuPesoADuplicar.put(verticeLlave, 1);
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));		
		//FileReader archivoLeido = new FileReader("A_2p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		ElMenorOrdenLexicografico problemaA = new ElMenorOrdenLexicografico();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			Grafo<Character> grafoConLasLetras = problemaA.new Grafo<>();
			int cantidadDeVariables = Integer.parseInt(cadenaDeEntrada.readLine());
			String stringConLasVariables = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLasVariables = stringConLasVariables.split(" ");
			for(int k = 0 ; k <= cantidadDeVariables - 1 ; k = k + 1)
			{
				grafoConLasLetras.introducirElemento(arregloDeCadenasConLasVariables[k].charAt(0));
			}
			String stringConLasRestricciones = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConLasRestricciones = stringConLasRestricciones.split(" ");
			for(int k = 0 ; k <= arregloDeCadenasConLasRestricciones.length - 1 ; k = k + 1)
			{
				char restriccion = arregloDeCadenasConLasRestricciones[k].charAt(1);
				switch(restriccion)
				{
				    case '<':
				    	grafoConLasLetras.conexionDirigida(arregloDeCadenasConLasRestricciones[k].charAt(0), arregloDeCadenasConLasRestricciones[k].charAt(2));
				    	break;
				    case '>':
				    	grafoConLasLetras.conexionDirigida(arregloDeCadenasConLasRestricciones[k].charAt(2), arregloDeCadenasConLasRestricciones[k].charAt(0));
				    	break;
				}
			}
			PriorityQueue<Character> colaDePrioridadDeLosCaracteresConEntradaCero = new PriorityQueue<>();
			TreeMap<Character, Integer> mapDeEntradasARecorrer = new TreeMap<>();
			problemaA.duplicarMapDeEntradas(mapDeEntradasARecorrer, grafoConLasLetras.gradoDeEntradaMap);
			for(int k = 0; k <= cantidadDeVariables - 1 ; k = k + 1)
			{
				if(mapDeEntradasARecorrer.get(arregloDeCadenasConLasVariables[k].charAt(0)) == 0)
				{
					colaDePrioridadDeLosCaracteresConEntradaCero.add(arregloDeCadenasConLasVariables[k].charAt(0));
				}
			}
			StringBuilder constructorDeCadenaConLaPosibleRespuesta = new StringBuilder();
			while(!colaDePrioridadDeLosCaracteresConEntradaCero.isEmpty())
			{
				char caracterParaImprimir = colaDePrioridadDeLosCaracteresConEntradaCero.remove();
				TreeMap<Character, Integer> mapDeHijosConSuPesoDelCaracterParaImprimir = new TreeMap<>();
				problemaA.duplicarmapDeHijosConSuPeso(mapDeHijosConSuPesoDelCaracterParaImprimir, grafoConLasLetras.grafoMap.get(caracterParaImprimir).mapDeHijosConSuPeso);
				constructorDeCadenaConLaPosibleRespuesta.append(caracterParaImprimir + " ");
				grafoConLasLetras.desconectarElemento(caracterParaImprimir);
				while(!mapDeHijosConSuPesoDelCaracterParaImprimir.isEmpty())
				{
					char posibleVerticeConEntradaCero = mapDeHijosConSuPesoDelCaracterParaImprimir.firstKey();
					if(grafoConLasLetras.gradoDeEntradaMap.get(posibleVerticeConEntradaCero)  == 0)
					{
						colaDePrioridadDeLosCaracteresConEntradaCero.add(posibleVerticeConEntradaCero);
					}
					mapDeHijosConSuPesoDelCaracterParaImprimir.remove(mapDeHijosConSuPesoDelCaracterParaImprimir.firstKey());
				}
			}
			if(grafoConLasLetras.isEmpty())
			{
				constructorDeCadenaConLaPosibleRespuesta.deleteCharAt(constructorDeCadenaConLaPosibleRespuesta.length() - 1);
				constructorDeCadenaDeLaRespuesta.append(constructorDeCadenaConLaPosibleRespuesta + System.lineSeparator());
			}
			else
			{
				constructorDeCadenaDeLaRespuesta.append("NO" + System.lineSeparator());
			}			
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();		
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;
import java.util.PriorityQueue;

public class LaRedDeComputadores 
{	
	public class Grafo<CualquierTipo extends java.lang.Comparable<? super CualquierTipo>>
	{
		int tamano;
		TreeMap<CualquierTipo,Vertice<CualquierTipo>> grafoMap;
		TreeMap<CualquierTipo, Integer> gradoDeEntradaMap;
		TreeMap<CualquierTipo, Integer> gradoDeSalidaMap;
		
		
		public Grafo()
		{
			tamano = 0;
			grafoMap = new TreeMap<>();
			gradoDeEntradaMap = new TreeMap<>();
			gradoDeSalidaMap = new TreeMap<>();
		}
		
		public class Vertice<CualquierTipo extends java.lang.Comparable<? super CualquierTipo>> implements java.lang.Comparable
		{
			CualquierTipo valor;
			TreeMap<CualquierTipo,Integer> mapDeHijosConSuPeso;
			TreeMap<CualquierTipo,Integer> mapDePadresConSuPeso;
			Integer distancia;
			boolean visitado;
			
			public Vertice(CualquierTipo valor)
			{
				this.valor =  valor;
				mapDeHijosConSuPeso = new TreeMap<>();
				mapDePadresConSuPeso = new TreeMap<>();
				distancia = Integer.MAX_VALUE;
				visitado = false;
			}

			@Override
			public int compareTo(Object objetoAComparar) 
			{
				Vertice<CualquierTipo> objetoACompararConvertidoEnInteger = (Vertice<CualquierTipo>) objetoAComparar;
				return distancia.compareTo(objetoACompararConvertidoEnInteger.distancia);
			}
			
			@Override
			public String toString()
			{
				StringBuilder stringDeImpresion = new StringBuilder();
				stringDeImpresion.append(System.lineSeparator() + "Valor: " + valor + System.lineSeparator() + "Distancia: " + distancia + System.lineSeparator() + "Visitado: " + visitado + System.lineSeparator() + "Hijos: " + mapDeHijosConSuPeso.toString() + System.lineSeparator() + "Padres: " + mapDePadresConSuPeso.toString() + System.lineSeparator());
				return stringDeImpresion.toString();
			}
		}
		
		public void conexionDirigida(CualquierTipo padre, CualquierTipo hijo, Integer peso)
		{
			if(grafoMap.get(padre).mapDeHijosConSuPeso.containsKey(hijo) && grafoMap.get(hijo).mapDePadresConSuPeso.containsKey(padre))
			{
				return;
			}
			Vertice<CualquierTipo> verticePadre = grafoMap.get(padre);
			if(!grafoMap.containsKey(padre))
			{
				verticePadre = new Vertice<>(padre);
				gradoDeEntradaMap.put(padre, 0);
				gradoDeSalidaMap.put(padre, 0);
				tamano = tamano + 1;
			}
			Vertice<CualquierTipo> verticeHijo = grafoMap.get(hijo);
			if(!grafoMap.containsKey(hijo))
			{
				verticeHijo = new Vertice<>(hijo);
				gradoDeEntradaMap.put(hijo, 0);
				gradoDeSalidaMap.put(hijo, 0);
				tamano = tamano + 1;
			}			
			verticePadre.mapDeHijosConSuPeso.put(verticeHijo.valor, peso);
			verticeHijo.mapDePadresConSuPeso.put(verticePadre.valor, peso);
			gradoDeSalidaMap.put(padre, gradoDeSalidaMap.get(padre) + 1);
			gradoDeEntradaMap.put(hijo, gradoDeEntradaMap.get(hijo) + 1);
			grafoMap.put(padre, verticePadre);
			grafoMap.put(hijo, verticeHijo);
		}
		
		public void introducirElemento(CualquierTipo elemento)
		{
			Vertice<CualquierTipo> verticeDelElemento = new Vertice<>(elemento);
			gradoDeEntradaMap.put(elemento, 0);
			gradoDeSalidaMap.put(elemento, 0);
			grafoMap.put(elemento, verticeDelElemento);
			tamano = tamano + 1;
		}
		
		public void desconectarElemento(CualquierTipo elemento)
		{
			if(!grafoMap.containsKey(elemento))
			{
				return;
			}
			Vertice<CualquierTipo> verticeAEliminar = grafoMap.get(elemento);
			CualquierTipo hijoADesconectar;
			CualquierTipo padreADesconectar;
			while(!verticeAEliminar.mapDeHijosConSuPeso.isEmpty())
			{
				hijoADesconectar = verticeAEliminar.mapDeHijosConSuPeso.firstKey();
				grafoMap.get(hijoADesconectar).mapDePadresConSuPeso.remove(verticeAEliminar.valor);
				gradoDeEntradaMap.put(hijoADesconectar, gradoDeEntradaMap.get(hijoADesconectar) - 1);
				verticeAEliminar.mapDeHijosConSuPeso.remove(verticeAEliminar.mapDeHijosConSuPeso.firstKey());
			}
			gradoDeSalidaMap.put(verticeAEliminar.valor, 0);
			while(!verticeAEliminar.mapDePadresConSuPeso.isEmpty())
			{
				padreADesconectar = verticeAEliminar.mapDePadresConSuPeso.firstKey();
				grafoMap.get(padreADesconectar).mapDeHijosConSuPeso.remove(verticeAEliminar.valor);
				gradoDeSalidaMap.put(padreADesconectar, gradoDeSalidaMap.get(padreADesconectar) - 1);
				verticeAEliminar.mapDePadresConSuPeso.remove(verticeAEliminar.mapDePadresConSuPeso.firstKey());
			}
			gradoDeEntradaMap.put(verticeAEliminar.valor, 0);
			tamano = tamano - 1;
		}
		
		public void conexionDirigida(CualquierTipo padre, CualquierTipo hijo)
		{
			conexionDirigida(padre, hijo, 1);
		}
		
		public void conexionNoDirigida(CualquierTipo padre, CualquierTipo hijo, Integer peso)
		{
			conexionDirigida(padre, hijo, peso);
			conexionDirigida(hijo, padre, peso);
		}
		
		public void conexionNoDirigida(CualquierTipo padre, CualquierTipo hijo)
		{
			conexionDirigida(padre, hijo, 1);
			conexionDirigida(hijo, padre, 1);
		}
		
		public boolean isEmpty()
		{
			if(tamano == 0)
			{
				return true;
			}else{
				     return false;
			     }
		}
	}
	
	public void duplicarmapDeHijosConSuPeso(TreeMap<Integer, Integer> mapEnBlanco, TreeMap<Integer, Integer> mapDeHijosConSuPesoADuplicar)
	{
		if(mapDeHijosConSuPesoADuplicar.isEmpty())
		{
			return;
		}
		int verticeLlave = mapDeHijosConSuPesoADuplicar.firstEntry().getKey();
		int pesoDelVerticeLlave = mapDeHijosConSuPesoADuplicar.firstEntry().getValue();
		mapEnBlanco.put(verticeLlave, pesoDelVerticeLlave);
		mapDeHijosConSuPesoADuplicar.remove(mapDeHijosConSuPesoADuplicar.firstKey());
		duplicarmapDeHijosConSuPeso(mapEnBlanco, mapDeHijosConSuPesoADuplicar);		
		mapDeHijosConSuPesoADuplicar.put(verticeLlave, pesoDelVerticeLlave);
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));		
		//FileReader archivoLeido = new FileReader("B_2p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		LaRedDeComputadores problemaB = new LaRedDeComputadores();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
		PriorityQueue<Grafo<Integer>.Vertice<Integer>> colaDePrioridadDeVerticesHijos = new PriorityQueue<>();
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			String stringConNMAB = cadenaDeEntrada.readLine();
			String[] arregloDeCadenasConNMAB = stringConNMAB.split(" ");
			int cantidadDeComputadores = Integer.parseInt(arregloDeCadenasConNMAB[0]);
			int cantidadDeConexiones = Integer.parseInt(arregloDeCadenasConNMAB[1]);
			int computadorDeOrigen = Integer.parseInt(arregloDeCadenasConNMAB[2]);
			int computadorDeDestino = Integer.parseInt(arregloDeCadenasConNMAB[3]);
			Grafo<Integer> grafoConLosComputadores = problemaB.new Grafo<>();
			for(int k = 0 ; k <= cantidadDeComputadores - 1 ; k = k + 1)
			{
				grafoConLosComputadores.introducirElemento(k);
			}
			for(int k = 1 ; k <= cantidadDeConexiones ; k = k + 1)
			{
				String stringConLaConexion = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLaConexion = stringConLaConexion.split(" ");
				grafoConLosComputadores.conexionNoDirigida(Integer.parseInt(arregloDeCadenasConLaConexion[0]), Integer.parseInt(arregloDeCadenasConLaConexion[1]), Integer.parseInt(arregloDeCadenasConLaConexion[2]));
			}
			grafoConLosComputadores.grafoMap.get(computadorDeOrigen).distancia = 0;
			colaDePrioridadDeVerticesHijos.add(grafoConLosComputadores.grafoMap.get(computadorDeOrigen));
			while(!colaDePrioridadDeVerticesHijos.isEmpty())
			{
				LaRedDeComputadores.Grafo<Integer>.Vertice<Integer> verticeOrigen = colaDePrioridadDeVerticesHijos.remove();
				TreeMap<Integer, Integer> mapDeHijosConSuPesoARecorrer = new TreeMap<>();
				verticeOrigen.visitado = true;
				problemaB.duplicarmapDeHijosConSuPeso(mapDeHijosConSuPesoARecorrer, verticeOrigen.mapDeHijosConSuPeso);
				while(!mapDeHijosConSuPesoARecorrer.isEmpty())
				{
					if(!grafoConLosComputadores.grafoMap.get(mapDeHijosConSuPesoARecorrer.firstKey()).visitado)
					{
						if(grafoConLosComputadores.grafoMap.get(mapDeHijosConSuPesoARecorrer.firstKey()).distancia > verticeOrigen.distancia + mapDeHijosConSuPesoARecorrer.firstEntry().getValue())
						{
							grafoConLosComputadores.grafoMap.get(mapDeHijosConSuPesoARecorrer.firstKey()).distancia = verticeOrigen.distancia + mapDeHijosConSuPesoARecorrer.firstEntry().getValue();
						}
						colaDePrioridadDeVerticesHijos.remove(grafoConLosComputadores.grafoMap.get(mapDeHijosConSuPesoARecorrer.firstKey()));
						colaDePrioridadDeVerticesHijos.add(grafoConLosComputadores.grafoMap.get(mapDeHijosConSuPesoARecorrer.firstKey()));
					}
					mapDeHijosConSuPesoARecorrer.remove(mapDeHijosConSuPesoARecorrer.firstKey());
				}				
			}
			if(grafoConLosComputadores.grafoMap.get(computadorDeDestino).distancia == Integer.MAX_VALUE)
			{
				constructorDeCadenaDeLaRespuesta.append("inalcanzable" + System.lineSeparator());
			}
			else
			{
				constructorDeCadenaDeLaRespuesta.append(grafoConLosComputadores.grafoMap.get(computadorDeDestino).distancia + System.lineSeparator());
			}
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.TreeMap;
import java.util.TreeSet;

public class LasZonasDeUnaMatriz 
{
	TreeSet<Integer> setConLasPosicionesNoVisitadasDeLaMatriz = new TreeSet<>();
	TreeSet<Integer> setConLasZonas = new TreeSet<>();
	
	public boolean recorrerZona(int posicion, int[][] matriz)
	{
		ArrayDeque<Integer> colaDelRecorrido = new ArrayDeque<>();
		setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion);
		int fila;
		int columna;
		if(posicion % matriz.length == 0)
		{
			fila = (posicion / matriz.length) - 1;
			columna = matriz.length - 1;
		}else{
			     fila = posicion / matriz.length;
			     columna = (posicion % matriz.length) - 1;
		     }
		if(setConLasZonas.contains(matriz[fila][columna]))
		{
			return true;
		}
		setConLasZonas.add(matriz[fila][columna]);
		if(columna != matriz.length - 1)
		{
			if(matriz[fila][columna + 1] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion + 1))
			{
				setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion + 1);
				colaDelRecorrido.add(posicion + 1);			
			}
		}
		if(fila != matriz.length - 1)
		{
			if(matriz[fila + 1][columna] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion + matriz.length))
			{
				setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion + matriz.length);
				colaDelRecorrido.add(posicion + matriz.length);				
			}
		}
		if(columna != 0)
		{
			if(matriz[fila][columna - 1] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion - 1))
			{
				setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion - 1);
				colaDelRecorrido.add(posicion - 1);				
			}
		}
		if(fila != 0)
		{
			if(matriz[fila - 1][columna] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion - matriz.length))
			{
				setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion - matriz.length);
				colaDelRecorrido.add(posicion - matriz.length);			
			}
		}
		while(!colaDelRecorrido.isEmpty())
		{
			posicion = colaDelRecorrido.remove();
			setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion);
			if(posicion % matriz.length == 0)
			{
				fila = (posicion / matriz.length) - 1;
				columna = matriz.length - 1;
			}else{
				     fila = posicion / matriz.length;
				     columna = (posicion % matriz.length) - 1;
			     }
			if(columna != matriz.length - 1)
			{
				if(matriz[fila][columna + 1] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion + 1))
				{
					setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion + 1);
					colaDelRecorrido.add(posicion + 1);			
				}
			}
			if(fila != matriz.length - 1)
			{
				if(matriz[fila + 1][columna] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion + matriz.length))
				{
					setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion + matriz.length);
					colaDelRecorrido.add(posicion + matriz.length);				
				}
			}
			if(columna != 0)
			{
				if(matriz[fila][columna - 1] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion - 1))
				{
					setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion - 1);
					colaDelRecorrido.add(posicion - 1);				
				}
			}
			if(fila != 0)
			{
				if(matriz[fila - 1][columna] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion - matriz.length))
				{
					setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion - matriz.length);
					colaDelRecorrido.add(posicion - matriz.length);			
				}
			}
		}
		return false;
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));		
		//FileReader archivoLeido = new FileReader("C_2p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		LasZonasDeUnaMatriz problemaC = new LasZonasDeUnaMatriz();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			int tamanoDeLaMatriz = Integer.parseInt(cadenaDeEntrada.readLine());
			int[][] matriz = new int[tamanoDeLaMatriz][tamanoDeLaMatriz];
			for(int fila = 0 ; fila <= tamanoDeLaMatriz - 1 ; fila = fila + 1)
			{
				String stringDeLaFila = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLosElementosDeLaFila = stringDeLaFila.split(" ");
				for(int columna = 0 ; columna <= tamanoDeLaMatriz - 1 ; columna = columna + 1)
				{
					matriz[fila][columna] = Integer.parseInt(arregloDeCadenasConLosElementosDeLaFila[columna]);
				}
			}
			int cantidadDePosicionesDeLaMatriz = tamanoDeLaMatriz*tamanoDeLaMatriz;			
			for(int k = 1 ; k <= cantidadDePosicionesDeLaMatriz ; k = k + 1)
			{
				problemaC.setConLasPosicionesNoVisitadasDeLaMatriz.add(k);
			}
			boolean repitioZona = false;
			while(!problemaC.setConLasPosicionesNoVisitadasDeLaMatriz.isEmpty() && !repitioZona)
			{
				repitioZona = problemaC.recorrerZona(problemaC.setConLasPosicionesNoVisitadasDeLaMatriz.first(), matriz);
			}
			if(repitioZona == true)
			{
				constructorDeCadenaDeLaRespuesta.append("NO" + System.lineSeparator());
			}else{
				     constructorDeCadenaDeLaRespuesta.append("YES" + System.lineSeparator());
			     }
			problemaC.setConLasPosicionesNoVisitadasDeLaMatriz = new TreeSet<>();
			problemaC.setConLasZonas = new TreeSet<>();
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.TreeMap;
import java.util.TreeSet;

public class LasZonasDeUnaMatrizModificado 
{
	TreeSet<Integer> setConLasPosicionesNoVisitadasDeLaMatriz = new TreeSet<>();
	TreeMap<Integer,TreeMap<Integer,Integer>> mapConLasZonas = new TreeMap<>();
	
	public void recorrerZona(int posicion, int[][] matriz)
	{
		ArrayDeque<Integer> colaDelRecorrido = new ArrayDeque<>();
		setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion);
		int fila;
		int columna;
		if(posicion % matriz.length == 0)
		{
			fila = (posicion / matriz.length) - 1;
			columna = matriz.length - 1;
		}else{
			     fila = posicion / matriz.length;
			     columna = (posicion % matriz.length) - 1;
		     }
		if(!mapConLasZonas.containsKey(matriz[fila][columna]))
		{
			TreeMap<Integer,Integer> mapDeSubZonas = new TreeMap<>();
			mapDeSubZonas.put(1, 0);
			mapConLasZonas.put(matriz[fila][columna], mapDeSubZonas);
		}else{
			     mapConLasZonas.get(matriz[fila][columna]).put(mapConLasZonas.get(matriz[fila][columna]).lastKey() + 1, 0);   
		     }		
		if(columna != matriz.length - 1)
		{
			if(matriz[fila][columna + 1] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion + 1))
			{
				setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion + 1);
				colaDelRecorrido.add(posicion + 1);			
			}
		}
		if(fila != matriz.length - 1)
		{
			if(matriz[fila + 1][columna] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion + matriz.length))
			{
				setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion + matriz.length);
				colaDelRecorrido.add(posicion + matriz.length);				
			}
		}
		if(columna != 0)
		{
			if(matriz[fila][columna - 1] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion - 1))
			{
				setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion - 1);
				colaDelRecorrido.add(posicion - 1);				
			}
		}
		if(fila != 0)
		{
			if(matriz[fila - 1][columna] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion - matriz.length))
			{
				setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion - matriz.length);
				colaDelRecorrido.add(posicion - matriz.length);			
			}
		}
		mapConLasZonas.get(matriz[fila][columna]).put(mapConLasZonas.get(matriz[fila][columna]).lastKey(), mapConLasZonas.get(matriz[fila][columna]).lastEntry().getValue() + 1);
		while(!colaDelRecorrido.isEmpty())
		{
			posicion = colaDelRecorrido.remove();
			setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion);
			if(posicion % matriz.length == 0)
			{
				fila = (posicion / matriz.length) - 1;
				columna = matriz.length - 1;
			}else{
				     fila = posicion / matriz.length;
				     columna = (posicion % matriz.length) - 1;
			     }
			if(columna != matriz.length - 1)
			{
				if(matriz[fila][columna + 1] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion + 1))
				{
					setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion + 1);
					colaDelRecorrido.add(posicion + 1);			
				}
			}
			if(fila != matriz.length - 1)
			{
				if(matriz[fila + 1][columna] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion + matriz.length))
				{
					setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion + matriz.length);
					colaDelRecorrido.add(posicion + matriz.length);				
				}
			}
			if(columna != 0)
			{
				if(matriz[fila][columna - 1] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion - 1))
				{
					setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion - 1);
					colaDelRecorrido.add(posicion - 1);				
				}
			}
			if(fila != 0)
			{
				if(matriz[fila - 1][columna] == matriz[fila][columna] && setConLasPosicionesNoVisitadasDeLaMatriz.contains(posicion - matriz.length))
				{
					setConLasPosicionesNoVisitadasDeLaMatriz.remove(posicion - matriz.length);
					colaDelRecorrido.add(posicion - matriz.length);			
				}
			}
			mapConLasZonas.get(matriz[fila][columna]).put(mapConLasZonas.get(matriz[fila][columna]).lastKey(), mapConLasZonas.get(matriz[fila][columna]).lastEntry().getValue() + 1);
		}
	}
	
	public static void main(String[] args) throws NumberFormatException, IOException 
	{
		BufferedReader cadenaDeEntrada  = new BufferedReader(new InputStreamReader(System.in));		
		//FileReader archivoLeido = new FileReader("C_2p.txt");
		//BufferedReader cadenaDeEntrada = new BufferedReader(archivoLeido);
		LasZonasDeUnaMatrizModificado problemaC = new LasZonasDeUnaMatrizModificado();
		StringBuilder constructorDeCadenaDeLaRespuesta = new StringBuilder();
		int casosDePrueba = Integer.parseInt(cadenaDeEntrada.readLine());
		for(int i = 1 ; i <= casosDePrueba ; i = i + 1)
		{
			constructorDeCadenaDeLaRespuesta.append("Caso #" + i + ":" + System.lineSeparator());
			int tamanoDeLaMatriz = Integer.parseInt(cadenaDeEntrada.readLine());
			int[][] matriz = new int[tamanoDeLaMatriz][tamanoDeLaMatriz];
			for(int fila = 0 ; fila <= tamanoDeLaMatriz - 1 ; fila = fila + 1)
			{
				String stringDeLaFila = cadenaDeEntrada.readLine();
				String[] arregloDeCadenasConLosElementosDeLaFila = stringDeLaFila.split(" ");
				for(int columna = 0 ; columna <= tamanoDeLaMatriz - 1 ; columna = columna + 1)
				{
					matriz[fila][columna] = Integer.parseInt(arregloDeCadenasConLosElementosDeLaFila[columna]);
				}
			}
			int cantidadDePosicionesDeLaMatriz = tamanoDeLaMatriz*tamanoDeLaMatriz;			
			for(int k = 1 ; k <= cantidadDePosicionesDeLaMatriz ; k = k + 1)
			{
				problemaC.setConLasPosicionesNoVisitadasDeLaMatriz.add(k);
			}
			while(!problemaC.setConLasPosicionesNoVisitadasDeLaMatriz.isEmpty())
			{
				problemaC.recorrerZona(problemaC.setConLasPosicionesNoVisitadasDeLaMatriz.first(), matriz);
			}
			TreeMap<Integer,Integer> subZonaAImprimir = new TreeMap<>();
			int respuesta = 0;
			while(!problemaC.mapConLasZonas.isEmpty())
			{
				//constructorDeCadenaDeLaRespuesta.append(problemaC.mapConLasZonas.firstKey() + System.lineSeparator());
				subZonaAImprimir = problemaC.mapConLasZonas.get(problemaC.mapConLasZonas.firstKey());
				while(!subZonaAImprimir.isEmpty())
				{
					respuesta = respuesta + 1;
					//constructorDeCadenaDeLaRespuesta.append(subZonaAImprimir.firstEntry() + System.lineSeparator());
					subZonaAImprimir.remove(subZonaAImprimir.firstKey());
				}
				problemaC.mapConLasZonas.remove(problemaC.mapConLasZonas.firstKey());
			}
			constructorDeCadenaDeLaRespuesta.append(respuesta + System.lineSeparator());
			problemaC.setConLasPosicionesNoVisitadasDeLaMatriz = new TreeSet<>();
			problemaC.mapConLasZonas = new TreeMap<>();
		}
		System.out.print(constructorDeCadenaDeLaRespuesta);
		cadenaDeEntrada.close();
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
