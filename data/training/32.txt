import java.util.Scanner;


public class problemA {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int N, c, max1=1,max2=1,min1=1,min2=1;
		Scanner in = new Scanner(System.in);
		//System.out.print("Hola Uber! Ingresa la cantidad de elementos contenidos en tu conjunto: ");
		N = in.nextInt();
		int[] set = new int[N];
		//System.out.print("Ingresa los elementos: ");
		for(c=0; c<N; c++) {
		    set[c] = in.nextInt();
		    if(set[c]>=0)
			{
				if(set[c]>=max1)
				{
					max2 = max1;
					max1 = set[c];
				}
				else if(set[c]<max1 && set[c]>=max2)
				{
					max2=set[c];
				}
			}
			else
			{
				if(set[c]<=min1)
				{
					min2 = min1;
					min1 = set[c];
				}
				else if(set[c]>min1 && set[c]<=min2)
				{
					min2=set[c];
				}
			}
		}
		System.out.println(Math.max((long) max1*max2,(long) min1*min2));
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


public class problemB {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		int T = -1, i,j,N,W=0;
		while(T<1 || T>10)
		{
			//System.out.println("Hola Alice. Hola Bob. Diganme cuantos casos hay que procesar: ");
			T = in.nextInt(); in.nextLine();
		}
		String[] S = new String[T];
		for(i=0; i<T; i++)
		{
			S[i] = "";
			while(S[i].length()>100000 || S[i].length()<1) // Probar isEmpty()
			{
				//System.out.println("Ingresen el caso "+(i+1)+": ");
				S[i]=in.nextLine();
			}
			N=S[i].length();
			for(j=0; j<N; j++)
			{
				if(S[i].charAt(j)=='W' && (((j-1>=0 && j-2>=0 && j+1<N && j+2<N) && (S[i].charAt(j+1)=='B'||S[i].charAt(j+2)=='B'||S[i].charAt(j-1)=='B'||S[i].charAt(j-2)=='B')) || ((j-1>=0&&S[i].charAt(j-1)=='B') || (j-2>=0&&S[i].charAt(j-2)=='B') || (j+1<=N-1&&S[i].charAt(j+1)=='B') || (j+2<=N-1&&S[i].charAt(j+2)=='B')) ))
				{
					W+=1;
				}
			}
			System.out.println(W);
			W=0;
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


public class problemC {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int T,N,c,d,e,L,w;
		String S;
		Scanner in = new Scanner(System.in);
		//System.out.println("T: ");
		T = in.nextInt();
		for (c=0; c<T; c++)
		{
			//System.out.println("N: ");
			N = in.nextInt();
			//System.out.println("S: ");
			S = in.next();
			w=N;
			for(d=0; d<N; d++)
			{
				L=S.charAt(d);
				e=1;
				while (d+e<N)
				{
					if(L <= (int) S.charAt(d+e))
					{
						L = (int) S.charAt(d+e);
						e+=1; w+=1;
					}
					else
					{
						e = N;
						break;
					}
				}
			}
			System.out.println(w);
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


public class problemD {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int T,N;
		int i,j,k;
		int[] V, H;
		int h,v;
		String[] R;
		Scanner in = new Scanner(System.in);
		T = in.nextInt();
		for(i=0;i<T;i++)
		{
			N = in.nextInt();
			R = new String[N];
			V = new int[N];
			H = new int[N];
			for(j=0;j<N;j++)
			{
				R[j] = in.next();
				for(k=0; k<N; k++)
				{
					if(R[j].charAt(k) == '#')
					{
						V[k]+=1;
						H[j]+=1;
					}
					if(k>0 && j==N-1)
					{
						V[k]+=V[k-1];
					}
				}
				if(j>0)
				{
					H[j]+=H[j-1];
				}
			}
			if(H[N-1]%2==0)
			{
				H[N-1]/=2;
				for(j=0;j<N-1;j++)
				{
					if(V[j]==H[N-1] || H[j]==H[N-1])
					{
						System.out.println("YES");
						break;
					}
					if(j==N-2 && V[j]!=H[N-1] && H[j]!=H[N-1])
					{
						System.out.println("NO");
					}
				}
			}
			else
			{
				System.out.println("NO");
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


public class problemaE {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int T,N;
		int[] V,H;
		String S;
		int i,j,k;
		int f,c;
		Scanner in = new Scanner(System.in);
		T = in.nextInt();
		for(i=0; i<T; i++)
		{
			N = in.nextInt();
			V = new int[N];
			H = new int[N];
			f=0; c=0;
			for(j=0; j<N; j++)
			{
				S = in.next();
				for(k=0; k<N; k++)
				{
					if(S.charAt(k)=='#')
					{
						V[k]+=1; H[j]+=1;
					}
					if(j == N-1 && k>0)
					{
						V[k]+=V[k-1];
					}
					//System.out.print(V[k]);
				}
				if(j>0)
				{
					H[j]+=H[j-1];
				}
				//System.out.println();
				//System.out.println(H[j]);
			}
			if(H[N-1]%2==0)
			{
				H[N-1]/=2;
				for(j=0; j<N-1; j++)
				{
					if(H[j]==H[N-1])
					{
						f+=1;
					}
					if(V[j]==H[N-1])
					{
						c+=1;
					}
				}
				System.out.println(f+" "+c);
			}
			else
			{
				System.out.println("0 0");
			}
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

class Fila
{
	class nodoFila
	{
		int ID;
		nodoFila next;
		nodoFila prev;
		public nodoFila(int id)
		{
			ID = id;
			next = null;
			prev = null;
		}
	}
	int size;
	nodoFila begin;
	nodoFila end;
	
	public Fila()
	{
		size = 0;
		begin = new nodoFila(-1);
		end = new nodoFila(-1);
		begin.next = end;
		begin.prev = null;
		end.prev = begin;
		end.next = null;
	}
	
	public void add(int id)
	{
		nodoFila tmp = new nodoFila(id);
		tmp.next = begin.next;
		begin.next.prev = tmp;
		begin.next = tmp;
		tmp.prev = begin;
		size++;
	}
	
	public int remove()
	{
		nodoFila tmp = end.prev;
		end.prev = tmp.prev;
		tmp.prev.next = end;
		size--;
		return tmp.ID;
	}
}

//BinarySearchTree class
//
//CONSTRUCTION: with no initializer
//
//******************PUBLIC OPERATIONS*********************
//void insert( x )       --> Insert x
//void remove( x )       --> Remove x
//boolean contains( x )  --> Return true if x is present
//Comparable findMin( )  --> Return smallest item
//Comparable findMax( )  --> Return largest item
//boolean isEmpty( )     --> Return true if empty; else false
//void makeEmpty( )      --> Remove all items
//void printTree( )      --> Print tree in sorted order
//******************ERRORS********************************
//Throws UnderflowException as appropriate

/**
* Implements an unbalanced binary search tree.
* Note that all "matching" is based on the compareTo method.
*/
class BinarySearchTree<AnyType extends Comparable<? super AnyType>>
{
 /**
  * Construct the tree.
  */
 public BinarySearchTree( )
 {
     root = null;
 }

 /**
  * Insert into the tree; duplicates are ignored.
  * @param x the item to insert.
  */
 public void insert( AnyType x )
 {
     root = insert( x, root );
 }

 /**
  * Remove from the tree. Nothing is done if x is not found.
  * @param x the item to remove.
  */
 public void remove( AnyType x )
 {
     root = remove( x, root );
 }

 /**
  * Find the smallest item in the tree.
  * @return smallest item or null if empty.
  */
 public AnyType findMin( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return findMin( root ).element;
 }

 /**
  * Find the largest item in the tree.
  * @return the largest item of null if empty.
  */
 public AnyType findMax( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return findMax( root ).element;
 }

 /**
  * Find an item in the tree.
  * @param x the item to search for.
  * @return true if not found.
  */
 public boolean contains( AnyType x )
 {
     return contains( x, root );
 }

 /**
  * Make the tree logically empty.
  */
 public void makeEmpty( )
 {
     root = null;
 }

 /**
  * Test if the tree is logically empty.
  * @return true if empty, false otherwise.
  */
 public boolean isEmpty( )
 {
     return root == null;
 }

 /**
  * Print the tree contents in sorted order.
  */
 public void printTree( )
 {
     if( isEmpty( ) )
         System.out.println( "Empty tree" );
     else
         printTree( root );
 }

 /**
  * Internal method to insert into a subtree.
  * @param x the item to insert.
  * @param t the node that roots the subtree.
  * @return the new root of the subtree.
  */
 private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
 {
     if( t == null )
         return new BinaryNode<>( x, null, null );
     
     int compareResult = x.compareTo( t.element );
         
     if( compareResult < 0 )
         t.left = insert( x, t.left );
     else if( compareResult > 0 )
         t.right = insert( x, t.right );
     else
         ;  // Duplicate; do nothing
     return t;
 }

 /**
  * Internal method to remove from a subtree.
  * @param x the item to remove.
  * @param t the node that roots the subtree.
  * @return the new root of the subtree.
  */
 private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
 {
     if( t == null )
         return t;   // Item not found; do nothing
         
     int compareResult = x.compareTo( t.element );
         
     if( compareResult < 0 )
         t.left = remove( x, t.left );
     else if( compareResult > 0 )
         t.right = remove( x, t.right );
     else if( t.left != null && t.right != null ) // Two children
     {
         t.element = findMin( t.right ).element;
         t.right = remove( t.element, t.right );
     }
     else
         t = ( t.left != null ) ? t.left : t.right;
     return t;
 }

 /**
  * Internal method to find the smallest item in a subtree.
  * @param t the node that roots the subtree.
  * @return node containing the smallest item.
  */
 private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
 {
     if( t == null )
         return null;
     else if( t.left == null )
         return t;
     return findMin( t.left );
 }

 /**
  * Internal method to find the largest item in a subtree.
  * @param t the node that roots the subtree.
  * @return node containing the largest item.
  */
 private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
 {
     if( t != null )
         while( t.right != null )
             t = t.right;

     return t;
 }

 /**
  * Internal method to find an item in a subtree.
  * @param x is item to search for.
  * @param t the node that roots the subtree.
  * @return node containing the matched item.
  */
 private boolean contains( AnyType x, BinaryNode<AnyType> t )
 {
     if( t == null )
         return false;
         
     int compareResult = x.compareTo( t.element );
         
     if( compareResult < 0 )
         return contains( x, t.left );
     else if( compareResult > 0 )
         return contains( x, t.right );
     else
         return true;    // Match
 }

 /**
  * Internal method to print a subtree in sorted order.
  * @param t the node that roots the subtree.
  */
 private void printTree( BinaryNode<AnyType> t )
 {
     if( t != null )
     {
         printTree( t.left );
         System.out.println( t.element );
         printTree( t.right );
     }
 }

 /**
  * Internal method to compute height of a subtree.
  * @param t the node that roots the subtree.
  */
 private int height( BinaryNode<AnyType> t )
 {
     if( t == null )
         return -1;
     else
         return 1 + Math.max( height( t.left ), height( t.right ) );    
 }
 
 // Basic node stored in unbalanced binary search trees
 private static class BinaryNode<AnyType>
 {
         // Constructors
     BinaryNode( AnyType theElement )
     {
         this( theElement, null, null );
     }

     BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
     {
         element  = theElement;
         left     = lt;
         right    = rt;
     }

     AnyType element;            // The data in the node
     BinaryNode<AnyType> left;   // Left child
     BinaryNode<AnyType> right;  // Right child
 }


   /** The tree root. */
 private BinaryNode<AnyType> root;
}

public class ProblemaA {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		int T,Q;
		int i,j;
		String str;
		String[] splited;
		Fila fila;
		BinarySearchTree<Integer> bst;
		T = Integer.parseInt(in.nextLine());
		for(i=0; i<T; i++)
		{
			System.out.println("Caso #"+(i+1)+":");
			fila = new Fila();
			bst = new BinarySearchTree<>();
			Q = Integer.parseInt(in.nextLine());
			for(j=0; j<Q; j++)
			{
				str = in.nextLine();
				splited = str.split(" ");
				if(splited[0].equals("agregar")) {
					fila.add(Integer.parseInt(splited[1]));
				} else if(splited[0].equals("atender")) {
					bst.insert(fila.remove());
				} else { // existe
					if(bst.contains(Integer.parseInt(splited[1])))
						System.out.println("SI");
					else
						System.out.println("NO");
						
				}
			}
		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

class Fila
{
	class nodoFila
	{
		int ID;
		nodoFila next;
		nodoFila prev;
		public nodoFila(int id)
		{
			ID = id;
			next = null;
			prev = null;
		}
	}
	int size;
	nodoFila begin;
	nodoFila end;
	
	public Fila()
	{
		size = 0;
		begin = new nodoFila(-1);
		end = new nodoFila(-1);
		begin.next = end;
		begin.prev = null;
		end.prev = begin;
		end.next = null;
	}
	
	public void add(int id)
	{
		nodoFila tmp = new nodoFila(id);
		tmp.next = begin.next;
		begin.next.prev = tmp;
		begin.next = tmp;
		tmp.prev = begin;
		size++;
	}
	
	public int remove()
	{
		nodoFila tmp = end.prev;
		end.prev = tmp.prev;
		tmp.prev.next = end;
		size--;
		return tmp.ID;
	}
}

//AvlTree class
//
//CONSTRUCTION: with no initializer
//
//******************PUBLIC OPERATIONS*********************
//void insert( x )       --> Insert x
//void remove( x )       --> Remove x (unimplemented)
//boolean contains( x )  --> Return true if x is present
//boolean remove( x )    --> Return true if x was present
//Comparable findMin( )  --> Return smallest item
//Comparable findMax( )  --> Return largest item
//boolean isEmpty( )     --> Return true if empty; else false
//void makeEmpty( )      --> Remove all items
//void printTree( )      --> Print tree in sorted order
//******************ERRORS********************************
//Throws UnderflowException as appropriate

/**
* Implements an AVL tree.
* Note that all "matching" is based on the compareTo method.
*/
class AvlTree<AnyType extends Comparable<? super AnyType>>
{
 /**
  * Construct the tree.
  */
 public AvlTree( )
 {
     root = null;
 }

 /**
  * Insert into the tree; duplicates are ignored.
  * @param x the item to insert.
  */
 public void insert( AnyType x )
 {
     root = insert( x, root );
 }

 /**
  * Remove from the tree. Nothing is done if x is not found.
  * @param x the item to remove.
  */
 public void remove( AnyType x )
 {
     root = remove( x, root );
 }

    
 /**
  * Internal method to remove from a subtree.
  * @param x the item to remove.
  * @param t the node that roots the subtree.
  * @return the new root of the subtree.
  */
 private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t )
 {
     if( t == null )
         return t;   // Item not found; do nothing
         
     int compareResult = x.compareTo( t.element );
         
     if( compareResult < 0 )
         t.left = remove( x, t.left );
     else if( compareResult > 0 )
         t.right = remove( x, t.right );
     else if( t.left != null && t.right != null ) // Two children
     {
         t.element = findMin( t.right ).element;
         t.right = remove( t.element, t.right );
     }
     else
         t = ( t.left != null ) ? t.left : t.right;
     return balance( t );
 }
 
 /**
  * Find the smallest item in the tree.
  * @return smallest item or null if empty.
  */
 public AnyType findMin( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return findMin( root ).element;
 }

 /**
  * Find the largest item in the tree.
  * @return the largest item of null if empty.
  */
 public AnyType findMax( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return findMax( root ).element;
 }

 /**
  * Find an item in the tree.
  * @param x the item to search for.
  * @return true if x is found.
  */
 public boolean contains( AnyType x )
 {
     return contains( x, root );
 }

 /**
  * Make the tree logically empty.
  */
 public void makeEmpty( )
 {
     root = null;
 }

 /**
  * Test if the tree is logically empty.
  * @return true if empty, false otherwise.
  */
 public boolean isEmpty( )
 {
     return root == null;
 }

 /**
  * Print the tree contents in sorted order.
  */
 public void printTree( )
 {
     if( isEmpty( ) )
         System.out.println( "Empty tree" );
     else
         printTree( root );
 }

 private static final int ALLOWED_IMBALANCE = 1;
 
 // Assume t is either balanced or within one of being balanced
 private AvlNode<AnyType> balance( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;
     
     if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
         if( height( t.left.left ) >= height( t.left.right ) )
             t = rotateWithLeftChild( t );
         else
             t = doubleWithLeftChild( t );
     else
     if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
         if( height( t.right.right ) >= height( t.right.left ) )
             t = rotateWithRightChild( t );
         else
             t = doubleWithRightChild( t );

     t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
     return t;
 }
 
 public void checkBalance( )
 {
     checkBalance( root );
 }
 
 private int checkBalance( AvlNode<AnyType> t )
 {
     if( t == null )
         return -1;
     
     if( t != null )
     {
         int hl = checkBalance( t.left );
         int hr = checkBalance( t.right );
         if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                 height( t.left ) != hl || height( t.right ) != hr )
             System.out.println( "OOPS!!" );
     }
     
     return height( t );
 }
 
 
 /**
  * Internal method to insert into a subtree.
  * @param x the item to insert.
  * @param t the node that roots the subtree.
  * @return the new root of the subtree.
  */
 private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t )
 {
     if( t == null )
         return new AvlNode<>( x, null, null );
     
     int compareResult = x.compareTo( t.element );
     
     if( compareResult < 0 )
         t.left = insert( x, t.left );
     else if( compareResult > 0 )
         t.right = insert( x, t.right );
     else
         ;  // Duplicate; do nothing
     return balance( t );
 }

 /**
  * Internal method to find the smallest item in a subtree.
  * @param t the node that roots the tree.
  * @return node containing the smallest item.
  */
 private AvlNode<AnyType> findMin( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;

     while( t.left != null )
         t = t.left;
     return t;
 }

 /**
  * Internal method to find the largest item in a subtree.
  * @param t the node that roots the tree.
  * @return node containing the largest item.
  */
 private AvlNode<AnyType> findMax( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;

     while( t.right != null )
         t = t.right;
     return t;
 }

 /**
  * Internal method to find an item in a subtree.
  * @param x is item to search for.
  * @param t the node that roots the tree.
  * @return true if x is found in subtree.
  */
 private boolean contains( AnyType x, AvlNode<AnyType> t )
 {
     while( t != null )
     {
         int compareResult = x.compareTo( t.element );
         
         if( compareResult < 0 )
             t = t.left;
         else if( compareResult > 0 )
             t = t.right;
         else
             return true;    // Match
     }

     return false;   // No match
 }

 /**
  * Internal method to print a subtree in sorted order.
  * @param t the node that roots the tree.
  */
 private void printTree( AvlNode<AnyType> t )
 {
     if( t != null )
     {
         printTree( t.left );
         System.out.println( t.element );
         printTree( t.right );
     }
 }

 /**
  * Return the height of node t, or -1, if null.
  */
 private int height( AvlNode<AnyType> t )
 {
     return t == null ? -1 : t.height;
 }

 /**
  * Rotate binary tree node with left child.
  * For AVL trees, this is a single rotation for case 1.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 )
 {
     AvlNode<AnyType> k1 = k2.left;
     k2.left = k1.right;
     k1.right = k2;
     k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
     k1.height = Math.max( height( k1.left ), k2.height ) + 1;
     return k1;
 }

 /**
  * Rotate binary tree node with right child.
  * For AVL trees, this is a single rotation for case 4.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 )
 {
     AvlNode<AnyType> k2 = k1.right;
     k1.right = k2.left;
     k2.left = k1;
     k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
     k2.height = Math.max( height( k2.right ), k1.height ) + 1;
     return k2;
 }

 /**
  * Double rotate binary tree node: first left child
  * with its right child; then node k3 with new left child.
  * For AVL trees, this is a double rotation for case 2.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 )
 {
     k3.left = rotateWithRightChild( k3.left );
     return rotateWithLeftChild( k3 );
 }

 /**
  * Double rotate binary tree node: first right child
  * with its left child; then node k1 with new right child.
  * For AVL trees, this is a double rotation for case 3.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 )
 {
     k1.right = rotateWithLeftChild( k1.right );
     return rotateWithRightChild( k1 );
 }

 private static class AvlNode<AnyType>
 {
         // Constructors
     AvlNode( AnyType theElement )
     {
         this( theElement, null, null );
     }

     AvlNode( AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
     {
         element  = theElement;
         left     = lt;
         right    = rt;
         height   = 0;
     }

     AnyType           element;      // The data in the node
     AvlNode<AnyType>  left;         // Left child
     AvlNode<AnyType>  right;        // Right child
     int               height;       // Height
 }

   /** The tree root. */
 private AvlNode<AnyType> root;

}

public class ProblemaA {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		int T,Q;
		int i,j;
		String str;
		String[] splited;
		Fila fila;
		AvlTree<Integer> bst;
		T = Integer.parseInt(in.nextLine());
		for(i=0; i<T; i++)
		{
			System.out.println("Caso #"+(i+1)+":");
			fila = new Fila();
			bst = new AvlTree<>();
			Q = Integer.parseInt(in.nextLine());
			for(j=0; j<Q; j++)
			{
				str = in.nextLine();
				splited = str.split(" ");
				if(splited[0].equals("agregar")) {
					fila.add(Integer.parseInt(splited[1]));
				} else if(splited[0].equals("atender")) {
					bst.insert(fila.remove());
				} else { // existe
					if(bst.contains(Integer.parseInt(splited[1])))
						System.out.println("SI");
					else
						System.out.println("NO");
						
				}
			}
		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

class nodoFila
{
	int ID;
	int pos;
	nodoFila next;
	nodoFila prev;
	public nodoFila(int id,int pos)
	{
		ID = id;
		next = null;
		prev = null;
	}
}

class Fila
{
	int size;
	nodoFila begin;
	nodoFila end;
	
	public Fila()
	{
		size = 0;
		begin = new nodoFila(-1,-1);
		end = new nodoFila(-1,-1);
		begin.next = end;
		begin.prev = null;
		end.prev = begin;
		end.next = null;
	}
	
	public void add(int id,int pos)
	{
		nodoFila tmp = new nodoFila(id,pos);
		tmp.next = begin.next;
		begin.next.prev = tmp;
		begin.next = tmp;
		tmp.prev = begin;
		size++;
	}
	
	public nodoFila remove()
	{
		nodoFila tmp = end.prev;
		end.prev = tmp.prev;
		tmp.prev.next = end;
		size--;
		return tmp;
	}
}

//AvlTree class
//
//CONSTRUCTION: with no initializer
//
//******************PUBLIC OPERATIONS*********************
//void insert( x )       --> Insert x
//void remove( x )       --> Remove x (unimplemented)
//boolean contains( x )  --> Return true if x is present
//boolean remove( x )    --> Return true if x was present
//Comparable findMin( )  --> Return smallest item
//Comparable findMax( )  --> Return largest item
//boolean isEmpty( )     --> Return true if empty; else false
//void makeEmpty( )      --> Remove all items
//void printTree( )      --> Print tree in sorted order
//******************ERRORS********************************
//Throws UnderflowException as appropriate

/**
* Implements an AVL tree.
* Note that all "matching" is based on the compareTo method.
*/
class AvlTree<AnyType extends Comparable<? super AnyType>>
{
 /**
  * Construct the tree.
  */
 public AvlTree( )
 {
     root = null;
 }

 /**
  * Insert into the tree; duplicates are ignored.
  * @param x the item to insert.
  */
 public void insert( AnyType x , int pos)
 {
     root = insert( x, pos,root );
 }

 /**
  * Remove from the tree. Nothing is done if x is not found.
  * @param x the item to remove.
  */
 public void remove( AnyType x )
 {
     root = remove( x, root );
 }

    
 /**
  * Internal method to remove from a subtree.
  * @param x the item to remove.
  * @param t the node that roots the subtree.
  * @return the new root of the subtree.
  */
 private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t )
 {
     if( t == null )
         return t;   // Item not found; do nothing
         
     int compareResult = x.compareTo( t.element );
         
     if( compareResult < 0 )
         t.left = remove( x, t.left );
     else if( compareResult > 0 )
         t.right = remove( x, t.right );
     else if( t.left != null && t.right != null ) // Two children
     {
         t.element = findMin( t.right ).element;
         t.right = remove( t.element, t.right );
     }
     else
         t = ( t.left != null ) ? t.left : t.right;
     return balance( t );
 }
 
 /**
  * Find the smallest item in the tree.
  * @return smallest item or null if empty.
  */
 public AnyType findMin( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return findMin( root ).element;
 }

 /**
  * Find the largest item in the tree.
  * @return the largest item of null if empty.
  */
 public AnyType findMax( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return findMax( root ).element;
 }

 /**
  * Find an item in the tree.
  * @param x the item to search for.
  * @return true if x is found.
  */
 public boolean contains( AnyType x )
 {
     return contains( x, root );
 }
 
 public int contain( AnyType x )
 {
     return contain( x, root );
 }

 /**
  * Make the tree logically empty.
  */
 public void makeEmpty( )
 {
     root = null;
 }

 /**
  * Test if the tree is logically empty.
  * @return true if empty, false otherwise.
  */
 public boolean isEmpty( )
 {
     return root == null;
 }

 /**
  * Print the tree contents in sorted order.
  */
 public void printTree( )
 {
     if( isEmpty( ) )
         System.out.println( "Empty tree" );
     else
         printTree( root );
 }

 private static final int ALLOWED_IMBALANCE = 1;
 
 // Assume t is either balanced or within one of being balanced
 private AvlNode<AnyType> balance( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;
     
     if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
         if( height( t.left.left ) >= height( t.left.right ) )
             t = rotateWithLeftChild( t );
         else
             t = doubleWithLeftChild( t );
     else
     if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
         if( height( t.right.right ) >= height( t.right.left ) )
             t = rotateWithRightChild( t );
         else
             t = doubleWithRightChild( t );

     t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
     return t;
 }
 
 public void checkBalance( )
 {
     checkBalance( root );
 }
 
 private int checkBalance( AvlNode<AnyType> t )
 {
     if( t == null )
         return -1;
     
     if( t != null )
     {
         int hl = checkBalance( t.left );
         int hr = checkBalance( t.right );
         if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                 height( t.left ) != hl || height( t.right ) != hr )
             System.out.println( "OOPS!!" );
     }
     
     return height( t );
 }
 
 
 /**
  * Internal method to insert into a subtree.
  * @param x the item to insert.
  * @param t the node that roots the subtree.
  * @return the new root of the subtree.
  */
 private AvlNode<AnyType> insert( AnyType x, int pos, AvlNode<AnyType> t )
 {
     if( t == null )
         return new AvlNode<>( x, pos,null, null );
     
     int compareResult = x.compareTo( t.element );
     
     if( compareResult < 0 )
         t.left = insert( x, pos,t.left );
     else if( compareResult > 0 )
         t.right = insert( x, pos,t.right );
     else
         ;  // Duplicate; do nothing
     return balance( t );
 }

 /**
  * Internal method to find the smallest item in a subtree.
  * @param t the node that roots the tree.
  * @return node containing the smallest item.
  */
 private AvlNode<AnyType> findMin( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;

     while( t.left != null )
         t = t.left;
     return t;
 }

 /**
  * Internal method to find the largest item in a subtree.
  * @param t the node that roots the tree.
  * @return node containing the largest item.
  */
 private AvlNode<AnyType> findMax( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;

     while( t.right != null )
         t = t.right;
     return t;
 }

 /**
  * Internal method to find an item in a subtree.
  * @param x is item to search for.
  * @param t the node that roots the tree.
  * @return true if x is found in subtree.
  */
 private boolean contains( AnyType x, AvlNode<AnyType> t )
 {
     while( t != null )
     {
         int compareResult = x.compareTo( t.element );
         
         if( compareResult < 0 )
             t = t.left;
         else if( compareResult > 0 )
             t = t.right;
         else
             return true;    // Match
     }

     return false;   // No match
 }
 
 private int contain( AnyType x, AvlNode<AnyType> t )
 {
     while( t != null )
     {
         int compareResult = x.compareTo( t.element );
         
         if( compareResult < 0 )
             t = t.left;
         else if( compareResult > 0 )
             t = t.right;
         else
             return t.pos;    // Match
     }

     return -1;   // No match
 }

 /**
  * Internal method to print a subtree in sorted order.
  * @param t the node that roots the tree.
  */
 private void printTree( AvlNode<AnyType> t )
 {
     if( t != null )
     {
         printTree( t.left );
         System.out.println( t.element );
         printTree( t.right );
     }
 }

 /**
  * Return the height of node t, or -1, if null.
  */
 private int height( AvlNode<AnyType> t )
 {
     return t == null ? -1 : t.height;
 }

 /**
  * Rotate binary tree node with left child.
  * For AVL trees, this is a single rotation for case 1.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 )
 {
     AvlNode<AnyType> k1 = k2.left;
     k2.left = k1.right;
     k1.right = k2;
     k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
     k1.height = Math.max( height( k1.left ), k2.height ) + 1;
     return k1;
 }

 /**
  * Rotate binary tree node with right child.
  * For AVL trees, this is a single rotation for case 4.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 )
 {
     AvlNode<AnyType> k2 = k1.right;
     k1.right = k2.left;
     k2.left = k1;
     k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
     k2.height = Math.max( height( k2.right ), k1.height ) + 1;
     return k2;
 }

 /**
  * Double rotate binary tree node: first left child
  * with its right child; then node k3 with new left child.
  * For AVL trees, this is a double rotation for case 2.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 )
 {
     k3.left = rotateWithRightChild( k3.left );
     return rotateWithLeftChild( k3 );
 }

 /**
  * Double rotate binary tree node: first right child
  * with its left child; then node k1 with new right child.
  * For AVL trees, this is a double rotation for case 3.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 )
 {
     k1.right = rotateWithLeftChild( k1.right );
     return rotateWithRightChild( k1 );
 }

 private static class AvlNode<AnyType>
 {
         // Constructors
     AvlNode( AnyType theElement, int pos )
     {
         this( theElement, pos, null, null );
     }

     AvlNode( AnyType theElement, int position, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
     {
         element  = theElement;
         left     = lt;
         right    = rt;
         height   = 0;
         pos = position;
     }

     AnyType           element;      // The data in the node
     AvlNode<AnyType>  left;         // Left child
     AvlNode<AnyType>  right;        // Right child
     int               height;       // Height
     int pos;
 }

   /** The tree root. */
 private AvlNode<AnyType> root;

}

//BinaryHeap class
//
//CONSTRUCTION: with optional capacity (that defaults to 100)
//            or an array containing initial items
//
//******************PUBLIC OPERATIONS*********************
//void insert( x )       --> Insert x
//Comparable deleteMin( )--> Return and remove smallest item
//Comparable findMin( )  --> Return smallest item
//boolean isEmpty( )     --> Return true if empty; else false
//void makeEmpty( )      --> Remove all items
//******************ERRORS********************************
//Throws UnderflowException as appropriate

/**
* Implements a binary heap.
* Note that all "matching" is based on the compareTo method.
* @param <AnyType>
*/
class BinaryHeap<AnyType extends Comparable<? super AnyType>>
{
 /**
  * Construct the binary heap.
  */
 public BinaryHeap( )
 {
     this( DEFAULT_CAPACITY );
 }

 /**
  * Construct the binary heap.
  * @param capacity the capacity of the binary heap.
  */
 public BinaryHeap( int capacity )
 {
     currentSize = 0;
     array = (AnyType[]) new Comparable[ capacity + 1 ];
 }
 
 /**
  * Construct the binary heap given an array of items.
  * @param items
  */
 public BinaryHeap( AnyType [ ] items )
 {
         currentSize = items.length;
         array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

         int i = 1;
         for( AnyType item : items )
             array[ i++ ] = item;
         buildHeap( );
 }

 /**
  * Insert into the priority queue, maintaining heap order.
  * Duplicates are allowed.
  * @param x the item to insert.
  */
 public void insert( AnyType x )
 {
     if( currentSize == array.length - 1 )
         enlargeArray( array.length * 2 + 1 );

         // Percolate up
     int hole = ++currentSize;
     for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
         array[ hole ] = array[ hole / 2 ];
     array[ hole ] = x;
 }


 private void enlargeArray( int newSize )
 {
         AnyType [] old = array;
         array = (AnyType []) new Comparable[ newSize ];
         for( int i = 0; i < old.length; i++ )
             array[ i ] = old[ i ];        
 }
 
 /**
  * Find the smallest item in the priority queue.
  * @return the smallest item, or throw an UnderflowException if empty.
  * @throws java.lang.Exception
  */
 public AnyType findMin( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return array[ 1 ];
 }

 /**
  * Remove the smallest item from the priority queue.
  * @return the smallest item, or throw an UnderflowException if empty.
  * @throws java.lang.Exception
  */
 public AnyType deleteMin( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );

     AnyType minItem = findMin( );
     array[ 1 ] = array[ currentSize-- ];
     percolateDown( 1 );

     return minItem;
 }

 /**
  * Establish heap order property from an arbitrary
  * arrangement of items. Runs in linear time.
  */
 private void buildHeap( )
 {
     for( int i = currentSize / 2; i > 0; i-- )
         percolateDown( i );
 }

 /**
  * Test if the priority queue is logically empty.
  * @return true if empty, false otherwise.
  */
 public boolean isEmpty( )
 {
     return currentSize == 0;
 }

 /**
  * Make the priority queue logically empty.
  */
 public void makeEmpty( )
 {
     currentSize = 0;
 }

 private static final int DEFAULT_CAPACITY = 10;

 private int currentSize;      // Number of elements in heap
 private AnyType [ ] array; // The heap array

 /**
  * Internal method to percolate down in the heap.
  * @param hole the index at which the percolate begins.
  */
 private void percolateDown( int hole )
 {
     int child;
     AnyType tmp = array[ hole ];

     for( ; hole * 2 <= currentSize; hole = child )
     {
         child = hole * 2;
         if( child != currentSize &&
                 array[ child + 1 ].compareTo( array[ child ] ) < 0 )
             child++;
         if( array[ child ].compareTo( tmp ) < 0 )
             array[ hole ] = array[ child ];
         else
             break;
     }
     array[ hole ] = tmp;
 }

}


public class ProblemaA {

	public static void main(String[] args) throws NumberFormatException, Exception {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		int T,Q,N;
		int i,j;
		String str;
		String[] splited;
		Fila fila;
		AvlTree<Integer> bst;
		BinaryHeap<Integer> positions;
		T = Integer.parseInt(in.nextLine());
		for(i=0; i<T; i++)
		{
			System.out.println("Caso #"+(i+1)+":");
			fila = new Fila();
			bst = new AvlTree<>();
			positions = new BinaryHeap<>();
			str = in.nextLine();
			splited = str.split(" ");
			Q = Integer.parseInt(splited[0]);
			N = Integer.parseInt(splited[1]);
			for(j=0; j<N; j++)
			{
				positions.insert(j);
			}
			for(j=0; j<Q; j++)
			{
				str = in.nextLine();
				splited = str.split(" ");
				if(splited[0].equals("agregar")) {
					fila.add(Integer.parseInt(splited[1]),positions.deleteMin());
				} else if(splited[0].equals("atender")) {
					nodoFila tmp = fila.remove();
					bst.insert(tmp.ID,tmp.pos);
				} else if(splited[0].equals("salir")) {
					int pos = bst.contain(Integer.parseInt(splited[1]));
					bst.remove(Integer.parseInt(splited[1]));
					positions.insert(pos);
				} else { // existe
					if(bst.contains(Integer.parseInt(splited[1])))
						System.out.println("SI " + bst.contain(Integer.parseInt(splited[1])));
					else
						System.out.println("NO");
						
				}
			}
		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

class nodoFila
{
	int ID;
	int pos;
	nodoFila next;
	nodoFila prev;
	public nodoFila(int id,int pos)
	{
		ID = id;
		this.pos = pos;
		next = null;
		prev = null;
	}
}

class Fila
{
	int size;
	nodoFila begin;
	nodoFila end;
	
	public Fila()
	{
		size = 0;
		begin = new nodoFila(-1,-1);
		end = new nodoFila(-1,-1);
		begin.next = end;
		begin.prev = null;
		end.prev = begin;
		end.next = null;
	}
	
	public void add(int id,int pos)
	{
		nodoFila tmp = new nodoFila(id,pos);
		tmp.next = begin.next;
		begin.next.prev = tmp;
		begin.next = tmp;
		tmp.prev = begin;
		size++;
	}
	
	public nodoFila remove()
	{
		nodoFila tmp = end.prev;
		end.prev = tmp.prev;
		tmp.prev.next = end;
		size--;
		return tmp;
	}
}

//AvlTree class
//
//CONSTRUCTION: with no initializer
//
//******************PUBLIC OPERATIONS*********************
//void insert( x )       --> Insert x
//void remove( x )       --> Remove x (unimplemented)
//boolean contains( x )  --> Return true if x is present
//boolean remove( x )    --> Return true if x was present
//Comparable findMin( )  --> Return smallest item
//Comparable findMax( )  --> Return largest item
//boolean isEmpty( )     --> Return true if empty; else false
//void makeEmpty( )      --> Remove all items
//void printTree( )      --> Print tree in sorted order
//******************ERRORS********************************
//Throws UnderflowException as appropriate

/**
* Implements an AVL tree.
* Note that all "matching" is based on the compareTo method.
*/
class AvlTree<AnyType extends Comparable<? super AnyType>>
{
 /**
  * Construct the tree.
  */
 public AvlTree( )
 {
     root = null;
 }

 /**
  * Insert into the tree; duplicates are ignored.
  * @param x the item to insert.
  */
 public void insert( AnyType x , int pos)
 {
     root = insert( x, pos,root );
 }

 /**
  * Remove from the tree. Nothing is done if x is not found.
  * @param x the item to remove.
  */
 public void remove( AnyType x )
 {
     root = remove( x, root );
 }

    
 /**
  * Internal method to remove from a subtree.
  * @param x the item to remove.
  * @param t the node that roots the subtree.
  * @return the new root of the subtree.
  */
 private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t )
 {
     if( t == null )
         return t;   // Item not found; do nothing
         
     int compareResult = x.compareTo( t.element );
         
     if( compareResult < 0 )
         t.left = remove( x, t.left );
     else if( compareResult > 0 )
         t.right = remove( x, t.right );
     else if( t.left != null && t.right != null ) // Two children
     {
         t.element = findMin( t.right ).element;
         t.right = remove( t.element, t.right );
     }
     else
         t = ( t.left != null ) ? t.left : t.right;
     return balance( t );
 }
 
 /**
  * Find the smallest item in the tree.
  * @return smallest item or null if empty.
  */
 public AnyType findMin( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return findMin( root ).element;
 }

 /**
  * Find the largest item in the tree.
  * @return the largest item of null if empty.
  */
 public AnyType findMax( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return findMax( root ).element;
 }

 /**
  * Find an item in the tree.
  * @param x the item to search for.
  * @return true if x is found.
  */
 public boolean contains( AnyType x )
 {
     return contains( x, root );
 }
 
 public int contain( AnyType x )
 {
     return contain( x, root );
 }

 /**
  * Make the tree logically empty.
  */
 public void makeEmpty( )
 {
     root = null;
 }

 /**
  * Test if the tree is logically empty.
  * @return true if empty, false otherwise.
  */
 public boolean isEmpty( )
 {
     return root == null;
 }

 /**
  * Print the tree contents in sorted order.
  */
 public void printTree( )
 {
     if( isEmpty( ) )
         System.out.println( "Empty tree" );
     else
         printTree( root );
 }

 private static final int ALLOWED_IMBALANCE = 1;
 
 // Assume t is either balanced or within one of being balanced
 private AvlNode<AnyType> balance( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;
     
     if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
         if( height( t.left.left ) >= height( t.left.right ) )
             t = rotateWithLeftChild( t );
         else
             t = doubleWithLeftChild( t );
     else
     if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
         if( height( t.right.right ) >= height( t.right.left ) )
             t = rotateWithRightChild( t );
         else
             t = doubleWithRightChild( t );

     t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
     return t;
 }
 
 public void checkBalance( )
 {
     checkBalance( root );
 }
 
 private int checkBalance( AvlNode<AnyType> t )
 {
     if( t == null )
         return -1;
     
     if( t != null )
     {
         int hl = checkBalance( t.left );
         int hr = checkBalance( t.right );
         if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                 height( t.left ) != hl || height( t.right ) != hr )
             System.out.println( "OOPS!!" );
     }
     
     return height( t );
 }
 
 
 /**
  * Internal method to insert into a subtree.
  * @param x the item to insert.
  * @param t the node that roots the subtree.
  * @return the new root of the subtree.
  */
 private AvlNode<AnyType> insert( AnyType x, int pos, AvlNode<AnyType> t )
 {
     if( t == null )
         return new AvlNode<>( x, pos,null, null );
     
     int compareResult = x.compareTo( t.element );
     
     if( compareResult < 0 )
         t.left = insert( x, pos,t.left );
     else if( compareResult > 0 )
         t.right = insert( x, pos,t.right );
     else
         ;  // Duplicate; do nothing
     return balance( t );
 }

 /**
  * Internal method to find the smallest item in a subtree.
  * @param t the node that roots the tree.
  * @return node containing the smallest item.
  */
 private AvlNode<AnyType> findMin( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;

     while( t.left != null )
         t = t.left;
     return t;
 }

 /**
  * Internal method to find the largest item in a subtree.
  * @param t the node that roots the tree.
  * @return node containing the largest item.
  */
 private AvlNode<AnyType> findMax( AvlNode<AnyType> t )
 {
     if( t == null )
         return t;

     while( t.right != null )
         t = t.right;
     return t;
 }

 /**
  * Internal method to find an item in a subtree.
  * @param x is item to search for.
  * @param t the node that roots the tree.
  * @return true if x is found in subtree.
  */
 private boolean contains( AnyType x, AvlNode<AnyType> t )
 {
     while( t != null )
     {
         int compareResult = x.compareTo( t.element );
         
         if( compareResult < 0 )
             t = t.left;
         else if( compareResult > 0 )
             t = t.right;
         else
             return true;    // Match
     }

     return false;   // No match
 }
 
 private int contain( AnyType x, AvlNode<AnyType> t )
 {
     while( t != null )
     {
         int compareResult = x.compareTo( t.element );
         
         if( compareResult < 0 )
             t = t.left;
         else if( compareResult > 0 )
             t = t.right;
         else
             return t.pos;    // Match
     }

     return -1;   // No match
 }

 /**
  * Internal method to print a subtree in sorted order.
  * @param t the node that roots the tree.
  */
 private void printTree( AvlNode<AnyType> t )
 {
     if( t != null )
     {
         printTree( t.left );
         System.out.println( t.element );
         printTree( t.right );
     }
 }

 /**
  * Return the height of node t, or -1, if null.
  */
 private int height( AvlNode<AnyType> t )
 {
     return t == null ? -1 : t.height;
 }

 /**
  * Rotate binary tree node with left child.
  * For AVL trees, this is a single rotation for case 1.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 )
 {
     AvlNode<AnyType> k1 = k2.left;
     k2.left = k1.right;
     k1.right = k2;
     k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
     k1.height = Math.max( height( k1.left ), k2.height ) + 1;
     return k1;
 }

 /**
  * Rotate binary tree node with right child.
  * For AVL trees, this is a single rotation for case 4.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 )
 {
     AvlNode<AnyType> k2 = k1.right;
     k1.right = k2.left;
     k2.left = k1;
     k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
     k2.height = Math.max( height( k2.right ), k1.height ) + 1;
     return k2;
 }

 /**
  * Double rotate binary tree node: first left child
  * with its right child; then node k3 with new left child.
  * For AVL trees, this is a double rotation for case 2.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 )
 {
     k3.left = rotateWithRightChild( k3.left );
     return rotateWithLeftChild( k3 );
 }

 /**
  * Double rotate binary tree node: first right child
  * with its left child; then node k1 with new right child.
  * For AVL trees, this is a double rotation for case 3.
  * Update heights, then return new root.
  */
 private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 )
 {
     k1.right = rotateWithLeftChild( k1.right );
     return rotateWithRightChild( k1 );
 }

 private static class AvlNode<AnyType>
 {
         // Constructors
     AvlNode( AnyType theElement, int pos )
     {
         this( theElement, pos, null, null );
     }

     AvlNode( AnyType theElement, int position, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
     {
         element  = theElement;
         left     = lt;
         right    = rt;
         height   = 0;
         pos = position;
     }

     AnyType           element;      // The data in the node
     AvlNode<AnyType>  left;         // Left child
     AvlNode<AnyType>  right;        // Right child
     int               height;       // Height
     int pos;
 }

   /** The tree root. */
 private AvlNode<AnyType> root;

}

//BinaryHeap class
//
//CONSTRUCTION: with optional capacity (that defaults to 100)
//            or an array containing initial items
//
//******************PUBLIC OPERATIONS*********************
//void insert( x )       --> Insert x
//Comparable deleteMin( )--> Return and remove smallest item
//Comparable findMin( )  --> Return smallest item
//boolean isEmpty( )     --> Return true if empty; else false
//void makeEmpty( )      --> Remove all items
//******************ERRORS********************************
//Throws UnderflowException as appropriate

/**
* Implements a binary heap.
* Note that all "matching" is based on the compareTo method.
* @param <AnyType>
*/
class BinaryHeap<AnyType extends Comparable<? super AnyType>>
{
 /**
  * Construct the binary heap.
  */
 public BinaryHeap( )
 {
     this( DEFAULT_CAPACITY );
 }

 /**
  * Construct the binary heap.
  * @param capacity the capacity of the binary heap.
  */
 public BinaryHeap( int capacity )
 {
     currentSize = 0;
     array = (AnyType[]) new Comparable[ capacity + 1 ];
 }
 
 /**
  * Construct the binary heap given an array of items.
  * @param items
  */
 public BinaryHeap( AnyType [ ] items )
 {
         currentSize = items.length;
         array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

         int i = 1;
         for( AnyType item : items )
             array[ i++ ] = item;
         buildHeap( );
 }

 /**
  * Insert into the priority queue, maintaining heap order.
  * Duplicates are allowed.
  * @param x the item to insert.
  */
 public void insert( AnyType x )
 {
     if( currentSize == array.length - 1 )
         enlargeArray( array.length * 2 + 1 );

         // Percolate up
     int hole = ++currentSize;
     for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
         array[ hole ] = array[ hole / 2 ];
     array[ hole ] = x;
 }


 private void enlargeArray( int newSize )
 {
         AnyType [] old = array;
         array = (AnyType []) new Comparable[ newSize ];
         for( int i = 0; i < old.length; i++ )
             array[ i ] = old[ i ];        
 }
 
 /**
  * Find the smallest item in the priority queue.
  * @return the smallest item, or throw an UnderflowException if empty.
  * @throws java.lang.Exception
  */
 public AnyType findMin( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );
     return array[ 1 ];
 }

 /**
  * Remove the smallest item from the priority queue.
  * @return the smallest item, or throw an UnderflowException if empty.
  * @throws java.lang.Exception
  */
 public AnyType deleteMin( ) throws Exception
 {
     if( isEmpty( ) )
         throw new Exception( );

     AnyType minItem = findMin( );
     array[ 1 ] = array[ currentSize-- ];
     percolateDown( 1 );

     return minItem;
 }

 /**
  * Establish heap order property from an arbitrary
  * arrangement of items. Runs in linear time.
  */
 private void buildHeap( )
 {
     for( int i = currentSize / 2; i > 0; i-- )
         percolateDown( i );
 }

 /**
  * Test if the priority queue is logically empty.
  * @return true if empty, false otherwise.
  */
 public boolean isEmpty( )
 {
     return currentSize == 0;
 }

 /**
  * Make the priority queue logically empty.
  */
 public void makeEmpty( )
 {
     currentSize = 0;
 }

 private static final int DEFAULT_CAPACITY = 10;

 private int currentSize;      // Number of elements in heap
 private AnyType [ ] array; // The heap array

 /**
  * Internal method to percolate down in the heap.
  * @param hole the index at which the percolate begins.
  */
 private void percolateDown( int hole )
 {
     int child;
     AnyType tmp = array[ hole ];

     for( ; hole * 2 <= currentSize; hole = child )
     {
         child = hole * 2;
         if( child != currentSize &&
                 array[ child + 1 ].compareTo( array[ child ] ) < 0 )
             child++;
         if( array[ child ].compareTo( tmp ) < 0 )
             array[ hole ] = array[ child ];
         else
             break;
     }
     array[ hole ] = tmp;
 }

}


public class ProblemaA {

	public static void main(String[] args) throws NumberFormatException, Exception {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		int T,Q,N;
		int i,j;
		String str;
		String[] splited;
		Fila fila;
		AvlTree<Integer> bst;
		BinaryHeap<Integer> positions;
		T = Integer.parseInt(in.nextLine());
		for(i=0; i<T; i++)
		{
			System.out.println("Caso #"+(i+1)+":");
			fila = new Fila();
			bst = new AvlTree<>();
			positions = new BinaryHeap<>();
			str = in.nextLine();
			splited = str.split(" ");
			Q = Integer.parseInt(splited[0]);
			N = Integer.parseInt(splited[1]);
			for(j=0; j<N; j++)
			{
				positions.insert(j);
			}
			for(j=0; j<Q; j++)
			{
				str = in.nextLine();
				splited = str.split(" ");
				if(splited[0].equals("agregar")) {
					fila.add(Integer.parseInt(splited[1]),positions.deleteMin());
				} else if(splited[0].equals("atender")) {
					nodoFila tmp = fila.remove();
					bst.insert(tmp.ID,tmp.pos);
				} else if(splited[0].equals("salir")) {
					int pos = bst.contain(Integer.parseInt(splited[1]));
					bst.remove(Integer.parseInt(splited[1]));
					positions.insert(pos);
				} else { // existe
					if(bst.contains(Integer.parseInt(splited[1])))
						System.out.println("SI " + bst.contain(Integer.parseInt(splited[1])));
					else
						System.out.println("NO"); 
						
				}
			}
		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

class VertexB {
	final private String id;
	final private String name;
	public VertexB(String id, String name) {this.id = id; this.name = name;}
	public String getId() {return id;}
	public String getName() {return name;}
	@Override
	public int hashCode() {
	  final int prime = 31;
	  int result = 1;
	  result = prime * result + ((id == null) ? 0 : id.hashCode());
	  return result;
	}
	@Override
	public boolean equals(Object obj) {
	  if (this == obj)
	    return true;
	  if (obj == null)
	    return false;
	  if (getClass() != obj.getClass())
	    return false;
	  VertexB other = (VertexB) obj;
	  if (id == null) {
	    if (other.id != null)
	      return false;
	  } else if (!id.equals(other.id))
	    return false;
	  return true;
	}
	@Override
	public String toString() {return name;}
}

class EdgeB  {
	private final String id; 
	private final VertexB source;
	private final VertexB destination;
	private final int weight; 
	public EdgeB(String id, VertexB source, VertexB destination, int weight) {this.id = id; this.source = source; this.destination = destination; this.weight = weight;}
	public String getId() {return id;}
	public VertexB getDestination() {return destination;}
	public VertexB getSource() {return source;}
	public int getWeight() {return weight;}
	@Override
	public String toString() {return source + " " + destination;}
}

class GraphB
{
	private final List<VertexB> Vertexes;
	private final List<EdgeB> Edges;
	public GraphB(List<VertexB> Vertexes, List<EdgeB> Edges) {this.Vertexes = Vertexes; this.Edges = Edges;}
	public List<VertexB> getVertexes() {return Vertexes;}
	public List<EdgeB> getEdges() {return Edges;}
}

class DijkstraAlgorithm {
	private final List<VertexB> nodes;
	private final List<EdgeB> edges;
	private Set<VertexB> settledNodes;
	private Set<VertexB> unSettledNodes;
	private Map<VertexB, VertexB> predecessors;
	private Map<VertexB, Integer> distance;
	public DijkstraAlgorithm(GraphB graph) {
	  // create a copy of the array so that we can operate on this array
	  this.nodes = new ArrayList<VertexB>(graph.getVertexes());
	  this.edges = new ArrayList<EdgeB>(graph.getEdges());
	}
	public void execute(VertexB source) {
	  settledNodes = new HashSet<VertexB>();
	  unSettledNodes = new HashSet<VertexB>();
	  distance = new HashMap<VertexB, Integer>();
	  predecessors = new HashMap<VertexB, VertexB>();
	  distance.put(source, 0);
	  unSettledNodes.add(source);
	  while (unSettledNodes.size() > 0) {
	    VertexB node = getMinimum(unSettledNodes);
	    settledNodes.add(node);
	    unSettledNodes.remove(node);
	    findMinimalDistances(node);
	  }
	  System.out.println(settledNodes.toString());
	}
	
	private void findMinimalDistances(VertexB node) {
	  List<VertexB> adjacentNodes = getNeighbors(node);
	  for (VertexB target : adjacentNodes) {
	    if (getShortestDistance(target) > getShortestDistance(node) + getDistance(node, target)) {
	      distance.put(target, getShortestDistance(node) + getDistance(node, target));
	      predecessors.put(target, node);
	      unSettledNodes.add(target);
	    }
	  }
	}
	private int getDistance(VertexB node, VertexB target) {
	  for (EdgeB Edge : edges) {
	    if (Edge.getSource().equals(node)
	        && Edge.getDestination().equals(target)) {
	      return Edge.getWeight();
	    }
	  }
	  throw new RuntimeException("Should not happen");
	}
	
	private List<VertexB> getNeighbors(VertexB node) {
	  List<VertexB> neighbors = new ArrayList<VertexB>();
	  for (EdgeB Edge : edges) {
	    if (Edge.getSource().equals(node)
	        && !isSettled(Edge.getDestination())) {
	      neighbors.add(Edge.getDestination());
	    }
	  }
	  return neighbors;
	}
	
	private VertexB getMinimum(Set<VertexB> Vertexes) {
	  VertexB minimum = null;
	  for (VertexB VertexB : Vertexes) {
	    if (minimum == null) {
	      minimum = VertexB;
	    } else {
	      if (getShortestDistance(VertexB) < getShortestDistance(minimum)) {
	        minimum = VertexB;
	      }
	    }
	  }
	  return minimum;
	}
	
	private boolean isSettled(VertexB VertexB) {
	  return settledNodes.contains(VertexB);
	}
	
	private int getShortestDistance(VertexB destination) {
	  Integer d = distance.get(destination);
	  if (d == null) {
	    return Integer.MAX_VALUE;
	  } else {
	    return d;
	  }
	}
	
	/*
	 * This method returns the path from the source to the selected target and
	 * NULL if no path exists
	 */
	public LinkedList<VertexB> getPath(VertexB target) {
	  LinkedList<VertexB> path = new LinkedList<VertexB>();
	  VertexB step = target;
	  // check if a path exists
		if (predecessors.get(step) == null) {
		  return null;
		}
		path.add(step);
		while (predecessors.get(step) != null) {
		  step = predecessors.get(step);
		  path.add(step);
		}
		// Put it into the correct order
		    Collections.reverse(path);
		    return path;
	}
} 

public class ProblemaB {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int T,N,M,A,B;
		int i,j;
		String str;
		String[] splited;
		List<VertexB> nodes;
		List<EdgeB> edges; 
		GraphB graph;
		LinkedList<VertexB> path;
		DijkstraAlgorithm dijkstra;
		Scanner in = new Scanner(System.in);
		T = Integer.parseInt(in.nextLine());
		for(i=0; i<T; i++)
		{
			System.out.println(" Caso #"+(i+1)+":");
			nodes = new ArrayList<VertexB>();
		    edges = new ArrayList<EdgeB>();
			str = in.nextLine();
			splited = str.split(" ");
			N = Integer.parseInt(splited[0]); // Numero computadores
			M = Integer.parseInt(splited[1]); // Numero conexiones
			A = Integer.parseInt(splited[2]); // Inicio
			B = Integer.parseInt(splited[3]); // Destino
			for(j=0; j<N; j++)
				nodes.add(new VertexB(""+j,""+j));
			for(j=0; j<M; j++)
			{
				str = in.nextLine();
				splited = str.split(" ");
				edges.add(new EdgeB(""+j,nodes.get(Integer.parseInt(splited[0])),nodes.get(Integer.parseInt(splited[1])),Integer.parseInt(splited[2])));
			}
			graph = new GraphB(nodes,edges);
			dijkstra = new DijkstraAlgorithm(graph);
			dijkstra.execute(nodes.get(A));
			path = dijkstra.getPath(nodes.get(B));
			if(path == null)
				System.out.println("Inalcanzable");
			else
				for (VertexB vertex : path)
				      System.out.println(vertex);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;  

class TopologicalSort {
	
	static void dfs(List<Character>[] graph, Map<Character,Integer> vals, boolean[] used, List<Integer> res, int u) {
	  used[u] = true;
	  for (int v=0; v<graph[u].size(); v++)
	    if (!used[vals.get(graph[u].get(v))])
	      dfs(graph, vals, used, res, vals.get(graph[u].get(v)));
	  
	  res.add(u);
	}
	
	public static List<Integer> topologicalSort(List<Character>[] graph,Map<Character,Integer> vals) {
	  int n = graph.length;
	  boolean[] used = new boolean[n];
	  List<Integer>[] res = new ArrayList[n];
	  List<Integer> res0 = new ArrayList<>();
	  for (int i = 0; i < n; i++) 
	  {
	    if (!used[i])
	    {
	      res[i] = new ArrayList<>();
	      dfs(graph, vals, used, res[i], i);
		  Collections.reverse(res[i]);
		  res0.addAll(res[i]);
	    }
	  }
	  return res0;
	}
}

public class ProblemaA {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int T,N;
		int i,j,k;
		String str;
		String[] splited;
		Map<Character,Integer> vals;
		Map<Integer,Character> lets;
		boolean[][] matrix;
		boolean simple;
		Scanner in = new Scanner(System.in);
		T = Integer.parseInt(in.nextLine());
		for(i=0; i<T; i++)
		{
			System.out.println("Caso #"+(i+1)+":");
			N = Integer.parseInt(in.nextLine());
			List<Character>[] g = new List[N];
			matrix = new boolean[N][N];
			for (j = 0; j<N; j++)
			    g[j] = new ArrayList<>();
			str = in.nextLine();
			splited = str.split(" ");
			vals = new HashMap<Character,Integer>();
			lets = new HashMap<Integer,Character>();
			for(j=0; j<N; j++) {
				vals.put(splited[j].charAt(0),j);
				lets.put(j,splited[j].charAt(0));
			}
			str = in.nextLine();
			splited = str.split(" ");	
			for(j=0; j<splited.length; j++)
			{
				int cero = vals.get(splited[j].charAt(0));
				int dos = vals.get(splited[j].charAt(2));
				if(splited[j].charAt(1) == '<') {
					g[cero].add(splited[j].charAt(2));
					matrix[cero][dos] = true;
				}
				else {
					g[dos].add(splited[j].charAt(0));
					matrix[dos][cero] = true;
				}
			}
			simple = true;
			for(j=1; j<N; j++)
				for(k=0; k<j; k++)
					if(matrix[k][j] && matrix[j][k])
						simple = false;
			
			if(!simple) {
				System.out.println("NO");
			} else {
				for(j=0; j<N; j++) {
					List<Integer> ns = new ArrayList<>();
					List<Character> ls = new ArrayList<>();
					for(k=0; k<g[j].size(); k++)
					{
						ns.add(vals.get(g[j].get(k)));
					}
					Collections.sort(ns);
					for(k=0; k<g[j].size(); k++)
					{
						ls.add(lets.get(ns.get(k)));
					}
					g[j] = ls;
					Collections.reverse(g[j]);
				}
				List<Integer> res = TopologicalSort.topologicalSort(g,vals);
			    for(j=0; j<res.size(); j++)
			    	System.out.print(lets.get(res.get(j)) + " ");
			    System.out.println();
			}
			
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;

class Vertex implements Comparable<Vertex>
{
    public final String name;
    public List<Edge> adjacencies;
    public double minDistance = Double.POSITIVE_INFINITY;
    public Vertex previous;
    public Vertex(String argName) { name = argName; }
    public String toString() { return name; }
    public int compareTo(Vertex other)
    {
        return Double.compare(minDistance, other.minDistance);
    }

}


class Edge
{
    public final Vertex target;
    public final double weight;
    public Edge(Vertex argTarget, double argWeight)
    { target = argTarget; weight = argWeight; }
}

public class Dijkstra
{
    public static void computePaths(Vertex source)
    {
        source.minDistance = 0.;
        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();
        vertexQueue.add(source);

	    while (!vertexQueue.isEmpty()) {
	        Vertex u = vertexQueue.poll();
	
            // Visit each edge exiting u
            for (Edge e : u.adjacencies)
            {
                Vertex v = e.target;
                double weight = e.weight;
                double distanceThroughU = u.minDistance + weight;
		        if (distanceThroughU < v.minDistance) {
		            vertexQueue.remove(v);
		            v.minDistance = distanceThroughU ;
		            v.previous = u;
		            vertexQueue.add(v);
		        }
            }
        }
    }

    public static List<Vertex> getShortestPathTo(Vertex target)
    {
        List<Vertex> path = new ArrayList<Vertex>();
        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)
            path.add(vertex);

        Collections.reverse(path);
        return path;
    }

    public static void main(String[] args)
    {
    	int T,N,M,A,B;
		int i,j;
		String str;
		String[] splited;
		List<Vertex> nodes;
		
		Scanner in = new Scanner(System.in);
		T = Integer.parseInt(in.nextLine());
		for(i=0; i<T; i++)
		{
			System.out.println("Caso #"+(i+1)+":");
			nodes = new ArrayList<Vertex>();
			str = in.nextLine();
			splited = str.split(" ");
			N = Integer.parseInt(splited[0]); // Numero computadores
			M = Integer.parseInt(splited[1]); // Numero conexiones
			A = Integer.parseInt(splited[2]); // Inicio
			B = Integer.parseInt(splited[3]); // Destino
			for(j=0; j<N; j++){
				nodes.add(new Vertex(""+j));
				nodes.get(j).adjacencies = new ArrayList<Edge>();
			}
			for(j=0; j<M; j++)
			{
				str = in.nextLine();
				splited = str.split(" ");
				nodes.get(Integer.parseInt(splited[0])).adjacencies.add(nodes.get(Integer.parseInt(splited[0])).adjacencies.size(),new Edge(nodes.get(Integer.parseInt(splited[1])),Double.parseDouble(splited[2])));
				nodes.get(Integer.parseInt(splited[1])).adjacencies.add(nodes.get(Integer.parseInt(splited[1])).adjacencies.size(),new Edge(nodes.get(Integer.parseInt(splited[0])),Double.parseDouble(splited[2])));
			}
			computePaths(nodes.get(A));
			double p = (int) nodes.get(B).minDistance;
			if(p >= 2147483647)
				System.out.println("Inalcanzable");
			else
				System.out.println((int) p);
		}
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;

class Vertex implements Comparable<Vertex>
{
    public final String name;
    public List<Edge> adjacencies;
    public double minDistance = Double.POSITIVE_INFINITY;
    public Vertex previous;
    public Vertex(String argName) { name = argName; }
    public String toString() { return name; }
    public int compareTo(Vertex other)
    {
        return Double.compare(minDistance, other.minDistance);
    }

}


class Edge
{
    public final Vertex target;
    public final double weight;
    public Edge(Vertex argTarget, double argWeight)
    { target = argTarget; weight = argWeight; }
}

public class Dijkstra
{
    public static void computePaths(Vertex source)
    {
        source.minDistance = 0.;
        PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>();
        vertexQueue.add(source);

	    while (!vertexQueue.isEmpty()) {
	        Vertex u = vertexQueue.poll();
	
            // Visit each edge exiting u
            for (Edge e : u.adjacencies)
            {
                Vertex v = e.target;
                double weight = e.weight;
                double distanceThroughU = u.minDistance + weight;
		        if (distanceThroughU < v.minDistance) {
		            vertexQueue.remove(v);
		            v.minDistance = distanceThroughU ;
		            v.previous = u;
		            vertexQueue.add(v);
		        }
            }
        }
    }

    public static List<Vertex> getShortestPathTo(Vertex target)
    {
        List<Vertex> path = new ArrayList<Vertex>();
        for (Vertex vertex = target; vertex != null; vertex = vertex.previous)
            path.add(vertex);

        Collections.reverse(path);
        return path;
    }

    public static void main(String[] args)
    {
    	int T,N,M,A,B;
		int i,j;
		String str;
		String[] splited;
		List<Vertex> nodes;
		
		Scanner in = new Scanner(System.in);
		T = Integer.parseInt(in.nextLine());
		for(i=0; i<T; i++)
		{
			System.out.println("Caso #"+(i+1)+":");
			nodes = new ArrayList<Vertex>();
			str = in.nextLine();
			splited = str.split(" ");
			N = Integer.parseInt(splited[0]); // Numero computadores
			M = Integer.parseInt(splited[1]); // Numero conexiones
			A = Integer.parseInt(splited[2]); // Inicio
			B = Integer.parseInt(splited[3]); // Destino
			for(j=0; j<N; j++){
				nodes.add(new Vertex(""+j));
				nodes.get(j).adjacencies = new ArrayList<Edge>();
			}
			for(j=0; j<M; j++)
			{
				str = in.nextLine();
				splited = str.split(" ");
				nodes.get(Integer.parseInt(splited[0])).adjacencies.add(nodes.get(Integer.parseInt(splited[0])).adjacencies.size(),new Edge(nodes.get(Integer.parseInt(splited[1])),Double.parseDouble(splited[2])));
				nodes.get(Integer.parseInt(splited[1])).adjacencies.add(nodes.get(Integer.parseInt(splited[1])).adjacencies.size(),new Edge(nodes.get(Integer.parseInt(splited[0])),Double.parseDouble(splited[2])));
			}
			computePaths(nodes.get(A));
			double p = (int) nodes.get(B).minDistance;
			if(p >= 2147483647)
				System.out.println("inalcanzable");
			else
				System.out.println((int) p);
		}
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
