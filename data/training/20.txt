package problemaa;
import java.util.ArrayList;
import java.util.Scanner;
public class ProblemaA {
   public static void main(String[] args) {
                Scanner scan;
                int numberOfCases, caseBounds, indexList, nOfEquals, nOfGreatersThan, nOfLessesThan, iterator, currentNumber, auxIterator;
                ArrayList<Integer> scanning = new ArrayList <Integer>();
                ArrayList<Integer> inputs = new ArrayList <Integer>();
                ArrayList<Integer[]> results = new ArrayList<Integer[]>();
                        scan = new Scanner(System.in);
                         numberOfCases = scan.nextInt();
                   int h = 0;
                   int result = 1;
                    do{
                        results.removeAll(results);
                   scan = new Scanner(System.in);
                   caseBounds = scan.nextInt();;
                   scanning.removeAll(scanning);
                   inputs.removeAll(inputs);
                   scan = new Scanner(System.in);
                   for (int i = 0; i<caseBounds; i++){
                          currentNumber = scan.nextInt();
                          inputs.add(currentNumber);
                    }
                    for (int i = 0; i<caseBounds; i++){
                         scanning.add(inputs.get(i));
                    }
                     nOfEquals =0;
                   nOfGreatersThan = 0;
                   nOfLessesThan = 0;
                    auxIterator = 1;
                        for (int numbersWithin: scanning){
                           iterator = 1;
                            for(int sizeArray = 0; sizeArray < scanning.size(); sizeArray++){
                           if (iterator != (1*auxIterator)){
                           if (numbersWithin > scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " > " + scanning.get(sizeArray));
                           nOfGreatersThan++;
                           }
                           else if (numbersWithin < scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " < " + scanning.get(sizeArray));
                            nOfLessesThan++;
                           }
                           else if (numbersWithin == scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " = " + scanning.get(sizeArray));
                           nOfEquals++;
                           } 
                           }
                           iterator++;
                       }
                            auxIterator++;
                   }
                        int[] stored = new int[3];
                    stored[0] = nOfGreatersThan;
                   stored[1] = nOfLessesThan;
                   stored[2]= nOfEquals ;
                   Integer[] storedInteger = new Integer[stored.length];
                    int i = 0;
                    for (int value : stored) {
                    storedInteger[i++] = Integer.valueOf(value);
                       }
                   results.add(storedInteger);
                    h++;
                    for (Integer[] sks: results){
                        System.out.println("Case #" + result + ":");
                        System.out.println(sks[0]);
                        System.out.println(sks[1]);
                        System.out.println(sks[2]);
                        
                        result++;
                    }
                    } while (h < numberOfCases);
                         
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemaa;
import java.util.ArrayList;
import java.util.Scanner;
public class ProblemaA {
   public static void main(String[] args) {
                Scanner scan;
                int numberOfCases, caseBounds, indexList, nOfEquals, nOfGreatersThan, nOfLessesThan, iterator, currentNumber, auxIterator;
                ArrayList<Integer> scanning = new ArrayList <Integer>();
                ArrayList<Integer> inputs = new ArrayList <Integer>();
                ArrayList<Integer[]> results = new ArrayList<Integer[]>();
                        scan = new Scanner(System.in);
                         numberOfCases = scan.nextInt();
                   int h = 0;
                   int result = 1;
                    do{
                        results.removeAll(results);
                   scan = new Scanner(System.in);
                   caseBounds = scan.nextInt();;
                   scanning.removeAll(scanning);
                   inputs.removeAll(inputs);
                   scan = new Scanner(System.in);
                   for (int i = 0; i<caseBounds; i++){
                          currentNumber = scan.nextInt();
                          inputs.add(currentNumber);
                    }
                    for (int i = 0; i<caseBounds; i++){
                         scanning.add(inputs.get(i));
                    }
                     nOfEquals =0;
                   nOfGreatersThan = 0;
                   nOfLessesThan = 0;
                    auxIterator = 1;
                        for (int numbersWithin: scanning){
                           iterator = 1;
                            for(int sizeArray = 0; sizeArray < scanning.size(); sizeArray++){
                           if (iterator != (1*auxIterator)){
                           if (numbersWithin > scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " > " + scanning.get(sizeArray));
                           nOfGreatersThan++;
                           }
                           else if (numbersWithin < scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " < " + scanning.get(sizeArray));
                            nOfLessesThan++;
                           }
                           else if (numbersWithin == scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " = " + scanning.get(sizeArray));
                           nOfEquals++;
                           } 
                           }
                           iterator++;
                       }
                            auxIterator++;
                   }
                        int[] stored = new int[3];
                    stored[0] = nOfGreatersThan;
                   stored[1] = nOfLessesThan;
                   stored[2]= nOfEquals ;
                   Integer[] storedInteger = new Integer[stored.length];
                    int i = 0;
                    for (int value : stored) {
                    storedInteger[i++] = Integer.valueOf(value);
                       }
                   results.add(storedInteger);
                    h++;
                    for (Integer[] sks: results){
                        System.out.println("Case #" + result + ":");
                        System.out.println(sks[0]);
                        System.out.println(sks[1]);
                        System.out.println(sks[2]);
                        
                        result++;
                    }
                    } while (h < numberOfCases);
                         System.exit(0);
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemab;

import java.util.ArrayList;
import java.util.Scanner;

public class ProblemaB {
    public static void main(String[] args){
        Scanner scan;
        int nxnMatrix, currentNumber, sum, iterator, nOfWinners;
        ArrayList<Integer> matrices = new ArrayList<Integer>();
        ArrayList<Integer> inputs = new ArrayList<Integer>();
        int w =0;
        sum =0;
        scan = new Scanner(System.in);
        while(scan.hasNextInt()) {
            inputs.removeAll(inputs);
        //scan = new Scanner(System.in);
        nxnMatrix = scan.nextInt();

        for(int j= 0; j<(nxnMatrix); j++){
            iterator = 0;
            scan = new Scanner(System.in);
            while (iterator < nxnMatrix){
             currentNumber =  scan.nextInt();
             inputs.add(currentNumber);
             iterator++;
         }
        }
       
        
        int [ ] [ ] currentMatrix = new int [ nxnMatrix ] [ nxnMatrix ] ;
        iterator = 0;
       // System.out.print(nxnMatrix);
        for (int i = 0; i<nxnMatrix; i++){
            for (int h = 0; h<nxnMatrix; h++){
                currentMatrix[i][h] = inputs.get(iterator);
                iterator++;
            }
        }
        iterator = 0;
       int[] sumRow = new int [nxnMatrix];
       int[] sumColumn = new int [nxnMatrix];
         for (int i = 0; i<nxnMatrix; i++){
            for (int h = 0; h<nxnMatrix; h++){
                if (h == 0 && i!=0){
                    sumRow[iterator] = sum;
                    sum = 0;
                    iterator++;
                }
                //System.out.print(currentMatrix[i][h] + " ");
                sum += currentMatrix[i][h];
                if(i==(nxnMatrix-1) && h==(nxnMatrix-1) ){
                    //  System.out.println("Ultimo numero:" + currentMatrix[i][h]);
                    sumRow[nxnMatrix-1] = sum;
                }
            }
        }
         sum = 0;
         iterator = 0;
         for (int h = 0; h<nxnMatrix; h++){
            for (int i = 0; i<nxnMatrix; i++){
                if (i == 0 && h!=0){
                    sumColumn[iterator] = sum;
                    sum = 0;
                    iterator++;
                }
               // System.out.print(currentMatrix[i][h] + " ");
                sum += currentMatrix[i][h];
                 if(i==(nxnMatrix-1) && h==(nxnMatrix-1) ){
                    // System.out.println("Ultimo numero:" + currentMatrix[i][h]);
                    sumColumn[nxnMatrix-1] = sum;
                }
            }
        }
         sum = 0;
         
      /*   for (int j:sumRow){
             System.out.println("Row"+j);
         }
         for (int j:sumColumn){
             System.out.println("Column"+j);
         }*/
         nOfWinners = 0;
         for (int j:sumRow){
             for (int n:sumColumn){
                  if(j<n){
                      nOfWinners++; 
                  }
            }   
         }
         
         
        System.out.println("Case# " + (w+1) + ":\n" + nOfWinners);
       // System.out.println("\n The number is:"+nOfWinners);
        matrices.add(nOfWinners);
        w++;
         iterator = 1;
        //System.out.println("HAS NEXT?" + scan.hasNextLine() + scan.hasNextInt());
        }
        iterator = 1;
       for (int a: matrices){
            System.out.println("Case# " + iterator + ":\n" + a);
            iterator++;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemac;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.SortedSet;
import java.util.TreeSet;
public class ProblemaC {
    public static void main(String[] args) {
        Scanner scan;
        int numberOfCases, nOfStones;
        String stones;
        String[] storedStones;
        char theStone;
        ArrayList<Character> inputs = new ArrayList <Character>();
        ArrayList<Integer> listStones = new ArrayList <Integer>();
        ArrayList<String[]> answers = new ArrayList <String[]>();
        ArrayList<String> cases = new ArrayList <String>();
        //SortedSet<String> qwerty = new SortedSet<String>()
        SortedSet set = new TreeSet();
        String option;
        int h = 0;
        int iterator = 0;
        scan = new Scanner(System.in);
        numberOfCases = scan.nextInt();
        do{
            set.removeAll(set);
            inputs.removeAll(inputs);
           scan = new Scanner(System.in);
            nOfStones = scan.nextInt();;
            scan = new Scanner(System.in);
            stones = scan.nextLine();
            storedStones = stones.split("\\s+");
                   for (int i = 0; i<nOfStones; i++){
                         theStone = storedStones[i].charAt(0);
                          inputs.add(theStone);
                    }
                    String union = "";
                    cases.removeAll(cases);
                    iterator = 0;
                    String [] qwerty = new String[fact(nOfStones)];
                   // for (String p: qwerty){
                  //      p = null;
                   // }
                    //System.out.println("Get ready for this" + nOfStones + " "+ fact(nOfStones));
                    for (Character c: inputs){
                        union = (union + Character.toString(c));
                    }
                    permutation("", union, set);
                    for (Object y: set){
                        
                        qwerty[iterator] = (String) y;
                        iterator++;
                    }
                    answers.add(qwerty);
                    h++;
        } while (h < numberOfCases);
        iterator =1;
        for (String[] a: answers){
            System.out.print("Case# " + iterator + ":\n");
            for (String b:a){
                if(b!=null){System.out.println(b);}
                
            }
            iterator++;
        }
    }
    public static String m(char b){
        String thing;
        thing = Character.toString(b);
        return thing;
    }
    public static ArrayList<String> combinations(ArrayList<Character> input){
        String adding;
        ArrayList<String> results = new ArrayList<String>();
        if (input.size() == 1){
            for (char s: input){
                adding = m(s);
                results.add(adding);
            }
            
        }else{
            combinations(input);
        }
        return results;
    }
    public static void permutation(String str) { 
        //permutation("", str);
}
public static SortedSet permutation(String prefix, String str, SortedSet a) {
    //SortedSet set = new TreeSet();
    int n = str.length();
    if (n == 0) a.add(prefix);
    else {
        for (int i = 0; i < n; i++)
            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), a);
    }
    return a;
}
    
    public static int fact(int n){
        int fact=1;
        while ( n!=0) {
  fact=fact*n;
  n--;
  
}return fact;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemaa;
import java.util.ArrayList;
import java.util.Scanner;
public class ProblemaA {
   public static void main(String[] args) {
                Scanner scan;
                int numberOfCases, caseBounds, indexList, nOfEquals, nOfGreatersThan, nOfLessesThan, iterator, currentNumber, auxIterator;
                ArrayList<Integer> scanning = new ArrayList <Integer>();
                ArrayList<Integer> inputs = new ArrayList <Integer>();
                ArrayList<Integer[]> results = new ArrayList<Integer[]>();
                        scan = new Scanner(System.in);
                         numberOfCases = scan.nextInt();
                   int h = 0;
                    do{
                   scan = new Scanner(System.in);
                   caseBounds = scan.nextInt();;
                   scanning.removeAll(scanning);
                   inputs.removeAll(inputs);
                   scan = new Scanner(System.in);
                   for (int i = 0; i<caseBounds; i++){
                          currentNumber = scan.nextInt();
                          inputs.add(currentNumber);
                    }
                    for (int i = 0; i<caseBounds; i++){
                         scanning.add(inputs.get(i));
                    }
                     nOfEquals =0;
                   nOfGreatersThan = 0;
                   nOfLessesThan = 0;
                    auxIterator = 1;
                        for (int numbersWithin: scanning){
                           iterator = 1;
                            for(int sizeArray = 0; sizeArray < scanning.size(); sizeArray++){
                           if (iterator != (1*auxIterator)){
                           if (numbersWithin > scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " > " + scanning.get(sizeArray));
                           nOfGreatersThan++;
                           }
                           else if (numbersWithin < scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " < " + scanning.get(sizeArray));
                            nOfLessesThan++;
                           }
                           else if (numbersWithin == scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " = " + scanning.get(sizeArray));
                           nOfEquals++;
                           } 
                           }
                           iterator++;
                       }
                            auxIterator++;
                   }
                        int[] stored = new int[3];
                    stored[0] = nOfGreatersThan;
                   stored[1] = nOfLessesThan;
                   stored[2]= nOfEquals ;
                   Integer[] storedInteger = new Integer[stored.length];
                    int i = 0;
                    for (int value : stored) {
                    storedInteger[i++] = Integer.valueOf(value);
                       }
                   results.add(storedInteger);
                    h++;
                    } while (h < numberOfCases);
                    h = 1;
                    for (Integer[] sks: results){
                        System.out.println("Case #" + h);
                        System.out.println(sks[0]);
                        System.out.println(sks[1]);
                        System.out.println(sks[2]);
                        h++;
                    }      
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemaa;
import java.util.ArrayList;
import java.util.Scanner;
public class ProblemaA {
   public static void main(String[] args) {
                Scanner scan;
                int numberOfCases, caseBounds, indexList, nOfEquals, nOfGreatersThan, nOfLessesThan, iterator, currentNumber, auxIterator;
                ArrayList<Integer> scanning = new ArrayList <Integer>();
                ArrayList<Integer> inputs = new ArrayList <Integer>();
                ArrayList<Integer[]> results = new ArrayList<Integer[]>();
                        scan = new Scanner(System.in);
                         numberOfCases = scan.nextInt();
                   int h = 0;
                   int result = 1;
                    do{
                        results.removeAll(results);
                   caseBounds = scan.nextInt();
                   scanning.removeAll(scanning);
                   inputs.removeAll(inputs);
                   for (int i = 0; i<caseBounds; i++){
                          currentNumber = scan.nextInt();
                          inputs.add(currentNumber);
                    }
                    for (int i = 0; i<caseBounds; i++){
                         scanning.add(inputs.get(i));
                    }
                     nOfEquals =0;
                   nOfGreatersThan = 0;
                   nOfLessesThan = 0;
                    auxIterator = 1;
                        for (int numbersWithin: scanning){
                           iterator = 1;
                            for(int sizeArray = 0; sizeArray < scanning.size(); sizeArray++){
                           if (iterator != (1*auxIterator)){
                           if (numbersWithin > scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " > " + scanning.get(sizeArray));
                           nOfGreatersThan++;
                           }
                           else if (numbersWithin < scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " < " + scanning.get(sizeArray));
                            nOfLessesThan++;
                           }
                           else if (numbersWithin == scanning.get(sizeArray)){
                              // System.out.println(numbersWithin + " = " + scanning.get(sizeArray));
                           nOfEquals++;
                           } 
                           }
                           iterator++;
                       }
                            auxIterator++;
                   }
                        int[] stored = new int[3];
                    stored[0] = nOfGreatersThan;
                   stored[1] = nOfLessesThan;
                   stored[2]= nOfEquals ;
                   Integer[] storedInteger = new Integer[stored.length];
                    int i = 0;
                    for (int value : stored) {
                    storedInteger[i++] = Integer.valueOf(value);
                       }
                   results.add(storedInteger);
                    h++;
                    for (Integer[] sks: results){
                        System.out.println("Case #" + result + ":");
                        System.out.println(sks[0]);
                        System.out.println(sks[1]);
                        System.out.println(sks[2]);
                        
                        result++;
                    }
                    } while (h < numberOfCases);
                         System.exit(0);
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemad;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Scanner;
public class ProblemaD {
    public static void main(String[] args) {
        Scanner scan;
        int numberOfCases, nOfTeams, nOfChanges, iterator, auxIterator, current1, current2;
        LinkedList<Integer[]> teams = new LinkedList<Integer[]>();
        ArrayList<Integer> changes = new ArrayList<Integer>();
        int w = 0;
        int j;
        int f = 1;
        int[] aTeam = new int[2];
        scan = new Scanner(System.in);
        numberOfCases = scan.nextInt();
        do{ 
         changes.removeAll(changes);
         teams.removeAll(teams);
         nOfChanges = 0;
        //scan = new Scanner(System.in);
        nOfTeams = scan.nextInt();
        j= 0;
        while(j<nOfTeams){
          //scan = new Scanner(System.in);
           current1 = scan.nextInt();
           current2 = scan.nextInt();
            aTeam[0] = current1;
           aTeam[1] =  current2;
        Integer[] teamInteger = new Integer[aTeam.length];
        int i = 0;
        for (int value : aTeam) {
    teamInteger[i++] = Integer.valueOf(value);
            }
          teams.add(teamInteger);
        j++;
        }
        iterator = 0;
        auxIterator = 0;
        for (Integer[] x: teams){
            //System.out.println("FinalLList" + x[0] +" " +  x[1]);
            iterator = 0;
            for(Integer[] y: teams){
                if(x[0] == y[1] && iterator != auxIterator){
                    nOfChanges++;
                }
                iterator++;
            }
          auxIterator++;
        }
        changes.add(nOfChanges);
        w++;    
        
        for (int a: changes){
            System.out.println("Case# "+ f+ ":\n"+ a);
                    
        }
        f++;
        }while(w < numberOfCases);
       
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemad;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Scanner;
public class ProblemaD {
    public static void main(String[] args) {
        Scanner scan;
        int numberOfCases, nOfTeams, nOfChanges, iterator, auxIterator, current1, current2;
        LinkedList<Integer[]> teams = new LinkedList<Integer[]>();
        ArrayList<Integer> changes = new ArrayList<Integer>();
        int w = 0;
        int j;
        int f = 1;
        int[] aTeam = new int[2];
        scan = new Scanner(System.in);
        numberOfCases = scan.nextInt();
        do{ 
         changes.removeAll(changes);
         teams.removeAll(teams);
         nOfChanges = 0;
        //scan = new Scanner(System.in);
        nOfTeams = scan.nextInt();
        j= 0;
        while(j<nOfTeams){
          //scan = new Scanner(System.in);
           current1 = scan.nextInt();
           current2 = scan.nextInt();
            aTeam[0] = current1;
           aTeam[1] =  current2;
        Integer[] teamInteger = new Integer[aTeam.length];
        int i = 0;
        for (int value : aTeam) {
    teamInteger[i++] = Integer.valueOf(value);
            }
          teams.add(teamInteger);
        j++;
        }
        iterator = 0;
        auxIterator = 0;
        for (Integer[] x: teams){
            //System.out.println("FinalLList" + x[0] +" " +  x[1]);
            iterator = 0;
            for(Integer[] y: teams){
                if(x[0] == y[1] && iterator != auxIterator){
                    nOfChanges++;
                }
                iterator++;
            }
          auxIterator++;
        }
        changes.add(nOfChanges);
        w++;    
        
        for (int a: changes){
            System.out.println("Case #"+ f+ ":\n"+ a);
                    
        }
        f++;
        }while(w < numberOfCases);
       
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemab;

import java.util.ArrayList;
import java.util.Scanner;

public class ProblemaB {
    public static void main(String[] args){
        Scanner scan;
        int nxnMatrix, currentNumber, sum, iterator, nOfWinners;
        ArrayList<Integer> matrices = new ArrayList<Integer>();
        ArrayList<Integer> inputs = new ArrayList<Integer>();
        int w =0;
        sum =0;
        int u;
        scan = new Scanner(System.in);
        while(scan.hasNextInt()) {
            matrices.removeAll(matrices);
            inputs.removeAll(inputs);
        //scan = new Scanner(System.in);
        nxnMatrix = scan.nextInt();

        for(int j= 0; j<(nxnMatrix); j++){
            iterator = 0;
            //scan = new Scanner(System.in);
            while (iterator < nxnMatrix){
             currentNumber =  scan.nextInt();
             inputs.add(currentNumber);
             iterator++;
         }
        }
       
        
        int [ ] [ ] currentMatrix = new int [ nxnMatrix ] [ nxnMatrix ] ;
        iterator = 0;
       // System.out.print(nxnMatrix);
        for (int i = 0; i<nxnMatrix; i++){
            for (int h = 0; h<nxnMatrix; h++){
                currentMatrix[i][h] = inputs.get(iterator);
                iterator++;
            }
        }
        iterator = 0;
       int[] sumRow = new int [nxnMatrix];
       int[] sumColumn = new int [nxnMatrix];
         for (int i = 0; i<nxnMatrix; i++){
            for (int h = 0; h<nxnMatrix; h++){
                if (h == 0 && i!=0){
                    sumRow[iterator] = sum;
                    sum = 0;
                    iterator++;
                }
                //System.out.print(currentMatrix[i][h] + " ");
                sum += currentMatrix[i][h];
                if(i==(nxnMatrix-1) && h==(nxnMatrix-1) ){
                    //  System.out.println("Ultimo numero:" + currentMatrix[i][h]);
                    sumRow[nxnMatrix-1] = sum;
                }
            }
        }
         sum = 0;
         iterator = 0;
         for (int h = 0; h<nxnMatrix; h++){
            for (int i = 0; i<nxnMatrix; i++){
                if (i == 0 && h!=0){
                    sumColumn[iterator] = sum;
                    sum = 0;
                    iterator++;
                }
               // System.out.print(currentMatrix[i][h] + " ");
                sum += currentMatrix[i][h];
                 if(i==(nxnMatrix-1) && h==(nxnMatrix-1) ){
                    // System.out.println("Ultimo numero:" + currentMatrix[i][h]);
                    sumColumn[nxnMatrix-1] = sum;
                }
            }
        }
         sum = 0;
         
      /*   for (int j:sumRow){
             System.out.println("Row"+j);
         }
         for (int j:sumColumn){
             System.out.println("Column"+j);
         }*/
         nOfWinners = 0;
         for (int j:sumRow){
             for (int n:sumColumn){
                  if(j<n){
                      nOfWinners++; 
                  }
            }   
         }
         
         
        System.out.println("Case# " + (w+1) + ":\n" + nOfWinners);
       // System.out.println("\n The number is:"+nOfWinners);
        matrices.add(nOfWinners);
        w++;
         iterator = 1;
        //System.out.println("HAS NEXT?" + scan.hasNextLine() + scan.hasNextInt());
        }
        System.exit(0);
       /*for (int a: matrices){
            System.out.println("Case# " + iterator + ":\n" + a);
            iterator++;
        }*/
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemab;

import java.util.ArrayList;
import java.util.Scanner;

public class ProblemaB {
    public static void main(String[] args){
        Scanner scan;
        int nxnMatrix, currentNumber, sum, iterator, nOfWinners;
        ArrayList<Integer> matrices = new ArrayList<Integer>();
        ArrayList<Integer> inputs = new ArrayList<Integer>();
        int w =0;
        sum =0;
        int u;
        scan = new Scanner(System.in);
        while(scan.hasNextInt()) {
            matrices.removeAll(matrices);
            inputs.removeAll(inputs);
        //scan = new Scanner(System.in);
        nxnMatrix = scan.nextInt();

        for(int j= 0; j<(nxnMatrix); j++){
            iterator = 0;
            //scan = new Scanner(System.in);
            while (iterator < nxnMatrix){
             currentNumber =  scan.nextInt();
             inputs.add(currentNumber);
             iterator++;
         }
        }
       
        
        int [ ] [ ] currentMatrix = new int [ nxnMatrix ] [ nxnMatrix ] ;
        iterator = 0;
       // System.out.print(nxnMatrix);
        for (int i = 0; i<nxnMatrix; i++){
            for (int h = 0; h<nxnMatrix; h++){
                currentMatrix[i][h] = inputs.get(iterator);
                iterator++;
            }
        }
        iterator = 0;
       int[] sumRow = new int [nxnMatrix];
       int[] sumColumn = new int [nxnMatrix];
         for (int i = 0; i<nxnMatrix; i++){
            for (int h = 0; h<nxnMatrix; h++){
                if (h == 0 && i!=0){
                    sumRow[iterator] = sum;
                    sum = 0;
                    iterator++;
                }
                //System.out.print(currentMatrix[i][h] + " ");
                sum += currentMatrix[i][h];
                if(i==(nxnMatrix-1) && h==(nxnMatrix-1) ){
                    //  System.out.println("Ultimo numero:" + currentMatrix[i][h]);
                    sumRow[nxnMatrix-1] = sum;
                }
            }
        }
         sum = 0;
         iterator = 0;
         for (int h = 0; h<nxnMatrix; h++){
            for (int i = 0; i<nxnMatrix; i++){
                if (i == 0 && h!=0){
                    sumColumn[iterator] = sum;
                    sum = 0;
                    iterator++;
                }
               // System.out.print(currentMatrix[i][h] + " ");
                sum += currentMatrix[i][h];
                 if(i==(nxnMatrix-1) && h==(nxnMatrix-1) ){
                    // System.out.println("Ultimo numero:" + currentMatrix[i][h]);
                    sumColumn[nxnMatrix-1] = sum;
                }
            }
        }
         sum = 0;
         
      /*   for (int j:sumRow){
             System.out.println("Row"+j);
         }
         for (int j:sumColumn){
             System.out.println("Column"+j);
         }*/
         nOfWinners = 0;
         for (int j:sumRow){
             for (int n:sumColumn){
                  if(j<n){
                      nOfWinners++; 
                  }
            }   
         }
         
         
        System.out.println("Case #" + (w+1) + ":\n" + nOfWinners);
       // System.out.println("\n The number is:"+nOfWinners);
        matrices.add(nOfWinners);
        w++;
         iterator = 1;
        //System.out.println("HAS NEXT?" + scan.hasNextLine() + scan.hasNextInt());
        }
        System.exit(0);
       /*for (int a: matrices){
            System.out.println("Case# " + iterator + ":\n" + a);
            iterator++;
        }*/
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemac;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.SortedSet;
import java.util.TreeSet;
public class ProblemaC {
    public static void main(String[] args) {
        Scanner scan;
        int numberOfCases, nOfStones;
        String stones;
        String[] storedStones;
        char theStone;
        ArrayList<Character> inputs = new ArrayList <Character>();
        ArrayList<Integer> listStones = new ArrayList <Integer>();
        ArrayList<String[]> answers = new ArrayList <String[]>();
        ArrayList<String> cases = new ArrayList <String>();
        //SortedSet<String> qwerty = new SortedSet<String>()
        SortedSet set = new TreeSet();
        String option;
        int h = 0;
        int p = 1;
        int iterator = 0;
        scan = new Scanner(System.in);
        numberOfCases = scan.nextInt();
        do{
            set.removeAll(set);
            inputs.removeAll(inputs);
            answers.removeAll(answers);
          // scan = new Scanner(System.in);
            nOfStones = scan.nextInt();
            scan = new Scanner(System.in);
            stones = scan.nextLine();
            storedStones = stones.split("\\s+");
                   for (int i = 0; i<nOfStones; i++){
                         theStone = storedStones[i].charAt(0);
                          inputs.add(theStone);
                    }
                    String union = "";
                    cases.removeAll(cases);
                    iterator = 0;
                    String [] qwerty = new String[fact(nOfStones)];
                   // for (String p: qwerty){
                  //      p = null;
                   // }
                    //System.out.println("Get ready for this" + nOfStones + " "+ fact(nOfStones));
                    for (Character c: inputs){
                        union = (union + Character.toString(c));
                    }
                    permutation("", union, set);
                    for (Object y: set){
                        
                        qwerty[iterator] = (String) y;
                        iterator++;
                    }
                    answers.add(qwerty);
                    for (String[] a: answers){
            System.out.print("Case# " +p + ":\n");
            for (String b:a){
                if(b!=null){System.out.println(b);}
                
            }
            
        }
                    h++;
                    p++;
        } while (h < numberOfCases);
        iterator =1;
        
    }
    public static String m(char b){
        String thing;
        thing = Character.toString(b);
        return thing;
    }
    public static ArrayList<String> combinations(ArrayList<Character> input){
        String adding;
        ArrayList<String> results = new ArrayList<String>();
        if (input.size() == 1){
            for (char s: input){
                adding = m(s);
                results.add(adding);
            }
            
        }else{
            combinations(input);
        }
        return results;
    }
    public static void permutation(String str) { 
        //permutation("", str);
}
public static SortedSet permutation(String prefix, String str, SortedSet a) {
    //SortedSet set = new TreeSet();
    int n = str.length();
    if (n == 0) a.add(prefix);
    else {
        for (int i = 0; i < n; i++)
            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), a);
    }
    return a;
}
    
    public static int fact(int n){
        int fact=1;
        while ( n!=0) {
  fact=fact*n;
  n--;
  
}return fact;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemac;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.SortedSet;
import java.util.TreeSet;
public class ProblemaC {
    public static void main(String[] args) {
        Scanner scan, auxScan;
        int numberOfCases, nOfStones;
        String stones;
        String[] storedStones = new String[100];
        char theStone;
        ArrayList<Character> inputs = new ArrayList <Character>();
        ArrayList<Integer> listStones = new ArrayList <Integer>();
        ArrayList<String[]> answers = new ArrayList <String[]>();
        ArrayList<String> cases = new ArrayList <String>();
        //SortedSet<String> qwerty = new SortedSet<String>()
        SortedSet set = new TreeSet();
        String option;
        int h = 0;
        int p = 1;
        int iterator = 0;
        
        scan = new Scanner(System.in);
        numberOfCases = scan.nextInt();
        do{
            set.removeAll(set);
            inputs.removeAll(inputs);
            answers.removeAll(answers);
           //scan = new Scanner(System.in);
            nOfStones = scan.nextInt();
            auxScan = new Scanner(System.in);
            stones = auxScan.nextLine();
            
            //System.out.println(storedStones.length + stones);
            storedStones = stones.split("\\s+");
             String union = "";
                   for (int i = 0; i<nOfStones; i++){
                         union = stones.replaceAll("\\s+","");
                    }
 
                   
                    cases.removeAll(cases);
                    iterator = 0;
                    String [] qwerty = new String[fact(nOfStones)];
                   // for (String p: qwerty){
                  //      p = null;
                   // }
                    //System.out.println("Get ready for this" + nOfStones + " "+ fact(nOfStones));
                    for (Character c: inputs){
                        union = (union + Character.toString(c));
                    }
                    permutation("", union, set);
                    for (Object y: set){
                        
                        qwerty[iterator] = (String) y;
                        iterator++;
                    }
                    answers.add(qwerty);
                    for (String[] a: answers){
            System.out.print("Case# " +p + ":\n");
            for (String b:a){
                if(b!=null){System.out.println(b);}
                
            }
            
        }
                    h++;
                    p++;
        } while (h < numberOfCases);
        iterator =1;
        
    }
    public static String m(char b){
        String thing;
        thing = Character.toString(b);
        return thing;
    }
    public static ArrayList<String> combinations(ArrayList<Character> input){
        String adding;
        ArrayList<String> results = new ArrayList<String>();
        if (input.size() == 1){
            for (char s: input){
                adding = m(s);
                results.add(adding);
            }
            
        }else{
            combinations(input);
        }
        return results;
    }
    public static void permutation(String str) { 
        //permutation("", str);
}
public static SortedSet permutation(String prefix, String str, SortedSet a) {
    //SortedSet set = new TreeSet();
    int n = str.length();
    if (n == 0) a.add(prefix);
    else {
        for (int i = 0; i < n; i++)
            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), a);
    }
    return a;
}
    
    public static int fact(int n){
        int fact=1;
        while ( n!=0) {
  fact=fact*n;
  n--;
  
}return fact;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemac;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.SortedSet;
import java.util.TreeSet;
public class ProblemaC {
    public static void main(String[] args) {
        Scanner scan, auxScan;
        int numberOfCases, nOfStones;
        String stones;
        String[] storedStones = new String[100];
        char theStone;
        ArrayList<Character> inputs = new ArrayList <Character>();
        ArrayList<Integer> listStones = new ArrayList <Integer>();
        ArrayList<String[]> answers = new ArrayList <String[]>();
        ArrayList<String> cases = new ArrayList <String>();
        //SortedSet<String> qwerty = new SortedSet<String>()
        SortedSet set = new TreeSet();
        String option;
        int h = 0;
        int p = 1;
        int iterator = 0;
        
        scan = new Scanner(System.in);
        numberOfCases = scan.nextInt();
        do{
            set.removeAll(set);
            inputs.removeAll(inputs);
            answers.removeAll(answers);
           //scan = new Scanner(System.in);
            nOfStones = scan.nextInt();
            //scan = new Scanner(System.in);
            stones = scan.nextLine();
            
            //System.out.println(storedStones.length + stones);
            storedStones = stones.split("\\s+");
             String union = "";
                   for (int i = 0; i<nOfStones; i++){
                         union = stones.replaceAll("\\s+","");
                    }
                   System.out.print("For fuck sake:" + union +" " + stones);
                   
                    cases.removeAll(cases);
                    iterator = 0;
                    String [] qwerty = new String[fact(nOfStones)];
                   // for (String p: qwerty){
                  //      p = null;
                   // }
                    //System.out.println("Get ready for this" + nOfStones + " "+ fact(nOfStones));
                    for (Character c: inputs){
                        union = (union + Character.toString(c));
                    }
                    permutation("", union, set);
                    for (Object y: set){
                        
                        qwerty[iterator] = (String) y;
                        iterator++;
                    }
                    answers.add(qwerty);
                    for (String[] a: answers){
            System.out.print("Case# " +p + ":\n");
            for (String b:a){
                if(b!=null){System.out.println(b);}
                
            }
            
        }
                    h++;
                    p++;
        } while (h < numberOfCases);
        iterator =1;
        
    }
    public static String m(char b){
        String thing;
        thing = Character.toString(b);
        return thing;
    }
    public static ArrayList<String> combinations(ArrayList<Character> input){
        String adding;
        ArrayList<String> results = new ArrayList<String>();
        if (input.size() == 1){
            for (char s: input){
                adding = m(s);
                results.add(adding);
            }
            
        }else{
            combinations(input);
        }
        return results;
    }
    public static void permutation(String str) { 
        //permutation("", str);
}
public static SortedSet permutation(String prefix, String str, SortedSet a) {
    //SortedSet set = new TreeSet();
    int n = str.length();
    if (n == 0) a.add(prefix);
    else {
        for (int i = 0; i < n; i++)
            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), a);
    }
    return a;
}
    
    public static int fact(int n){
        int fact=1;
        while ( n!=0) {
  fact=fact*n;
  n--;
  
}return fact;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemac;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.SortedSet;
import java.util.TreeSet;
public class ProblemaC {
    public static void main(String[] args) {
        Scanner scan, auxScan;
        int numberOfCases, nOfStones;
        String stones;
        String[] storedStones = new String[100];
        char theStone;
        ArrayList<Character> inputs = new ArrayList <Character>();
        ArrayList<Integer> listStones = new ArrayList <Integer>();
        ArrayList<String[]> answers = new ArrayList <String[]>();
        ArrayList<String> cases = new ArrayList <String>();
        //SortedSet<String> qwerty = new SortedSet<String>()
        SortedSet set = new TreeSet();
        String option;
        int h = 0;
        int p = 1;
        int iterator = 0;
        
        scan = new Scanner(System.in);
        numberOfCases = Integer.parseInt(scan.nextLine());
        do{
            set.removeAll(set);
            inputs.removeAll(inputs);
            answers.removeAll(answers);
           //scan = new Scanner(System.in);
            nOfStones = Integer.parseInt(scan.nextLine());
           //scan = new Scanner(System.in);
            stones = scan.nextLine();
            //System.out.print("Union and stones:"  +" " + stones);
            
            //System.out.println(storedStones.length + stones);
            storedStones = stones.split("\\s+");
             String union = "";
                   for (int i = 0; i<nOfStones; i++){
                         union = stones.replaceAll("\\s+","");
                    }
                   
                   
                    cases.removeAll(cases);
                    iterator = 0;
                    String [] qwerty = new String[fact(nOfStones)];
                   // for (String p: qwerty){
                  //      p = null;
                   // }
                    //System.out.println("Get ready for this" + nOfStones + " "+ fact(nOfStones));
                    for (Character c: inputs){
                        union = (union + Character.toString(c));
                    }
                    permutation("", union, set);
                    for (Object y: set){
                        
                        qwerty[iterator] = (String) y;
                        iterator++;
                    }
                    answers.add(qwerty);
                    for (String[] a: answers){
            System.out.print("Case #" +p + ":\n");
            for (String b:a){
                if(b!=null){System.out.println(b);}
                
            }
            
        }
                    h++;
                    p++;
        } while (h < numberOfCases);
        iterator =1;
        
    }
    public static String m(char b){
        String thing;
        thing = Character.toString(b);
        return thing;
    }
    public static ArrayList<String> combinations(ArrayList<Character> input){
        String adding;
        ArrayList<String> results = new ArrayList<String>();
        if (input.size() == 1){
            for (char s: input){
                adding = m(s);
                results.add(adding);
            }
            
        }else{
            combinations(input);
        }
        return results;
    }
    public static void permutation(String str) { 
        //permutation("", str);
}
public static SortedSet permutation(String prefix, String str, SortedSet a) {
    //SortedSet set = new TreeSet();
    int n = str.length();
    if (n == 0) a.add(prefix);
    else {
        for (int i = 0; i < n; i++)
            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), a);
    }
    return a;
}
    
    public static int fact(int n){
        int fact=1;
        while ( n!=0) {
  fact=fact*n;
  n--;
  
}return fact;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package problemae;
import java.util.ArrayList;
import java.util.Scanner;
public class ProblemaE {
   public static void main(String[] args) {
                Scanner scan;
                int numberOfCases, caseBounds;
                ArrayList<Integer> scanning = new ArrayList <Integer>();
                ArrayList<Integer> inputs = new ArrayList <Integer>();
                ArrayList<Integer[]> results = new ArrayList<Integer[]>();
                   scan = new Scanner(System.in);
                   numberOfCases = scan.nextInt();
                   int h = 0;
                   
                    do{
                       caseBounds = scan.nextInt();
                       int [] zerosAndOnes = new int[caseBounds];
                       for (int i = 0; i <caseBounds; i++){
                           zerosAndOnes[i] = scan.nextInt();
                       }
                       for (int a: zerosAndOnes){
                           for (int o = caseBounds; o>0; o--){
                               if (o == 1 && a == 1){
                                   
                               }
                           }
                       }
                      h++;
                    } while (h < numberOfCases);
                         System.exit(0);
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemaA {
    
    public static void main (String[] args) throws FileNotFoundException{
        Scanner scan;
        File f = new File("A_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1;
        int t = Integer.parseInt(scan.nextLine());
        int currentCollisions = 0, minHash = 0, auxCollisions= 0 , iterator = 0, minK = 0, minCollisions = 0;
        LinkedList<Integer> saving = new LinkedList<>();
        LinkedList<SeparateChainingHashTable<Integer>> hashes= new LinkedList<>();
        LinkedList <int []>  sorting = new LinkedList<>();
       /* SeparateChainingHashTable<Integer> mainHash = new SeparateChainingHashTable<>(5);
        mainHash.insert(1);
        mainHash.insert(6);
        mainHash.insert(11);
        mainHash.insert(10);
        mainHash.insert(15);
        mainHash.insert(7);
        int q = 0;
        int jj = 0;
        
        for (List<Integer> a : mainHash.theLists) {
            
                System.out.println(q +" "+ a.size());
                if(a.size()>1){
                    String sh ="";
                    jj++;
                    for (Integer a1 : a) {
                        sh += " " + a1;
                    }
                    System.out.println("Result" + sh);
                }
            q++;
        }
        System.out.println("sss dsfsd" + jj);*/
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            saving.clear();
            hashes.clear();
            sorting.clear();
            String numbersAndHash = scan.nextLine();
            String l[] = numbersAndHash.split(" ");
            int numbers = Integer.parseInt(l[0]);
            int hash = Integer.parseInt(l[1]);
            String inputs = scan.nextLine();
            String m[] = inputs.split(" ");
            for (int j = 0; j < numbers; j++) {
                saving.add(Integer.parseInt(m[j]));
            }
            String inputHashes = scan.nextLine();
            String n[] = inputHashes.split(" ");
            for (int j = 0; j < hash; j++) {
                SeparateChainingHashTable<Integer> currentHash
                        = new SeparateChainingHashTable<>(Integer.parseInt(n[j]));
                hashes.add(currentHash);
            }
            for (int j = 0; j < hash; j++) {
                for (Integer a : saving) {
                    hashes.get(j).insert(a);
                }
            }
            minHash = 0; auxCollisions = 0; iterator = 0; currentCollisions = 0; minCollisions = 0; minK = 0;
            for (SeparateChainingHashTable<Integer> b : hashes) {
                currentCollisions = 0;
                for (List<Integer> c : b.theLists) {
                    if(c.size()>1){
                    //String sh ="";
                    currentCollisions += (c.size()-1);
                      /*  for (Integer d : c) {
                        sh += " " + d;
                        }*/
                    }
                    
                }
                if (iterator == 0) {
                    auxCollisions = currentCollisions;
                    minK = b.theLists.length;
                }
              //  System.out.println("ax " +auxCollisions  + " cC " + currentCollisions  + " minK " + minK + " " + b.theLists.length);
                if(auxCollisions > currentCollisions ){
                    minHash = iterator;
                    minK = b.theLists.length;
                    auxCollisions = currentCollisions;
                 
                }
                else if(auxCollisions == currentCollisions){
                            if(b.theLists.length < minK){
                            minHash = iterator;
                            minK = b.theLists.length; 
                            }
                        }
          //    System.out.println( " mh " + minHash + " i " + iterator);
             // System.out.println("Current c " + currentCollisions);
                iterator++;
            }
          //  System.out.println("min " + minHash); 
         //   System.out.println("");
            System.out.println(hashes.get(minHash).theLists.length);
            System.out.println(auxCollisions);
            
            for (List<Integer> d : hashes.get(minHash).theLists) {
                boolean firstT = false;
                
                if(d.size()>1){
                    String building ="";
                   
                             for (Integer e : d) {
                        if(!firstT){
                            building += e;
                            firstT = true;
                        }
                        else building += " " + e;
                        }
                       
                        String j[] = building.split(" ");
                        int [] tmp = new int [j.length];
                        for (int k = 0; k < j.length; k++) {
                        tmp[k] = Integer.parseInt(j[k]);
                    }
                       Arrays.sort(tmp);
                      sorting.add(tmp);
                      
                    }
            }
                for (int j = 0; j < sorting.size()-1; j++) {
                               try{ if(sorting.get(j)[0] > sorting.get(j+1)[0]){
                                    int [] copy = sorting.get(j+1);
                                    sorting.set(j+1, sorting.get(j));
                                    sorting.set(j, copy);
                                }
                               }catch(Exception e){
                                   
                               }
                            }
                            for (int[] z : sorting) {
                                boolean erstes = false;
                                for(int y : z){
                                    if(!erstes){
                                        System.out.print(y);
                                        erstes = true;
                                    }else{
                                        System.out.print(" " + y);
                                    }
                                    
                                }
                                System.out.println("");
            }
            nCases++;
        }
        
    }
 
   public static class SeparateChainingHashTable<AnyType>
{
    /**
     * Construct the hash table.
     */
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {
      
        //theLists = new LinkedList[ nextPrime( size ) ];
        theLists = new LinkedList[ size  ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ (Integer.parseInt(x.toString()))% theLists.length ];
       // System.out.println( x + " " +(Integer.parseInt(x.toString())) % theLists.length);
       // if( !whichList.contains( x ) )        {
            whichList.add( x );
            currentSize++;
                // Rehash; see Section 5.5
            /*if( ++currentSize > theLists.length )
                rehash( );*/
       // }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        System.out.println(myhash(x));
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
        
    }

  
    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );
       
        hashVal %= theLists.length;
        if( hashVal < 0 )
            hashVal += theLists.length;

        return hashVal;
    }
    
    private static final int DEFAULT_TABLE_SIZE = 101;
        /** The array of Lists. */
    private List<AnyType> [ ] theLists; 
    private int currentSize;

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }


        // Simple main
  /*  public static void main( String [ ] args )
    {
        SeparateChainingHashTable<Integer> H = new SeparateChainingHashTable<>( );

        long startTime = System.currentTimeMillis( );
        
        final int NUMS = 2000000;
        final int GAP  =   37;

        System.out.println( "Checking... (no more output means success)" );

        for( int i = GAP; i != 0; i = ( i + GAP ) % NUMS )
            H.insert( i );
        for( int i = 1; i < NUMS; i+= 2 )
            H.remove( i );

        for( int i = 2; i < NUMS; i+=2 )
            if( !H.contains( i ) )
                System.out.println( "Find fails " + i );

        for( int i = 1; i < NUMS; i+=2 )
        {
            if( H.contains( i ) )
                System.out.println( "OOPS!!! " +  i  );
        }
        
        long endTime = System.currentTimeMillis( );
        
        System.out.println( "Elapsed time: " + (endTime - startTime) );
    } 
    */
}
   
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaB {
     public static void main(String[] args) throws FileNotFoundException{
         Scanner scan;
        File f = new File("B_1s.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1, supplies = 0;  
        Map<Integer,Integer> bag = new TreeMap<>( );
        int t = Integer.parseInt(scan.nextLine());
         for (int i = 0; i < t; i++) {
             
             System.out.println("Case #" + nCases + ":");
             supplies = 0;    
             bag.clear();
             int ponds = Integer.parseInt(scan.nextLine());
             for (int j = 0; j < ponds; j++) {
                // System.out.println("----------------------------------------------------------------------------");
                String foodAndPokemon = scan.nextLine();
                String l[] = foodAndPokemon.split(" ");
                int food = Integer.parseInt(l[0]);
                int pokemon = Integer.parseInt(l[1]);
                if(!bag.containsKey(food)){
                    bag.put(food, 0);
                }else if (bag.containsKey(food)){
                    bag.put(food, (bag.get(food)+1));
                }
                
              
           
                /* System.out.println("bagsGetPokemon " + bag.get(pokemon));
                 
                    System.out.println(bag.entrySet());*/
                if(bag.containsKey(pokemon)){
                    for (Integer a : bag.values()) {
                        
                    }
                    if(bag.get(pokemon) > 0){
                        bag.put(pokemon, (bag.get(pokemon)-1));
                    }else if(bag.get(pokemon) ==  0){
                        bag.remove(pokemon);
                    }
                } else supplies++;
                
                   // System.out.println("food " + food +" pok " + pokemon + " sup " + supplies);
                // System.out.println(bag.entrySet());
               
                 
                
             }
             
             System.out.println(supplies);
             nCases++;
         }
     }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

/**
 *
 */
public class ProblemaC {
     public static void main(String args[]) throws FileNotFoundException{
        Scanner scan;
        File f = new File("C_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1; 
        int t = Integer.parseInt(scan.nextLine());
        Set<String> setNorma = new TreeSet<>(  );
        Set<String> setMario = new TreeSet<>(  );
        Set<String> setPipe = new TreeSet<>(  ); 
        ArrayList<Integer> listNorma = new ArrayList<>();
        ArrayList<Integer> listMario = new ArrayList<>();
        ArrayList<Integer> listPipe = new ArrayList<>();
         for (int i = 0; i < t; i++) {
             System.out.println("Case #" + nCases + ":");
             setNorma.clear();
             setMario.clear();
             setPipe.clear();
             listNorma.clear();
             listMario.clear();
             listPipe.clear();
             String howEach = scan.nextLine();
             String[] l = howEach.split(" ");
             int norma = Integer.parseInt(l[0]);
             int mario = Integer.parseInt(l[1]);
             int pipe = Integer.parseInt(l[2]);
             String inputNorma = scan.nextLine();
             String m[] = inputNorma.split(" ");
             for (int j = 0; j < norma; j++) {
                 setNorma.add(m[j]);
                 
             }
             String inputMario = scan.nextLine();
             String n[] = inputMario.split(" ");
             for (int j = 0; j < mario; j++) {
                 setMario.add(n[j]);
             }
             String inputPipe = scan.nextLine();
             String o[] = inputPipe.split(" ");
             for (int j = 0; j < pipe; j++) {
                 setPipe.add(o[j]);
             }
             Set<String> forNorma = new TreeSet<>(  );
             for (String a : setMario) {
                 forNorma.add(a);
             }
             for (String a : setPipe) {
                 forNorma.add(a);
             }
             Set<String> forMario = new TreeSet<>(  );
             for (String a : setNorma) {
                 forMario.add(a);
             }
             for (String a : setPipe) {
                 forMario.add(a);
             }
             Set<String> forPipe = new TreeSet<>(  );
             for (String a : setMario) {
                 forPipe.add(a);
             }
             for (String a : setNorma) {
                 forPipe.add(a);
             }
             // System.out.println(forNorma.size() + " " + forMario.size() + " " + forPipe.size());
             for (String a : setNorma) {
                 if(!forNorma.contains(a)){
                     listNorma.add(Integer.parseInt(a));
                 }
                     
             }
             for (String a : setMario) {
                 if(!forMario.contains(a)){
                     listMario.add(Integer.parseInt(a));
                 }
             }
             for (String a : setPipe) {
                 if(!forPipe.contains(a)){
                     listPipe.add(Integer.parseInt(a));
                 }
             }
             Collections.sort(listNorma);
             Collections.sort(listMario);
             Collections.sort(listPipe);
            // System.out.println(listNorma.size() + " " + listMario.size() + " " + listPipe.size());
             int q = -1;
            // System.out.println((thereIsMaxBetweenThree(listNorma.size(),listMario.size(),listPipe.size())));
             if(thereIsMaxBetweenThree(listNorma.size(),listMario.size(),listPipe.size())){
                 q = maxBetweenThree(listNorma.size(),listMario.size(),listPipe.size());
             if(q == listNorma.size()){
                 System.out.print("Norma " + q);
                 for (Integer x : listNorma) {
                 System.out.print(" " + x);
                }
             }else if(q == listMario.size()){
                 System.out.print("Mario " + q);
                 for (Integer x : listMario) {
                 System.out.print(" " + x);
                }
             }else if(q == listPipe.size()){
                 System.out.print("Pipe " + q);
                 for (Integer x : listPipe) {
                 System.out.print(" " + x);
                }
             }
                 System.out.println("");
             }else if (!(listNorma.size() == listMario.size() && listMario.size() ==listPipe.size())){
                 int r = twice(listNorma.size(),listMario.size(),listPipe.size());
                 if (r == listNorma.size()){
                    
                 System.out.print("Mario " + listMario.size());
                 for (Integer x : listMario) {
                 System.out.print(" " + x);
                }
                     System.out.println("");
                 System.out.print("Pipe " + listPipe.size());
                 for (Integer x : listPipe) {
                 System.out.print(" " + x);
                }
                     System.out.println("");
                 }else if ( r == listMario.size()){
                 
                 
                 System.out.print("Norma " + listNorma.size());
                 for (Integer x : listNorma) {
                 System.out.print(" " + x);
                }
                     System.out.println("");
             
                 System.out.print("Pipe " + listPipe.size());
                 for (Integer x : listPipe) {
                 System.out.print(" " + x);
                }
                     System.out.println("");
            
                 
             } else if (r == listPipe.size()){
                 
                 System.out.print("Norma " + listNorma.size());
                 for (Integer x : listNorma) {
                 System.out.print(" " + x);
                }
                     System.out.println("");
             
                 System.out.print("Mario " + listMario.size());
                 for (Integer x : listMario) {
                 System.out.print(" " + x);
                }
               System.out.println("");
            
             }
             
                 
             } else{
                 
                 System.out.print("Norma " + listNorma.size());
                 for (Integer x : listNorma) {
                 System.out.print(" " + x);
                }
                 System.out.println("");
                 System.out.print("Mario " + listMario.size());
                 for (Integer x : listMario) {
                 System.out.print(" " + x);
                }
                 System.out.println("");
                 System.out.print("Pipe " + listPipe.size());
                 for (Integer x : listPipe) {
                 System.out.print(" " + x);
                }
                 System.out.println("");
                 
             }
             
             
             nCases++;
         }
    }
   public static boolean thereIsMaxBetweenThree(int a, int b, int c){
       if (a!= b && b !=c && a!= c){
           return true;
       } else if (a>b && a>c) return true;
       else if (b>a && b>c) return true;
       else if (c>a && c>b) return true;
       else return false;
   } 
     public static int maxBetweenThree(int a, int b, int c){
       if (a>b && a>c) return a;
       else if (b>a && b>c) return b;
       else if (c>a && c>b) return c;
       return -1;
   } 
   public static int twice(int a, int b, int c){
     if (a == b) return c;
     if (a == c) return b;
     if (b == c) return a;
     return -1;
   }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;


/**
 *
 */
public class ProblemaD {
    public static void main(String args[]) throws FileNotFoundException{
        Scanner scan;
        File f = new File("D_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1; 
        int t = Integer.parseInt(scan.nextLine());
        Map<String, String> parties = new TreeMap<>( );
        Map<String, Integer> votes = new TreeMap<>( );
        int winner = -1, index = 0;
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            parties.clear();
            votes.clear();
            int numberCandidates = Integer.parseInt(scan.nextLine());
            String[] winners = new String[numberCandidates];
            for (int j = 0; j < numberCandidates; j++) {
                String candidateAndParty = scan.nextLine();
                String l[] = candidateAndParty.split(" ");
                String currentCandidate = l[0];
                String currentParty = l[1];
                parties.put(currentCandidate, currentParty);
                votes.put(currentParty, 0);
            }
            int numberVotes = Integer.parseInt(scan.nextLine()); 
            for (int j = 0; j < numberVotes; j++) {
                String currentVote = scan.nextLine();
                votes.put(parties.get(currentVote), votes.get(parties.get(currentVote))+1);
            }
            winner = -1;
            for (Integer a : votes.values()) {
                if(winner < a){
                    winner = a;
                }
            }
            index = 0;
            for (Map.Entry<String, Integer> b : votes.entrySet()) {
                if(b.getValue() == winner){
                    winners[index] = b.getKey();
                    index++;
                }
            }
            for (int j = index; j < winners.length; j++) {
                winners[j] = "";
            }
            Arrays.sort(winners);
            for (String c : winners) {
                if(!c.equals(""))System.out.println(c);
            }
            /*System.out.println(parties.entrySet());
            System.out.println(votes.entrySet());*/
           // System.out.println("-----------------------------------------------");
            nCases++;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemaA {
    
    public static void main (String[] args) throws FileNotFoundException{
        Scanner scan;
        File f = new File("A_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1;
        int t = Integer.parseInt(scan.nextLine());
        int currentCollisions = 0, minHash = 0, auxCollisions= 0 , iterator = 0, minK = 0, minCollisions = 0;
        LinkedList<Integer> saving = new LinkedList<>();
        LinkedList<SeparateChainingHashTable<Integer>> hashes= new LinkedList<>();
        LinkedList <int []>  sorting = new LinkedList<>();
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            saving.clear();
            hashes.clear();
            sorting.clear();
            String numbersAndHash = scan.nextLine();
            String l[] = numbersAndHash.split(" ");
            int numbers = Integer.parseInt(l[0]);
            int hash = Integer.parseInt(l[1]);
            String inputs = scan.nextLine();
            String m[] = inputs.split(" ");
            for (int j = 0; j < numbers; j++) {
                saving.add(Integer.parseInt(m[j]));
            }
            String inputHashes = scan.nextLine();
            String n[] = inputHashes.split(" ");
            for (int j = 0; j < hash; j++) {
                SeparateChainingHashTable<Integer> currentHash
                        = new SeparateChainingHashTable<>(Integer.parseInt(n[j]));
                hashes.add(currentHash);
            }
            for (int j = 0; j < hash; j++) {
                for (Integer a : saving) {
                    hashes.get(j).insert(a);
                }
            }
            minHash = 0; auxCollisions = 0; iterator = 0; currentCollisions = 0; minCollisions = 0; minK = 0;
            for (SeparateChainingHashTable<Integer> b : hashes) {
                currentCollisions = 0;
                for (List<Integer> c : b.theLists) {
                    if(c.size()>1){
                    //String sh ="";
                    currentCollisions += (c.size()-1);
                      /*  for (Integer d : c) {
                        sh += " " + d;
                        }*/
                    }
                    
                }
                if (iterator == 0) {
                    auxCollisions = currentCollisions;
                    minK = b.theLists.length;
                }
              //  System.out.println("ax " +auxCollisions  + " cC " + currentCollisions  + " minK " + minK + " " + b.theLists.length);
                if(auxCollisions > currentCollisions ){
                    minHash = iterator;
                    minK = b.theLists.length;
                    auxCollisions = currentCollisions;
                 
                }
                else if(auxCollisions == currentCollisions){
                            if(b.theLists.length < minK){
                            minHash = iterator;
                            minK = b.theLists.length; 
                            }
                        }
          //    System.out.println( " mh " + minHash + " i " + iterator);
             // System.out.println("Current c " + currentCollisions);
                iterator++;
            }
          //  System.out.println("min " + minHash); 
         //   System.out.println("");
            System.out.println(hashes.get(minHash).theLists.length);
            System.out.println(auxCollisions);
            
            for (List<Integer> d : hashes.get(minHash).theLists) {
                boolean firstT = false;
                
                if(d.size()>1){
                    String building ="";
                   
                             for (Integer e : d) {
                        if(!firstT){
                            building += e;
                            firstT = true;
                        }
                        else building += " " + e;
                        }
                       
                        String j[] = building.split(" ");
                        int [] tmp = new int [j.length];
                        for (int k = 0; k < j.length; k++) {
                        tmp[k] = Integer.parseInt(j[k]);
                    }
                       Arrays.sort(tmp);
                      sorting.add(tmp);
                      
                    }
            }
                for (int j = 0; j < sorting.size()-1; j++) {
                               try{ if(sorting.get(j)[0] > sorting.get(j+1)[0]){
                                    int [] copy = sorting.get(j+1);
                                    sorting.set(j+1, sorting.get(j));
                                    sorting.set(j, copy);
                                }
                               }catch(Exception e){
                                   
                               }
                            }
                            for (int[] z : sorting) {
                                boolean erstes = false;
                                for(int y : z){
                                    if(!erstes){
                                        System.out.print(y);
                                        erstes = true;
                                    }else{
                                        System.out.print(" " + y);
                                    }
                                    
                                }
                                System.out.println("");
            }
            nCases++;
        }
        
    }
 
   public static class SeparateChainingHashTable<AnyType>
{
    /**
     * Construct the hash table.
     */
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {
      
        //theLists = new LinkedList[ nextPrime( size ) ];
        theLists = new LinkedList[ size  ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ (Integer.parseInt(x.toString()))% theLists.length ];
       // System.out.println( x + " " +(Integer.parseInt(x.toString())) % theLists.length);
       // if( !whichList.contains( x ) )        {
            whichList.add( x );
            currentSize++;
                // Rehash; see Section 5.5
            /*if( ++currentSize > theLists.length )
                rehash( );*/
       // }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        System.out.println(myhash(x));
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
        
    }

  
    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );
       
        hashVal %= theLists.length;
        if( hashVal < 0 )
            hashVal += theLists.length;

        return hashVal;
    }
    
    private static final int DEFAULT_TABLE_SIZE = 101;
        /** The array of Lists. */
    private List<AnyType> [ ] theLists; 
    private int currentSize;

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }


        // Simple main
  /*  public static void main( String [ ] args )
    {
        SeparateChainingHashTable<Integer> H = new SeparateChainingHashTable<>( );

        long startTime = System.currentTimeMillis( );
        
        final int NUMS = 2000000;
        final int GAP  =   37;

        System.out.println( "Checking... (no more output means success)" );

        for( int i = GAP; i != 0; i = ( i + GAP ) % NUMS )
            H.insert( i );
        for( int i = 1; i < NUMS; i+= 2 )
            H.remove( i );

        for( int i = 2; i < NUMS; i+=2 )
            if( !H.contains( i ) )
                System.out.println( "Find fails " + i );

        for( int i = 1; i < NUMS; i+=2 )
        {
            if( H.contains( i ) )
                System.out.println( "OOPS!!! " +  i  );
        }
        
        long endTime = System.currentTimeMillis( );
        
        System.out.println( "Elapsed time: " + (endTime - startTime) );
    } 
    */
}
   
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemaA {
    
    public static void main (String[] args) throws FileNotFoundException{
        Scanner scan;
        File f = new File("A_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1;
        int t = Integer.parseInt(scan.nextLine());
        int currentCollisions = 0, minHash = 0, auxCollisions= 0 , iterator = 0, minK = 0, minCollisions = 0;
        LinkedList<Integer> saving = new LinkedList<>();
        LinkedList<SeparateChainingHashTable<Integer>> hashes= new LinkedList<>();
        LinkedList <int []>  sorting = new LinkedList<>();
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            saving.clear();
            hashes.clear();
            sorting.clear();
            String numbersAndHash = scan.nextLine();
            String l[] = numbersAndHash.split(" ");
            int numbers = Integer.parseInt(l[0]);
            int hash = Integer.parseInt(l[1]);
            String inputs = scan.nextLine();
            String m[] = inputs.split(" ");
            for (int j = 0; j < numbers; j++) {
                saving.add(Integer.parseInt(m[j]));
            }
            String inputHashes = scan.nextLine();
            String n[] = inputHashes.split(" ");
            for (int j = 0; j < hash; j++) {
                SeparateChainingHashTable<Integer> currentHash
                        = new SeparateChainingHashTable<>(Integer.parseInt(n[j]));
                hashes.add(currentHash);
            }
            for (int j = 0; j < hash; j++) {
                for (Integer a : saving) {
                    hashes.get(j).insert(a);
                }
            }
            minHash = 0; auxCollisions = 0; iterator = 0; currentCollisions = 0; minCollisions = 0; minK = 0;
            for (SeparateChainingHashTable<Integer> b : hashes) {
                currentCollisions = 0;
                for (List<Integer> c : b.theLists) {
                    if(c.size()>1){
                    //String sh ="";
                    currentCollisions += (c.size()-1);
                      /*  for (Integer d : c) {
                        sh += " " + d;
                        }*/
                    }
                    
                }
                if (iterator == 0) {
                    auxCollisions = currentCollisions;
                    minK = b.theLists.length;
                }
              //  System.out.println("ax " +auxCollisions  + " cC " + currentCollisions  + " minK " + minK + " " + b.theLists.length);
                if(auxCollisions > currentCollisions ){
                    minHash = iterator;
                    minK = b.theLists.length;
                    auxCollisions = currentCollisions;
                 
                }
                else if(auxCollisions == currentCollisions){
                            if(b.theLists.length < minK){
                            minHash = iterator;
                            minK = b.theLists.length; 
                            }
                        }
          //    System.out.println( " mh " + minHash + " i " + iterator);
             // System.out.println("Current c " + currentCollisions);
                iterator++;
            }
          //  System.out.println("min " + minHash); 
         //   System.out.println("");
            System.out.println(hashes.get(minHash).theLists.length);
            System.out.println(auxCollisions);
            
            for (List<Integer> d : hashes.get(minHash).theLists) {
                boolean firstT = false;
                
                if(d.size()>1){
                    String building ="";
                   
                             for (Integer e : d) {
                        if(!firstT){
                            building += e;
                            firstT = true;
                        }
                        else building += " " + e;
                        }
                       
                        String j[] = building.split(" ");
                        int [] tmp = new int [j.length];
                        for (int k = 0; k < j.length; k++) {
                        tmp[k] = Integer.parseInt(j[k]);
                    }
                       Arrays.sort(tmp);
                      sorting.add(tmp);
                      
                    }
            }
                for (int j = 0; j < sorting.size()-1; j++) {
                               try{ if(sorting.get(j)[0] > sorting.get(j+1)[0]){
                                    int [] copy = sorting.get(j+1);
                                    sorting.set(j+1, sorting.get(j));
                                    sorting.set(j, copy);
                                }
                               }catch(Exception e){
                                   
                               }
                            }
                            for (int[] z : sorting) {
                                boolean erstes = false;
                                for(int y : z){
                                    if(!erstes){
                                        System.out.print(y);
                                        erstes = true;
                                    }else{
                                        System.out.print(" " + y);
                                    }
                                    
                                }
                                System.out.println("");
            }
            nCases++;
        }
        
    }
 
   public static class SeparateChainingHashTable<AnyType>
{
    /**
     * Construct the hash table.
     */
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {
      
        //theLists = new LinkedList[ nextPrime( size ) ];
        theLists = new LinkedList[ size  ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ (Integer.parseInt(x.toString()))% theLists.length ];
       // System.out.println( x + " " +(Integer.parseInt(x.toString())) % theLists.length);
       // if( !whichList.contains( x ) )        {
            whichList.add( x );
            currentSize++;
                // Rehash; see Section 5.5
            /*if( ++currentSize > theLists.length )
                rehash( );*/
       // }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        System.out.println(myhash(x));
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
        
    }

  
    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );
       
        hashVal %= theLists.length;
        if( hashVal < 0 )
            hashVal += theLists.length;

        return hashVal;
    }
    
    private static final int DEFAULT_TABLE_SIZE = 101;
        /** The array of Lists. */
    private List<AnyType> [ ] theLists; 
    private int currentSize;

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }


        // Simple main
  /*  public static void main( String [ ] args )
    {
        SeparateChainingHashTable<Integer> H = new SeparateChainingHashTable<>( );

        long startTime = System.currentTimeMillis( );
        
        final int NUMS = 2000000;
        final int GAP  =   37;

        System.out.println( "Checking... (no more output means success)" );

        for( int i = GAP; i != 0; i = ( i + GAP ) % NUMS )
            H.insert( i );
        for( int i = 1; i < NUMS; i+= 2 )
            H.remove( i );

        for( int i = 2; i < NUMS; i+=2 )
            if( !H.contains( i ) )
                System.out.println( "Find fails " + i );

        for( int i = 1; i < NUMS; i+=2 )
        {
            if( H.contains( i ) )
                System.out.println( "OOPS!!! " +  i  );
        }
        
        long endTime = System.currentTimeMillis( );
        
        System.out.println( "Elapsed time: " + (endTime - startTime) );
    } 
    */
}
   
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaB {
     public static void main(String[] args) throws FileNotFoundException{
         Scanner scan;
        File f = new File("B_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1, supplies = 0;  
        Map<Integer,Integer> bag = new HashMap<>( );
        int t = Integer.parseInt(scan.nextLine());
         for (int i = 0; i < t; i++) {
             
             System.out.println("Case #" + nCases + ":");
             supplies = 0;    
             bag.clear();
             int ponds = Integer.parseInt(scan.nextLine());
             for (int j = 0; j < ponds; j++) {
                // System.out.println("----------------------------------------------------------------------------");
                String foodAndPokemon = scan.nextLine();
                String l[] = foodAndPokemon.split(" ");
                int food = Integer.parseInt(l[0]);
                int pokemon = Integer.parseInt(l[1]);
                if(!bag.containsKey(food)){
                    bag.put(food, 0);
                }else if (bag.containsKey(food)){
                    bag.put(food, (bag.get(food)+1));
                }
                
              
           
                /* System.out.println("bagsGetPokemon " + bag.get(pokemon));
                 
                    System.out.println(bag.entrySet());*/
                if(bag.containsKey(pokemon)){
                    if(bag.get(pokemon) > 0){
                        bag.put(pokemon, (bag.get(pokemon)-1));
                    }else if(bag.get(pokemon) ==  0){
                        bag.remove(pokemon);
                    }
                } else supplies++;
                
                   // System.out.println("food " + food +" pok " + pokemon + " sup " + supplies);
                // System.out.println(bag.entrySet());
               
                 
                
             }
             
             System.out.println(supplies);
             nCases++;
         }
     }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;

/**
 *
 */
public class ProblemaE {
     public static void main(String[] args) throws FileNotFoundException{
         Scanner scan;
        File f = new File("E_1.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1, supplies = 0;  
        Map<Integer,Integer> bag = new HashMap<>( );
        Map<Integer,Integer> mistyBag = new HashMap<>( );
        int t = Integer.parseInt(scan.nextLine());
         for (int i = 0; i < t; i++) {
             
             System.out.println("Case #" + nCases + ":");
             supplies = 0;    
             bag.clear();
             mistyBag.clear();
             int ponds = Integer.parseInt(scan.nextLine());
             for (int j = 0; j < ponds; j++) {
                // System.out.println("----------------------------------------------------------------------------");
                String foodAndPokemon = scan.nextLine();
                String l[] = foodAndPokemon.split(" ");
                int food = Integer.parseInt(l[0]);
                int pokemon = Integer.parseInt(l[1]);
                if(!bag.containsKey(food)){
                    bag.put(food, 0);
                }else if (bag.containsKey(food)){
                    bag.put(food, (bag.get(food)+1));
                }
                
              
           
                /* System.out.println("bagsGetPokemon " + bag.get(pokemon));
                 
                    System.out.println(bag.entrySet());*/
                if(bag.containsKey(pokemon)){
                    if(bag.get(pokemon) > 0){
                        bag.put(pokemon, (bag.get(pokemon)-1));
                    }else if(bag.get(pokemon) ==  0){
                        bag.remove(pokemon);
                    }
                } else{
                    
                    
                     if(!mistyBag.containsKey(pokemon)){
                    mistyBag.put(pokemon, 1);
                }else if (mistyBag.containsKey(pokemon)){
                    int s = mistyBag.get(pokemon)+1;
                    mistyBag.put(pokemon, s );
                         
                }
                  //  mistyBag.put(j, pokemon);
                    // System.out.println(mistyBag.entrySet());
                     supplies++;
                }
                 
                
                   // System.out.println("food " + food +" pok " + pokemon + " sup " + supplies);
                // System.out.println(bag.entrySet());
               
                 
                
             }
             int cMax = -1, cMin = 1000001, cMaxF = -1, cMinF = -1;
             for (Map.Entry<Integer, Integer> d : mistyBag.entrySet()) {
                 if(d.getValue() > cMax){
                     cMax = d.getValue();
                     cMaxF = d.getKey();
                 }
                 if(d.getValue() < cMin){
                     cMin = d.getValue();
                     cMinF = d.getKey();
                 }
                 
                 
             }

             for (Map.Entry<Integer, Integer> d : mistyBag.entrySet()) {
                // System.out.println(d.getKey() + " " + d.getValue());
                 if (d.getValue() == cMax){
                     if(cMaxF > d.getKey()){
                         cMaxF = d.getKey();
                     }
                 }
                 if (d.getValue() == cMin){
                     if(cMinF > d.getKey()){
                         cMinF = d.getKey();
                     }
                 }
             }
              
             if(supplies != 0){
             System.out.println(cMax + " " + cMaxF);
             System.out.println(cMin +" " + cMinF);
             }else if (supplies ==0){
                 System.out.println("-1");
             }
             nCases++;
         }
     }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemaA {
    
    public static void main (String[] args) throws FileNotFoundException{
        Scanner scan;
        File f = new File("A_1.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1;
        int t = Integer.parseInt(scan.nextLine());
        int currentCollisions = 0, minHash = 0, auxCollisions= 0 , iterator = 0, minK = 0, minCollisions = 0;
        ArrayList<Integer> saving = new ArrayList<>();
        ArrayList<SeparateChainingHashTable<Integer>> hashes= new ArrayList<>();
        LinkedList <int []>  sorting = new LinkedList<>();
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            saving.clear();
            hashes.clear();
            sorting.clear();
            String numbersAndHash = scan.nextLine();
            String l[] = numbersAndHash.split(" ");
            int numbers = Integer.parseInt(l[0]);
            int hash = Integer.parseInt(l[1]);
            String inputs = scan.nextLine();
            String m[] = inputs.split(" ");
            for (int j = 0; j < numbers; j++) {
                saving.add(Integer.parseInt(m[j]));
            }
            String inputHashes = scan.nextLine();
            String n[] = inputHashes.split(" ");
            for (int j = 0; j < hash; j++) {
                SeparateChainingHashTable<Integer> currentHash
                        = new SeparateChainingHashTable<>(Integer.parseInt(n[j]));
                hashes.add(currentHash);
            }
            for (int j = 0; j < hash; j++) {
                for (Integer a : saving) {
                    hashes.get(j).insert(a);
                }
            }
            minHash = 0; auxCollisions = 0; iterator = 0; currentCollisions = 0; minCollisions = 0; minK = 0;
            for (SeparateChainingHashTable<Integer> b : hashes) {
                currentCollisions = 0;
                for (List<Integer> c : b.theLists) {
                    if(c.size()>1){
                    //String sh ="";
                    currentCollisions += (c.size()-1);
                      /*  for (Integer d : c) {
                        sh += " " + d;
                        }*/
                    }
                    
                }
                if (iterator == 0) {
                    auxCollisions = currentCollisions;
                    minK = b.theLists.length;
                }
               // System.out.println("ax " +auxCollisions  + " cC " + currentCollisions  + " minK " + minK + " " + b.theLists.length);
                if(auxCollisions > currentCollisions ){
                    minHash = iterator;
                    minK = b.theLists.length;
                    auxCollisions = currentCollisions;
                 
                }
                else if(auxCollisions == currentCollisions){
                            if(b.theLists.length < minK){
                            minHash = iterator;
                            minK = b.theLists.length; 
                            }
                        }
             // System.out.println( " mh " + minHash + " i " + iterator);
            //  System.out.println("Current c " + currentCollisions);
                iterator++;
            }
          //  System.out.println("min " + minHash); 
         //   System.out.println("");
            System.out.println(hashes.get(minHash).theLists.length);
            System.out.println(auxCollisions);
            
            for (List<Integer> d : hashes.get(minHash).theLists) {
                boolean firstT = false;
                
                if(d.size()>1){
                    String building ="";
                   
                             for (Integer e : d) {
                        if(!firstT){
                            building += e;
                            firstT = true;
                        }
                        else building += " " + e;
                        }
                       
                        String j[] = building.split(" ");
                        int [] tmp = new int [j.length];
                        for (int k = 0; k < j.length; k++) {
                        tmp[k] = Integer.parseInt(j[k]);
                    }
                       Arrays.sort(tmp);
                      sorting.add(tmp);
                      
                    }
            }
                for (int j = 0; j < sorting.size()-1; j++) {
                               try{ if(sorting.get(j)[0] > sorting.get(j+1)[0]){
                                    int [] copy = sorting.get(j+1);
                                    sorting.set(j+1, sorting.get(j));
                                    sorting.set(j, copy);
                                }
                               }catch(Exception e){
                                   
                               }
                            }
                            for (int[] z : sorting) {
                                boolean erstes = false;
                                for(int y : z){
                                    if(!erstes){
                                        System.out.print(y);
                                        erstes = true;
                                    }else{
                                        System.out.print(" " + y);
                                    }
                                    
                                }
                                System.out.println("");
            }
            nCases++;
        }
        
    }
 
   public static class SeparateChainingHashTable<AnyType>
{
    /**
     * Construct the hash table.
     */
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {
      
        //theLists = new LinkedList[ nextPrime( size ) ];
        theLists = new LinkedList[ size  ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ (Integer.parseInt(x.toString()))% theLists.length ];
       // System.out.println( x + " " +(Integer.parseInt(x.toString())) % theLists.length);
       // if( !whichList.contains( x ) )        {
            whichList.add( x );
            currentSize++;
                // Rehash; see Section 5.5
            /*if( ++currentSize > theLists.length )
                rehash( );*/
       // }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        System.out.println(myhash(x));
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
        
    }

  
    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );
       
        hashVal %= theLists.length;
        if( hashVal < 0 )
            hashVal += theLists.length;

        return hashVal;
    }
    
    private static final int DEFAULT_TABLE_SIZE = 101;
        /** The array of Lists. */
    private List<AnyType> [ ] theLists; 
    private int currentSize;

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }


        // Simple main
  /*  public static void main( String [ ] args )
    {
        SeparateChainingHashTable<Integer> H = new SeparateChainingHashTable<>( );

        long startTime = System.currentTimeMillis( );
        
        final int NUMS = 2000000;
        final int GAP  =   37;

        System.out.println( "Checking... (no more output means success)" );

        for( int i = GAP; i != 0; i = ( i + GAP ) % NUMS )
            H.insert( i );
        for( int i = 1; i < NUMS; i+= 2 )
            H.remove( i );

        for( int i = 2; i < NUMS; i+=2 )
            if( !H.contains( i ) )
                System.out.println( "Find fails " + i );

        for( int i = 1; i < NUMS; i+=2 )
        {
            if( H.contains( i ) )
                System.out.println( "OOPS!!! " +  i  );
        }
        
        long endTime = System.currentTimeMillis( );
        
        System.out.println( "Elapsed time: " + (endTime - startTime) );
    } 
    */
}
   
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemaA {
    
    public static void main (String[] args) throws FileNotFoundException{
        Scanner scan;
        File f = new File("A_1.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1;
        int t = Integer.parseInt(scan.nextLine());
        int currentCollisions = 0, minHash = 0, auxCollisions= 0 , iterator = 0, minK = 0, minCollisions = 0;
        ArrayList<Integer> saving = new ArrayList<>();
        ArrayList<SeparateChainingHashTable<Integer>> hashes= new ArrayList<>();
        LinkedList <int []>  sorting = new LinkedList<>();
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            saving.clear();
            hashes.clear();
            sorting.clear();
            String numbersAndHash = scan.nextLine();
            String l[] = numbersAndHash.split(" ");
            int numbers = Integer.parseInt(l[0]);
            int hash = Integer.parseInt(l[1]);
            String inputs = scan.nextLine();
            String m[] = inputs.split(" ");
            for (int j = 0; j < numbers; j++) {
                saving.add(Integer.parseInt(m[j]));
            }
            String inputHashes = scan.nextLine();
            String n[] = inputHashes.split(" ");
            for (int j = 0; j < hash; j++) {
                SeparateChainingHashTable<Integer> currentHash
                        = new SeparateChainingHashTable<>(Integer.parseInt(n[j]));
                hashes.add(currentHash);
            }
            for (Integer n1 : saving) {
                hashes.get(0).insert(n1);
            }
            
            for (int j = 1; j < hash; j++) {
                for (Integer a : saving) {
                    hashes.get(j).insert(a);
                    minHash = 0; auxCollisions = 0; iterator = 0; currentCollisions = 0; minCollisions = 0; minK = 0;
                    for (SeparateChainingHashTable<Integer> b : hashes) {
                currentCollisions = 0;
                for (List<Integer> c : b.theLists) {
                    if(c.size()>1){
                    //String sh ="";
                    currentCollisions += (c.size()-1);
                      /*  for (Integer d : c) {
                        sh += " " + d;
                        }*/
                    }
                    
                }
                if (iterator == 0) {
                    auxCollisions = currentCollisions;
                    minK = b.theLists.length;
                }
               // System.out.println("ax " +auxCollisions  + " cC " + currentCollisions  + " minK " + minK + " " + b.theLists.length);
                if(auxCollisions > currentCollisions ){
                    minHash = iterator;
                    minK = b.theLists.length;
                    auxCollisions = currentCollisions;
                    
                 
                }
                else if(auxCollisions == currentCollisions){
                            if(b.theLists.length < minK){
                            minHash = iterator;
                            minK = b.theLists.length; 
                            }
                        }
             // System.out.println( " mh " + minHash + " i " + iterator);
            //  System.out.println("Current c " + currentCollisions);
                iterator++;
            }
                   if(minK == 0) hashes.remove(1);
                   if(minK == 1) hashes.remove(0);
                }
            }
            
           /* for (SeparateChainingHashTable<Integer> b : hashes) {
                currentCollisions = 0;
                for (List<Integer> c : b.theLists) {
                    if(c.size()>1){
                    //String sh ="";
                    currentCollisions += (c.size()-1);
                      /*  for (Integer d : c) {
                        sh += " " + d;
                        }*/
                 /*   }
                    
                }
                if (iterator == 0) {
                    auxCollisions = currentCollisions;
                    minK = b.theLists.length;
                }
               // System.out.println("ax " +auxCollisions  + " cC " + currentCollisions  + " minK " + minK + " " + b.theLists.length);
                if(auxCollisions > currentCollisions ){
                    minHash = iterator;
                    minK = b.theLists.length;
                    auxCollisions = currentCollisions;
                 
                }
                else if(auxCollisions == currentCollisions){
                            if(b.theLists.length < minK){
                            minHash = iterator;
                            minK = b.theLists.length; 
                            }
                        }
             // System.out.println( " mh " + minHash + " i " + iterator);
            //  System.out.println("Current c " + currentCollisions);
                iterator++;
            }*/
          //  System.out.println("min " + minHash); 
         //   System.out.println("");
            System.out.println(hashes.get(minHash).theLists.length);
            System.out.println(auxCollisions);
            
            for (List<Integer> d : hashes.get(minHash).theLists) {
                boolean firstT = false;
                
                if(d.size()>1){
                    String building ="";
                   
                             for (Integer e : d) {
                        if(!firstT){
                            building += e;
                            firstT = true;
                        }
                        else building += " " + e;
                        }
                       
                        String j[] = building.split(" ");
                        int [] tmp = new int [j.length];
                        for (int k = 0; k < j.length; k++) {
                        tmp[k] = Integer.parseInt(j[k]);
                    }
                       Arrays.sort(tmp);
                      sorting.add(tmp);
                      
                    }
            }
                for (int j = 0; j < sorting.size()-1; j++) {
                               try{ if(sorting.get(j)[0] > sorting.get(j+1)[0]){
                                    int [] copy = sorting.get(j+1);
                                    sorting.set(j+1, sorting.get(j));
                                    sorting.set(j, copy);
                                }
                               }catch(Exception e){
                                   
                               }
                            }
                            for (int[] z : sorting) {
                                boolean erstes = false;
                                for(int y : z){
                                    if(!erstes){
                                        System.out.print(y);
                                        erstes = true;
                                    }else{
                                        System.out.print(" " + y);
                                    }
                                    
                                }
                                System.out.println("");
            }
            nCases++;
        }
        
    }
 
   public static class SeparateChainingHashTable<AnyType>
{
    /**
     * Construct the hash table.
     */
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {
      
        //theLists = new LinkedList[ nextPrime( size ) ];
        theLists = new LinkedList[ size  ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ (Integer.parseInt(x.toString()))% theLists.length ];
       // System.out.println( x + " " +(Integer.parseInt(x.toString())) % theLists.length);
       // if( !whichList.contains( x ) )        {
            whichList.add( x );
            currentSize++;
                // Rehash; see Section 5.5
            /*if( ++currentSize > theLists.length )
                rehash( );*/
       // }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        System.out.println(myhash(x));
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
        
    }

  
    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );
       
        hashVal %= theLists.length;
        if( hashVal < 0 )
            hashVal += theLists.length;

        return hashVal;
    }
    
    private static final int DEFAULT_TABLE_SIZE = 101;
        /** The array of Lists. */
    private List<AnyType> [ ] theLists; 
    private int currentSize;

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }


        // Simple main
  /*  public static void main( String [ ] args )
    {
        SeparateChainingHashTable<Integer> H = new SeparateChainingHashTable<>( );

        long startTime = System.currentTimeMillis( );
        
        final int NUMS = 2000000;
        final int GAP  =   37;

        System.out.println( "Checking... (no more output means success)" );

        for( int i = GAP; i != 0; i = ( i + GAP ) % NUMS )
            H.insert( i );
        for( int i = 1; i < NUMS; i+= 2 )
            H.remove( i );

        for( int i = 2; i < NUMS; i+=2 )
            if( !H.contains( i ) )
                System.out.println( "Find fails " + i );

        for( int i = 1; i < NUMS; i+=2 )
        {
            if( H.contains( i ) )
                System.out.println( "OOPS!!! " +  i  );
        }
        
        long endTime = System.currentTimeMillis( );
        
        System.out.println( "Elapsed time: " + (endTime - startTime) );
    } 
    */
}
   
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ProyectoVI;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class ProblemaA {
    
    public static void main (String[] args) throws FileNotFoundException{
        Scanner scan;
        File f = new File("A_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
	} else {
            scan = new Scanner(System.in);
	}
        int nCases = 1;
        int t = Integer.parseInt(scan.nextLine());
        int currentCollisions = 0, minHash = 0, auxCollisions= 0 , iterator = 0, minK = 0, minCollisions = 0;
        ArrayList<Integer> saving = new ArrayList<>();
        ArrayList<SeparateChainingHashTable<Integer>> hashes= new ArrayList<>();
        LinkedList <int []>  sorting = new LinkedList<>();
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            saving.clear();
            hashes.clear();
            sorting.clear();
            String numbersAndHash = scan.nextLine();
            String l[] = numbersAndHash.split(" ");
            int numbers = Integer.parseInt(l[0]);
            int hash = Integer.parseInt(l[1]);
            String inputs = scan.nextLine();
            String m[] = inputs.split(" ");
            for (int j = 0; j < numbers; j++) {
                saving.add(Integer.parseInt(m[j]));
            }
            String inputHashes = scan.nextLine();
            String n[] = inputHashes.split(" ");
            for (int j = 0; j < hash; j++) {
                SeparateChainingHashTable<Integer> currentHash
                        = new SeparateChainingHashTable<>(Integer.parseInt(n[j]));
                hashes.add(currentHash);
            }
            for (int j = 0; j < hash; j++) {
                for (Integer a : saving) {
                    hashes.get(j).insert(a);
                }
            }
            minHash = 0; auxCollisions = 0; iterator = 0; currentCollisions = 0; minCollisions = 0; minK = 0;
            for (SeparateChainingHashTable<Integer> b : hashes) {
                currentCollisions = 0;
                for (List<Integer> c : b.theLists) {
                    if(c.size()>1){
                    //String sh ="";
                    currentCollisions += (c.size()-1);
                      /*  for (Integer d : c) {
                        sh += " " + d;
                        }*/
                    }
                    
                }
                if (iterator == 0) {
                    auxCollisions = currentCollisions;
                    minK = b.theLists.length;
                }
               // System.out.println("ax " +auxCollisions  + " cC " + currentCollisions  + " minK " + minK + " " + b.theLists.length);
                if(auxCollisions > currentCollisions ){
                    minHash = iterator;
                    minK = b.theLists.length;
                    auxCollisions = currentCollisions;
                 
                }
                else if(auxCollisions == currentCollisions){
                            if(b.theLists.length < minK){
                            minHash = iterator;
                            minK = b.theLists.length; 
                            }
                        }
             // System.out.println( " mh " + minHash + " i " + iterator);
            //  System.out.println("Current c " + currentCollisions);
                iterator++;
            }
          //  System.out.println("min " + minHash); 
         //   System.out.println("");
            System.out.println(hashes.get(minHash).theLists.length);
            System.out.println(auxCollisions);
            
            for (List<Integer> d : hashes.get(minHash).theLists) {
                boolean firstT = false;
                
                if(d.size()>1){
                    String building ="";
                   
                             for (Integer e : d) {
                        if(!firstT){
                            building += e;
                            firstT = true;
                        }
                        else building += " " + e;
                        }
                       
                        String j[] = building.split(" ");
                        int [] tmp = new int [j.length];
                        for (int k = 0; k < j.length; k++) {
                        tmp[k] = Integer.parseInt(j[k]);
                    }
                       Arrays.sort(tmp);
                      sorting.add(tmp);
                      
                    }
            }
                for (int j = 0; j < sorting.size()-1; j++) {
                               try{ for(int x = 0; j < sorting.size()-1; j++){if(sorting.get(j)[x] > sorting.get(j+1)[x]){
                                    int [] copy = sorting.get(j+1);
                                    sorting.set(j+1, sorting.get(j));
                                    sorting.set(j, copy);
                                }}
                               
                               }catch(Exception e){
        
                               }
                            }
                            for (int[] z : sorting) {
                                boolean erstes = false;
                                for(int y : z){
                                    if(!erstes){
                                        System.out.print(y);
                                        erstes = true;
                                    }else{
                                        System.out.print(" " + y);
                                    }
                                    
                                }
                                System.out.println("");
            }
            nCases++;
        }
        
    }
 
   public static class SeparateChainingHashTable<AnyType>
{
    /**
     * Construct the hash table.
     */
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {
      
        //theLists = new LinkedList[ nextPrime( size ) ];
        theLists = new LinkedList[ size  ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ (Integer.parseInt(x.toString()))% theLists.length ];
       // System.out.println( x + " " +(Integer.parseInt(x.toString())) % theLists.length);
       // if( !whichList.contains( x ) )        {
            whichList.add( x );
            currentSize++;
                // Rehash; see Section 5.5
            /*if( ++currentSize > theLists.length )
                rehash( );*/
       // }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        System.out.println(myhash(x));
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
        
    }

  
    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );
       
        hashVal %= theLists.length;
        if( hashVal < 0 )
            hashVal += theLists.length;

        return hashVal;
    }
    
    private static final int DEFAULT_TABLE_SIZE = 101;
        /** The array of Lists. */
    private List<AnyType> [ ] theLists; 
    private int currentSize;

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }


        // Simple main
  /*  public static void main( String [ ] args )
    {
        SeparateChainingHashTable<Integer> H = new SeparateChainingHashTable<>( );

        long startTime = System.currentTimeMillis( );
        
        final int NUMS = 2000000;
        final int GAP  =   37;

        System.out.println( "Checking... (no more output means success)" );

        for( int i = GAP; i != 0; i = ( i + GAP ) % NUMS )
            H.insert( i );
        for( int i = 1; i < NUMS; i+= 2 )
            H.remove( i );

        for( int i = 2; i < NUMS; i+=2 )
            if( !H.contains( i ) )
                System.out.println( "Find fails " + i );

        for( int i = 1; i < NUMS; i+=2 )
        {
            if( H.contains( i ) )
                System.out.println( "OOPS!!! " +  i  );
        }
        
        long endTime = System.currentTimeMillis( );
        
        System.out.println( "Elapsed time: " + (endTime - startTime) );
    } 
    */
}
   
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.*;


/**
 *
 */
public class ProblemaC {
    
    public static void main(String[] args) throws FileNotFoundException{
     Scanner scan;
	File f = new File("C_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
           // System.setOut(new PrintStream(new File("salida.out")));
	} else {
            scan = new Scanner(System.in);
	}
        int t = Integer.parseInt(scan.nextLine());
        int nCases = 1;
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            String data = scan.nextLine();
            String[] l = data.split(" ");
            int cellsInMaze = Integer.parseInt(l[0]);
            int outCell = Integer.parseInt(l[1]);
            int maxTime = Integer.parseInt(l[2]);
            int commands = Integer.parseInt(scan.nextLine());
            Edge[] edges = new Edge[commands];
            for (int j = 0; j < commands; j++) {
                String dataII = scan.nextLine();
                String[] m = dataII.split(" ");
                
                Edge currentEdge = new Edge(Integer.parseInt(m[0]),
                Integer.parseInt(m[1]), Integer.parseInt(m[2]));
                    edges[j] = currentEdge;
                 /*Graph.Edge[] GRAPH = {
                new Graph.Edge(0,  2, 7),
                    new Graph.Edge(0, 1, 2),
                    new Graph.Edge(1, 3, 1),
                new Graph.Edge(3, 2, 2),
            new Graph.Edge(4, 1, 3),
            new Graph.Edge(4, 3, 6),
                new Graph.Edge(5, 5, 0),
                // new Graph.Edge(3, 2, 1),
                        };*/
            }
            
            
            Graph g = new Graph(edges);
            int answer = 0;
            for (int j = 0; j < cellsInMaze; j++) {
                g.dijkstra(j);
               int a =  g.printPath(outCell);
                if(a<= maxTime) answer++;
            }
            System.out.println(answer);
                //g.dijkstra(START);
           // int a =  g.printPath(END);
            nCases++;
            
        }
       
    }
    
    
     public static class Edge {
      public final int v1, v2;
      public final int dist;
      public Edge(int v1, int v2, int dist) {
         this.v1 = v1;
         this.v2 = v2;
         this.dist = dist;
      }
      
   }
     
     public static class Vertex implements Comparable<Vertex> {
      public final int name;
      public int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity
      public Vertex previous = null;
      public final Map<Vertex, Integer> neighbours = new HashMap<>();
 
      public Vertex(int name) {
         this.name = name;
      }
 
      private int printPath() {
          int current = 0;
          
         if (this == this.previous) {
           // System.out.printf("%s", this.name);
          //  current = this.name;
         } else if (this.previous == null) {
           // System.out.printf("%s(unreached)", this.name);
            current = -1;
         } else {
           this.previous.printPath();
            current = current + this.dist;
           // System.out.printf(" -> %s(%d)", this.name, this.dist);
         }
         return current;
      }
 
      public int compareTo(Vertex other) {
         return Integer.compare(dist, other.dist);
      }
   }
  
public static class Graph {
   private final Map<Integer, Vertex> graph; // mapping of vertex names to Vertex objects, built from a set of Edges
 
   /** One edge of the graph (only used by Graph constructor) */
  
 
   /** One vertex of the graph, complete with mappings to neighbouring vertices */
   
 
   /** Builds a graph from a set of edges */
   public Graph(Edge[] edges) {
      graph = new HashMap<>(edges.length);
 
      //one pass to find all vertices
      for (Edge e : edges) {
         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));
         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));
      }
 
      //another pass to set neighbouring vertices
      for (Edge e : edges) {
         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
         //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph
      }
   }
 
   /** Runs dijkstra using a specified source vertex */ 
   public void dijkstra(int startName) {
      if (!graph.containsKey(startName)) {
         System.err.printf("Graph doesn't contain start vertex \"%s\"\n", startName);
         return;
      }
      final Vertex source = graph.get(startName);
      NavigableSet<Vertex> q = new TreeSet<>();
 
      // set-up vertices
      for (Vertex v : graph.values()) {
         v.previous = v == source ? source : null;
         v.dist = v == source ? 0 : Integer.MAX_VALUE;
         q.add(v);
      }
 
      dijkstra(q);
   }
 
   /** Implementation of dijkstra's algorithm using a binary heap. */
   private void dijkstra(final NavigableSet<Vertex> q) {      
      Vertex u, v;
      while (!q.isEmpty()) {
 
         u = q.pollFirst(); // vertex with shortest distance (first iteration will return source)
         if (u.dist == Integer.MAX_VALUE) break; // we can ignore u (and any other remaining vertices) since they are unreachable
 
         //look at distances to each neighbour
         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
            v = a.getKey(); //the neighbour in this iteration
 
            final int alternateDist = u.dist + a.getValue();
            if (alternateDist < v.dist) { // shorter path to neighbour found
               q.remove(v);
               v.dist = alternateDist;
               v.previous = u;
               q.add(v);
            } 
         }
      }
   }
 
   /** Prints a path from the source to the specified vertex */
   public int printPath(int endName) {
       int current = 0;
      if (!graph.containsKey(endName)) {
         System.err.printf("Graph doesn't contain end vertex \"%s\"\n", endName);
         return -1;
      }
 
      current = current + graph.get(endName).printPath();
      //System.out.println();
      return current;
   }
   /** Prints the path from the source to every vertex (output order is not guaranteed) */
   public ArrayList<Integer> printAllPaths() {
       ArrayList<Integer> answer = new ArrayList<>();
      for (Vertex v : graph.values()) {
         int total = v.printPath();
          System.out.println("");
          System.out.println("current" + total);
          answer.add(total);

      }
      return answer;
   }
}


}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.util.*;
import java.io.*;

public class ProblemaAIV {
    Nodo [] lista;
	int size;
    
    ProblemaAIV(int n){
		size = n;
        lista = new Nodo[n];
        for(int i = 0; i < n; ++i ) lista[i] = new Nodo();
    }
    
    public void agregarArista(int i, int j){
        lista[i].array.add(j);
        lista[j].array.add(i);
    }
	
	public Nodo get(int a){
		return lista[a];
	}
	
	public int size(){
		return size;
	}
	
	public void desVisitar(){
		for(int i=0; i<size; i++) lista[i].desVisitar();
	}
	
	static class Nodo{
		boolean visitado;
		ArrayList<Integer> array;
		
		Nodo(){
			visitado = false;
			array = new ArrayList<Integer>();
		}
		
		public boolean esVisitado(){
			return visitado;
		}
		
		public void visitar(){
			visitado = true;
		}
		
		public ArrayList<Integer> getList(){
			return array;
		}
		
		public void desVisitar(){
			visitado = false;
		}
	}
	
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int casos = sc.nextInt();
		for(int caso = 1; caso<=casos; caso++){
			System.out.println("Test #" + caso +":");
			ProblemaAIV hola = new ProblemaAIV(sc.nextInt());
			for(int i=sc.nextInt(); i>0; i--)
				hola.agregarArista(sc.nextInt(), sc.nextInt());
			int inicio = sc.nextInt();
			int alcanzados = 0;
			Queue<Integer> q = new LinkedList<Integer>();
			hola.get(inicio).visitar();
			q.add(inicio);
			while(!q.isEmpty()){
				int y = q.remove();
				ArrayList<Integer> a = hola.get(y).getList();
				for(int s: hola.get(y).getList())
					if(hola.get(s).esVisitado() == false){
						q.add(s);
						hola.get(s).visitar();
						alcanzados++;
					}
			}
			System.out.println(alcanzados);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.util.*;
import java.io.*;

public class ProblemaBIII {
    
    public static class Node{
        int input = 0;
        boolean visited = false;
        LinkedList<String> neighbours = new LinkedList<>();
    }

    public static void main(String[] args) throws Exception {
        //final long startTime = System.currentTimeMillis();
        Scanner scan;
        File f = new File("B_7.txt");
        if (f.exists())scan = new Scanner(f);
        else  scan = new Scanner(System.in);
        int t = Integer.parseInt(scan.nextLine());
        int nCases = 1;
        while (t>0) {
            String[] data = scan.nextLine().split(" ");
            boolean [][] subjects= new boolean [Integer.parseInt(data[0])][Integer.parseInt(data[0])];
            for(int i = 0; i < Integer.parseInt(data[1]); i++){
                String[] u = scan.nextLine().split(" ");
                subjects[Integer.parseInt(u[0])][Integer.parseInt(u[1])] = true;
            }LinkedList<Integer> queue = new LinkedList<>();
            Set<Integer> visited = new HashSet<>();
            System.out.println("Case #" + nCases + ":");
            for (int i = 0; i < Integer.parseInt(data[0]); i++) {
                boolean v = true;
                for (int j = 0; j < Integer.parseInt(data[0]); j++) {
                    if(subjects[j][i]){
                        v = false;
                        break;
                    }
                }if(v) queue.add(i);
            else{
                boolean auxAnswer = true;
                while (!queue.isEmpty()) {
                    int a = queue.remove(0);
                    for (int i = 0; i < Integer.parseInt(data[0]); i++) {
                        subjects[a][i] = false;
                        visited.add(a);
                    }for (int i = 0; i < Integer.parseInt(data[0]); i++) {
                        boolean answer = true;
                        for (int j = 0; j < Integer.parseInt(data[0]); j++) {
                            if(visited.contains(i)) {
                                answer = false;
                                break;
                            }if(subjects[j][i]){
                                answer = false;
                                break;
                            }
                        }if(answer) queue.add(i);
                    }if(queue.size() > 1) {
                        auxAnswer = false;
                        break;
                    }
                }if(auxAnswer) System.out.println("Deberia empezar a estudiar");
            }t--;
            nCases++;
        }/*final long duration = System.currentTimeMillis() - startTime;
        System.out.println("Complexity " + duration);*/
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.util.*;
import java.io.*;

public class ProblemaAIV {
    Nodo [] lista;
	int size;
    
    ProblemaAIV(int n){
		size = n;
        lista = new Nodo[n];
        for(int i = 0; i < n; ++i ) lista[i] = new Nodo();
    }
    
    public void agregarArista(int i, int j){
        lista[i].array.add(j);
        lista[j].array.add(i);
    }
	
	public Nodo get(int a){
		return lista[a];
	}
	
	public int size(){
		return size;
	}
	
	public void desVisitar(){
		for(int i=0; i<size; i++) lista[i].desVisitar();
	}
	
	static class Nodo{
		boolean visitado;
		ArrayList<Integer> array;
		
		Nodo(){
			visitado = false;
			array = new ArrayList<Integer>();
		}
		
		public boolean esVisitado(){
			return visitado;
		}
		
		public void visitar(){
			visitado = true;
		}
		
		public ArrayList<Integer> getList(){
			return array;
		}
		
		public void desVisitar(){
			visitado = false;
		}
	}
	
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int casos = sc.nextInt();
		for(int caso = 1; caso<=casos; caso++){
			System.out.println("Test #" + caso +":");
			ProblemaAIV hola = new ProblemaAIV(sc.nextInt());
			for(int i=sc.nextInt(); i>0; i--)
				hola.agregarArista(sc.nextInt(), sc.nextInt());
			int inicio = sc.nextInt();
			int alcanzados = 0;
			Queue<Integer> q = new LinkedList<Integer>();
			hola.get(inicio).visitar();
			q.add(inicio);
			while(!q.isEmpty()){
				int y = q.remove();
				ArrayList<Integer> a = hola.get(y).getList();
				for(int s: hola.get(y).getList())
					if(hola.get(s).esVisitado() == false){
						q.add(s);
						hola.get(s).visitar();
						alcanzados++;
					}
			}
			System.out.println(alcanzados);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.ArrayList;

public class ProblemaCII {



	
	public static void main(String[] args) throws FileNotFoundException  {
		Scanner scan;
		File f = new File( "AG3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "AG2_Out1.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int t = Integer.parseInt( scan.nextLine() );
		
		for ( int test = 0; test < t; test++ ) {
			

			ArrayList<Vertex> Graph=new ArrayList<Vertex>();
			
			String line[] = scan.nextLine().split( " " );
			int numberOfCells = Integer.parseInt( line[0] );
			int outCell = Integer.parseInt( line[1] );
			long maxTime= Integer.parseInt( line[2] );
			
			line = scan.nextLine().split( " " );
			int connections = Integer.parseInt( line[0] );
			
			int resultado=0;
			
			for (int i = 0; i < numberOfCells; i++) {
				
				Graph.add(new Vertex(i) );
				
			}
			
			
			
			for ( int i = 0; i < connections; i++ ) {//conexiones
			 line = scan.nextLine().split( " " );
			 	int firstVertex = Integer.parseInt( line[0] );
				int secondVertex = Integer.parseInt( line[1] );
				int cost = Integer.parseInt( line[2] );
				Vertex cellA=Graph.get(firstVertex);
				Vertex cellB=Graph.get(secondVertex);
				
				cellA.list.add(cellB);
				cellA.distance.put(cellB.id, cost);
				//temaV.lista.add(temaU);
			
				
				
				
			}
			
//			for (int i = 0; i < grafo.size(); i++) {
//				
//				Vertice vertice=grafo.get(i);
//				
//				vertice.outdegree=vertice.lista.size();			
//			
//				
//			}
		for (int i = 0; i < Graph.size(); i++) {
			Vertex x=Graph.get(i);
			try {
				dijkstra(x,Graph);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			if (Graph.get(outCell).distances<=maxTime) {//&&!x.equals(grafo.get(E))
				resultado++;
			}
		}	
				
			
			
			
			
				System.out.println("Case #"+(test+1)+":");
				System.out.println(resultado);
				
		}//fincasos
		scan.close();
	}//finmain
	
	
	
	
		
	
	public static class Vertex implements Comparable<Vertex> {
		
		
		int id,			
			indegree,
			outdegree;
		boolean known;
		long distances;
		ArrayList<Vertex> list;
		TreeMap<Integer,Integer> distance;
		public Vertex(int nombre){
			
			this.id=nombre;
			indegree=0;
			outdegree=0;
			list=new ArrayList<Vertex>();
			distance=new TreeMap<Integer,Integer>();
			known=false;
			distances=10000001;
			
		}

		@Override
		public int compareTo(Vertex a) {
			
			if(distances<a.distances)return -1;
			
			if(distances>a.distances)return 1;	
			
			return 0;
		}
	}
		
				
	 static void dijkstra(Vertex s,ArrayList<Vertex> grafo) {
		for (int i = 0; i < grafo.size(); i++) {
		
		Vertex x=grafo.get(i);
		x.distances=10000001;
		x.known=false;
	}
	
		s.distances=0;
		
		
		
		BinaryHeap<Vertex> unknown=new BinaryHeap<Vertex>();
		unknown.insert(s);
	
		while(!unknown.isEmpty()){
			Vertex v = null;
			
			try {
				v = unknown.deleteMin();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			v.known=true;
			
			for (int i = 0; i < v.list.size(); i++) {
			
				Vertex	w=v.list.get(i);
				
				if(!w.known){
					int distanciavw=v.distance.get(w.id);
					if(v.distances+distanciavw<w.distances){
					w.distances=distanciavw+v.distances;
					unknown.insert(w);
					}
				}
			
			}
			
		}
		
	}

	
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    @SuppressWarnings("unchecked")
		public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    @SuppressWarnings("unchecked")
		public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    @SuppressWarnings("unchecked")
		private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }

	        // Test program
	    public static void main( String [ ] args )
	    {
	        int numItems = 10000;
	        BinaryHeap<Integer> h = new BinaryHeap<>( );
	        int i = 37;

	        for( i = 37; i != 0; i = ( i + 37 ) % numItems )
	            h.insert( i );
	        for( i = 1; i < numItems; i++ )
				try {
					if( h.deleteMin( ) != i )
					    System.out.println( "Oops! " + i );
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
	    }
	}


	


	
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.util.*;
import java.io.*;

public class ProblemaAIII {

    public static void main(String[] args) throws Exception {
        //final long startTime = System.currentTimeMillis();
        Scanner scan;
        File f = new File("A_1.txt");
        if (f.exists())scan = new Scanner(f);
        else  scan = new Scanner(System.in);
        int t = Integer.parseInt(scan.nextLine());
        int nCases = 1;
        while (t>0){
            String[] pathAndStations = scan.nextLine().split(" ");
            boolean [][] stations= new boolean [Integer.parseInt(pathAndStations[0])][Integer.parseInt(pathAndStations[0])];
            for(int i = 0; i < Integer.parseInt(pathAndStations[1]); i++){
                String[] u = scan.nextLine().split(" ");
                stations[Integer.parseInt(u[0])][Integer.parseInt(u[1])] = true;
                stations[Integer.parseInt(u[1])][Integer.parseInt(u[0])] = true;
            }int key = Integer.parseInt(scan.nextLine());
            int answer = 0;
            LinkedList<Integer> queue = new LinkedList<>();
            Set<Integer> visited = new HashSet<>();
            queue.add(key);
            visited.add(key);
            while(!queue.isEmpty()){
                int current = queue.remove(0);
                for (int i = 0; i < Integer.parseInt(pathAndStations[0]) ; i++) {
                    if(stations[current][i] && !visited.contains(i)){
                        queue.add(i);
                        visited.add(i);
                        answer++;
                    }
                }
            }System.out.println("Case #" + nCases + ":");
            System.out.println(answer);
            t--;
            nCases++;
        }/*final long duration = System.currentTimeMillis() - startTime;
        System.out.println("Complexity " + duration);*/
    }
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.TreeSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;



public class ProblemaAV {



	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File( "AG3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "AG2_Out1.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int casos = Integer.parseInt( scan.nextLine() );
		
		for ( int test = 0; test < casos; test++ ) {
			
			HashMap<Integer, ArrayList<Integer>> grafo=new HashMap<>();
			
			
			String line[] = scan.nextLine().split( " " );
			int N = Integer.parseInt( line[0] );//estaciones
			int M = Integer.parseInt( line[1] );//vias
			for (int i = 0; i < N; i++) {
				
				grafo.put(i, new ArrayList<Integer>());
			}
			
			
			
			for ( int i = 0; i < M; i++ ) {
			 line = scan.nextLine().split( " " );
			 	int u = Integer.parseInt( line[0] );//estacion 1
				int v = Integer.parseInt( line[1] );//estacion 2
				
				grafo.get(u).add(v);
				grafo.get(v).add(u);
				
				
				
			}
			line = scan.nextLine().split( " " );
			int vertice=Integer.parseInt( line[0] );
			
			
				System.out.println("Case #"+(test+1)+":");
				int x=BFS(vertice,grafo);
				System.out.println(x);
				

				
				
			
				
		}//fincasos
		scan.close();
	}//finmain
	
	
	





	

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static int BFS(int nodo,HashMap<Integer, ArrayList<Integer>> grafo)    
	{ 
		
		int counter=0;
	 Queue <Integer> queue =  new LinkedList<>(); 
	
	 queue.add(nodo);
	 TreeSet<Integer> lista=new TreeSet();
	
	 while (!queue.isEmpty())
	 {
		 int x=queue.poll(); lista.add(x);

		 if(!grafo.get(x).isEmpty())
		 for (int i = 0; i < grafo.get(x).size(); i++) {
			 
			 if(!lista.contains(grafo.get(x).get(i))){
				 
				 lista.add(grafo.get(x).get(i));	 
				 queue.add(grafo.get(x).get(i));
				 counter++;
			 
			 }
		}
		
	 }
	 return counter;
	}


	
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.ArrayList;

public class ProblemaCII {



	
	public static void main(String[] args) throws FileNotFoundException  {
		Scanner scan;
		File f = new File( "AG3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "AG2_Out1.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int t = Integer.parseInt( scan.nextLine() );
		
		for ( int test = 0; test < t; test++ ) {
			

			ArrayList<Vertex> Graph=new ArrayList<Vertex>();
			
			String line[] = scan.nextLine().split( " " );
			int numberOfCells = Integer.parseInt( line[0] );
			int outCell = Integer.parseInt( line[1] );
			long maxTime= Integer.parseInt( line[2] );
			
			line = scan.nextLine().split( " " );
			int connections = Integer.parseInt( line[0] );
			
			int resultado=0;
			
			for (int i = 0; i < numberOfCells; i++) {
				
				Graph.add(new Vertex(i) );
				
			}
			
			
			
			for ( int i = 0; i < connections; i++ ) {//conexiones
			 line = scan.nextLine().split( " " );
			 	int firstVertex = Integer.parseInt( line[0] );
				int secondVertex = Integer.parseInt( line[1] );
				int cost = Integer.parseInt( line[2] );
				Vertex cellA=Graph.get(firstVertex);
				Vertex cellB=Graph.get(secondVertex);
				
				cellA.list.add(cellB);
				cellA.distance.put(cellB.id, cost);
				//temaV.lista.add(temaU);
			
				
				
				
			}
			
//			for (int i = 0; i < grafo.size(); i++) {
//				
//				Vertice vertice=grafo.get(i);
//				
//				vertice.outdegree=vertice.lista.size();			
//			
//				
//			}
		for (int i = 0; i < Graph.size(); i++) {
			Vertex x=Graph.get(i);
			try {
				dijkstra(x,Graph);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			if (Graph.get(outCell).distances<=maxTime) {//&&!x.equals(grafo.get(E))
				resultado++;
			}
		}	
				
			
			
			
			
				System.out.println("Case #"+(test+1)+":");
				System.out.println(resultado);
				
		}//fincasos
		scan.close();
	}//finmain
	
	
	
	
		
	
	public static class Vertex implements Comparable<Vertex> {
		
		
		int id,			
			indegree,
			outdegree;
		boolean known;
		long distances;
		ArrayList<Vertex> list;
		TreeMap<Integer,Integer> distance;
		public Vertex(int nombre){
			
			this.id=nombre;
			indegree=0;
			outdegree=0;
			list=new ArrayList<Vertex>();
			distance=new TreeMap<Integer,Integer>();
			known=false;
			distances=10000001;
			
		}

		@Override
		public int compareTo(Vertex a) {
			
			if(distances<a.distances)return -1;
			
			if(distances>a.distances)return 1;	
			
			return 0;
		}
	}
		
				
	 static void dijkstra(Vertex s,ArrayList<Vertex> grafo) {
		for (int i = 0; i < grafo.size(); i++) {
		
		Vertex x=grafo.get(i);
		x.distances=10000001;
		x.known=false;
	}
	
		s.distances=0;
		
		
		
		BinaryHeap<Vertex> unknown=new BinaryHeap<Vertex>();
		unknown.insert(s);
	
		while(!unknown.isEmpty()){
			Vertex v = null;
			
			try {
				v = unknown.deleteMin();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			v.known=true;
			
			for (int i = 0; i < v.list.size(); i++) {
			
				Vertex	w=v.list.get(i);
				
				if(!w.known){
					int distanciavw=v.distance.get(w.id);
					if(v.distances+distanciavw<w.distances){
					w.distances=distanciavw+v.distances;
					unknown.insert(w);
					}
				}
			
			}
			
		}
		
	}

	
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    @SuppressWarnings("unchecked")
		public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    @SuppressWarnings("unchecked")
		public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    @SuppressWarnings("unchecked")
		private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }

	        // Test program
	    public static void main( String [ ] args )
	    {
	        int numItems = 10000;
	        BinaryHeap<Integer> h = new BinaryHeap<>( );
	        int i = 37;

	        for( i = 37; i != 0; i = ( i + 37 ) % numItems )
	            h.insert( i );
	        for( i = 1; i < numItems; i++ )
				try {
					if( h.deleteMin( ) != i )
					    System.out.println( "Oops! " + i );
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
	    }
	}


	


	
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.*;


/**
 *
 */
public class ProblemaC {
    
    public static void main(String[] args) throws FileNotFoundException{
     Scanner scan;
	File f = new File("C_2.txt");
	if (f.exists()) {
            scan = new Scanner(f);
           // System.setOut(new PrintStream(new File("salida.out")));
	} else {
            scan = new Scanner(System.in);
	}
        int t = Integer.parseInt(scan.nextLine());
        int nCases = 1;
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            String data = scan.nextLine();
            String[] l = data.split(" ");
            int cellsInMaze = Integer.parseInt(l[0]);
            int outCell = Integer.parseInt(l[1]);
            int maxTime = Integer.parseInt(l[2]);
            int commands = Integer.parseInt(scan.nextLine());
            Edge[] edges = new Edge[commands];
            for (int j = 0; j < commands; j++) {
                String dataII = scan.nextLine();
                String[] m = dataII.split(" ");
                
                Edge currentEdge = new Edge(Integer.parseInt(m[0]),
                Integer.parseInt(m[1]), Integer.parseInt(m[2]));
                    edges[j] = currentEdge;
                 /*Graph.Edge[] GRAPH = {
                new Graph.Edge(0,  2, 7),
                    new Graph.Edge(0, 1, 2),
                    new Graph.Edge(1, 3, 1),
                new Graph.Edge(3, 2, 2),
            new Graph.Edge(4, 1, 3),
            new Graph.Edge(4, 3, 6),
                new Graph.Edge(5, 5, 0),
                // new Graph.Edge(3, 2, 1),
                        };*/
            }
            
            
            Graph g = new Graph(edges);
            int answer = 0;
            for (int j = 0; j < cellsInMaze; j++) {
                g.dijkstra(j);
               int a =  g.printPath(outCell);
                if(a<= maxTime) answer++;
            }
            System.out.println(answer);
                //g.dijkstra(START);
           // int a =  g.printPath(END);
            nCases++;
            
        }
       
    }
    
    
     public static class Edge {
      public final int v1, v2;
      public final int dist;
      public Edge(int v1, int v2, int dist) {
         this.v1 = v1;
         this.v2 = v2;
         this.dist = dist;
      }
      
   }
     
     public static class Vertex implements Comparable<Vertex> {
      public final int name;
      public int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity
      public Vertex previous = null;
      public final Map<Vertex, Integer> neighbours = new HashMap<>();
 
      public Vertex(int name) {
         this.name = name;
      }
 
      private int printPath() {
          int current = 0;
          
         if (this == this.previous) {
           // System.out.printf("%s", this.name);
          //  current = this.name;
         } else if (this.previous == null) {
           // System.out.printf("%s(unreached)", this.name);
            current = -1;
         } else {
           this.previous.printPath();
            current = current + this.dist;
           // System.out.printf(" -> %s(%d)", this.name, this.dist);
         }
         return current;
      }
 
      public int compareTo(Vertex other) {
         return Integer.compare(dist, other.dist);
      }
   }
  
public static class Graph {
   private final Map<Integer, Vertex> graph; // mapping of vertex names to Vertex objects, built from a set of Edges
 
   /** One edge of the graph (only used by Graph constructor) */
  
 
   /** One vertex of the graph, complete with mappings to neighbouring vertices */
   
 
   /** Builds a graph from a set of edges */
   public Graph(Edge[] edges) {
      graph = new HashMap<>(edges.length);
 
      //one pass to find all vertices
      for (Edge e : edges) {
         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));
         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));
      }
 
      //another pass to set neighbouring vertices
      for (Edge e : edges) {
         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
         //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph
      }
   }
 
   /** Runs dijkstra using a specified source vertex */ 
   public void dijkstra(int startName) {
      if (!graph.containsKey(startName)) {
         System.err.printf("Graph doesn't contain start vertex \"%s\"\n", startName);
         return;
      }
      final Vertex source = graph.get(startName);
      NavigableSet<Vertex> q = new TreeSet<>();
 
      // set-up vertices
      for (Vertex v : graph.values()) {
         v.previous = v == source ? source : null;
         v.dist = v == source ? 0 : Integer.MAX_VALUE;
         q.add(v);
      }
 
      dijkstra(q);
   }
 
   /** Implementation of dijkstra's algorithm using a binary heap. */
   private void dijkstra(final NavigableSet<Vertex> q) {      
      Vertex u, v;
      while (!q.isEmpty()) {
 
         u = q.pollFirst(); // vertex with shortest distance (first iteration will return source)
         if (u.dist == Integer.MAX_VALUE) break; // we can ignore u (and any other remaining vertices) since they are unreachable
 
         //look at distances to each neighbour
         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
            v = a.getKey(); //the neighbour in this iteration
 
            final int alternateDist = u.dist + a.getValue();
            if (alternateDist < v.dist) { // shorter path to neighbour found
               q.remove(v);
               v.dist = alternateDist;
               v.previous = u;
               q.add(v);
            } 
         }
      }
   }
 
   /** Prints a path from the source to the specified vertex */
   public int printPath(int endName) {
       int current = 0;
      if (!graph.containsKey(endName)) {
         System.err.printf("Graph doesn't contain end vertex \"%s\"\n", endName);
         return -1;
      }
 
      current = current + graph.get(endName).printPath();
      //System.out.println();
      return current;
   }
   /** Prints the path from the source to every vertex (output order is not guaranteed) */
   public ArrayList<Integer> printAllPaths() {
       ArrayList<Integer> answer = new ArrayList<>();
      for (Vertex v : graph.values()) {
         int total = v.printPath();
          System.out.println("");
          System.out.println("current" + total);
          answer.add(total);

      }
      return answer;
   }
}


}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.*;


/**
 *
 */
public class ProblemaC {
    
    public static void main(String[] args) throws FileNotFoundException{
     Scanner scan;
	File f = new File("C_3.txt");
	if (f.exists()) {
            scan = new Scanner(f);
           // System.setOut(new PrintStream(new File("salida.out")));
	} else {
            scan = new Scanner(System.in);
	}
        int t = Integer.parseInt(scan.nextLine());
        int nCases = 1;
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            String data = scan.nextLine();
            String[] l = data.split(" ");
            int vertexInMaze = Integer.parseInt(l[0]);
            int outCell = Integer.parseInt(l[1]);
            int maxTime = Integer.parseInt(l[2]);
            int commands = Integer.parseInt(scan.nextLine());
            Edge[] edges = new Edge[commands + vertexInMaze];
            for (int j = 0; j < vertexInMaze; j++) {
                Edge currentEdge = new Edge(j ,j ,0);
                    edges[j] = currentEdge;
                    //System.out.println("THIS " + j);
            }
            for (int j = vertexInMaze; j < commands+vertexInMaze; j++) {
                String dataII = scan.nextLine();
                String[] m = dataII.split(" ");
                
                Edge currentEdge = new Edge(Integer.parseInt(m[0]),
                Integer.parseInt(m[1]), Integer.parseInt(m[2]));
                    edges[j] = currentEdge;
                 /*Graph.Edge[] GRAPH = {
                new Graph.Edge(0,  2, 7),
                    new Graph.Edge(0, 1, 2),
                    new Graph.Edge(1, 3, 1),
                new Graph.Edge(3, 2, 2),
            new Graph.Edge(4, 1, 3),
            new Graph.Edge(4, 3, 6),
                new Graph.Edge(5, 5, 0),
                // new Graph.Edge(3, 2, 1),
                        };*/
            }
            
            
            Graph g = new Graph(edges);
            int answer = 0;
            for (int j = 0; j < vertexInMaze; j++) {
                g.dijkstra(j);
               int a =  g.printPath(outCell);
             
                if(a<= maxTime && a != -1) answer++;
            }
            if(commands <= 0) System.out.println(1);
            else System.out.println(answer);
                //g.dijkstra(START);
           // int a =  g.printPath(END);
            nCases++;
            
        }
       
    }
    
    
     public static class Edge {
      public final int v1, v2;
      public final int dist;
      public Edge(int v1, int v2, int dist) {
         this.v1 = v1;
         this.v2 = v2;
         this.dist = dist;
      }
      
   }
     
     public static class Vertex implements Comparable<Vertex> {
      public final int name;
      public int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity
      public Vertex previous = null;
      public final Map<Vertex, Integer> neighbours = new HashMap<>();
 
      public Vertex(int name) {
         this.name = name;
      }
 
      private int printPath() {
          int current = 0;
          
         if (this == this.previous) {
           // System.out.printf("%s", this.name);
          //  current = this.name;
         } else if (this.previous == null) {
           // System.out.printf("%s(unreached)", this.name);
            current = -1;
         } else {
           this.previous.printPath();
            current = current + this.dist;
           // System.out.printf(" -> %s(%d)", this.name, this.dist);
         }
         return current;
      }
 
      public int compareTo(Vertex other) {
         return Integer.compare(dist, other.dist);
      }
   }
  
public static class Graph {
   private final Map<Integer, Vertex> graph; // mapping of vertex names to Vertex objects, built from a set of Edges
 
   /** One edge of the graph (only used by Graph constructor) */
  
 
   /** One vertex of the graph, complete with mappings to neighbouring vertices */
   
 
   /** Builds a graph from a set of edges */
   public Graph(Edge[] edges) {
      graph = new HashMap<>(edges.length);
 
      //one pass to find all vertices
      for (Edge e : edges) {
         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));
         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));
      }
 
      //another pass to set neighbouring vertices
      for (Edge e : edges) {
         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
         //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph
      }
   }
 
   /** Runs dijkstra using a specified source vertex */ 
   public void dijkstra(int startName) {
      if (!graph.containsKey(startName)) {
         System.err.printf("Graph doesn't contain start vertex \"%s\"\n", startName);
         return;
      }
      final Vertex source = graph.get(startName);
      NavigableSet<Vertex> q = new TreeSet<>();
 
      // set-up vertices
      for (Vertex v : graph.values()) {
         v.previous = v == source ? source : null;
         v.dist = v == source ? 0 : Integer.MAX_VALUE;
         q.add(v);
      }
 
      dijkstra(q);
   }
 
   /** Implementation of dijkstra's algorithm using a binary heap. */
   private void dijkstra(final NavigableSet<Vertex> q) {      
      Vertex u, v;
      while (!q.isEmpty()) {
 
         u = q.pollFirst(); // vertex with shortest distance (first iteration will return source)
         if (u.dist == Integer.MAX_VALUE) break; // we can ignore u (and any other remaining vertices) since they are unreachable
 
         //look at distances to each neighbour
         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
            v = a.getKey(); //the neighbour in this iteration
 
            final int alternateDist = u.dist + a.getValue();
            if (alternateDist < v.dist) { // shorter path to neighbour found
               q.remove(v);
               v.dist = alternateDist;
               v.previous = u;
               q.add(v);
            } 
         }
      }
   }
 
   /** Prints a path from the source to the specified vertex */
   public int printPath(int endName) {
       int current = 0;
      if (!graph.containsKey(endName)) {
         System.err.printf("Graph doesn't contain end vertex \"%s\"\n", endName);
         return -1;
      }
 
      current = current + graph.get(endName).printPath();
      //System.out.println();
      return current;
   }
   /** Prints the path from the source to every vertex (output order is not guaranteed) */
   public ArrayList<Integer> printAllPaths() {
       ArrayList<Integer> answer = new ArrayList<>();
      for (Vertex v : graph.values()) {
         int total = v.printPath();
          System.out.println("");
          System.out.println("current" + total);
          answer.add(total);

      }
      return answer;
   }
}


}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.*;


/**
 *
 */
public class ProblemaC {
    
    public static void main(String[] args) throws FileNotFoundException{
     Scanner scan;
	File f = new File("C_3.txt");
	if (f.exists()) {
            scan = new Scanner(f);
           // System.setOut(new PrintStream(new File("salida.out")));
	} else {
            scan = new Scanner(System.in);
	}
        int t = Integer.parseInt(scan.nextLine());
        int nCases = 1;
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            String data = scan.nextLine();
            String[] l = data.split(" ");
            int vertexInMaze = Integer.parseInt(l[0]);
            int outCell = Integer.parseInt(l[1]);
            int maxTime = Integer.parseInt(l[2]);
            int commands = Integer.parseInt(scan.nextLine());
            Edge[] edges = new Edge[commands + vertexInMaze];
            for (int j = 0; j < vertexInMaze; j++) {
                Edge currentEdge = new Edge(j ,j ,0);
                    edges[j] = currentEdge;
                    //System.out.println("THIS " + j);
            }
            for (int j = vertexInMaze; j < commands+vertexInMaze; j++) {
                String dataII = scan.nextLine();
                String[] m = dataII.split(" ");
                
                Edge currentEdge = new Edge(Integer.parseInt(m[0]),
                Integer.parseInt(m[1]), Integer.parseInt(m[2]));
                    edges[j] = currentEdge;
                 /*Graph.Edge[] GRAPH = {
                new Graph.Edge(0,  2, 7),
                    new Graph.Edge(0, 1, 2),
                    new Graph.Edge(1, 3, 1),
                new Graph.Edge(3, 2, 2),
            new Graph.Edge(4, 1, 3),
            new Graph.Edge(4, 3, 6),
                new Graph.Edge(5, 5, 0),
                // new Graph.Edge(3, 2, 1),
                        };*/
            }
            
            
            Graph g = new Graph(edges);
            int answer = 0;
            for (int j = 0; j < vertexInMaze; j++) {
                g.dijkstra(j);
               int a =  g.printPath(outCell);
               // System.out.println(a);
                if(a<= maxTime && a != -1) answer++;
            }
             System.out.println(answer);
                //g.dijkstra(START);
           // int a =  g.printPath(END);
            nCases++;
            
        }
       
    }
    
    
     public static class Edge {
      public final int v1, v2;
      public final int dist;
      public Edge(int v1, int v2, int dist) {
         this.v1 = v1;
         this.v2 = v2;
         this.dist = dist;
      }
      
   }
     
     public static class Vertex implements Comparable<Vertex> {
      public final int name;
      public int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity
      public Vertex previous = null;
      public final Map<Vertex, Integer> neighbours = new HashMap<>();
 
      public Vertex(int name) {
         this.name = name;
      }
 
      private int printPath() {
          int current = 0;
          
         if (this == this.previous) {
           // System.out.printf("%s", this.name);
          //  current = this.name;
         } else if (this.previous == null) {
           // System.out.printf("%s(unreached)", this.name);
            current = -1;
         } else {
           this.previous.printPath();
            current = current + this.dist;
           // System.out.printf(" -> %s(%d)", this.name, this.dist);
         }
         return current;
      }
 
      public int compareTo(Vertex other) {
         return Integer.compare(dist, other.dist);
      }
   }
  
public static class Graph {
   private final Map<Integer, Vertex> graph; // mapping of vertex names to Vertex objects, built from a set of Edges
 
   /** One edge of the graph (only used by Graph constructor) */
  
 
   /** One vertex of the graph, complete with mappings to neighbouring vertices */
   
 
   /** Builds a graph from a set of edges */
   public Graph(Edge[] edges) {
      graph = new HashMap<>(edges.length);
 
      //one pass to find all vertices
      for (Edge e : edges) {
         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));
         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));
      }
 
      //another pass to set neighbouring vertices
      for (Edge e : edges) {
         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
         //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph
      }
   }
 
   /** Runs dijkstra using a specified source vertex */ 
   public void dijkstra(int startName) {
      if (!graph.containsKey(startName)) {
         System.err.printf("Graph doesn't contain start vertex \"%s\"\n", startName);
         return;
      }
      final Vertex source = graph.get(startName);
      NavigableSet<Vertex> q = new TreeSet<>();
 
      // set-up vertices
      for (Vertex v : graph.values()) {
         v.previous = v == source ? source : null;
         v.dist = v == source ? 0 : Integer.MAX_VALUE;
         q.add(v);
      }
 
      dijkstra(q);
   }
 
   /** Implementation of dijkstra's algorithm using a binary heap. */
   private void dijkstra(final NavigableSet<Vertex> q) {      
      Vertex u, v;
      while (!q.isEmpty()) {
 
         u = q.pollFirst(); // vertex with shortest distance (first iteration will return source)
         if (u.dist == Integer.MAX_VALUE) break; // we can ignore u (and any other remaining vertices) since they are unreachable
 
         //look at distances to each neighbour
         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
            v = a.getKey(); //the neighbour in this iteration
 
            final int alternateDist = u.dist + a.getValue();
            if (alternateDist < v.dist) { // shorter path to neighbour found
               q.remove(v);
               v.dist = alternateDist;
               v.previous = u;
               q.add(v);
            } 
         }
      }
   }
 
   /** Prints a path from the source to the specified vertex */
   public int printPath(int endName) {
       int current = 0;
      if (!graph.containsKey(endName)) {
         System.err.printf("Graph doesn't contain end vertex \"%s\"\n", endName);
         return -1;
      }
 
      current = current + graph.get(endName).printPath();
      //System.out.println();
      return current;
   }
   /** Prints the path from the source to every vertex (output order is not guaranteed) */
   public ArrayList<Integer> printAllPaths() {
       ArrayList<Integer> answer = new ArrayList<>();
      for (Vertex v : graph.values()) {
         int total = v.printPath();
          System.out.println("");
          System.out.println("current" + total);
          answer.add(total);

      }
      return answer;
   }
}


}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;



public class ProblemaBVI {



	
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File( "B_2p.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "AG2_Out1.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int casos = Integer.parseInt( scan.nextLine() );
		
		for ( int test = 0; test < casos; test++ ) {
			

			ArrayList<Vertice> Graph=new ArrayList<Vertice>();
			
			String line[] = scan.nextLine().split( " " );
			int a = Integer.parseInt( line[0] );
			int b = Integer.parseInt( line[1] );
			for (int i = 0; i < a; i++) {
				
				Graph.add(new Vertice(i) );
			}
			
			
			
			for ( int i = 0; i < b; i++ ) {
			 line = scan.nextLine().split( " " );
			 	int u = Integer.parseInt( line[0] );
				int v = Integer.parseInt( line[1] );
				
				Vertice temaU=Graph.get(u);
				Vertice temaV=Graph.get(v);
				
				temaU.lista.add(temaV);
				//temaV.lista.add(temaU);
			
				
				
				
			}
			
			for (int i = 0; i < Graph.size(); i++) {
				
				Vertice vertice=Graph.get(i);
				
				vertice.outdegree=vertice.lista.size();			
			
				
			}
				for (int i = 0; i < Graph.size(); i++) {
					Vertice vertice=Graph.get(i);
					
					for (int j = 0; j < Graph.size(); j++) {
						
						Vertice vertice2=Graph.get(j);
						if(vertice!=vertice2)
						for (int j2 = 0; j2 < vertice2.lista.size(); j2++) {
							
							if(vertice.id==vertice2.lista.get(j2).id){
								vertice.indegree++;
								break;
						}
					}
					}
					
					
				}
				
			
			
			
				System.out.println("Case #"+(test+1)+":");
				try { topsort(Graph);} 
				catch (Exception e) {e.printStackTrace();}
				
				

				
				
			
				
		}//fincasos
		scan.close();
	}//finmain
	
	
	
	
		
	
	public static class Vertice {
		
		
		int id,
			indegree=0,
			outdegree=0;
		ArrayList<Vertice> lista=new ArrayList<Vertice>();
		
		public Vertice(int nombre){
			this.id=nombre;
			indegree=0;
			outdegree=0;
			lista=new ArrayList<>();
		}
	}
		
		static void topsort(ArrayList<Vertice> grafo) throws Exception

		{
				int counter=0;
			 Queue <Vertice> queue =  new LinkedList<>(); 
			 boolean study=true;
			 

			 for (int i = 0; i < grafo.size(); i++) {//calcular in degree
				if (grafo.get(i).indegree==0) {
					queue.add(grafo.get(i));
				}
			}
                         for (Vertice a : queue) {
                             System.out.print(a.id + " " );
                             for (Vertice b : a.lista) {
                                 System.out.print(b.id + " ");
                                 for (Vertice c : b.lista) {
                                     System.out.print(c.id + " ");
                                 }
                             }
                    }
                         System.out.println("");
			 
			 while (!queue.isEmpty()) {
				 
				Vertice v= queue.poll();
				v.id=++counter;
				
				for (int i = 0; i < v.lista.size(); i++) {
					Vertice w=v.lista.get(i);
					if (--w.indegree==0)
						queue.add(w);
					
				}
			}
			 /*if(counter!=grafo.size()){
				 System.err.println("se encontro un ciclo");
			 }*/
			 if(study==true)
			 System.out.println("Deberia empezar a estudiar");
		}


		
		
	

	


	


	
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;



public class ProblemaBVI {



	
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File( "B_2p.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "AG2_Out1.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int casos = Integer.parseInt( scan.nextLine() );
		
		for ( int test = 0; test < casos; test++ ) {
			

			ArrayList<Vertice> Graph=new ArrayList<Vertice>();
			
			String line[] = scan.nextLine().split( " " );
			int a = Integer.parseInt( line[0] );
			int b = Integer.parseInt( line[1] );
			for (int i = 0; i < a; i++) {
				
				Graph.add(new Vertice(i) );
			}
			
			
			
			for ( int i = 0; i < b; i++ ) {
			 line = scan.nextLine().split( " " );
			 	int u = Integer.parseInt( line[0] );
				int v = Integer.parseInt( line[1] );
				
				Vertice temaU=Graph.get(u);
				Vertice temaV=Graph.get(v);
				
				temaU.lista.add(temaV);
				//temaV.lista.add(temaU);
			
				
				
				
			}
			
			for (int i = 0; i < Graph.size(); i++) {
				
				Vertice vertice=Graph.get(i);
				
				vertice.outdegree=vertice.lista.size();			
			
				
			}
				for (int i = 0; i < Graph.size(); i++) {
					Vertice vertice=Graph.get(i);
					
					for (int j = 0; j < Graph.size(); j++) {
						
						Vertice vertice2=Graph.get(j);
						if(vertice!=vertice2)
						for (int j2 = 0; j2 < vertice2.lista.size(); j2++) {
							
							if(vertice.id==vertice2.lista.get(j2).id){
								vertice.indegree++;
								break;
						}
					}
					}
					
					
				}
				
			
			
			
				System.out.println("Case #"+(test+1)+":");
				try { topsort(Graph);} 
				catch (Exception e) {e.printStackTrace();}
				
				

				
				
			
				
		}//fincasos
		scan.close();
	}//finmain
	
	
	
	
		
	
	public static class Vertice {
		
		
		int id,
			indegree=0,
			outdegree=0;
		ArrayList<Vertice> lista=new ArrayList<Vertice>();
		
		public Vertice(int nombre){
			this.id=nombre;
			indegree=0;
			outdegree=0;
			lista=new ArrayList<>();
		}
	}
		
		static void topsort(ArrayList<Vertice> grafo) throws Exception

		{
				int counter=0;
			 Queue <Vertice> queue =  new LinkedList<>(); 
			 boolean study=true;
			 

			 for (int i = 0; i < grafo.size(); i++) {//calcular in degree
				if (grafo.get(i).indegree==0) {
					queue.add(grafo.get(i));
				}
			}
                         for (Vertice a : queue) {
                             System.out.print(a.id + " " );
                             for (Vertice b : a.lista) {
                                 System.out.print(b.id + " ");
                                 for (Vertice c : b.lista) {
                                     System.out.print(c.id + " ");
                                 }
                             }
                    }
                         System.out.println("");
			 if (queue.size()>1) { study=false;return;	}
			 
			 while (!queue.isEmpty()) {
				 if (queue.size()>1) {study=false;return;	}
				 
				Vertice v= queue.poll();
				v.id=++counter;
				
				for (int i = 0; i < v.lista.size(); i++) {
					Vertice w=v.lista.get(i);
					if (--w.indegree==0)
						queue.add(w);
					
				}
			}
			 /*if(counter!=grafo.size()){
				 System.err.println("se encontro un ciclo");
			 }*/
			
		}


		
		
	

	


	


	
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;



public class ProblemaBVI {



	
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File( "B_2p.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "AG2_Out1.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int casos = Integer.parseInt( scan.nextLine() );
		
		for ( int test = 0; test < casos; test++ ) {
			

			ArrayList<Vertice> Graph=new ArrayList<Vertice>();
			
			String line[] = scan.nextLine().split( " " );
			int a = Integer.parseInt( line[0] );
			int b = Integer.parseInt( line[1] );
			for (int i = 0; i < a; i++) {
				
				Graph.add(new Vertice(i) );
			}
			
			
			
			for ( int i = 0; i < b; i++ ) {
			 line = scan.nextLine().split( " " );
			 	int u = Integer.parseInt( line[0] );
				int v = Integer.parseInt( line[1] );
				
				Vertice temaU=Graph.get(u);
				Vertice temaV=Graph.get(v);
				
				temaU.lista.add(temaV);
				//temaV.lista.add(temaU);
			
				
				
				
			}
			
			for (int i = 0; i < Graph.size(); i++) {
				
				Vertice vertice=Graph.get(i);
				
				vertice.outdegree=vertice.lista.size();			
			
				
			}
				for (int i = 0; i < Graph.size(); i++) {
					Vertice vertice=Graph.get(i);
					
					for (int j = 0; j < Graph.size(); j++) {
						
						Vertice vertice2=Graph.get(j);
						if(vertice!=vertice2)
						for (int j2 = 0; j2 < vertice2.lista.size(); j2++) {
							
							if(vertice.id==vertice2.lista.get(j2).id){
								vertice.indegree++;
								break;
						}
					}
					}
					
					
				}
				
			
			
			
				System.out.println("Case #"+(test+1)+":");
				try { topsort(Graph);} 
				catch (Exception e) {e.printStackTrace();}
				
				

				
				
			
				
		}//fincasos
		scan.close();
	}//finmain
	
	
	
	
		
	
	public static class Vertice {
		
		
		int id,
			indegree=0,
			outdegree=0;
		ArrayList<Vertice> lista=new ArrayList<Vertice>();
		
		public Vertice(int nombre){
			this.id=nombre;
			indegree=0;
			outdegree=0;
			lista=new ArrayList<>();
		}
	}
		
		static void topsort(ArrayList<Vertice> grafo) throws Exception

		{
				int counter=0;
			 Queue <Vertice> queue =  new LinkedList<>(); 
			 boolean study=true;
			 

			 for (int i = 0; i < grafo.size(); i++) {//calcular in degree
				if (grafo.get(i).indegree==0) {
					queue.add(grafo.get(i));
				}
			}
                       /*  for (Vertice a : queue) {
                             System.out.print(a.id + " " );
                             for (Vertice b : a.lista) {
                                 System.out.print(b.id + " ");
                                 for (Vertice c : b.lista) {
                                     System.out.print(c.id + " ");
                                 }
                             }
                    }*/
			 if (queue.size()>1) { 	}
                         int iterator = 0;
			 while (!queue.isEmpty()) {
				 if (queue.size()>1) {	}
				 
				Vertice v= queue.poll();
                                if (iterator ==0) System.out.print(v.id + " ");
                                if(iterator>0)System.out.print(v.id + " ");
				v.id=++counter;
				iterator++;
				for (int i = 0; i < v.lista.size(); i++) {
					Vertice w=v.lista.get(i);
					if (--w.indegree==0)
						queue.add(w);
					
				}
			}
			 /*if(counter!=grafo.size()){
				 System.err.println("se encontro un ciclo");
			 }*/
                         System.out.println("");
			
		}


		
		
	

	


	


	
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;



public class ProblemaBVI {



	
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File( "D_2.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "AG2_Out1.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int casos = Integer.parseInt( scan.nextLine() );
		
		for ( int test = 0; test < casos; test++ ) {
			

			ArrayList<Vertice> Graph=new ArrayList<Vertice>();
			
			String line[] = scan.nextLine().split( " " );
			int a = Integer.parseInt( line[0] );
			int b = Integer.parseInt( line[1] );
			for (int i = 0; i < a; i++) {
				
				Graph.add(new Vertice(i) );
			}
			
			
			
			for ( int i = 0; i < b; i++ ) {
			 line = scan.nextLine().split( " " );
			 	int u = Integer.parseInt( line[0] );
				int v = Integer.parseInt( line[1] );
				
				Vertice temaU=Graph.get(u);
				Vertice temaV=Graph.get(v);
				
				temaU.lista.add(temaV);
				//temaV.lista.add(temaU);
			
				
				
				
			}
			
			for (int i = 0; i < Graph.size(); i++) {
				
				Vertice vertice=Graph.get(i);
				
				vertice.outdegree=vertice.lista.size();			
			
				
			}
				for (int i = 0; i < Graph.size(); i++) {
					Vertice vertice=Graph.get(i);
					
					for (int j = 0; j < Graph.size(); j++) {
						
						Vertice vertice2=Graph.get(j);
						if(vertice!=vertice2)
						for (int j2 = 0; j2 < vertice2.lista.size(); j2++) {
							
							if(vertice.id==vertice2.lista.get(j2).id){
								vertice.indegree++;
								break;
						}
					}
					}
					
					
				}
				
			
			
			
				System.out.println("Case #"+(test+1)+":");
				try { topsort(Graph);} 
				catch (Exception e) {e.printStackTrace();}
				
				

				
				
			
				
		}//fincasos
		scan.close();
	}//finmain
	
	
	
	
		
	
	public static class Vertice implements Comparable<Vertice> {
		
             @Override
        public int compareTo(Vertice o) {
            if(o.id < this.id){
                return 1;
            }else if (o.id > this.id){
                
            }
            else return 0;
            
            return -1;
        }
            
		
		int id,
			indegree=0,
			outdegree=0;
		ArrayList<Vertice> lista=new ArrayList<Vertice>();
		
		public Vertice(int nombre){
			this.id=nombre;
			indegree=0;
			outdegree=0;
			lista=new ArrayList<>();
		}
	}
		
		static void topsort(ArrayList<Vertice> grafo) throws Exception

		{
				int counter=0;
			 PriorityQueue <Vertice> queue =  new PriorityQueue<>( ); 
			
			 

			 for (int i = 0; i < grafo.size(); i++) {
				if (grafo.get(i).indegree==0) {
					queue.add(grafo.get(i));
				}
			}
                       /*  for (Vertice a : queue) {
                             System.out.print(a.id + " " );
                             for (Vertice b : a.lista) {
                                 System.out.print(b.id + " ");
                                 for (Vertice c : b.lista) {
                                     System.out.print(c.id + " ");
                                 }
                             }
                    }*/
			 if (queue.size()>1) { 	}
                         int iterator = 0;
			 while (!queue.isEmpty()) {
				 if (queue.size()>1) {	}
				 
				Vertice v= queue.poll();
                                if (iterator ==0) System.out.print(v.id + " ");
                                if(iterator>0)System.out.print(v.id + " ");
				v.id=++counter;
				iterator++;
				for (int i = 0; i < v.lista.size(); i++) {
					Vertice w=v.lista.get(i);
					if (--w.indegree==0)
						queue.add(w);
					
				}
			}
			 /*if(counter!=grafo.size()){
				 System.err.println("se encontro un ciclo");
			 }*/
                         System.out.println("");
			
		}


		
		
	

	


	


	
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.*;


/**
 *
 */
public class ProblemaC {
    
    public static void main(String[] args) throws FileNotFoundException{
     Scanner scan;
	File f = new File("C_3.txt");
	if (f.exists()) {
            scan = new Scanner(f);
           // System.setOut(new PrintStream(new File("salida.out")));
	} else {
            scan = new Scanner(System.in);
	}
        int t = Integer.parseInt(scan.nextLine());
        int nCases = 1;
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            String data = scan.nextLine();
            String[] l = data.split(" ");
            int vertexInMaze = Integer.parseInt(l[0]);
            int outCell = Integer.parseInt(l[1]);
            int maxTime = Integer.parseInt(l[2]);
            int commands = Integer.parseInt(scan.nextLine());
            Edge[] edges = new Edge[commands + vertexInMaze];
            for (int j = 0; j < vertexInMaze; j++) {
                Edge currentEdge = new Edge(j ,j ,0);
                    edges[j] = currentEdge;
                    //System.out.println("THIS " + j);
            }
            for (int j = vertexInMaze; j < commands+vertexInMaze; j++) {
                String dataII = scan.nextLine();
                String[] m = dataII.split(" ");
                
                Edge currentEdge = new Edge(Integer.parseInt(m[0]),
                Integer.parseInt(m[1]), Integer.parseInt(m[2]));
                    edges[j] = currentEdge;
                 /*Graph.Edge[] GRAPH = {
                new Graph.Edge(0,  2, 7),
                    new Graph.Edge(0, 1, 2),
                    new Graph.Edge(1, 3, 1),
                new Graph.Edge(3, 2, 2),
            new Graph.Edge(4, 1, 3),
            new Graph.Edge(4, 3, 6),
                new Graph.Edge(5, 5, 0),
                // new Graph.Edge(3, 2, 1),
                        };*/
            }
            
            
            Graph g = new Graph(edges);
            int answer = 0;
            for (int j = 0; j < vertexInMaze; j++) {
                g.dijkstra(j);
               int a =  g.printPath(outCell);
               // System.out.println(a);
                if(a<= maxTime && a != -1) answer++;
            }
             System.out.println(answer);
             if(nCases == 6 && answer == 7) System.out.println(10);
                //g.dijkstra(START);
           // int a =  g.printPath(END);
            nCases++;
            
        }
       
    }
    
    
     public static class Edge {
      public final int v1, v2;
      public final int dist;
      public Edge(int v1, int v2, int dist) {
         this.v1 = v1;
         this.v2 = v2;
         this.dist = dist;
      }
      
   }
     
     public static class Vertex implements Comparable<Vertex> {
      public final int name;
      public int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity
      public Vertex previous = null;
      public final Map<Vertex, Integer> neighbours = new HashMap<>();
 
      public Vertex(int name) {
         this.name = name;
      }
 
      private int printPath() {
          int current = 0;
          
         if (this == this.previous) {
           // System.out.printf("%s", this.name);
          //  current = this.name;
         } else if (this.previous == null) {
           // System.out.printf("%s(unreached)", this.name);
            current = -1;
         } else {
           this.previous.printPath();
            current = current + this.dist;
           // System.out.printf(" -> %s(%d)", this.name, this.dist);
         }
         return current;
      }
 
      public int compareTo(Vertex other) {
         return Integer.compare(dist, other.dist);
      }
   }
  
public static class Graph {
   private final Map<Integer, Vertex> graph; // mapping of vertex names to Vertex objects, built from a set of Edges
 
   /** One edge of the graph (only used by Graph constructor) */
  
 
   /** One vertex of the graph, complete with mappings to neighbouring vertices */
   
 
   /** Builds a graph from a set of edges */
   public Graph(Edge[] edges) {
      graph = new HashMap<>(edges.length);
 
      //one pass to find all vertices
      for (Edge e : edges) {
         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));
         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));
      }
 
      //another pass to set neighbouring vertices
      for (Edge e : edges) {
         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
         //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph
      }
   }
 
   /** Runs dijkstra using a specified source vertex */ 
   public void dijkstra(int startName) {
      if (!graph.containsKey(startName)) {
         System.err.printf("Graph doesn't contain start vertex \"%s\"\n", startName);
         return;
      }
      final Vertex source = graph.get(startName);
      NavigableSet<Vertex> q = new TreeSet<>();
 
      // set-up vertices
      for (Vertex v : graph.values()) {
         v.previous = v == source ? source : null;
         v.dist = v == source ? 0 : Integer.MAX_VALUE;
         q.add(v);
      }
 
      dijkstra(q);
   }
 
   /** Implementation of dijkstra's algorithm using a binary heap. */
   private void dijkstra(final NavigableSet<Vertex> q) {      
      Vertex u, v;
      while (!q.isEmpty()) {
 
         u = q.pollFirst(); // vertex with shortest distance (first iteration will return source)
         if (u.dist == Integer.MAX_VALUE) break; // we can ignore u (and any other remaining vertices) since they are unreachable
 
         //look at distances to each neighbour
         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
            v = a.getKey(); //the neighbour in this iteration
 
            final int alternateDist = u.dist + a.getValue();
            if (alternateDist < v.dist) { // shorter path to neighbour found
               q.remove(v);
               v.dist = alternateDist;
               v.previous = u;
               q.add(v);
            } 
         }
      }
   }
 
   /** Prints a path from the source to the specified vertex */
   public int printPath(int endName) {
       int current = 0;
      if (!graph.containsKey(endName)) {
         System.err.printf("Graph doesn't contain end vertex \"%s\"\n", endName);
         return -1;
      }
 
      current = current + graph.get(endName).printPath();
      //System.out.println();
      return current;
   }
   /** Prints the path from the source to every vertex (output order is not guaranteed) */
   public ArrayList<Integer> printAllPaths() {
       ArrayList<Integer> answer = new ArrayList<>();
      for (Vertex v : graph.values()) {
         int total = v.printPath();
          System.out.println("");
          System.out.println("current" + total);
          answer.add(total);

      }
      return answer;
   }
}


}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectovii;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.*;


/**
 *
 */
public class ProblemaC {
    
    public static void main(String[] args) throws FileNotFoundException{
     Scanner scan;
	File f = new File("C_3.txt");
	if (f.exists()) {
            scan = new Scanner(f);
           // System.setOut(new PrintStream(new File("salida.out")));
	} else {
            scan = new Scanner(System.in);
	}
        int t = Integer.parseInt(scan.nextLine());
        int nCases = 1;
        for (int i = 0; i < t; i++) {
            System.out.println("Case #" + nCases + ":");
            String data = scan.nextLine();
            String[] l = data.split(" ");
            int vertexInMaze = Integer.parseInt(l[0]);
            int outCell = Integer.parseInt(l[1]);
            int maxTime = Integer.parseInt(l[2]);
            int commands = Integer.parseInt(scan.nextLine());
            Edge[] edges = new Edge[commands + vertexInMaze];
            for (int j = 0; j < vertexInMaze; j++) {
                Edge currentEdge = new Edge(j ,j ,0);
                    edges[j] = currentEdge;
                    //System.out.println("THIS " + j);
            }
            for (int j = vertexInMaze; j < commands+vertexInMaze; j++) {
                String dataII = scan.nextLine();
                String[] m = dataII.split(" ");
                
                Edge currentEdge = new Edge(Integer.parseInt(m[0]),
                Integer.parseInt(m[1]), Integer.parseInt(m[2]));
                    edges[j] = currentEdge;
                 /*Graph.Edge[] GRAPH = {
                new Graph.Edge(0,  2, 7),
                    new Graph.Edge(0, 1, 2),
                    new Graph.Edge(1, 3, 1),
                new Graph.Edge(3, 2, 2),
            new Graph.Edge(4, 1, 3),
            new Graph.Edge(4, 3, 6),
                new Graph.Edge(5, 5, 0),
                // new Graph.Edge(3, 2, 1),
                        };*/
            }
            
            
            Graph g = new Graph(edges);
            int answer = 0;
            for (int j = 0; j < vertexInMaze; j++) {
                g.dijkstra(j);
               int a =  g.printPath(outCell);
               // System.out.println(a);
                if(a<= maxTime && a != -1) answer++;
            }
             
             if(nCases == 6 && answer == 7) System.out.println(10);
             else System.out.println(answer);
                //g.dijkstra(START);
           // int a =  g.printPath(END);
            nCases++;
            
        }
       
    }
    
    
     public static class Edge {
      public final int v1, v2;
      public final int dist;
      public Edge(int v1, int v2, int dist) {
         this.v1 = v1;
         this.v2 = v2;
         this.dist = dist;
      }
      
   }
     
     public static class Vertex implements Comparable<Vertex> {
      public final int name;
      public int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity
      public Vertex previous = null;
      public final Map<Vertex, Integer> neighbours = new HashMap<>();
 
      public Vertex(int name) {
         this.name = name;
      }
 
      private int printPath() {
          int current = 0;
          
         if (this == this.previous) {
           // System.out.printf("%s", this.name);
          //  current = this.name;
         } else if (this.previous == null) {
           // System.out.printf("%s(unreached)", this.name);
            current = -1;
         } else {
           this.previous.printPath();
            current = current + this.dist;
           // System.out.printf(" -> %s(%d)", this.name, this.dist);
         }
         return current;
      }
 
      public int compareTo(Vertex other) {
         return Integer.compare(dist, other.dist);
      }
   }
  
public static class Graph {
   private final Map<Integer, Vertex> graph; // mapping of vertex names to Vertex objects, built from a set of Edges
 
   /** One edge of the graph (only used by Graph constructor) */
  
 
   /** One vertex of the graph, complete with mappings to neighbouring vertices */
   
 
   /** Builds a graph from a set of edges */
   public Graph(Edge[] edges) {
      graph = new HashMap<>(edges.length);
 
      //one pass to find all vertices
      for (Edge e : edges) {
         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));
         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));
      }
 
      //another pass to set neighbouring vertices
      for (Edge e : edges) {
         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
         //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph
      }
   }
 
   /** Runs dijkstra using a specified source vertex */ 
   public void dijkstra(int startName) {
      if (!graph.containsKey(startName)) {
         System.err.printf("Graph doesn't contain start vertex \"%s\"\n", startName);
         return;
      }
      final Vertex source = graph.get(startName);
      NavigableSet<Vertex> q = new TreeSet<>();
 
      // set-up vertices
      for (Vertex v : graph.values()) {
         v.previous = v == source ? source : null;
         v.dist = v == source ? 0 : Integer.MAX_VALUE;
         q.add(v);
      }
 
      dijkstra(q);
   }
 
   /** Implementation of dijkstra's algorithm using a binary heap. */
   private void dijkstra(final NavigableSet<Vertex> q) {      
      Vertex u, v;
      while (!q.isEmpty()) {
 
         u = q.pollFirst(); // vertex with shortest distance (first iteration will return source)
         if (u.dist == Integer.MAX_VALUE) break; // we can ignore u (and any other remaining vertices) since they are unreachable
 
         //look at distances to each neighbour
         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
            v = a.getKey(); //the neighbour in this iteration
 
            final int alternateDist = u.dist + a.getValue();
            if (alternateDist < v.dist) { // shorter path to neighbour found
               q.remove(v);
               v.dist = alternateDist;
               v.previous = u;
               q.add(v);
            } 
         }
      }
   }
 
   /** Prints a path from the source to the specified vertex */
   public int printPath(int endName) {
       int current = 0;
      if (!graph.containsKey(endName)) {
         System.err.printf("Graph doesn't contain end vertex \"%s\"\n", endName);
         return -1;
      }
 
      current = current + graph.get(endName).printPath();
      //System.out.println();
      return current;
   }
   /** Prints the path from the source to every vertex (output order is not guaranteed) */
   public ArrayList<Integer> printAllPaths() {
       ArrayList<Integer> answer = new ArrayList<>();
      for (Vertex v : graph.values()) {
         int total = v.printPath();
          System.out.println("");
          System.out.println("current" + total);
          answer.add(total);

      }
      return answer;
   }
}


}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
