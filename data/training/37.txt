
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaA {

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }
        return arr;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int numerosLista = Integer.parseInt(in.readLine());
        if (1 < numerosLista && numerosLista < 100000) {
            int[] str = readInts(in.readLine(), numerosLista);
            int aux, num1 = 0, num2 = 0, mayorProducto = num1 * num2;
            for (int i = 0; i < numerosLista; i++) {
                for (int j = 0; j < numerosLista; j++) {
                    aux = str[i] * str[j];
                    if (aux > mayorProducto && j != i) {
                        mayorProducto = aux;
                    }
                }
            }
            System.out.print(mayorProducto);
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaA {

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }
        return arr;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int numerosLista = Integer.parseInt(in.readLine());
        if (1 < numerosLista && numerosLista < 100000) {
            int[] str = readInts(in.readLine(), numerosLista);
            int aux, num1 = 0, num2 = 0, mayorProducto = num1 * num2;
            for (int i = 0; i < numerosLista; i++) {
                for (int j = 0; j < numerosLista; j++) {
                    aux = str[i] * str[j];
                    if (aux > mayorProducto && j != i) {
                        mayorProducto = aux;
                    }
                }
            }
            System.out.print(mayorProducto);
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, j, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 11 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                String cadena = in.readLine();
                char[] cter = cadena.toCharArray();
                int count = 0;
                for (j = 0; j < cter.length; j++) {
                    if ('W' == cter[j]) {
                        if (j == 0) {
                            if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == 1) {
                            if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j < cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                count++;
                            }
                        } else if (j == cter.length - 1) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                count++;
                            }
                        }
                    }
                }
                System.out.println(count);
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */

public class ProblemaC {
	
	public static int contarSubCadenas(String cadena,int tamanhoCadena){
		int tamanhoSub = 2,count = tamanhoCadena;
		for(int i = 0;i<tamanhoCadena;i++){
			if(tamanhoCadena >tamanhoSub){
				count += (tamanhoCadena/tamanhoSub);
			}
			tamanhoSub++;
		}
		return count;
	}
	
	public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 1000 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                int  aux = 0, /*aux2 = 0,*/ tamanhoCadena = Integer.parseInt(in.readLine());
                String cadena = in.readLine();
            	aux = contarSubCadenas(cadena, tamanhoCadena);
            	System.out.println(aux);
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaD {

    public static int repeticiones(String cadena, char caracter, int tamanhoCadena) {
        int count = 0;
        for (int i = 0; i < tamanhoCadena; i++) {
            if (cadena.charAt(i) == caracter) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int j, i, casosPrueba = Integer.parseInt(in.readLine());
        char cereza = '#';
        if (casosPrueba < 1000 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                int total = 0, aux = 0, aux2 = 0, tamanhoCadena = Integer.parseInt(in.readLine());
                for (j = 0; j < tamanhoCadena; j++) {
                    String linea = in.readLine();
                    aux = repeticiones(linea, cereza, tamanhoCadena);
                    total += aux;
                    if (aux != linea.length()) {
                        aux2 -= aux;
                    } else {
                        aux2 += repeticiones(linea, cereza, tamanhoCadena);
                    }
                    //System.out.println(totalCerezas + "\t" + aux + "\t" + aux2);
                }
                if (aux2 != 0 || total % 2 != 0) {
                    System.out.println("NO");
                } else {
                    System.out.println("YES");
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */

public class ProblemaC {
	
	public static int contarSubCadenas(String cadena,int tamanhoCadena){
		int tamanhoSub = 2,count = tamanhoCadena;
		for(int i = 0;i<tamanhoCadena;i++){
			if(tamanhoCadena >tamanhoSub){
				count += (tamanhoCadena/tamanhoSub);
			}
			tamanhoSub++;
		}
		return count;
	}
	
	public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 1000 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                int  aux = 0, tamanhoCadena = in.readLine().length();
                String cadena = in.readLine();
            	aux = contarSubCadenas(cadena, tamanhoCadena);
            	System.out.println(aux);
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */

public class ProblemaC {
	
	public static int contarSubCadenas(String cadena,int tamanhoCadena){
		int tamanhoSub = 2,count = tamanhoCadena;
		for(int i = 0;i<tamanhoCadena;i++){
			if(tamanhoCadena >tamanhoSub){
				count += (tamanhoCadena/tamanhoSub);
			}
			tamanhoSub++;
		}
		return count;
	}
	
	public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 1000 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                int  aux = 0, tamanhoCadena = in.readLine().length();
                String cadena = in.readLine();
            	aux = contarSubCadenas(cadena, tamanhoCadena);
            	System.out.println(aux);
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, j, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 11 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                String cadena = in.readLine();
                char[] cter = cadena.toCharArray();
                int count = 0;
                for (j = 0; j < cter.length; j++) {
                    if ('W' == cter[j]) {
                        if (j == 0) {
                            if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == 1) {
                            if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j < cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                count++;
                            }
                        } else if (j == cter.length - 1) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                count++;
                            }
                        }
                    }
                }
                System.out.println(count);
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, j, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 11 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                String cadena = in.readLine();
                char[] cter = cadena.toCharArray();
                int count = 0;
                for (j = 0; j < cter.length; j++) {
                    if ('W' == cter[j]) {
                        if (j == 0) {
                            if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == 1) {
                            if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j < cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                count++;
                            }
                        } else if (j == cter.length - 1) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                count++;
                            }
                        }
                    }
                }
                System.out.print(count+"\n");
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaA {

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }
        return arr;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int numerosLista = Integer.parseInt(in.readLine());
        if (1 < numerosLista && numerosLista < 100000) {
            int[] str = readInts(in.readLine(), numerosLista);
            int aux, num1 = 0, num2 = 0, mayorProducto = num1 * num2;
            for (int i = 0; i < numerosLista; i++) {
                for (int j = 0; j < numerosLista; j++) {
                    aux = str[i] * str[j];
                    if (aux > mayorProducto && j != i) {
                        mayorProducto = aux;
                    }
                }
            }
            System.out.print(mayorProducto+"\n");
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaA {

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }
        return arr;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int numerosLista = Integer.parseInt(in.readLine());
        if (1 < numerosLista && numerosLista < 100000) {
            int[] str = readInts(in.readLine(), numerosLista);
            int aux, num1 = 0, num2 = 0, mayorProducto = num1 * num2;
            for (int i = 0; i < numerosLista; i++) {
                for (int j = 0; j < numerosLista; j++) {
                    aux = str[i] * str[j];
                    if (aux > mayorProducto && j != i) {
                        mayorProducto = aux;
                    }
                }
            }
        System.out.print(mayorProducto+"\n");    
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, j, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 11 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                String cadena = in.readLine();
                char[] cter = cadena.toCharArray();
                int count = 0;
                for (j = 0; j < cter.length; j++) {
                    if ('W' == cter[j]) {
                        if (j == 0) {
                            if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == 1) {
                            if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j < cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                count++;
                            }
                        } else if (j == cter.length - 1) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                count++;
                            }
                        }
                    }
                }
                System.out.print(count+"\n");
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */

public class ProblemaC {
	
	public static int contarSubCadenas(String cadena,int tamanhoCadena){
		int tamanhoSub = 2,count = tamanhoCadena;
		for(int i = 0;i<tamanhoCadena;i++){
			if(tamanhoCadena >tamanhoSub){
				count += (tamanhoCadena/tamanhoSub);
			}
			tamanhoSub++;
		}
		return count;
	}
	
	public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 1000 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                int  aux = 0, tamanhoCadena = in.readLine().length();
                String cadena = in.readLine();
            	aux = contarSubCadenas(cadena, tamanhoCadena);
            	System.out.println(aux);
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaD {

    public static int repeticiones(String cadena, char caracter, int tamanhoCadena) {
        int count = 0;
        for (int i = 0; i < tamanhoCadena; i++) {
            if (cadena.charAt(i) == caracter) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.txt")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int j, i, casosPrueba = Integer.parseInt(in.readLine());
        char cereza = '#';
        if (casosPrueba < 1000 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                int total = 0, aux = 0, aux2 = 0, tamanhoCadena = Integer.parseInt(in.readLine());
                for (j = 0; j < tamanhoCadena; j++) {
                    String linea = in.readLine();
                    aux = repeticiones(linea, cereza, tamanhoCadena);
                    total += aux;
                    if (aux != linea.length()) {
                        aux2 -= aux;
                    } else {
                        aux2 += repeticiones(linea, cereza, tamanhoCadena);
                    }
                    //System.out.println(totalCerezas + "\t" + aux + "\t" + aux2);
                }
                if (aux2 != 0 || total % 2 != 0) {
                    System.out.println("NO");
                } else {
                    System.out.println("YES");
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */

public class ProblemaC {
	
	public static int contarSubCadenas(String cadena,int tamanhoCadena){
		int tamanhoSub = 2,count = tamanhoCadena;
		for(int i = 0;i<tamanhoCadena;i++){
			if(tamanhoCadena >tamanhoSub){
				count += (tamanhoCadena/tamanhoSub);
			}
			tamanhoSub++;
		}
		return count;
	}
	
	public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 1000 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                int  aux = 0, tamanhoCadena = in.readLine().length();
                String cadena = in.readLine();
            	aux = contarSubCadenas(cadena, tamanhoCadena);
            	System.out.println(aux);
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaD {

    public static int repeticiones(String cadena, char caracter, int tamanhoCadena) {
        int count = 0;
        for (int i = 0; i < tamanhoCadena; i++) {
            if (cadena.charAt(i) == caracter) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int j, i, casosPrueba = Integer.parseInt(in.readLine());
        char cereza = '#';
        if (casosPrueba < 1000 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                int total = 0, aux = 0, aux2 = 0, tamanhoCadena = Integer.parseInt(in.readLine());
                for (j = 0; j < tamanhoCadena; j++) {
                    String linea = in.readLine();
                    aux = repeticiones(linea, cereza, tamanhoCadena);
                    total += aux;
                    if (aux != linea.length()) {
                        aux2 -= aux;
                    } else {
                        aux2 += repeticiones(linea, cereza, tamanhoCadena);
                    }
                    //System.out.println(totalCerezas + "\t" + aux + "\t" + aux2);
                }
                if (aux2 != 0 || total % 2 != 0) {
                    System.out.println("NO");
                } else {
                    System.out.println("YES");
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaA {

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }
        return arr;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int numerosLista = Integer.parseInt(in.readLine());
        if (1 < numerosLista && numerosLista < 100000) {
            int[] str = readInts(in.readLine(), numerosLista);
            int aux, num1 = 0, num2 = 0, mayorProducto = num1 * num2;
            for (int i = 0; i < numerosLista; i++) {
                for (int j = 0; j < numerosLista; j++) {
                    aux = str[i] * str[j];
                    if (aux > mayorProducto && j != i) {
                        mayorProducto = aux;
                    }
                }
            }
            System.out.print(mayorProducto + "\n");
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaA {

    public static int[] readInts(String s, int n) {
        String split[] = s.split(" ");
        int arr[] = new int[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }
        return arr;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int numerosLista = Integer.parseInt(in.readLine());
        if (1 < numerosLista && numerosLista < 100000) {
            int[] str = readInts(in.readLine(), numerosLista);
            int aux, num1 = 0, num2 = 0; 
            long mayorProducto = num1 * num2;
            for (int i = 0; i < numerosLista; i++) {
                for (int j = 0; j < numerosLista; j++) {
                    aux = str[i] * str[j];
                    if (aux > mayorProducto && j != i) {
                        mayorProducto = aux;
                    }
                }
            }
            System.out.print(mayorProducto + "\n");
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaA {

    public static long[] readInts(String s, int n) {
        String split[] = s.split(" ");
        long arr[] = new long[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }
        return arr;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int numerosLista = Integer.parseInt(in.readLine());
        if (1 < numerosLista && numerosLista < 100000) {
            long[] str = readInts(in.readLine(), numerosLista);
            int aux; 
            long num1 = 0, num2 = 0 ,mayorProducto = num1 * num2;
            for (int i = 0; i < numerosLista; i++) {
                for (int j = 0; j < numerosLista; j++) {
                    aux = (int) (str[i] * str[j]);
                    if (aux > mayorProducto && j != i) {
                        mayorProducto = aux;
                    }
                }
            }
            System.out.print(mayorProducto + "\n");
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaA {

    public static long[] readInts(String s, int n) {
        String split[] = s.split(" ");
        long arr[] = new long[n];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = Integer.parseInt(split[i]);
        }
        return arr;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int numerosLista = Integer.parseInt(in.readLine());
        if (1 < numerosLista && numerosLista < 100000) {
            long[] str = readInts(in.readLine(), numerosLista);
            long aux, num1 = 0, num2 = 0, mayorProducto = num1 * num2;
            for (int i = 0; i < numerosLista; i++) {
                for (int j = 0; j < numerosLista; j++) {
                    aux = (str[i] * str[j]);
                    if (aux > mayorProducto && j != i) {
                        mayorProducto = aux;
                    }
                }
            }
            System.out.print(mayorProducto + "\n");
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, j, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 11 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                String cadena = in.readLine();
                if (cadena.length() < 100001 && cadena.length() > 0) {
                    char[] cter = cadena.toCharArray();
                    int count = 0;
                    for (j = 0; j < cter.length; j++) {
                        if ('W' == cter[j]) {
                            if (j == 0) {
                                if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j == 1) {
                                if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j < cter.length - 2) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j == cter.length - 2) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                    count++;
                                }
                            } else if (j == cter.length - 1) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                    count++;
                                }
                            }
                        }
                    }
                    System.out.print(count + "\n");
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, j, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 11 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                String cadena = in.readLine();
                if (cadena.length() < 100001 && cadena.length() > 0) {
                    char[] cter = cadena.toCharArray();
                    int count = 0;
                    for (j = 0; j < cter.length; j++) {
                        if ('W' == cter[j]) {
                            if (j == 0) {
                                if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j == 1) {
                                if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j < cter.length - 2) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j == cter.length - 2) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                    count++;
                                }
                            } else if (j == cter.length - 1) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                    count++;
                                }
                            }
                        }
                    }
                    System.out.print(count + "\n");
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, j, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 11 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                String cadena = in.readLine();
                if (cadena.length() < 100001 && cadena.length() > 0) {
                    char[] cter = cadena.toCharArray();
                    int count = 0;
                    for (j = 0; j < cter.length; j++) {
                        if ('W' == cter[j]) {
                            if (j == 0) {
                                if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j == 1) {
                                if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j < cter.length - 2) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j == cter.length - 2) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                    count++;
                                }
                            } else if (j == cter.length - 1) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                    count++;
                                }
                            }
                        }
                    }
                    System.out.print(count + "\n");
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.IOException;
import java.util.Scanner;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        Scanner scan = new Scanner(System.in);
        int j, casosPrueba = Integer.parseInt(scan.nextLine());
        while (0 < casosPrueba && casosPrueba < 11) {
            String cadena = scan.nextLine();
            if (cadena.length() < 100001 && cadena.length() > 0) {
                char[] cter = cadena.toCharArray();
                int count = 0;
                for (j = 0; j < cter.length; j++) {
                    if ('W' == cter[j]) {
                        if (j == 0) {
                            if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == 1) {
                            if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j < cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                count++;
                            }
                        } else if (j == cter.length - 1) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                count++;
                            }
                        }
                    }
                }
                System.out.print(count + "\n");
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.IOException;
import java.util.Scanner;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        Scanner scan = new Scanner(System.in);
        int j, casosPrueba = Integer.parseInt(scan.nextLine());
        while (0 < casosPrueba && casosPrueba < 11) {
            String cadena = scan.nextLine();
            if (cadena.length() < 100001 && cadena.length() > 0) {
                char[] cter = cadena.toCharArray();
                int count = 0;
                for (j = 0; j < cter.length; j++) {
                    if ('W' == cter[j]) {
                        if (j == 0) {
                            if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == 1) {
                            if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j < cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                count++;
                            }
                        } else if (j == cter.length - 2) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                count++;
                            }
                        } else if (j == cter.length - 1) {
                            if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                count++;
                            }
                        }
                    }
                }
                System.out.print(count + "\n");
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("entrada.in");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            System.setOut(new PrintStream(new File("salida.in")));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int i, j, casosPrueba = Integer.parseInt(in.readLine());
        if (casosPrueba < 11 && casosPrueba > 0) {
            for (i = 0; i < casosPrueba; i++) {
                String cadena = in.readLine();
                if (cadena.length() < 100001 && cadena.length() > 0) {
                    char[] cter = cadena.toCharArray();
                    int count = 0;
                    for (j = 0; j < cter.length; j++) {
                        if ('W' == cter[j]) {
                            if (j == 0) {
                                if ('B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j == 1) {
                                if ('B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j < cter.length - 2) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1] || 'B' == cter[j + 2]) {
                                    count++;
                                }
                            } else if (j == cter.length - 2) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1] || 'B' == cter[j + 1]) {
                                    count++;
                                }
                            } else if (j == cter.length - 1) {
                                if ('B' == cter[j - 2] || 'B' == cter[j - 1]) {
                                    count++;
                                }
                            }
                        }
                    }
                    System.out.print(count + "\n");
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader input;
        File f = new File("B_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            int N = Integer.parseInt(input.readLine());
            String split[] = input.readLine().split(" ");
            Map<Integer, Integer> linkedHashMap = new LinkedHashMap<>();
            for (int j = 0; j < N; j++) {
                Integer aux = Integer.parseInt(split[j]);
                if (linkedHashMap.containsKey(aux)) {
                    int accumulated = linkedHashMap.get(aux) + 1;
                    linkedHashMap.replace(aux, accumulated);
                } else {
                    linkedHashMap.put(aux, 1);
                }
            }
            System.out.println("Caso #" + (i + 1) + ":");
            Iterator<Integer> it = linkedHashMap.keySet().iterator();
            while (it.hasNext()) {
                Integer key = (Integer) it.next();
                System.out.println(key + " " + linkedHashMap.get(key));
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader input;
        File f = new File("B_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            int N = Integer.parseInt(input.readLine());
            String split[] = input.readLine().split(" ");
            Map<Integer, Integer> linkedHashMap = new LinkedHashMap<>();
            for (int j = 0; j < N; j++) {
                Integer aux = Integer.parseInt(split[j]);
                if (linkedHashMap.containsKey(aux)) {
                    int accumulated = linkedHashMap.get(aux) + 1;
                    linkedHashMap.replace(aux, accumulated);
                } else {
                    linkedHashMap.put(aux, 1);
                }
            }
            System.out.println("Caso #" + (i + 1) + ":");
            Iterator<Integer> it = linkedHashMap.keySet().iterator();
            while (it.hasNext()) {
                Integer key = (Integer) it.next();
                System.out.println(key + " " + linkedHashMap.get(key));
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 */
public class ProblemaA {

    public static void main(String[] args) throws Exception {
        BufferedReader input;
        File f = new File("A_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String line = input.readLine();
            String split[] = line.split(" ");
            int K = Integer.parseInt(split[1]);
            Map<Integer, Group> myMap = new HashMap<>();
            for (int j = 0; j < K; j++) {
                line = input.readLine();
                split = line.split(" ");
                int team = Integer.parseInt(split[0]);
                //int problem = Integer.parseInt(split[1]);
                int time = Integer.parseInt(split[2]);
                Group aux;
                if (myMap.containsKey(team)) {
                    aux = myMap.get(team);
                    if (split[3].equals("C")) {
                        aux.penalty = aux.tmpPenalty + time;
                        aux.tmpPenalty = aux.penalty;
                        aux.problems++;
                    } else {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                    }
                    myMap.replace(team, aux);
                } else {
                    aux = new Group(team);
                    if (split[3].equals("C")) {
                        aux.penalty = aux.tmpPenalty + time;
                        aux.tmpPenalty = aux.penalty;
                        aux.problems++;
                    } else {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                    }
                    myMap.put(team, aux);
                }
            }
            MinBinaryHeap<Group> out = new MinBinaryHeap<>();
            for (Map.Entry<Integer, Group> entry : myMap.entrySet()) {
                Group group = entry.getValue();
                out.insert(group);
            }
            int size = out.currentSize;
            for (int j = 0; j < size; j++) {
                Group group = out.deleteMin();
                System.out.println(group.toString());
            }
        }
    }

    public static class Group implements Comparable<Group> {

        int team;
        int problems;
        int penalty;
        int tmpPenalty;

        public Group(int tm) {
            this.team = tm;
            this.problems = 0;
            this.penalty = 0;
            this.tmpPenalty = 0;
        }

        @Override
        public String toString() {
            return team + " " + problems + " " + penalty;
        }

        @Override
        public int compareTo(Group o) {
            if (team != o.team) {
                if (problems < o.problems) {
                    return 1;
                } else if (problems > o.problems) {
                    return -1;
                } else {
                    if (penalty < o.penalty) {
                        return -1;
                    } else if (penalty > o.penalty) {
                        return 1;
                    } else {
                        if (team < o.team) {
                            return -1;
                        } else if (team > o.team) {
                            return 1;
                        }
                    }
                }
            }
            return 0;
        }
    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 */
public class ProblemaE {

    public static void main(String[] args) throws Exception {
        BufferedReader input;
        File f = new File("A_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String line = input.readLine();
            String split[] = line.split(" ");
            int K = Integer.parseInt(split[1]);
            int[] board = new int[4];
            Map<Integer, Group> myMap = new HashMap<>();
            for (int k = 0; k < 4; k++) {
                board[k] = 0;
            }
            for (int j = 0; j < K; j++) {
                line = input.readLine();
                split = line.split(" ");
                int team = Integer.parseInt(split[0]);
                //int problem = Integer.parseInt(split[1]);
                int time = Integer.parseInt(split[2]);
                Group aux;
                if (myMap.containsKey(team)) {
                    aux = myMap.get(team);
                    if (split[3].equalsIgnoreCase("C")) {
                        aux.penalty = aux.tmpPenalty + time;
                        aux.tmpPenalty = aux.penalty;
                        aux.problems++;
                        board[0]++;
                    } else if (split[3].equalsIgnoreCase("I")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[1]++;
                    } else if (split[3].equalsIgnoreCase("T")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[2]++;
                    } else if (split[3].equalsIgnoreCase("R")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[3]++;
                    }
                    myMap.replace(team, aux);
                } else {
                    aux = new Group(team);
                    if (split[3].equalsIgnoreCase("C")) {
                        aux.penalty = aux.tmpPenalty + time;
                        aux.tmpPenalty = aux.penalty;
                        aux.problems++;
                        board[0]++;
                    } else if (split[3].equalsIgnoreCase("I")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[1]++;
                    } else if (split[3].equalsIgnoreCase("T")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[2]++;
                    } else if (split[3].equalsIgnoreCase("R")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[3]++;
                    }
                    myMap.put(team, aux);
                }
            }
            MinBinaryHeap<Group> out = new MinBinaryHeap<>();
            for (Map.Entry<Integer, Group> entry : myMap.entrySet()) {
                Group group = entry.getValue();
                out.insert(group);
            }
            int size = out.currentSize;
            for (int j = 0; j < size; j++) {
                Group group = out.deleteMin();
                System.out.println(group.toString());
            }
            for (int k = 0; k < 4; k++) {
                if (k != 3) {
                    System.out.print(board[k] + " ");
                }else{
                    System.out.println(board[k]);
                }
            }

        }
    }

    public static class Group implements Comparable<Group> {

        int team;
        int problems;
        int penalty;
        int tmpPenalty;

        public Group(int tm) {
            this.team = tm;
            this.problems = 0;
            this.penalty = 0;
            this.tmpPenalty = 0;
        }

        @Override
        public String toString() {
            return team + " " + problems + " " + penalty;
        }

        @Override
        public int compareTo(Group o) {
            if (team != o.team) {
                if (problems < o.problems) {
                    return 1;
                } else if (problems > o.problems) {
                    return -1;
                } else {
                    if (penalty < o.penalty) {
                        return -1;
                    } else if (penalty > o.penalty) {
                        return 1;
                    } else {
                        if (team < o.team) {
                            return -1;
                        } else if (team > o.team) {
                            return 1;
                        }
                    }
                }
            }
            return 0;
        }
    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 */
public class ProblemaB {

    public static void main(String[] args) throws IOException {
        BufferedReader input;
        File f = new File("B_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            int N = Integer.parseInt(input.readLine());
            String split[] = input.readLine().split(" ");
            Map<Integer, Integer> linkedHashMap = new LinkedHashMap<>();
            for (int j = 0; j < N; j++) {
                Integer aux = Integer.parseInt(split[j]);
                if (linkedHashMap.containsKey(aux)) {
                    int accumulated = linkedHashMap.get(aux) + 1;
                    linkedHashMap.put(aux, accumulated);
                } else {
                    linkedHashMap.put(aux, 1);
                }
            }
            System.out.println("Caso #" + (i + 1) + ":");
            Iterator<Integer> it = linkedHashMap.keySet().iterator();
            while (it.hasNext()) {
                Integer key = it.next();
                System.out.println(key + " " + linkedHashMap.get(key));
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 */
public class ProblemaA {

    public static void main(String[] args) throws Exception {
        BufferedReader input;
        File f = new File("A_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String line = input.readLine();
            String split[] = line.split(" ");
            int K = Integer.parseInt(split[1]);
            Map<Integer, Group> myMap = new HashMap<>();
            for (int j = 0; j < K; j++) {
                line = input.readLine();
                split = line.split(" ");
                int team = Integer.parseInt(split[0]);
                int problem = Integer.parseInt(split[1]);
                int time = Integer.parseInt(split[2]);
                Group aux;
                if (myMap.containsKey(team)) {
                    aux = myMap.get(team);
                    if (split[3].equals("C")) {
                        aux.penalty = aux.tmpPenalty + time;
                        aux.tmpPenalty = aux.penalty;
                        aux.problems++;
                    } else {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                    }
                    myMap.put(team, aux);
                } else {
                    aux = new Group(team);
                    if (split[3].equals("C")) {
                        aux.penalty = aux.tmpPenalty + time;
                        aux.tmpPenalty = aux.penalty;
                        aux.problems++;
                    } else {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                    }
                    myMap.put(team, aux);
                }
            }
            MinBinaryHeap<Group> out = new MinBinaryHeap<>();
            for (Map.Entry<Integer, Group> entry : myMap.entrySet()) {
                Group group = entry.getValue();
                out.insert(group);
            }
            int size = out.currentSize;
            for (int j = 0; j < size; j++) {
                Group group = out.deleteMin();
                System.out.println(group.toString());
            }
        }
    }

    public static class Group implements Comparable<Group> {

        int team;
        int problems;
        int penalty;
        int tmpPenalty;

        public Group(int tm) {
            this.team = tm;
            this.problems = 0;
            this.penalty = 0;
            this.tmpPenalty = 0;
        }

        @Override
        public String toString() {
            return team + " " + problems + " " + penalty;
        }

        @Override
        public int compareTo(Group o) {
            if (team != o.team) {
                if (problems < o.problems) {
                    return 1;
                } else if (problems > o.problems) {
                    return -1;
                } else {
                    if (penalty < o.penalty) {
                        return -1;
                    } else if (penalty > o.penalty) {
                        return 1;
                    } else {
                        if (team < o.team) {
                            return -1;
                        } else if (team > o.team) {
                            return 1;
                        }
                    }
                }
            }
            return 0;
        }
    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 */
public class ProblemaE {

    public static void main(String[] args) throws Exception {
        BufferedReader input;
        File f = new File("A_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String line = input.readLine();
            String split[] = line.split(" ");
            int K = Integer.parseInt(split[1]);
            int[] board = new int[4];
            Map<Integer, Group> myMap = new HashMap<>();
            for (int k = 0; k < 4; k++) {
                board[k] = 0;
            }
            for (int j = 0; j < K; j++) {
                line = input.readLine();
                split = line.split(" ");
                int team = Integer.parseInt(split[0]);
                //int problem = Integer.parseInt(split[1]);
                int time = Integer.parseInt(split[2]);
                Group aux;
                if (myMap.containsKey(team)) {
                    aux = myMap.get(team);
                    if (split[3].equalsIgnoreCase("C")) {
                        aux.penalty = aux.tmpPenalty + time;
                        aux.tmpPenalty = aux.penalty;
                        aux.problems++;
                        board[0]++;
                    } else if (split[3].equalsIgnoreCase("I")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[1]++;
                    } else if (split[3].equalsIgnoreCase("T")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[2]++;
                    } else if (split[3].equalsIgnoreCase("R")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[3]++;
                    }
                    myMap.put(team, aux);
                } else {
                    aux = new Group(team);
                    if (split[3].equalsIgnoreCase("C")) {
                        aux.penalty = aux.tmpPenalty + time;
                        aux.tmpPenalty = aux.penalty;
                        aux.problems++;
                        board[0]++;
                    } else if (split[3].equalsIgnoreCase("I")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[1]++;
                    } else if (split[3].equalsIgnoreCase("T")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[2]++;
                    } else if (split[3].equalsIgnoreCase("R")) {
                        aux.tmpPenalty = aux.tmpPenalty + 20;
                        board[3]++;
                    }
                    myMap.put(team, aux);
                }
            }
            MinBinaryHeap<Group> out = new MinBinaryHeap<>();
            for (Map.Entry<Integer, Group> entry : myMap.entrySet()) {
                Group group = entry.getValue();
                out.insert(group);
            }
            int size = out.currentSize;
            for (int j = 0; j < size; j++) {
                Group group = out.deleteMin();
                System.out.println(group.toString());
            }
            for (int k = 0; k < 4; k++) {
                if (k != 3) {
                    System.out.print(board[k] + " ");
                }else{
                    System.out.println(board[k]);
                }
            }

        }
    }

    public static class Group implements Comparable<Group> {

        int team;
        int problems;
        int penalty;
        int tmpPenalty;

        public Group(int tm) {
            this.team = tm;
            this.problems = 0;
            this.penalty = 0;
            this.tmpPenalty = 0;
        }

        @Override
        public String toString() {
            return team + " " + problems + " " + penalty;
        }

        @Override
        public int compareTo(Group o) {
            if (team != o.team) {
                if (problems < o.problems) {
                    return 1;
                } else if (problems > o.problems) {
                    return -1;
                } else {
                    if (penalty < o.penalty) {
                        return -1;
                    } else if (penalty > o.penalty) {
                        return 1;
                    } else {
                        if (team < o.team) {
                            return -1;
                        } else if (team > o.team) {
                            return 1;
                        }
                    }
                }
            }
            return 0;
        }
    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 */
public class ProblemaA {

    public static void main(String[] args) throws Exception {
        BufferedReader input;
        File f = new File("A_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String line = input.readLine();
            String split[] = line.split(" ");
            int K = Integer.parseInt(split[1]);
            Map<Integer, Group> myMap = new HashMap<>();
            for (int j = 0; j < K; j++) {
                line = input.readLine();
                split = line.split(" ");
                int team = Integer.parseInt(split[0]);
                int problem = Integer.parseInt(split[1]);
                int time = Integer.parseInt(split[2]);
                Group aux;
                int penalty;
                if (myMap.containsKey(team)) {
                    aux = myMap.get(team);
                } else {
                    aux = new Group(team);
                }
                if (split[3].equals("C")) {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.problems.get(problem) + time;
                        aux.setPenalty(penalty);
                    } else {
                        penalty = aux.penalty + time;
                        aux.setPenalty(penalty);
                    }
                    aux.problems.put(problem, penalty);
                    aux.numProblems++;
                } else {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.problems.get(problem) + 20;
                    } else {
                        penalty = 20;
                    }
                    aux.problems.put(problem, penalty);
                }
                myMap.put(team, aux);
            }
            MinBinaryHeap<Group> out = new MinBinaryHeap<>();
            for (Map.Entry<Integer, Group> entry : myMap.entrySet()) {
                Group group = entry.getValue();
                out.insert(group);
            }
            int size = out.currentSize;
            for (int j = 0; j < size; j++) {
                Group group = out.deleteMin();
                System.out.println(group.toString());
            }
        }
    }

    public static class Group implements Comparable<Group> {

        int team;
        Map<Integer, Integer> problems = new HashMap<>();
        int numProblems;
        private int penalty;

        public Group(int tm) {
            this.team = tm;
        }

        public void setPenalty(int penalty) {
            this.penalty = penalty;
        }

        @Override
        public String toString() {
            return team + " " + numProblems + " " + penalty;
        }

        @Override
        public int compareTo(Group o) {
            if (team != o.team) {
                if (numProblems < o.numProblems) {
                    return 1;
                } else if (numProblems > o.numProblems) {
                    return -1;
                } else {
                    if (penalty < o.penalty) {
                        return -1;
                    } else if (penalty > o.penalty) {
                        return 1;
                    } else {
                        if (team < o.team) {
                            return -1;
                        } else if (team > o.team) {
                            return 1;
                        }
                    }
                }
            }
            return 0;
        }

    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 */
public class ProblemaE {

    public static void main(String[] args) throws Exception {
        BufferedReader input;
        File f = new File("A_1.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String line = input.readLine();
            String split[] = line.split(" ");
            int K = Integer.parseInt(split[1]);
            Map<Integer, Group> myMap = new HashMap<>();
            int[] board = new int[4];
            for (int k = 0; k < 4; k++) {
                board[k] = 0;
            }
            for (int j = 0; j < K; j++) {
                line = input.readLine();
                split = line.split(" ");
                int team = Integer.parseInt(split[0]);
                int problem = Integer.parseInt(split[1]);
                int time = Integer.parseInt(split[2]);
                Group aux;
                int penalty;
                if (myMap.containsKey(team)) {
                    aux = myMap.get(team);
                } else {
                    aux = new Group(team);
                }
                if (split[3].equalsIgnoreCase("C")) {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.problems.get(problem) + time;
                        aux.setPenalty(penalty);
                    } else {
                        penalty = aux.penalty + time;
                        aux.setPenalty(penalty);
                    }
                    aux.problems.put(problem, penalty);
                    aux.numProblems++;
                    board[0]++;
                } else if (split[3].equalsIgnoreCase("I")){
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.problems.get(problem) + 20;
                    } else {
                        penalty = 20;
                    }
                    aux.problems.put(problem, penalty);
                    board[1]++;
                }  else if (split[3].equalsIgnoreCase("T")){
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.problems.get(problem) + 20;
                    } else {
                        penalty = 20;
                    }
                    aux.problems.put(problem, penalty);
                    board[2]++;
                } else if (split[3].equalsIgnoreCase("R")){
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.problems.get(problem) + 20;
                    } else {
                        penalty = 20;
                    }
                    aux.problems.put(problem, penalty);
                    board[3]++;
                }
                myMap.put(team, aux);
            }
            MinBinaryHeap<Group> out = new MinBinaryHeap<>();
            for (Map.Entry<Integer, Group> entry : myMap.entrySet()) {
                Group group = entry.getValue();
                out.insert(group);
            }
            int size = out.currentSize;
            for (int j = 0; j < size; j++) {
                Group group = out.deleteMin();
                System.out.println(group.toString());
            }
            
            for (int k = 0; k < 4; k++) {
                if (k != 3) {
                    System.out.print(board[k] + " ");
                } else {
                    System.out.println(board[k]);
                }
            }
        }
    }

    public static class Group implements Comparable<Group> {

        int team;
        Map<Integer, Integer> problems = new HashMap<>();
        int numProblems;
        private int penalty;

        public Group(int tm) {
            this.team = tm;
        }

        public void setPenalty(int penalty) {
            this.penalty = penalty;
        }

        @Override
        public String toString() {
            return team + " " + numProblems + " " + penalty;
        }

        @Override
        public int compareTo(Group o) {
            if (team != o.team) {
                if (numProblems < o.numProblems) {
                    return 1;
                } else if (numProblems > o.numProblems) {
                    return -1;
                } else {
                    if (penalty < o.penalty) {
                        return -1;
                    } else if (penalty > o.penalty) {
                        return 1;
                    } else {
                        if (team < o.team) {
                            return -1;
                        } else if (team > o.team) {
                            return 1;
                        }
                    }
                }
            }
            return 0;
        }

    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 */
public class ProblemaA {

    public static void main(String[] args) throws Exception {
        BufferedReader input;
        File f = new File("A_2.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String line = input.readLine();
            String split[] = line.split(" ");
            int K = Integer.parseInt(split[1]);
            Map<Integer, Group> myMap = new HashMap<>();
            for (int j = 0; j < K; j++) {
                line = input.readLine();
                split = line.split(" ");
                int team = Integer.parseInt(split[0]);
                int problem = Integer.parseInt(split[1]);
                int time = Integer.parseInt(split[2]);
                Group aux;
                int penalty;
                if (myMap.containsKey(team)) {
                    aux = myMap.get(team);
                } else {
                    aux = new Group(team);
                }
                if (split[3].equalsIgnoreCase("C")) {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.penalty +  aux.problems.get(problem) + time;
                    } else {
                        penalty = aux.penalty + time;
                    }
                    aux.setPenalty(penalty);
                    aux.problems.put(problem, penalty);
                    aux.numProblems++;
                } else {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.penalty + aux.problems.get(problem) + 20;
                    } else {
                        penalty = aux.penalty + 20;
                    }
                    aux.problems.put(problem, penalty);
                }
                myMap.put(team, aux);
            }
            MinBinaryHeap<Group> out = new MinBinaryHeap<>();
            for (Map.Entry<Integer, Group> entry : myMap.entrySet()) {
                Group group = entry.getValue();
                out.insert(group);
            }
            int size = out.currentSize;
            for (int j = 0; j < size; j++) {
                Group group = out.deleteMin();
                System.out.println(group.toString());
            }
        }
    }

    public static class Group implements Comparable<Group> {

        int team;
        Map<Integer, Integer> problems = new HashMap<>();
        int numProblems;
        private int penalty;

        public Group(int tm) {
            this.team = tm;
        }

        public void setPenalty(int penalty) {
            this.penalty = penalty;
        }

        @Override
        public String toString() {
            return team + " " + numProblems + " " + penalty;
        }

        @Override
        public int compareTo(Group o) {
            if (team != o.team) {
                if (numProblems < o.numProblems) {
                    return 1;
                } else if (numProblems > o.numProblems) {
                    return -1;
                } else {
                    if (penalty < o.penalty) {
                        return -1;
                    } else if (penalty > o.penalty) {
                        return 1;
                    } else {
                        if (team < o.team) {
                            return -1;
                        } else if (team > o.team) {
                            return 1;
                        }
                    }
                }
            }
            return 0;
        }

    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 */
public class ProblemaE {

    public static void main(String[] args) throws Exception {
        BufferedReader input;
        File f = new File("A_1.txt");
        if (f.exists()) {
            input = new BufferedReader(new FileReader(f));
        } else {
            input = new BufferedReader(new InputStreamReader(System.in));
        }
        int testCases = Integer.parseInt(input.readLine());
        for (int i = 0; i < testCases; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String line = input.readLine();
            String split[] = line.split(" ");
            int K = Integer.parseInt(split[1]);
            Map<Integer, Group> myMap = new HashMap<>();
            int[] board = new int[4];
            for (int k = 0; k < 4; k++) {
                board[k] = 0;
            }
            for (int j = 0; j < K; j++) {
                line = input.readLine();
                split = line.split(" ");
                int team = Integer.parseInt(split[0]);
                int problem = Integer.parseInt(split[1]);
                int time = Integer.parseInt(split[2]);
                Group aux;
                int penalty;
                if (myMap.containsKey(team)) {
                    aux = myMap.get(team);
                } else {
                    aux = new Group(team);
                }
                if (split[3].equalsIgnoreCase("C")) {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.problems.get(problem) + time;
                        aux.setPenalty(penalty);
                    } else {
                        penalty = aux.penalty + time;
                        aux.setPenalty(penalty);
                    }
                    aux.problems.put(problem, penalty);
                    aux.numProblems++;
                    board[0]++;
                } else if (split[3].equalsIgnoreCase("I")) {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.penalty + aux.problems.get(problem) + 20;
                    } else {
                        penalty = aux.penalty + 20;
                    }
                    aux.problems.put(problem, penalty);
                    board[1]++;
                } else if (split[3].equalsIgnoreCase("T")) {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.penalty + aux.problems.get(problem) + 20;
                    } else {
                        penalty = aux.penalty + 20;
                    }
                    aux.problems.put(problem, penalty);
                    board[2]++;
                } else if (split[3].equalsIgnoreCase("R")) {
                    if (aux.problems.containsKey(problem)) {
                        penalty = aux.penalty + aux.problems.get(problem) + 20;
                    } else {
                        penalty = aux.penalty + 20;
                    }
                    aux.problems.put(problem, penalty);
                    board[3]++;
                }
                myMap.put(team, aux);
            }
            MinBinaryHeap<Group> out = new MinBinaryHeap<>();
            for (Map.Entry<Integer, Group> entry : myMap.entrySet()) {
                Group group = entry.getValue();
                out.insert(group);
            }
            int size = out.currentSize;
            for (int j = 0; j < size; j++) {
                Group group = out.deleteMin();
                System.out.println(group.toString());
            }

            for (int k = 0; k < 4; k++) {
                if (k != 3) {
                    System.out.print(board[k] + " ");
                } else {
                    System.out.println(board[k]);
                }
            }
        }
    }

    public static class Group implements Comparable<Group> {

        int team;
        Map<Integer, Integer> problems = new HashMap<>();
        int numProblems;
        private int penalty;

        public Group(int tm) {
            this.team = tm;
        }

        public void setPenalty(int penalty) {
            this.penalty = penalty;
        }

        @Override
        public String toString() {
            return team + " " + numProblems + " " + penalty;
        }

        @Override
        public int compareTo(Group o) {
            if (team != o.team) {
                if (numProblems < o.numProblems) {
                    return 1;
                } else if (numProblems > o.numProblems) {
                    return -1;
                } else {
                    if (penalty < o.penalty) {
                        return -1;
                    } else if (penalty > o.penalty) {
                        return 1;
                    } else {
                        if (team < o.team) {
                            return -1;
                        } else if (team > o.team) {
                            return 1;
                        }
                    }
                }
            }
            return 0;
        }

    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 */
public class Parcial2A {

    public static void main(String[] args) throws IOException {
        BufferedReader in;
        File f = new File("A.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        for (int i = 0; i < n; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            int Q = Integer.parseInt(in.readLine());
            Map<Integer, Integer> linkedHashMap = new LinkedHashMap<>();
            MyQueue<Integer> fila = new MyQueue<>();
            for (int j = 0; j < Q; j++) {
                String[] line = in.readLine().split(" ");
                switch (line[0]) {
                    case "agregar":
                        fila.enqueue(Integer.parseInt(line[1]));
                        break;
                    case "existe":
                        if (linkedHashMap.containsKey(Integer.parseInt(line[1]))) {
                            System.out.println("SI");
                        } else {
                            System.out.println("NO");
                        }
                        break;
                    case "atender":
                        int aux = fila.dequeue();
                        linkedHashMap.put(aux, aux);
                        break;
                }
            }
        }
    }
    
    public static class MyQueue<AnyType> {

	private Node<AnyType> front;
	private Node<AnyType> back;
	private int theSize;

	public MyQueue() {
		front = back = null;
		theSize = 0;
	}

	public int size() {
		return theSize;
	}

	public boolean isEmpty() {
		return front == null;
	}

	public void enqueue(AnyType data) {
		Node<AnyType> nuevo = new Node<AnyType>(data, null);
		if (isEmpty()) {
			front = nuevo;
		} else {
			back.next = nuevo;
		}
		back = nuevo;
		theSize++;
	}

	public AnyType dequeue() {
		if (!isEmpty()) {
			AnyType aux = front.data;
			if (front == back) {
				front = null;
				back = null;
			} else {
				front = front.next;
			}
			theSize--;
			return aux;
		} else {
			return null;
		}
	}

	public AnyType peek() {
		return front.data;
	}

	public void print() {
		if (!this.isEmpty()) {
			Node<AnyType> aux = front;
			while (aux != null) {
				System.out.print(aux.data + "\t");
				aux = aux.next;
			}
		} else {
			System.out.println("Lista Vacia");
		}
	}

	private static class Node<AnyType> {

		public AnyType data;
		public Node<AnyType> next;

		public Node(AnyType d, Node<AnyType> n) {
			data = d;
			next = n;
		}
	}
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.HashMap;

/**
 */
public class Parcial2B {

    public static void main(String[] args) throws Exception {
        BufferedReader in;
        File f = new File("B.txt");
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
        } else {
            in = new BufferedReader(new InputStreamReader(System.in));
        }
        int n = Integer.parseInt(in.readLine());
        for (int i = 0; i < n; i++) {
            System.out.println("Caso #" + (i + 1) + ":");
            String[] line = in.readLine().split(" ");
            int Q = Integer.parseInt(line[0]);
            int N = Integer.parseInt(line[1]);
            HashMap<Integer, Integer> hashMap = new HashMap<>();
            MyQueue<Integer> fila = new MyQueue<>();
            MinBinaryHeap<Integer> parqueadero;
            Integer[] array = new Integer[N];
            for (int k = 0; k < N; k++) {
                array[k] = k;
            }
            parqueadero = new MinBinaryHeap<>(array);
            for (int j = 0; j < Q; j++) {
                line = in.readLine().split(" ");
                switch (line[0]) {
                    case "agregar":
                        fila.enqueue(Integer.parseInt(line[1]));
                        break;
                    case "existe":
                        if (hashMap.containsKey(Integer.parseInt(line[1]))) {
                            System.out.println("SI " + hashMap.get(Integer.parseInt(line[1])));
                        } else {
                            System.out.println("NO");
                        }
                        break;
                    case "atender":
                        int aux = fila.dequeue();
                        hashMap.put(aux, parqueadero.deleteMin());
                        break;
                    case "salir":
                        Integer key = Integer.parseInt(line[1]);
                        int libre = hashMap.remove(key);
                        parqueadero.insert(libre);
                        break;
                }
            }
        }
    }

    public static class MyQueue<AnyType> {

        private Node<AnyType> front;
        private Node<AnyType> back;
        private int theSize;

        public MyQueue() {
            front = back = null;
            theSize = 0;
        }

        public int size() {
            return theSize;
        }

        public boolean isEmpty() {
            return front == null;
        }

        public void enqueue(AnyType data) {
            Node<AnyType> nuevo = new Node<AnyType>(data, null);
            if (isEmpty()) {
                front = nuevo;
            } else {
                back.next = nuevo;
            }
            back = nuevo;
            theSize++;
        }

        public AnyType dequeue() {
            if (!isEmpty()) {
                AnyType aux = front.data;
                if (front == back) {
                    front = null;
                    back = null;
                } else {
                    front = front.next;
                }
                theSize--;
                return aux;
            } else {
                return null;
            }
        }

        public AnyType peek() {
            return front.data;
        }

        public void print() {
            if (!this.isEmpty()) {
                Node<AnyType> aux = front;
                while (aux != null) {
                    System.out.print(aux.data + "\t");
                    aux = aux.next;
                }
            } else {
                System.out.println("Lista Vacia");
            }
        }

        private static class Node<AnyType> {

            public AnyType data;
            public Node<AnyType> next;

            public Node(AnyType d, Node<AnyType> n) {
                data = d;
                next = n;
            }
        }
    }

    public static class MinBinaryHeap<AnyType extends Comparable<? super AnyType>> {

        private static final int DEFAULT_CAPACITY = 10;
        private int currentSize; // Number of elements in heap
        private AnyType[] array; // The heap array

        public MinBinaryHeap() {
            this(DEFAULT_CAPACITY);
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(int capacity) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[capacity + 1];
        }

        @SuppressWarnings("unchecked")
        public MinBinaryHeap(AnyType[] items) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
            int i = 1;
            for (AnyType item : items) {
                array[i++] = item;
            }
            buildHeap();
        }

        public boolean isEmpty() {
            return currentSize == 0;
        }

        public void makeEmpty() {
            currentSize = 0;
        }

        @SuppressWarnings("unchecked")
        private void enlargeArray(int newSize) {
            AnyType[] old = array;
            array = (AnyType[]) new Comparable[newSize];
            for (int i = 0; i < old.length; i++) {
                array[i] = old[i];
            }
        }

        public void insert(AnyType x) {
            if (currentSize == array.length - 1) {
                enlargeArray(array.length * 2 + 1);
            }
            // Percolate up
            int hole = ++currentSize;
            for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
                array[hole] = array[hole / 2];
            }
            array[hole] = x;
        }

        public AnyType findMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            return array[1];
        }

        public AnyType deleteMin() throws Exception {
            if (isEmpty()) {
                throw new Exception();
            }
            AnyType minItem = findMin();
            array[1] = array[currentSize--];
            percolateDown(1);
            return minItem;
        }

        private void buildHeap() {
            for (int i = currentSize / 2; i > 0; i--) {
                percolateDown(i);
            }
        }

        private void percolateDown(int hole) {
            int child;
            AnyType tmp = array[hole];
            for (; hole * 2 <= currentSize; hole = child) {
                child = hole * 2;
                if (child != currentSize && array[child + 1].compareTo(array[child]) < 0) {
                    child++;
                }
                if (array[child].compareTo(tmp) < 0) {
                    array[hole] = array[child];
                } else {
                    break;
                }
            }
            array[hole] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
