package Programs;

import java.util.Scanner;

public class ProblemA {

	public static long maxi( long[] arre){
		long[] produc= new long[arre.length]; 
		long	max=0; 
		long multi=0;
		for(int i =0; i<arre.length; i++){
				produc[i]=arre[i]; 
		}
		for (int i = 0; i < produc.length; i++) {
			for (int j = 0; j < produc.length; j++) {
				if(produc[i]!=arre[j]){
					 multi=produc[i]*arre[j]; 
					 if (multi>max) {
						max=multi;
					}
				}else{
					 j++; 
				 }	
			}
		}
		return max; 
}
	
	public static void main (String[] args) throws java.lang.Exception
	{ 	
		Scanner in= new Scanner (System.in); 
		int size= in.nextInt();
		long[] arr= new long[size]; 
		for(int i =0; i<arr.length; i++){
			arr[i]=in.nextInt(); 
		}
		System.out.println(maxi(arr)); 
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Programs;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.Scanner;

//Falta comletar el main 
public class ProblemB {

	public static int winBox(int[][] board){
		int tWin=0;

		int sumf=0, sumcol =0;
		for (int i = 0; i < board.length; i++) {
		
			for (int j = 0; j < board.length; j++) {
				sumf=0; sumcol =0;
				for (int j2 = 0; j2 < board.length; j2++) {
					for (int k = 0; k < board.length; k++) {
						sumf=sumf+board[i][j2];
						sumcol=sumcol+board[k][j];
				}
				}if(sumf<sumcol){
					tWin++; 
				} sumf=0; sumcol =0;
		
				
			}
			//board[0][1]; 

		
		}	return tWin; 
	}
	public static void main (String[] args) throws java.lang.Exception
	{
		Scanner in = new Scanner(System.in); 
		int cases=1;
		while(in.hasNext()){
			int size= in.nextInt();
			int[][] board= new int[size][size];
			for (int i = 0; i < board.length; i++) {
				for (int j = 0; j < board.length; j++) {
					board[i][j]= in.nextInt(); 
				}
			}

			int boxWinners= winBox(board); 
			System.out.println("Case #"+cases+":"+"\n"+boxWinners);
			cases++;
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Programs;

import java.util.Scanner;

public class roblemC {
	
	public static int uniLocal(int[][] teams){
		int sum=0;
		int[] local=new int[teams.length];
		int[] visit=new int[teams.length];
			for (int j = 0; j < teams.length; j++) {
				local[j]=teams[j][0];
				visit[j]=teams[j][1];
			}
			for (int i = 0; i < visit.length; i++) {
				for (int j = 0; j < visit.length; j++) {
					if(i!=j){
						if(local[i]==visit[j]){
							sum++; 
						}
					}
				}
			}
			return sum; 
	}
	public static void main(String[] args) {
		Scanner in= new Scanner (System.in); 
		int cases= in.nextInt(); 
		for (int m = 1; m <= cases; m++) {
			int size= in.nextInt();
			int[][] teams= new int[size+1][2];
			for (int i = 0; i < size; i++) {
				for (int j = 0; j < 2; j++) {
					teams[i][j]= in.nextInt(); 	
				}
			}
			int sum= uniLocal(teams);
			System.out.println("Case #"+m+":"+"\n"+sum);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Programs;
import java.util.Scanner;

public class ProblemD {
	public static String limar(char[][] choco){
		int count1=0, count2=0; 
		String exit; 
		boolean exit1=false, exit2=false; 
		//filas 
		for (int k = 1; k < choco.length; k++) {
			count1=0;
			count2=0;
			for (int i = 0; i <choco.length; i++) {
				for (int j = 0; j < choco.length; j++) {
					if(i<k ){
						if(choco[i][j]==35){
							count1++;
						}
					}
					if(i>=k ){
						if(choco[i][j]==35){
							count2++; 
					
						}
					}
				}
			}
			if(count1==count2){
				exit1=true; 
				break; 
			}
		}
		//columnas
		count1=0;
		count2=0;

		for (int k = 1; k < choco.length; k++) {
			count1=0;
			count2=0;
			for (int j = 0; j < choco.length; j++) {
				for (int i = 0; i < choco.length; i++) {
					if(j<k ){
						if(choco[i][j]==35){
							count1++; 
						}
					}
					if(j>=k ){
						if(choco[i][j]==35){
							count2++; 
						}
					}
				}
			}
			if(count1==count2){
				exit2=true; 
				break; 
			}
		}

		if(exit1 || exit2){
			exit="YES";
		}else{
			exit="NO";
		}
		return exit; 
	}





	public static void main(String[] args) {
		Scanner in = new  Scanner(System.in); 
		int cases= in.nextInt();
		for (int m = 0; m < cases; m++) {
		int size= in.nextInt(); 
		char[][] choco= new char[size][size]; 
		for (int i = 0; i <size; i++) {
			char[] cho=in.next().toCharArray();
			for (int j = 0; j < size; j++) {
				choco[i][j]=cho[j]; 
			}
		}
		System.out.println(limar(choco));
	}

	}
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class problemED {
	
    public static String limar(char[][] choco){
		int count1=0, count2=0,count4=0 , count3=0; 
		String exit; 
		boolean exit1=false, exit2=false; 
		//filas 
		for (int k = 1; k < choco.length; k++) {
			count1=0;
			count2=0;
                        count3=0;
                        count4=0; 
			for (int i = 0; i <choco.length; i++) {
				for (int j = 0; j < choco.length; j++) {
					if(i<k){
						if(choco[i][j]==35){
							count1++;
						}
                                                if(choco[j][i]==35){
							count3++; 
						}
					}
					if(i>=k ){
						if(choco[i][j]==35){
							count2++; 
					
						}
                                                if(choco[j][i]==35){
							count4++; 
						}
					}
				}
			}
			if(count1==count2){
				exit1=true; 
				break; 
			}
                        if(count3==count4){
				exit2=true; 
				break; 
			}
                        
                }
		if(exit1 || exit2){
			exit="YES";
		}else{
			exit="NO";
		}
		return exit; 
	}





	public static void main(String[] args) {
		Scanner in = new  Scanner(System.in); 
		int cases= in.nextInt();
		for (int m = 0; m < cases; m++) {
		int size= in.nextInt(); 
		char[][] choco= new char[size][size]; 
		for (int i = 0; i <size; i++) {
			char[] cho=in.next().toCharArray();
			for (int j = 0; j < size; j++) {
				choco[i][j]=cho[j]; 
			}
		}
		System.out.println(limar(choco));
	}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             char[][] choco=new char[size][size]; 
             for (int j = 0; j < size; j++) {
                 char[] a=in.next().toCharArray();
                 for (int k = 0; k < size; k++) {
                     	choco[j][k]=a[k]; 
                 }
             }
             boolean exit1=false,exit2=false; 
             //filas
             for (int j = 0; j < choco.length; j++) {
                 int a =Filas(choco, 0,j);
                 int b= Filas(choco, j, choco.length);
                 if(a==b){
                  exit1=true;
                  break;
                 }
             }
             //columnas
             for (int j = 0; j < choco.length; j++) {
                 int a =Columnas(choco, 0,j);
                 int b= Columnas(choco, j, choco.length);
                 if(a==b){
                  exit2=true;
                  break;
                 }
             }
             if(exit1 || exit2){
                 System.out.println("YES");
             }else{
                 System.out.println("NO");
             }
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             char[][] choco=new char[size][size]; 
             for (int j = 0; j < size; j++) {
                 char[] a=in.next().toCharArray();
                 for (int k = 0; k < size; k++) {
                     	choco[j][k]=a[k]; 
                 }
             }
             boolean exit1=false,exit2=false; 
             //filas
             for (int j = 0; j < choco.length; j++) {
                 int a =Filas(choco, 0,j);
                 int b= Filas(choco, j, choco.length);
                 int c =Columnas(choco, 0,j);
                 int d= Columnas(choco, j, choco.length);
                 if(a==b || c==d){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                if(exit1){
                     System.out.println("YES");
                 }else{
                System.out.println("NO");
                }
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD2 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             char[][] choco=new char[size][size]; 
             for (int j = 0; j < size; j++) {
                 char[] a=in.next().toCharArray();
                 for (int k = 0; k < size; k++) {
                     	choco[j][k]=a[k]; 
                 }
             }
             boolean exit1=false,exit2=false; 
             //filas
             for (int j = 0; j < choco.length; j++) {
                 int a =Filas(choco, 0,j);
                 int b= Filas(choco, j, choco.length);
                 int c =Columnas(choco, 0,j);
                 int d= Columnas(choco, j, choco.length);
                 if(a==b || c==d){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                if(exit1){
                     System.out.println("YES");
                 }else{
                System.out.println("NO");
                }
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class problema1 {
     
    public static void main(String[] args) {
    Scanner in= new Scanner(System.in); 
    int te= in.nextInt(), count=0; 
     for (int i = 0; i <5; i++) {
         int cor=in.nextInt();
         if(te==cor){
         count++;}
        }
        System.out.println(count);
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD2 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             char[][] choco=new char[size][size]; 
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                     	choco[j][k]=line.charAt(k); 
                 }
             }
             boolean exit1=false,exit2=false; 
             //filas
             for (int j = 0; j < choco.length; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j, choco.length) || Columnas(choco, 0,j)==Columnas(choco, j, choco.length)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                if(exit1){
                     System.out.println("YES");
                 }else{
                System.out.println("NO");
                }
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD2 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             char[][] choco=new char[size][size]; 
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                     	choco[j][k]=line.charAt(k); 
                 }
             }
             boolean exit1=false,exit2=false; 
             //filas
             for (int j = 0; j < choco.length; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1) || Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                if(exit1){
                     System.out.println("YES");
                 }else{
                System.out.println("NO");
                }
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD2 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             char[][] choco=new char[size][size]; 
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                     	choco[j][k]=line.charAt(k); 
                 }
             }
             boolean exit1=false,exit2=false; 
             //filas
             for (int j = 0; j < choco.length-1; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1) || Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                if(exit1){
                     System.out.println("YES");
                 }else{
                System.out.println("NO");
                }
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD3 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             char[][] choco=new char[size][size]; 
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                     	choco[j][k]=line.charAt(k); 
                 }
             }
             boolean exit1=false;
             //filas
             for (int j = 0; j < choco.length-1; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1) || Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD3 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1+1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1+1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false;
             //filas
             for (int j = 0; j < choco.length-1; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1) || Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD3 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1+1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1+1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false;
             //filas
             for (int j = 0; j < choco.length-1; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1) || Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
public class ProblemD3 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1+1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1+1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false;
             //filas
             for (int j = 0; j < choco.length-1; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1) || Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
import java.util.Scanner;
public class D {
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false;
             //filas
             for (int j = 0; j < choco.length; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1) || Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
import java.util.Scanner;
public class D {
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false;
             //filas
             for (int j = 0; j < choco.length; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1) || Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
              
             }
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
import java.util.Scanner;
public class D {
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false,exit2=false;
             //filas
             for (int j = 0; j < choco.length; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
                 if( Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit2=true;
                  break;
             
             }
              
             } exit1=exit2 || exit1; 
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
import java.util.Scanner;
public class D {
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false,exit2=false;
             //filas
             for (int j = 0; j < choco.length-1; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
                 if( Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit2=true;
                  break;
             
             }
              
             } exit1=exit2 || exit1; 
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
import java.util.Scanner;
public class D {
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false,exit2=false;
             //filas
             for (int j = 0; j < choco.length-1; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1)||Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
                 /*if( Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit2=true;
                  break;
             
             }*/
              
             } //exit1=exit2 || exit1; 
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 */
import java.util.Scanner;
public class D {
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        int aux=y0;
        if(y1<y0){
          y0=y1;
          y1=aux;
       
        }
        for (int i = 0; i < choco.length; i++) {
            for (int j = y0; j <y1 ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        int aux=x0; 
        if(x1<x0){
          x0=x1;
          x1=aux;
       
        }
        for (int i = x0; i < x1; i++) {
            for (int j = 0; j < choco.length; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             boolean exit1=false,exit2=false;
             //filas
             for (int j = 0; j < choco.length-1; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j+1, choco.length-1)||Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit1=true;
                  break;
             
             }
                 /*if( Columnas(choco, 0,j)==Columnas(choco, j+1, choco.length-1)){
                   exit2=true;
                  break;
             
             }*/
              
             } //exit1=exit2 || exit1; 
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

/**
 *
 */
public class ProblemD3 {
    
    public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j <choco.length ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = 0; i < choco.length; i++) {
            for (int j = x0; j < x1; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
     public static void main(String[] args) {
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             boolean exit1=false;
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             //filas
             for (int j = 1; j < choco.length; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j, choco.length)){
                   exit1=true;
                  break;
             
             }else if(Columnas(choco, 0,j)==Columnas(choco, j, choco.length)){
                   exit1=true;
                  break;
              }
             }
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
    }

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.util.*;

/* Name of the class has to be "Main" only if the class is public. */
class ProblemD
{	public static int Filas(char[][] choco, int y0, int y1){
        int cerezas=0; 
        
        for (int i = y0; i < y1; i++) {
            for (int j = 0; j <choco.length ; j++) {
                if(choco[i][j]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
    
    
    public static int Columnas(char[][] choco, int x0, int x1){
        int cerezas=0; 
        for (int i = 0; i < choco.length; i++) {
            for (int j = x0; j < x1; j++) {
                if(choco[j][i]==35){
                cerezas++;
                }
            }
        }
    return cerezas; 
    }
	public static void main (String[] args) 
	{
		
        Scanner in= new Scanner(System.in); 
        int cases= in.nextInt();
        
         for (int i = 0; i < cases; i++) {
             int size=in.nextInt();
             boolean exit1=false;
        
             char[][] choco=new char[size][size]; 
             
             for (int j = 0; j < size; j++) {
                String line= in.next(); 
                 for (int k = 0; k < size; k++) {
                 
                     choco[j][k]=line.charAt(k); 

                 }
             }
             //filas
             for (int j = 1; j < choco.length; j++) {
               
                 if( Filas(choco, 0,j)==Filas(choco, j, choco.length)){
                   exit1=true;
                  break;
             
             }else if(Columnas(choco, 0,j)==Columnas(choco, j, choco.length)){
                   exit1=true;
                  break;
              }
             }
             //columnas
                String ams=exit1? "YES" : "NO";
                System.out.println(ams);
           
         }
        
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class ProblemD {
	
	static int filas(char[][] choco,int x0,int x1){
		int cerezas=0;
		for(int i=x0;i<x1;i++){
			for(int j=0;j<choco.length;j++){
				if(choco[i][j]==35)
			cerezas++;
			}
		}
		return cerezas;
	}
	
	static int columnas(char[][] choco,int y0,int y1){
		int cerezas=0;
		for(int i=0;i<choco.length;i++){
			for(int j=y0;j<y1;j++){
				if(choco[i][j]==35)
		 cerezas++; 
			}
		}
		return cerezas;
	}
	
	public static void main(String args[]){
		Scanner in = new Scanner(System.in);
		int cases = in.nextInt();
		for(int m=0;m<cases;m++){
			boolean exit=false;
			int size = in.nextInt();
			char[][] choco = new char[size][size];
			for(int i=0;i<size;i++){
				String a = in.next();
				for(int j=0;j<size;j++){
					choco[i][j] = a.charAt(j);
				}
			}
			for(int p=1;p<size;p++){
				if(columnas(choco,0,p)==columnas(choco,p,size)){
					exit=true;
					break;
					}
				else if(filas(choco,0,p)==filas(choco,p,size)){
					exit=true;
					break;
				}
			}
			if(exit){
			 System.out.println("YES");
			}else{ System.out.println("NO");}
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
     
        public static boolean buscar(Stack cGirl ,String token){
            boolean res=false;
            if(!cGirl.empty()){
                 String cual;
                for(int i=(cGirl.size()-1) ; i>=0; i--){
                    cual=(String)cGirl.get(i);
                    if(cual.equals(token)){
                        res= true; 
                        break; 
            
                    }
                }
            }
            return res;
        }
    
        public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int nC=in.nextInt();
        in.nextLine();
        int nChiAprov=0; 
        Stack reque= new Stack(); 
        StringTokenizer cualidades=new StringTokenizer (in.nextLine());
         while(cualidades.hasMoreTokens()){
             reque.push(cualidades.nextToken()); 
         }
        int nChi= in.nextInt();
        in.nextLine();
        for(int i=0 ; i<nChi ; i++){
            Stack requeCopi= new Stack();
            for(int p=0; p<reque.size();p++){
                requeCopi.push(reque.get(p));
            }
            Stack cGirl= new Stack(); 
            cualidades= new StringTokenizer(in.nextLine());
            
            while(cualidades.hasMoreTokens()){                                                                
                 cGirl.push(cualidades.nextToken()); 
            }
            if(cGirl.size()>=requeCopi.size()){
                for(int j=requeCopi.size()-1; j>=0; j--){
                    String req= (String)requeCopi.get(j); 
                    if(buscar(cGirl,req)){
                        requeCopi.remove(j);
                        continue;
                    }else{
                        break; 
                    }
            
                }
            }
            if(requeCopi.empty()){
                nChiAprov++; 
            }
        }
        System.out.println(nChiAprov); 
    }
}
    
   
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Carlos {
     
        public static boolean buscar(Stack cGirl ,String token){
            boolean res=false;
            if(!cGirl.empty()){
                 String cual;
                for(int i=(cGirl.size()-1) ; i>=0; i--){
                    cual=(String)cGirl.get(i);
                    if(cual.equals(token)){
                        res= true; 
                        break; 
            
                    }
                }
            }
            return res;
        }
    
        public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int nC=in.nextInt();
        in.nextLine();
        int nChiAprov=0; 
        Stack reque= new Stack(); 
        StringTokenizer cualidades=new StringTokenizer (in.nextLine());
         while(cualidades.hasMoreTokens()){
             reque.push(cualidades.nextToken()); 
         }
        int nChi= in.nextInt();
        in.nextLine();
        for(int i=0 ; i<nChi ; i++){
            Stack requeCopi= new Stack();
            for(int p=0; p<reque.size();p++){
                requeCopi.push(reque.get(p));
            }
            Stack cGirl= new Stack(); 
            cualidades= new StringTokenizer(in.nextLine());
            
            while(cualidades.hasMoreTokens()){                                                                
                 cGirl.push(cualidades.nextToken()); 
            }
            if(cGirl.size()>=requeCopi.size()){
                for(int j=requeCopi.size()-1; j>=0; j--){
                    String req= (String)requeCopi.get(j); 
                    if(buscar(cGirl,req)){
                        requeCopi.remove(j);
                        continue;
                    }else{
                        break; 
                    }
            
                }
            }
            if(requeCopi.empty()){
                nChiAprov++; 
            }
        }
        System.out.println(nChiAprov); 
    }
}
    
   
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;
//FALTA QUE LO HAGA BIEN CON TODOS LOS CASOS (iNDIVIDUAL YA SIRVE)
import java.util.Scanner;
import java.util.Stack;
import java.util.StringTokenizer;

public class Players2 {

	public static void main(String[] args) {
	 	Scanner in = new  Scanner(System.in);
			int cases= in.nextInt();
			int n=0;
            int k=0;
	        for(int i =0; i <cases ; i++){
	            
	          
	            n=in.nextInt();
	            k=in.nextInt();
	            in.nextLine();
	            StringTokenizer mazo = new StringTokenizer(in.nextLine()); 
	            int[] score= new int[k];
	            Stack<Integer> pila= new Stack<Integer>(); 
	            while(mazo.hasMoreTokens()){	
	                    pila.push(Integer.valueOf(mazo.nextToken()));
	               }
	           // }
	            loop:
	            while(!pila.empty()){
	                for(int i1 =0; i1<k;i1++){
	                    if(!pila.empty()){
	                        int first=  pila.firstElement();
	                        int last= pila.peek();
	                        if(last>=first){
	                            score[i1]=score[i1]+last;
	                            pila.pop();
	                        }else{
	                            score[i1]=score[i1]+first;
	                            pila.remove(pila.firstElement());
	                        }
	                        
	                    }else{
	                    
	                        break loop;
	                    }
	                }
	            }
	            int max=score[0];
	            for(int i1 =1; i1<score.length;i1++){
	                
	                if(max<=score[i1]){
	                    max=score[i1];
	                 }
	             }   
	           String resul="";
	            for(int i1 =0; i1<score.length;i1++){
	            		if(score[i1]==max){
	            			resul=resul.concat(String.valueOf(i1+1).concat(" "));
		                    }
	            }
	            System.out.println("Caso #"+(i+1)+"\n"+resul);

		   }

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;

import java.util.LinkedList;
import java.util.Scanner;
import java.util.Stack;
import java.util.StringTokenizer;

public class GymUN {

	public static void main(String[] args) {
		Scanner in =new  Scanner(System.in); 
	      int cases= in.nextInt();
	       for(int  i=0; i<cases;i++){
	    	  System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<LinkedList<Persona>> gym= new LinkedList<LinkedList<Persona>>(); ;
	    	  int nCub= in.nextInt();
	    	  in.nextLine();
	    	  StringTokenizer capaci= new StringTokenizer(in.nextLine());
	    	  double[] tM = new double[capaci.toString().length()]; 
	    	  int capacit=0;
	    	  for (int j = 0; j < nCub; j++) {
	    		  gym.add(new LinkedList<Persona>()); 
	    		  tM[j]=Integer.valueOf(capaci.nextToken());
	    	  }
	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
	    	  //LINEAS DE COMANDO 
	    	  int comands=in.nextInt(); 
	    	  in.nextLine();
	    	  for (int j = 0; j < comands; j++) {
				//comandos
	    		  
	    		   capaci= new  StringTokenizer(in.nextLine()); 
	    		   String comando=capaci.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=capaci.nextToken();
	    			 apellido=capaci.nextToken();
	    			 cedula= Integer.valueOf(capaci.nextToken()); 
	    			 insertar(gym,tM,nombre,cedula,apellido); 
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(capaci.nextToken());
	    			  salir(exit, gym);
	    		  }
	    	  }
	       
	       }
	}
	public static void salir(long cedula,LinkedList<LinkedList<Persona>> gym ){
	String nom;
	loop:
		for (int i = 0; i < gym.size(); i++) {
			for (int j = 0; j < gym.get(i).size(); j++) {
				if(!gym.get(i).isEmpty()){
					if(gym.get(i).get(j).getCedula()==cedula){
						nom=gym.get(i).get(j).getNombre();
						System.out.println(nom);
						gym.get(i).remove(j);
						break loop;
					}
				}
				
			}
		}
	}
	
	public static void insertar(LinkedList<LinkedList<Persona>> gym, double[] tM, String nombre, long cedula,String apellido){
		double[] cap= new double[tM.length];
		for (int i = 0; i < gym.size(); i++) {
			cap[i]=(gym.get(i).size())/tM[i];
		}
		double cargaMin=cap[0];
		for (int i = 1; i < gym.size(); i++) {
			if(cargaMin>cap[i]){
				cargaMin=cap[i]; 
			}
		}
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int i = 0; i < gym.size(); i++) {
				if(cargaMin==cap[i]){
					gym.get(i).push( new Persona(nombre, apellido, cedula));
					System.out.println((i+1)+" "+gym.get(i).size());
					break;
				}
			}
		
		}
		
	}
public static class Persona{
	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;

import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;

public class ProblemE {

	public static void main(String[] args) {
		Scanner in =new  Scanner(System.in); 
	      int cases= in.nextInt();
	       for(int  i=0; i<cases;i++){
	    	   System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<Pregistrada> registro= new LinkedList<Pregistrada>();  
	    	  LinkedList<LinkedList<Persona>> gym= new LinkedList<LinkedList<Persona>>(); ;
	    	  int nCub= in.nextInt();
	    	  in.nextLine();
	    	  StringTokenizer capaci= new StringTokenizer(in.nextLine());
	    	  double[] tM = new double[capaci.toString().length()]; 
	    	  int capacit=0;
	    	  for (int j = 0; j < nCub; j++) {
	    		  gym.add(new LinkedList<Persona>()); 
	    		  tM[j]=Integer.valueOf(capaci.nextToken());
	    	  }
	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
	    	  //LINEAS DE COMANDO 
	    	  int comands=in.nextInt(); 
	    	  in.nextLine();
	    	  for (int j = 0; j < comands; j++) {
				//comandos
	    		  
	    		   capaci= new  StringTokenizer(in.nextLine()); 
	    		   String comando=capaci.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=capaci.nextToken();
	    			 apellido=capaci.nextToken();
	    			 cedula= Integer.valueOf(capaci.nextToken()); 
	    			 insertar(gym,tM,nombre,cedula,apellido,registro); 
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(capaci.nextToken());
	    			  salir(exit, gym);
	    		  }
	    	  }
	       
	       }

	}
	public static void salir(long cedula,LinkedList<LinkedList<Persona>> gym ){
	String nom;
	loop:
		for (int i = 0; i < gym.size(); i++) {
			for (int j = 0; j < gym.get(i).size(); j++) {
				if(!gym.get(i).isEmpty()){
					if(gym.get(i).get(j).getCedula()==cedula){
						nom=gym.get(i).get(j).getNombre();
						System.out.println(nom);
						gym.get(i).remove(j);
						break loop;
					}
				}
				
			}
		}
	}
	
	public static void insertar(LinkedList<LinkedList<Persona>> gym, double[] tM, String nombre, long cedula,String apellido, 
																					LinkedList<Pregistrada> registro){
		
		boolean registrado=false; 
		double[] cap= new double[tM.length];
		for (int i = 0; i < gym.size(); i++) {
			cap[i]=(gym.get(i).size())/tM[i];
		}
		double cargaMin=cap[0];
		for (int i = 1; i < gym.size(); i++) {
			if(cargaMin>cap[i]){
				cargaMin=cap[i]; 
			}
		}
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int i = 0; i < gym.size(); i++) {
				if(cargaMin==cap[i]){
					
					for (int j = 0; j < registro.size(); j++) {
						if(registro.get(j).getCedula()==cedula){
							if (registro.get(j).getEntradas()==3) {
								System.out.println("ingreso denegado");
								registrado=true;
								break;
							}else{
								gym.get(i).push( new Persona(nombre, apellido, cedula));
								System.out.println((i+1)+" "+gym.get(i).size());
								registro.get(j).setEntradas(registro.get(j).getEntradas()+1); 
								registrado=true;
								break;
							}
						}
					}
					if(!registrado){
						gym.get(i).push( new Persona(nombre, apellido, cedula));
						System.out.println((i+1)+" "+gym.get(i).size());
						registro.add(new Pregistrada(cedula)); 
					}
					break;
				}
			}
		
		}
		
	}
public static class Persona{

	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}
public static class Pregistrada {
	private long cedula;
	private int entradas;
	public Pregistrada(long cedula){
		this.cedula=cedula;
		this.entradas=1; 
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	public int getEntradas() {
		return entradas;
	}
	public void setEntradas(int entradas) {
		this.entradas = entradas;
	} 

}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
run:
8
12 3
6 9 15 17 6 15 2 4 3 7 9 15
6 1
6 5 9 14 14 4
12 2
1 17 15 19 17 5 4 19 4 15 18 14
4 3
2 13 12 17
5 3
13 17 3 5 9
8 3
11 12 15 6 7 2 3 14
9 3
12 7 12 18 1 3 17 18 14
16 4
15 11 18 4 2 18 13 4 1 10 19 11 5 12 5 2
Caso #1:
1 
Caso #2:
1 
Caso #3:
1 
Caso #4:
1 
Caso #5:
2 
Caso #6:
1 
Caso #7:
1 
Caso #8:
2 
BUILD SUCCESSFUL (total time: 4 seconds)

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;
//FALTA QUE LO HAGA BIEN CON TODOS LOS CASOS (iNDIVIDUAL YA SIRVE)
import java.util.Scanner;
import java.util.Stack;
import java.util.StringTokenizer;

public class Players2 {

	public static void main(String[] args) {
	 	Scanner in = new  Scanner(System.in);
			int cases= in.nextInt();
			int n=0;
            int k=0;
	        for(int i =0; i <cases ; i++){

	            n=in.nextInt();
	            k=in.nextInt();
	            in.nextLine();
	            StringTokenizer mazo = new StringTokenizer(in.nextLine());
	            int[] score= new int[k];
	            Stack<Integer> pila= new Stack<Integer>();
	            while(mazo.hasMoreTokens()){
	                    pila.push(Integer.valueOf(mazo.nextToken()));
	               }
	           // }
	            loop:
	            while(!pila.empty()){
	                for(int i1 =0; i1<k;i1++){
	                    if(!pila.empty()){
	                        int first=  pila.firstElement();
	                        int last= pila.peek();
	                        if(last>=first){
	                            score[i1]=score[i1]+last;
	                            pila.pop();
	                        }else{
	                            score[i1]=score[i1]+first;
	                            pila.remove(pila.firstElement());
	                        }

	                    }else{

	                        break loop;
	                    }
	                }
	            }
	            int max=score[0];
	            for(int i1 =1; i1<score.length;i1++){

	                if(max<=score[i1]){
	                    max=score[i1];
	                 }
	             }
	           String resul="";
	            for(int i1 =0; i1<score.length;i1++){
	            		if(score[i1]==max){
	            			resul=resul.concat(String.valueOf(i1+1).concat(" "));
		                    }
	            }
	            System.out.println("Caso #"+(i+1)+":"+"\n"+resul);

		   }

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;

import java.util.LinkedList;
import java.util.Scanner;
import java.util.Stack;
import java.util.StringTokenizer;

public class GymUN {

	public static void main(String[] args) {
		Scanner in =new  Scanner(System.in);
	      int cases= in.nextInt();
	       for(int  i=0; i<cases;i++){
	    	  System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<LinkedList<Persona>> gym= new LinkedList<LinkedList<Persona>>(); ;
	    	  int nCub= in.nextInt();
	    	  in.nextLine();
	    	  StringTokenizer capaci= new StringTokenizer(in.nextLine());
	    	  double[] tM = new double[nCub];
	    	  int capacit=0;
	    	  for (int j = 0; j < nCub; j++) {
	    		  gym.add(new LinkedList<Persona>());
	    		  tM[j]=Integer.valueOf(capaci.nextToken());
	    	  }
                  System.out.println(capaci.toString().length());

	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
	    	  //LINEAS DE COMANDO
	    	  int comands=in.nextInt();
	    	  in.nextLine();
	    	  for (int j = 0; j < comands; j++) {
				//comandos

	    		   capaci= new  StringTokenizer(in.nextLine());
	    		   String comando=capaci.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=capaci.nextToken();
	    			 apellido=capaci.nextToken();
	    			 cedula= Integer.valueOf(capaci.nextToken());
	    			 insertar(gym,tM,nombre,cedula,apellido);
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(capaci.nextToken());
	    			  salir(exit, gym);
	    		  }
	    	  }

	       }
	}
	public static void salir(long cedula,LinkedList<LinkedList<Persona>> gym ){
	String nom;
	loop:
		for (int i = 0; i < gym.size(); i++) {
			for (int j = 0; j < gym.get(i).size(); j++) {
				if(!gym.get(i).isEmpty()){
					if(gym.get(i).get(j).getCedula()==cedula){
						nom=gym.get(i).get(j).getNombre();
						System.out.println(nom);
						gym.get(i).remove(j);
						break loop;
					}
				}

			}
		}
	}

	public static void insertar(LinkedList<LinkedList<Persona>> gym, double[] tM, String nombre, long cedula,String apellido){
		double[] cap= new double[tM.length];
		for (int i = 0; i < gym.size(); i++) {
			cap[i]=(gym.get(i).size())/tM[i];
		}
		double cargaMin=cap[0];
		for (int i = 1; i < gym.size(); i++) {
			if(cargaMin>cap[i]){
				cargaMin=cap[i];
			}
		}
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int i = 0; i < gym.size(); i++) {
				if(cargaMin==cap[i]){
					gym.get(i).push( new Persona(nombre, apellido, cedula));
					System.out.println((i+1)+" "+gym.get(i).size());
					break;
				}
			}

		}

	}
public static class Persona{
	private String nombre;
	private String apellido;
	private long cedula;

	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido;
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}


	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;

import java.util.LinkedList;
import java.util.Scanner;
import java.util.Stack;
import java.util.StringTokenizer;

public class GymUN {

	public static void main(String[] args) {
		Scanner in =new  Scanner(System.in);
	      int cases= in.nextInt();
	       for(int  i=0; i<cases;i++){
	    	  System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<LinkedList<Persona>> gym= new LinkedList<LinkedList<Persona>>(); ;
	    	  int nCub= in.nextInt();
	    	  in.nextLine();
	    	  StringTokenizer capaci= new StringTokenizer(in.nextLine());
	    	  double[] tM = new double[nCub];
	    	 
	    	  for (int j = 0; j < nCub; j++) {
	    		  gym.add(new LinkedList<Persona>());
	    		  tM[j]=Integer.valueOf(capaci.nextToken());
	    	  }
                
	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
	    	  //LINEAS DE COMANDO
	    	  int comands=in.nextInt();
	    	  in.nextLine();
	    	  for (int j = 0; j < comands; j++) {
				//comandos

	    		   capaci= new  StringTokenizer(in.nextLine());
	    		   String comando=capaci.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=capaci.nextToken();
	    			 apellido=capaci.nextToken();
	    			 cedula= Integer.valueOf(capaci.nextToken());
	    			 insertar(gym,tM,nombre,cedula,apellido);
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(capaci.nextToken());
	    			  salir(exit, gym);
	    		  }
	    	  }

	       }
	}
	public static void salir(long cedula,LinkedList<LinkedList<Persona>> gym ){
	String nom;
	loop:
		for (int i = 0; i < gym.size(); i++) {
			for (int j = 0; j < gym.get(i).size(); j++) {
				if(!gym.get(i).isEmpty()){
					if(gym.get(i).get(j).getCedula()==cedula){
						nom=gym.get(i).get(j).getNombre();
						System.out.println(nom);
						gym.get(i).remove(j);
						break loop;
					}
				}

			}
		}
	}

	public static void insertar(LinkedList<LinkedList<Persona>> gym, double[] tM, String nombre, long cedula,String apellido){
		double[] cap= new double[tM.length];
		for (int i = 0; i < gym.size(); i++) {
			cap[i]=(gym.get(i).size())/tM[i];
		}
		double cargaMin=cap[0];
		for (int i = 1; i < gym.size(); i++) {
			if(cargaMin>cap[i]){
				cargaMin=cap[i];
			}
		}
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int i = 0; i < gym.size(); i++) {
				if(cargaMin==cap[i]){
					gym.get(i).push( new Persona(nombre, apellido, cedula));
					System.out.println((i+1)+" "+gym.get(i).size());
					break;
				}
			}

		}

	}
public static class Persona{
	private String nombre;
	private String apellido;
	private long cedula;

	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido;
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}


	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package DOMJudge2;

import java.util.Scanner;

public class MainA {
    
    static public class ListaEnlazada {
    
        private Nodo cabeza;
        private int costoList = 0;
        private int costoArray = 0;
        public boolean auxBoolean = true;
        
        class Nodo {
            int data;
            Nodo next;
        }
    
    
        
        public int getCostoList(){
        return costoList;
        }
    
        int getCostoArray(){
        return costoArray;
        }
    
        public ListaEnlazada () {
        cabeza = null;
        }
        
        public int tamanno(){
        int auxTamano = 0;
        Nodo i = cabeza;
            while ( i!=null ){
                i = i.next;
                auxTamano++;
            }
        return auxTamano;
        }
        
        void definirArray( int[]array, int idx ){
            int []aux = new int[ idx*2 ];
            for(int i = 0; i < idx*2; i++ ){
                aux[i] = -1;
            }
        
            for(int i = 0; i < idx; i++ ){
                aux[i] = array[i];
            }
        array = aux;
        }
    
        void recorrerArray( int[]array, int posicion, int idx){
        int count = 0;
        for(int i = idx; i > posicion; i-- ){
           array[i] = array[i-1];
           count++;
           
        }
        costoArray = costoArray + ( count - 1 );
        }
        
        void eliminarArray(int[]array ,int posicion,int idx){
            if( ( posicion <= idx ) && ( posicion >= 0 ) ){
                int count = 0;
                for(int i= posicion; i < idx; i++ ){
                    array[i] = array[ i+1 ] ;
                    count++;
                }
                array[idx] = -1;
                if( posicion == 0 ){
                    costoArray = costoArray + (count);
                }
                else{
                    costoArray = costoArray + (count);
                }
            }
        }
        
        
        void buscarArray( int[]array, int dato, int idx ){
            int count = 0;
            for(int x = 0; x < idx; x++ ){
                count++;
                if( array[x] == dato ){
                    costoArray = costoArray + count;
                    x = idx;
                }
                if( array[x] != dato && x == ( idx - 1 ) ){
                    costoArray = costoArray + count;
                }
            }
        }
        
        
        
        void insertar (int dato, int posicion){   
            if (posicion <= tamanno() && posicion >= 0 ){
                Nodo nuevo = new Nodo ();
                nuevo.data = dato;
                if (posicion == 0){
                    nuevo.next = cabeza;
                    cabeza = nuevo;
                }else{
                    if (posicion == tamanno ()){
                        Nodo i = cabeza;
                   
                        while (i.next != null) {
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        i.next = nuevo;
                        nuevo.next = null;
                    }else{
                        Nodo i = cabeza;
                        for (int x = 1; x < posicion ; x++){
                            i = i.next;
                        }
                        costoList = costoList + posicion;
                        Nodo siguiente = i.next;
                        i.next = nuevo;
                        nuevo.next = siguiente;
                    }
                }
                System.out.println("insertar: posicion valida");
            }else{
            System.out.println("insertar: posicion invalida");
            }   
        }
        
        
        void buscar(int dato){
            int aux = 0;
            boolean auxBool = true;
            Nodo i = cabeza;
            while( i != null && i.data != dato){
                 i = i.next;
                 aux++;
            }
            if( i != null ){
                System.out.println("buscar: " + aux);
                costoList = costoList + (aux+1);
            }else{
                System.out.println("no existe numero");
                costoList = costoList + tamanno();
            }
        }
        
        
        
        void consultar(int posicion){
            Nodo i = cabeza;
            if( posicion < tamanno() && posicion >= 0 && cabeza != null ){
                for(int x=0;x<posicion;x++){
                    i=i.next;
                    costoList++;
                }
                System.out.println("consulta: "+i.data);
            }else{
                System.out.println("consulta: no encontrado");
            }
        }
        
        
        
    
        void eliminar(int posicion){
            Nodo i = cabeza;
            boolean auxBoolTwo = true;
            if(posicion == 0 && cabeza != null ){
                auxBoolean = false;
                cabeza = cabeza.next;
                System.out.println("eliminar: posicion valida");
                auxBoolTwo = false;
            }
            if(posicion < tamanno() && posicion > 0){
                for( int x = 1; x < posicion; x++ ){
                     i = i.next;
                     costoList++;
                }
                auxBoolean = false;
                Nodo siguiente = i.next;
                i.next = siguiente.next;
                System.out.println("eliminar: posicion valida");
            }else{
                if(auxBoolTwo == true){
                    System.out.println("eliminar: posicion invalida");
                }
            }
        }
    
    
}

    public static void main(String[] ar) {
        Scanner sc = new Scanner( System.in );
        int casos = sc.nextInt();
        String comando;
        
        for(int u = 0; u < casos; u++ ){
            System.out.println( "Caso #" + (u+1) + ":" );
            int instruccion = sc.nextInt();
            ListaEnlazada list = new ListaEnlazada();
            int indice = 0;
            int[] array = new int[10];
            int tamano;
            for( int i = 0; i < 10 ; i++ ){
            array[i] = -1;
            }
         
            
            for( int i=0 ; i < instruccion ; i++ ){
                comando = sc.next();
                if( "insertar".equals(comando) ){
                    int dato = sc.nextInt();
                    int posicion = sc.nextInt();
                    list.insertar( dato, posicion );
                    if( posicion <= list.tamanno() ){
                        indice++;
                        tamano =  array.length;
                        if( indice == tamano ){
                        list.definirArray( array, indice );
                        }
                        if( array[posicion] == -1 ){
                            array[posicion] = dato;
                        }
                        else{
                        list.recorrerArray( array, posicion, indice );
                        array[posicion] = dato;
                        }
                    }
                }
                if("buscar".equals(comando)){
                    int datoAux = sc.nextInt();
                    list.buscar( datoAux );
                    list.buscarArray( array, datoAux, indice );
                }
                if("eliminar".equals( comando )){
                    int posicionAux = sc.nextInt();
                    list.eliminar( posicionAux );
                    if( list.auxBoolean == false ){
                        indice--;
                        list.auxBoolean = true;
                    }
                    list.eliminarArray( array, posicionAux, indice );
                }
                if("consultar".equals( comando )){
                    int pos = sc.nextInt();
                    list.consultar( pos );
                }
                if("costo".equals( comando )){
                    System.out.println("costo: " + list.getCostoArray() + " " + list.getCostoList());
                }
            }
        }                    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;
import java.util.*;

class nodo {
    public int dato;
    public nodo next;
    // constructor por defecto
    public nodo(){
        next=null;
    };
    // con un dato
    public nodo(int dato){
        this.dato = dato;
        this.next = null;
    };
    // el nodo vacio
    public nodo (nodo next){
        this.next=next;
    };
    //en nodo completo
    public nodo (int dato1,nodo next){
        dato=dato1;
        this.next=next;
    };
    
    
}

class lista {
    public nodo primero;
    // contructor basicao
    public lista(){
        listEmpty();
    };
    // borra la lista
    public void listEmpty(){
        this.primero=null;
    };
    // lista esta vacia?
    public boolean vacia(){
        return primero == null;
    }; 
    public void ingresarPrimero(int dato){
        nodo nuevo = new nodo(dato);
        if(!vacia()){
        nuevo.next=primero;
        };
        primero=nuevo;
    };
    public void ingresarUltimo(int dato){
        nodo tem = new nodo(dato);
        nodo tem2;
        if(vacia()){
            ingresarPrimero(dato);
        }else{
            tem2=primero;
            while(tem2.next!=null){
                tem2=tem2.next;
            };
            tem2.next=tem;
        };
        
    };
    public void removeFirst(){
        nodo tem;
        if(!vacia()){
            tem=primero;
            primero = primero.next;
            tem=null;
        };
    };
    public void removeLast(){
        nodo tem =primero;
        if(tem.next==null){
            listEmpty();
        };
        if(!vacia()){
            tem=primero;
            while(tem.next.next!=null){
                tem=tem.next;
            };
            tem.next=null;
        };
    };
    //muestra el ultimo dato
    public int muestraUltimo(){
        int dato=0;
        nodo tem;
        if(!vacia()){
            tem = primero;
            while(tem.next!=null){
                tem = tem.next;
            };
            dato = tem.dato;
        };
        return dato;
    };
    // muestre el primer dato
    public int muestraPrimero(){
        int dato = 0;
        if(!vacia()){
            dato= primero.dato;
        };
        return dato;
    };
    // da el numero de nodos en la lista
    public int numeroNodos(){
        nodo tem;
        int elementos=0;
        tem = primero;
        while(tem != null){
            elementos++;
            tem = tem.next;            
        };
        return elementos;
    }; 
    // muestre el dato en uan posicion
    public int muesrtaDato(int posicion){
        nodo tem = primero;
        int cont =0;
        int dato =0;
        if(posicion<0||posicion>=numeroNodos()){
            System.out.println("consulta: no econtrado");
        }else{
            while(tem != null){
                if(posicion == cont){
                    dato = tem.dato;
                };
                tem = tem.next;
                cont++;
            };
        };
        return dato;
    }; 
    // debuelve el nodo en una posicion
    public nodo mostrarNodo(int posicion){
        nodo tem = primero;
        int cont=0;
        if(posicion<0||posicion>=numeroNodos()){
            System.out.println("consulta: no encontrado");
            tem=null;
        }else{
            while(tem!=null){
                if(cont==posicion){
                    return tem;
                }
                tem=tem.next;
                cont++;
            }; 
        };
        return tem;
    };                  // funcion 2-A
    // agrega un nuevo nodo en una posicion x
    public void introducirNodo(int posicion,int dato){
        nodo tem=primero;
        nodo nuevo;
        nodo anterior=primero;
        int cont=0;
        if(posicion<0||posicion>numeroNodos()){
            System.out.println("insertar: posicion invalida");
        }else{
            System.out.println("insertar: posicion valida");
            if(posicion==0){
                ingresarPrimero(dato);
            }else if (posicion==numeroNodos()){
                ingresarUltimo(dato);
            }else{
                while(tem!=null){
                    if(posicion==cont){
                        nuevo= new nodo(dato,tem);
                        anterior.next=nuevo;
                    };
                    anterior=tem;
                    cont++;
                    tem=tem.next;
                };
            };
        };
    };      // funcion 1-A
    // cambia el dato de un nodo en una posicion
    public void changeDato(int posicion,int dato){
        nodo tem=primero;
        int cont =0;
        if(posicion<0||posicion>numeroNodos()){
            System.out.println("posicion no valida");
        }else{
            while(tem!=null){
                if(posicion==cont){
                    tem.dato=dato;
                };
                cont++;
                tem=tem.next;
            };
        };
    };
    //borra un nodo en la posicion 'x'
    public void borrarPosicion(int posicion){
        nodo tem = primero;
        nodo anterior =null;
        int cont=0;
        if(posicion<0||posicion>=numeroNodos()){
            System.out.println("eliminar: posicion invalida");
        }else{
            System.out.println("eliminar: posicion valida");
            while(tem!=null){
                if (cont==posicion){
                    if(anterior==null){
                        primero=primero.next;
                    }else{
                        anterior.next=tem.next;
                    };
                    tem=null;
                }else{
                    anterior=tem;
                    tem=tem.next;
                    cont++;
                };
            };
        };
    };              // funcion 3-A
    //muestra e primer dato y lo borra
    public int mostrarPrmero(){
        int dato = muestraPrimero();
        removeFirst();
        return dato;
    };
    // indica la posisicion del primer dato que se encuentre
    public int indexof(int dato){
        nodo tem=primero;
        if(vacia()){
            System.out.println("no existe numero987");
            return -1;
        }else{
            int cont=0;
            boolean encontrado= false;
            while(tem!=null&&!encontrado){
                if(dato==tem.dato){
                    encontrado=true;
                }else{
                    cont++;
                    tem=tem.next;
                };
            };
            if(encontrado){
                return cont;
            }else{
                System.out.println("no existe numero987");
                return -1;
            }
        }
    };                          // funcion 4-A
    // indica la posicion del primer dato desde la posocion que se indica
    public int indexof(int dato,int posicion){
        nodo tem;
        if(vacia()){
            return -1;
        }else{
            int cont=0;
            boolean encontrado= false;
            tem = mostrarNodo(posicion);
            while(tem!=null&&!encontrado){
                if(dato==tem.dato){
                    encontrado=true;
                }else{
                    cont++;
                    tem=tem.next;
                };
            };
            if(encontrado){
                return cont;
            }else{
                return -1;
            }
        }
    };
    // muestra si el dato existe en la lista 
    public boolean datoExiste(int dato){
        boolean existe = false;
        nodo tem = primero;
        while(tem!=null&&!existe){
            if(tem.dato==dato){
                existe=true;
            };
            tem=tem.next;
        };
        return existe;
    };
    //mustra el contenido de la lista
    public void mostrar(){
        System.out.println("contenido");
        nodo tem= primero;
        while(tem!=null){
            System.out.print(" "+tem.dato);
            tem = tem.next;
        };
    };
    
    @Override//devuelve el contenido de la lista en un string
    public String toString(){
        String contenido="";
        nodo tem = primero;
        while(tem!=null){
            contenido = tem.dato+"\n";
            tem=tem.next;
        };
        return contenido;
    };
}   

public class ProblemaA{

    
    public static void main(String[] args) {
       lista list = new lista();
        Scanner in = new Scanner(System.in);
        nodo nuevo = new nodo();
        //    nodo mostrarNodo(int posicion){
        //    void introducirNodo 
        //    void borrarPosicion
        //    int indexof buscar dato 
        int casos=in.nextInt();
        int cont=1;
        for(int i=0;i<casos;i++){
            System.out.println("Caso #"+cont+":");
            list.listEmpty();
            int operacionLista=0,operacionArreglo=0;
            int comandos=in.nextInt();
            for(int j=0;j<comandos;j++){
                String comando=in.next();
                int posicion,valor;
                switch(comando){
                    case "insertar":
                        valor=in.nextInt();
                        posicion=in.nextInt();
                        ////////////////////////////////////////////
                        if(!(posicion<0)&&(posicion<=list.numeroNodos())){
                            if(!list.vacia()&&posicion!=0){
                                operacionArreglo=operacionArreglo+posicion;
                            };
                            if(!list.vacia()&&posicion<list.numeroNodos()){
                                operacionLista=operacionLista+(list.numeroNodos()-(posicion));
                            };
                        };
                        //////////////////////////////////////////////
                        list.introducirNodo(posicion, valor);
                        
                        break;
                    case "consultar":
                        posicion=in.nextInt();
                        nuevo=list.mostrarNodo(posicion);
                        if(nuevo==null){
                            break;
                        };
                        System.out.println("consulta: "+nuevo.dato);
                        //////////////////////////////////////////////
                        operacionArreglo=operacionArreglo+posicion; 
                        ////////////////////////////////////////////
                        break;
                    case "buscar":
                        valor=in.nextInt();
                        if(list.datoExiste(valor)){
                            posicion = list.indexof(valor);
                            System.out.println("buscar: "+ posicion);
                            ////////////////////////////////////////////
                            operacionArreglo=operacionArreglo+posicion+1;
                            operacionLista=operacionLista+posicion+1;
                            /////////////////////////////////////////////
                        }else{
                            System.out.println("no existe numero");
                            operacionArreglo=operacionArreglo+list.numeroNodos();
                            operacionLista=operacionLista+list.numeroNodos();
                        };
                        
                        break;
                    case "eliminar":
                        posicion=in.nextInt();
                        ////////////////////////////////////////////////////////////////////////
                        if(!(posicion<0)&&(posicion<list.numeroNodos())){
                            if(!list.vacia()&&posicion!=0){
                                operacionArreglo=operacionArreglo+posicion;
                            };
                        };
                        if(!(posicion<0)&&(posicion+1<list.numeroNodos())){
                            if(!list.vacia()){
                                operacionLista=operacionLista+(list.numeroNodos()-(posicion+1));
                            };
                        };    
                        ///////////////////////////////////////////////////////////////////////
                        list.borrarPosicion(posicion);
                        break;
                    case "costo":
                        System.out.println("costo: "+operacionLista+" "+operacionArreglo);
                        break;
                    default:
                        break;
               };
           };
           cont++;
       }
    }
    
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;

import Exercises.GymUN.Persona;

public class ProblemD {

	public static void main(String[] args) {
		Scanner in =new  Scanner(System.in); 
	      int cases= in.nextInt();
	       for(int  i=0; i<cases;i++){
		    	  int nCub= in.nextInt();
		    	  ArrayList< ArrayList<Persona> > gym= new ArrayList<>();
		    	  int[] ocupados = new int[nCub];
		    	  for(int j = 0; j < nCub; j++) {
		    		  ocupados[j] = 0;
		    		  gym.add(new ArrayList<Persona>());
		    		  int d = in.nextInt();
		    		  for(int k = 0; k < d; k++)
		    			  gym.get(j).add(null);
		    	  }
		    	  
		    	  int comandos = in.nextInt();
		    	  
		    	  for(int j = 0; j < comandos; j++) {
		    		  String c = in.next();
		    		  if(c.equals("ingresar")) {
		    			  String a = in.next(), b = in.next();
		    			  long cedula = in.nextInt();
		    			  Persona tmp = new Persona(a, b, cedula);
		    			  insertar(tmp,gym,ocupados);
		    		  }else if(c.equals("salir")){
		    			  int cedula=in.nextInt();
		    			  salir(cedula, gym,ocupados); 
		    		  }
		    	  }
		    	  
		    	  
	       
	       }
	}
	public static void salir(long cedula,ArrayList< ArrayList<Persona>> gym, int[] ocupados ){
		String nom;
		loop:
			for (int i = 0; i < gym.size(); i++) {
				for (int j = 0; j < gym.get(i).size(); j++) {
						if(gym.get(i).get(j).getCedula()==cedula){
							nom=gym.get(i).get(j).getNombre();
							System.out.println(nom);
							gym.get(i).set(j, null);
							ocupados[i]=ocupados[i]-1;
							break loop;
						}
				}
			}
		
		
	}
	
	public static void insertar(Persona tmp,ArrayList< ArrayList<Persona>> gym, int[] ocupados){
		int[] carga= new int[ocupados.length]; 
		for (int i = 0; i < carga.length; i++) {
			carga[i]=(ocupados[i])/gym.get(i).size();
		}
		int minCarga=carga[0]; 
		for (int i = 1; i < carga.length; i++) {
			if(minCarga>carga[i]){
				minCarga=carga[i]; 
			}
		}
		if(minCarga==1){

			System.out.println("limite alcanzado");
		}else{
			loop:
				for (int i = 0; i < gym.size(); i++) {
					if(minCarga==carga[i]){
						for (int j = 0; j < gym.get(i).size(); j++) {
							if(gym.get(i).get(j)==null){
								gym.get(i).set(j, tmp);
								System.out.println((i+1)+" "+(j+1));
								ocupados[i]=ocupados[i]+1; 
								break loop;
							}/*else if(j+1==gym.get(i).size()){
								gym.get(i).add(tmp); 
								System.out.println((i+1)+" "+(j+1));
								break loop;
							}*/
						}
						
					}
				}                     
		}
	}

public static class Persona{
	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Scanner;


public class ProblemD {

	public static void main(String[] args) {
		Scanner in =new  Scanner(System.in); 
	      int cases= in.nextInt();
	       for(int  i=0; i<cases;i++){
		    	  int nCub= in.nextInt();
		    	  ArrayList< ArrayList<Persona> > gym= new ArrayList<>();
		    	  int[] ocupados = new int[nCub];
		    	  for(int j = 0; j < nCub; j++) {
		    		  ocupados[j] = 0;
		    		  gym.add(new ArrayList<Persona>());
		    		  int d = in.nextInt();
		    		  for(int k = 0; k < d; k++)
		    			  gym.get(j).add(null);
		    	  }
		    	  
		    	  int comandos = in.nextInt();
		    	  
		    	  for(int j = 0; j < comandos; j++) {
		    		  String c = in.next();
		    		  if(c.equals("ingresar")) {
		    			  String a = in.next(), b = in.next();
		    			  long cedula = in.nextInt();
		    			  Persona tmp = new Persona(a, b, cedula);
		    			  insertar(tmp,gym,ocupados);
		    		  }else if(c.equals("salir")){
		    			  int cedula=in.nextInt();
		    			  salir(cedula, gym,ocupados); 
		    		  }
		    	  }
		    	  
		    	  
	       
	       }
	}
	public static void salir(long cedula,ArrayList< ArrayList<Persona>> gym, int[] ocupados ){
		String nom;
		loop:
			for (int i = 0; i < gym.size(); i++) {
				for (int j = 0; j < gym.get(i).size(); j++) {
						if(gym.get(i).get(j).getCedula()==cedula){
							nom=gym.get(i).get(j).getNombre();
							System.out.println(nom);
							gym.get(i).set(j, null);
							ocupados[i]=ocupados[i]-1;
							break loop;
						}
				}
			}
		
		
	}
	
	public static void insertar(Persona tmp,ArrayList< ArrayList<Persona>> gym, int[] ocupados){
		int[] carga= new int[ocupados.length]; 
		for (int i = 0; i < carga.length; i++) {
			carga[i]=(ocupados[i])/gym.get(i).size();
		}
		int minCarga=carga[0]; 
		for (int i = 1; i < carga.length; i++) {
			if(minCarga>carga[i]){
				minCarga=carga[i]; 
			}
		}
		if(minCarga==1){

			System.out.println("limite alcanzado");
		}else{
			loop:
				for (int i = 0; i < gym.size(); i++) {
					if(minCarga==carga[i]){
						for (int j = 0; j < gym.get(i).size(); j++) {
							if(gym.get(i).get(j)==null){
								gym.get(i).set(j, tmp);
								System.out.println((i+1)+" "+(j+1));
								ocupados[i]=ocupados[i]+1; 
								break loop;
							}/*else if(j+1==gym.get(i).size()){
								gym.get(i).add(tmp); 
								System.out.println((i+1)+" "+(j+1));
								break loop;
							}*/
						}
						
					}
				}                     
		}
	}

public static class Persona{
	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Exercises;

import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;

public class ProblemE {

	public static void main(String[] args) {
		Scanner in =new  Scanner(System.in); 
	      int cases= in.nextInt();
	       for(int  i=0; i<cases;i++){
	    	   System.out.println("Caso #"+(i+1)+":");
	    	  LinkedList<Pregistrada> registro= new LinkedList<Pregistrada>();  
	    	  LinkedList<LinkedList<Persona>> gym= new LinkedList<LinkedList<Persona>>(); ;
	    	  int nCub= in.nextInt();
	    	  in.nextLine();
	    	  StringTokenizer capaci= new StringTokenizer(in.nextLine());
	    	  double[] tM = new double[capaci.toString().length()]; 
	    	  int capacit=0;
	    	  for (int j = 0; j < nCub; j++) {
	    		  gym.add(new LinkedList<Persona>()); 
	    		  tM[j]=Integer.valueOf(capaci.nextToken());
	    	  }
	    	  String nombre;
	    	  String apellido;
	    	  long cedula;
	    	  int exit;
	    	  //LINEAS DE COMANDO 
	    	  int comands=in.nextInt(); 
	    	  in.nextLine();
	    	  for (int j = 0; j < comands; j++) {
				//comandos
	    		  
	    		   capaci= new  StringTokenizer(in.nextLine()); 
	    		   String comando=capaci.nextToken();
	    		  if(comando.equals("ingresar")){
	    			 nombre=capaci.nextToken();
	    			 apellido=capaci.nextToken();
	    			 cedula= Integer.valueOf(capaci.nextToken()); 
	    			 insertar(gym,tM,nombre,cedula,apellido,registro); 
	    		  } else if(comando.equals("salir")){
	    			  exit=Integer.valueOf(capaci.nextToken());
	    			  salir(exit, gym);
	    		  }
	    	  }
	       
	       }

	}
	public static void salir(long cedula,LinkedList<LinkedList<Persona>> gym ){
	String nom;
	loop:
		for (int i = 0; i < gym.size(); i++) {
			for (int j = 0; j < gym.get(i).size(); j++) {
				if(!gym.get(i).isEmpty()){
					if(gym.get(i).get(j).getCedula()==cedula){
						nom=gym.get(i).get(j).getNombre();
						System.out.println(nom);
						gym.get(i).remove(j);
						break loop;
					}
				}
				
			}
		}
	}
	
	public static void insertar(LinkedList<LinkedList<Persona>> gym, double[] tM, String nombre, long cedula,String apellido, 
																					LinkedList<Pregistrada> registro){
		
		boolean registrado=false; 
		double[] cap= new double[tM.length];
		for (int i = 0; i < gym.size(); i++) {
			cap[i]=(gym.get(i).size())/tM[i];
		}
		double cargaMin=cap[0];
		for (int i = 1; i < gym.size(); i++) {
			if(cargaMin>cap[i]){
				cargaMin=cap[i]; 
			}
		}
		if(cargaMin==1){
			System.out.println("limite alcanzado");
		}else{
			for (int i = 0; i < gym.size(); i++) {
				if(cargaMin==cap[i]){
					
					for (int j = 0; j < registro.size(); j++) {
						if(registro.get(j).getCedula()==cedula){
							if (registro.get(j).getEntradas()==3) {
								System.out.println("ingreso denegado");
								registrado=true;
								break;
							}else{
								gym.get(i).push( new Persona(nombre, apellido, cedula));
								System.out.println((i+1)+" "+gym.get(i).size());
								registro.get(j).setEntradas(registro.get(j).getEntradas()+1); 
								registrado=true;
								break;
							}
						}
					}
					if(!registrado){
						gym.get(i).push( new Persona(nombre, apellido, cedula));
						System.out.println((i+1)+" "+gym.get(i).size());
						registro.add(new Pregistrada(cedula)); 
					}
					break;
				}
			}
		
		}
		
	}
public static class Persona{

	private String nombre;
	private String apellido;
	private long cedula;	
	
	public Persona(String nombre,String apellido, long cedula ){
		this.cedula=cedula;
		this.nombre=nombre;
		this.apellido=apellido; 
	}
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getApellido() {
		return apellido;
	}
	public void setApellido(String apellido) {
		this.apellido = apellido;
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	

	}
public static class Pregistrada {
	private long cedula;
	private int entradas;
	public Pregistrada(long cedula){
		this.cedula=cedula;
		this.entradas=1; 
	}
	public long getCedula() {
		return cedula;
	}
	public void setCedula(int cedula) {
		this.cedula = cedula;
	}
	public int getEntradas() {
		return entradas;
	}
	public void setEntradas(int entradas) {
		this.entradas = entradas;
	} 

}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles; 
import java.util.Scanner;

public class Problem_A {
	static class Node{
	    int value;
	    Node hijoDere;
	    Node HijoIzque;
	    
	}
		static boolean existe(int value, Node root){
			Node reco= root; 
	 
			while(reco!=null){
	 
				if(reco.value==value){
					return true;
	 
				}else if(reco.value<value){
	 
					reco=reco.hijoDere;
				}else{
	 
					reco=reco.HijoIzque; 
				}
			}
			return false; 
		}
		static Node ancestro(Node root,int v1,int v2)
	    {
			boolean ex1,ex2;
			ex1= existe(v1, root);
			ex2= existe(v2, root); 
			if(!ex1 || !ex2 ){
				return null; 
			}else{
			
	        if(root!=null){
	            if(root.value>v1 && root.value>v2){
	              return ancestro(root.HijoIzque,v1,v2); 
	            }
	            
	            if(root.value<v1 && root.value<v2){
	                return ancestro(root.hijoDere,v1,v2); 
	            }
	        }
	       return root; 
			}
		}

		static Node agregar(Node root,int value)
	    {   
	        if(root == null){
	            Node nodi= new Node();
	            nodi.value=value; 
	            
	            return nodi; 
	        }
	    Node nodo; 
	    
	               
	            if(root.value>value){
	                nodo=agregar(root.HijoIzque,value);
	                root.HijoIzque= nodo; 
	            }else{
	              nodo=agregar(root.hijoDere,value);   
	              root.hijoDere= nodo; 
	            }
	        
	       return root; 
	    }

		static int distancia (int n1, int n2, Node root){
			 
			boolean exn1, exn2; 
	 
			exn1=existe(n1,root);
			exn2=existe(n2,root); 
	 
			if(exn1 && exn2){
				Node reco1= ancestro( root, n1,n2);
				Node ancestro= ancestro(root,n1,n2); 
				Node reco2 = ancestro(root, n1, n2);
				if((n1>reco1.value && n2<reco1.value) || (n1<reco2.value && n2>reco2.value)){
					int dis1=0,dis2=0;
					
					while(reco1.value!=n1){
						
						if(n1>reco1.value){
						
							reco1=reco1.hijoDere; 
							dis1=dis1+1; 
						
						}else{
						
							reco1=reco1.HijoIzque; 
							dis1=dis1+1;
						
						}
					}
					
					while(reco2.value!=n2){
						
						if(n2>reco2.value){
						
							reco2=reco2.hijoDere; 
							dis2=dis2+1; 
						
						}else{
						
							reco2=reco2.HijoIzque; 
							dis2=dis2+1;
						
						}
					}
					return dis1+dis2; 
				}else{
					int dis=0; 
					
					if(reco1.value==n1){
						
						while(reco1.value!=n2){
							
							if(n2>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis;
						
					}else {
						
						while(reco1.value!=n1){	
							
							if(n1>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis; 
						
					}
				}
	         
			}else{
				return -1 ;
			}
		}
	    public static void main(String[] args) {
	       Scanner in = new Scanner(System.in); 
	       int casos=in.nextInt(); 
	       for (int i =0 ;i<casos ;i++){
	    	   
	    	   System.out.println("Caso #"+(i+1)+":");
	           int comad=in.nextInt(); 
	           Node root= null; 
	           int a =0; 
	           for (int j =0; j<comad ;j++){
	              
	              /* StringTokeni
	               * zer comando = new StringTokenizer(in.nextLine()); 
	                System.out.println(comando.nextToken().toString());*/
	               String comando= in.next(); 
	             //   System.out.println(comando); 
	               if(comando.equals("agregar")){
	                   int nodo= in.nextInt(); 
	                  a=a+1; 
	                   if(a==1){
	                       root=agregar(root,nodo); 

	                   }else{
	                        agregar(root,nodo); 
	                   }

	               }else if(comando.equals("ancestro")){
	                   int n1= in.nextInt();  
	                   int n2= in.nextInt(); 
	                   Node ances= ancestro(root,n1,n2); 
	                   if(ances==null){
	                	   System.out.println("ancestro: -1"); 
   
	                   }else{
	                   System.out.println("ancestro: "+ances.value); 
	                   }
	               }else if (comando.equals("distancia")){
	                   int n1= in.nextInt(); 
	                   int n2=in.nextInt();  
	                   int dista = distancia(n1,n2,root); 
	                   System.out.println("distancia: "+dista); 


	               }

	           }
	       }
	    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles; 
import java.util.Scanner;

public class Problem_A {
	static class Node{
	    int value;
	    Node hijoDere;
	    Node HijoIzque;
	    
	}
		static boolean existe(int value, Node root){
			Node reco= root; 
	 
			while(reco!=null){
	 
				if(reco.value==value){
					return true;
	 
				}else if(reco.value<value){
	 
					reco=reco.hijoDere;
				}else{
	 
					reco=reco.HijoIzque; 
				}
			}
			return false; 
		}
		static Node ancestro(Node root,int v1,int v2)
	    {
			boolean ex1,ex2;
			ex1= existe(v1, root);
			ex2= existe(v2, root); 
			if(!ex1 || !ex2 ){
				return null; 
			}else{
			
	        if(root!=null){
	            if(root.value>v1 && root.value>v2){
	              return ancestro(root.HijoIzque,v1,v2); 
	            }
	            
	            if(root.value<v1 && root.value<v2){
	                return ancestro(root.hijoDere,v1,v2); 
	            }
	        }
	       return root; 
			}
		}

		static Node agregar(Node root,int value)
	    {   
	        if(root == null){
	            Node nodi= new Node();
	            nodi.value=value; 
	            
	            return nodi; 
	        }
	    Node nodo; 
	    
	               
	            if(root.value>value){
	                nodo=agregar(root.HijoIzque,value);
	                root.HijoIzque= nodo; 
	            }else{
	              nodo=agregar(root.hijoDere,value);   
	              root.hijoDere= nodo; 
	            }
	        
	       return root; 
	    }

		static int distancia (int n1, int n2, Node root){
			 
			boolean exn1, exn2; 
	 
			exn1=existe(n1,root);
			exn2=existe(n2,root); 
	 
			if(exn1 && exn2){
				Node reco1= ancestro( root, n1,n2);
				Node ancestro= ancestro(root,n1,n2); 
				Node reco2 = ancestro(root, n1, n2);
				if((n1>reco1.value && n2<reco1.value) || (n1<reco2.value && n2>reco2.value)){
					int dis1=0,dis2=0;
					
					while(reco1.value!=n1){
						
						if(n1>reco1.value){
						
							reco1=reco1.hijoDere; 
							dis1=dis1+1; 
						
						}else{
						
							reco1=reco1.HijoIzque; 
							dis1=dis1+1;
						
						}
					}
					
					while(reco2.value!=n2){
						
						if(n2>reco2.value){
						
							reco2=reco2.hijoDere; 
							dis2=dis2+1; 
						
						}else{
						
							reco2=reco2.HijoIzque; 
							dis2=dis2+1;
						
						}
					}
					return dis1+dis2; 
				}else{
					int dis=0; 
					
					if(reco1.value==n1){
						
						while(reco1.value!=n2){
							
							if(n2>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis;
						
					}else {
						
						while(reco1.value!=n1){	
							
							if(n1>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis; 
						
					}
				}
	         
			}else{
				return -1 ;
			}
		}
	    public static void main(String[] args) {
	       Scanner in = new Scanner(System.in); 
	       int casos=in.nextInt(); 
	       for (int i =0 ;i<casos ;i++){
	    	   
	    	   System.out.println("Caso #"+(i+1)+":");
	           int comad=in.nextInt(); 
	           Node root= null; 
	           int a =0; 
	           for (int j =0; j<comad ;j++){
	              
	              /* StringTokeni
	               * zer comando = new StringTokenizer(in.nextLine()); 
	                System.out.println(comando.nextToken().toString());*/
	               String comando= in.next(); 
	             //   System.out.println(comando); 
	               if(comando.equals("agregar")){
	                   int nodo= in.nextInt(); 
	                  a=a+1; 
	                   if(a==1){
	                       root=agregar(root,nodo); 

	                   }else{
	                        agregar(root,nodo); 
	                   }

	               }else if(comando.equals("ancestro")){
	                   int n1= in.nextInt();  
	                   int n2= in.nextInt(); 
	                   Node ances= ancestro(root,n1,n2); 
	                   if(ances==null){
	                	   System.out.println("ancestro: -1"); 
   
	                   }else{
	                   System.out.println("ancestro: "+ances.value); 
	                   }
	               }else if (comando.equals("distancia")){
	                   int n1= in.nextInt(); 
	                   int n2=in.nextInt();  
	                   int dista = distancia(n1,n2,root); 
	                   System.out.println("distancia: "+dista); 


	               }

	           }
	       }
	    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles;

import java.util.LinkedList;
import java.util.Scanner;


public class Problem_e {
	static class Node{
	    int value;
	    Node hijoDere;
	    Node HijoIzque;
	    
	}
		static boolean existe(int value, Node root){
			Node reco= root; 
	 
			while(reco!=null){
	 
				if(reco.value==value){
					return true;
	 
				}else if(reco.value<value){
	 
					reco=reco.hijoDere;
				}else{
	 
					reco=reco.HijoIzque; 
				}
			}
			return false; 
		}
		
		
		
		static Node ancestro(Node root,int v1,int v2)
	    {
			boolean ex1,ex2;
			ex1= existe(v1, root);
			ex2= existe(v2, root); 
			if(!ex1 || !ex2 ){
				return null; 
			}else{
			
	        if(root!=null){
	            if(root.value>v1 && root.value>v2){
	              return ancestro(root.HijoIzque,v1,v2); 
	            }
	            
	            if(root.value<v1 && root.value<v2){
	                return ancestro(root.hijoDere,v1,v2); 
	            }
	        }
	       return root; 
			}
		}

		static Node agregar(Node root,int value)
	    {   
	        if(root == null){
	            Node nodi= new Node();
	            nodi.value=value; 
	            
	            return nodi; 
	        }
	    Node nodo; 
	    
	               
	            if(root.value>value){
	                nodo=agregar(root.HijoIzque,value);
	                root.HijoIzque= nodo; 
	            }else{
	              nodo=agregar(root.hijoDere,value);   
	              root.hijoDere= nodo; 
	            }
	        
	       return root; 
	    }

		static int distancia (int n1, int n2, Node root){
			 
			boolean exn1, exn2; 
	 
			exn1=existe(n1,root);
			exn2=existe(n2,root); 
	 
			if(exn1 && exn2){
				Node reco1= ancestro( root, n1,n2);
				Node ancestro= ancestro(root,n1,n2); 
				Node reco2 = ancestro(root, n1, n2);
				if((n1>reco1.value && n2<reco1.value) || (n1<reco2.value && n2>reco2.value)){
					int dis1=0,dis2=0;
					
					while(reco1.value!=n1){
						
						if(n1>reco1.value){
						
							reco1=reco1.hijoDere; 
							dis1=dis1+1; 
						
						}else{
						
							reco1=reco1.HijoIzque; 
							dis1=dis1+1;
						
						}
					}
					
					while(reco2.value!=n2){
						
						if(n2>reco2.value){
						
							reco2=reco2.hijoDere; 
							dis2=dis2+1; 
						
						}else{
						
							reco2=reco2.HijoIzque; 
							dis2=dis2+1;
						
						}
					}
					return dis1+dis2; 
				}else{
					int dis=0; 
					
					if(reco1.value==n1){
						
						while(reco1.value!=n2){
							
							if(n2>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis;
						
					}else {
						
						while(reco1.value!=n1){	
							
							if(n1>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis; 
						
					}
				}
	         
			}else{
				return -1 ;
			}
		}
		
	static	public Node buscar(int d , Node raiz ){
			if(raiz==null){
				return null; 
			}else if(raiz.value==d){
				return raiz ; 
			}else if(raiz.value<d){
				return buscar(d,raiz.hijoDere); 
			}else{
				return buscar(d,raiz.HijoIzque);
			}
		}
		/*/*void Preorder(Node root) {
   if(root==null){
       
   }else{
      System.out.print(root.data+" ");
      if(root.left!=null){
          Preorder(root.left);
      }
       if(root.right!=null){
          Preorder(root.right);
      }
       
   }
}*/			static LinkedList<Integer> recorridoHijos(Node root, LinkedList<Integer> hijos){
				
				if(root!=null){
					recorridoHijos(root.HijoIzque, hijos);
					hijos.add(root.value);  
					recorridoHijos( root.hijoDere,hijos);
				}
				return hijos; 
			}
	
		static int contarU(int value, Node root){
			Node padre= buscar(value, root); 
			if(padre==null){
				return -1;
			}else{
				LinkedList<Integer> hijos= new LinkedList<>(); 
				return (recorridoHijos( padre,hijos).size()-1); 
				
			}
		}
		
	    public static void main(String[] args) {
	       Scanner in = new Scanner(System.in); 
	       int casos=in.nextInt(); 
	       for (int i =0 ;i<casos ;i++){
	    	   
	    	   System.out.println("Caso #"+(i+1)+":");
	           int comad=in.nextInt(); 
	           Node root= null; 
	           int a =0; 
	           for (int j =0; j<comad ;j++){
	              
	              /* StringTokeni
	               * zer comando = new StringTokenizer(in.nextLine()); 
	                System.out.println(comando.nextToken().toString());*/
	               String comando= in.next(); 
	             //   System.out.println(comando); 
	               if(comando.equals("agregar")){
	                   int nodo= in.nextInt(); 
	                  a=a+1; 
	                   if(a==1){
	                       root=agregar(root,nodo); 

	                   }else{
	                        agregar(root,nodo); 
	                   }

	               }else if(comando.equals("ancestro")){
	                   int n1= in.nextInt();  
	                   int n2= in.nextInt(); 
	                   Node ances= ancestro(root,n1,n2); 
	                   if(ances==null){
	                	   System.out.println("ancestro: -1"); 
   
	                   }else{
	                   System.out.println("ancestro: "+ances.value); 
	                   }
	               }else if (comando.equals("distancia")){
	                   int n1= in.nextInt(); 
	                   int n2=in.nextInt();  
	                   int dista = distancia(n1,n2,root); 
	                   System.out.println("distancia: "+dista); 


	               }else if(comando.equals("contar")){
	            	   int n=in.nextInt(); 
	            	  System.out.println("contar: "+contarU(n, root));  
	               }

	           }
	       }
	    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.Scanner;

public class Problem_b_arrre {
	
	static dato[] datos; 
	
	static void agregar (int dato){
		int pos=0;
		for (int i = 0; i <datos.length  ; i++) {
			if(datos[i]==null){
				pos=i; 
				break;
			}
			if(datos[i].num==dato){
				datos[i].ocurrencias=datos[i].ocurrencias+1; 
				return; 
			}
			
		}
		datos[pos]= new dato(dato); 
		
	}
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int cases = in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+(i+1)+":");
			
			int ndatos = in.nextInt(); 
			datos= new dato[ndatos]; 
			
			
			for (int j = 0; j < ndatos; j++) {
				agregar(in.nextInt());
			}
			int reco=0;
			while( datos[reco]!=null ){
				System.out.println(datos[reco].num+" "+datos[reco].ocurrencias);
				reco=reco+1;
				if(reco==datos.length){
					break; 
				}
			}
			
		
		}

	}
	static class dato{
		int ocurrencias; 
		int num; 
		public dato(int n){
			this.num=n; 
			this.ocurrencias=1; 
		}
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.LinkedList;
import java.util.Scanner;

public class Problem_b {
	
	static LinkedList<dato> datos; 
	
	static void agregar (int dato){
		for (int i = 0; i <datos.size()  ; i++) {
			if(datos.get(i).num==dato){
				datos.get(i).ocurrencias=datos.get(i).ocurrencias+1; 
				return; 
			}
		}
		datos.add(new dato(dato)); 
		
	}
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int cases = in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+(i+1)+":");
			
			datos= new LinkedList<>(); 
			int ndatos = in.nextInt(); 
			
			for (int j = 0; j < ndatos; j++) {
				agregar(in.nextInt());
			}
			for (int j = 0; j < datos.size(); j++) {
				System.out.println(datos.get(j).num+" "+datos.get(j).ocurrencias);
			}
			
		
		}

	}
	static class dato{
		int ocurrencias; 
		int num; 
		public dato(int n){
			this.num=n; 
			this.ocurrencias=1; 
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.Scanner;

public class Problem_b_arrre {
	
	static dato[] datos; 
	
	static void agregar (int dato){
		int pos=0;
		for (int i = 0; i <datos.length  ; i++) {
			if(datos[i]==null){
				pos=i; 
				break;
			}
			if(datos[i].num==dato){
				datos[i].ocurrencias=datos[i].ocurrencias+1; 
				return; 
			}
			
		}
		datos[pos]= new dato(dato); 
		
	}
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int cases = in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+(i+1)+":");
			
			int ndatos = in.nextInt(); 
			datos= new dato[ndatos]; 
			
			
			for (int j = 0; j < ndatos; j++) {
				agregar(in.nextInt());
			}
			int reco=0;
			while( datos[reco]!=null ){
				System.out.println(datos[reco].num+" "+datos[reco].ocurrencias);
				reco=reco+1;
				if(reco==datos.length){
					break; 
				}
			}
			
		
		}

	}
	static class dato{
		int ocurrencias; 
		int num; 
		public dato(int n){
			this.num=n; 
			this.ocurrencias=1; 
		}
	}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.LinkedList;
import java.util.Scanner;

public class Problem_b {
	
	static LinkedList<dato> datos; 
	
	static void agregar (int dato){
		for (int i = 0; i <datos.size()  ; i++) {
			if(datos.get(i).num==dato){
				datos.get(i).ocurrencias=datos.get(i).ocurrencias+1; 
				return; 
			}
		}
		datos.add(new dato(dato)); 
		
	}
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int cases = in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+(i+1)+":");
			
			datos= new LinkedList<>(); 
			int ndatos = in.nextInt(); 
			
			for (int j = 0; j < ndatos; j++) {
				agregar(in.nextInt());
			}
			for (int j = 0; j < datos.size(); j++) {
				System.out.println(datos.get(j).num+" "+datos.get(j).ocurrencias);
			}
			
		
		}

	}
	static class dato{
		int ocurrencias; 
		int num; 
		public dato(int n){
			this.num=n; 
			this.ocurrencias=1; 
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles; 

import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;


public class KingKong {

	static class Node{
		
		int value;
		int nHijos; 
		LinkedList<Node> hijos= new LinkedList<>(); 
		boolean sentido;
		
	}
	static void aumentarHijo(Node nodo, Node padre){
		padre.hijos.add(nodo);
		padre.nHijos++; 
		nodo.sentido=!padre.sentido; 
	}
	static void recorridoIzDere(Node aux, LinkedList<Node> cola){
		for (int i = 0; i < aux.hijos.size(); i++) {
			cola.add(aux.hijos.removeLast()); 
		}	
		
	}
	static LinkedList<Node> recorridoDereIz(Node aux, LinkedList<Node> cola){
		for (int i = 0; i < aux.hijos.size(); i++) {
			cola.add(aux.hijos.removeFirst()); 
		}	
		return cola; 
	}
	static LinkedList<Integer>  recorrer(Node root){
			LinkedList<Node> cola = new LinkedList<Node>();  
			
			cola.add(root); 
	        Node reco= root; 
	        LinkedList<Integer> res= new LinkedList<Integer>(); 
	         	
	       root.sentido=false;
	        
	        int i =0 ;
	        int primer=reco.hijos.size();
	        loop1: 
	        while(!cola.isEmpty()){
	        	
	            if(i==0){
	            	for (int j = 0; j < primer; j++) {
	            		cola.add(reco.hijos.getLast());
	            		reco.hijos.removeLast();
					}
	            }
	        	if(!cola.isEmpty() && i!=0){
	        		int paso=cola.size();
	        		for (int j = paso-1; j>=0; j--) {
						
	        			Node aux= cola.get(j); 
	        			
	        			if(!aux.hijos.isEmpty()){

        					int p=aux.hijos.size();
	        				if(aux.sentido){
	        					for (int m = 0; m <p;  m++) {
	        						cola.add(aux.hijos.getFirst()); 
	        						aux.hijos.removeFirst();
	        					}	
	        				}else{
	        					
	        					for (int m = 0; m < p; m++) {
	        						cola.add(aux.hijos.getLast()); 
	        						aux.hijos.removeLast();
	        					}	
	        					
	        				}
	        			}else{
	        				continue;
	        			}
					}
	        	}
	        	++i; 
	        	reco= cola.removeFirst();
	        	res.add(reco.value); 
	        	
		            //tEERMINA ASIGNAR HIJOS
	        }
	       return res;
	}
	
	static void agregar(Node padre,int value, Node root)
    {   
		Node nuevo= new Node(); 
		nuevo.value= value;
		
        if(padre.value==root.value){
           aumentarHijo(nuevo, root);
          
        }else{ 
        	
        	for (int i = 0; i < root.hijos.size(); i++) {
		
        		if(root.hijos.get(i).value==padre.value){
					
					aumentarHijo(nuevo, root.hijos.get(i));
					

				}else{
					agregar(padre, value,root.hijos.get(i));
				}
			}
        }
	 }
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int casos= in.nextInt(); 
		for (int i = 0; i < casos; i++) {
			System.out.println();
			System.out.println("Caso #"+(i+1)+": ");
			int nNodos= in.nextInt();	
			Node root=new Node(); 
			
			for (int j = 0; j < nNodos; j++) {
				
				if(j==0){
					
					
					String rootV=in.next(); 
					int value=	Integer.valueOf(rootV);	
					StringTokenizer line = new StringTokenizer(in.nextLine()); 
					root.value= value; 
					root.sentido=false;
					while(line.hasMoreTokens()){
					
						int nAgre=Integer.valueOf(line.nextToken()); 
						agregar(root, nAgre,root); 
					
					}
				}else{
				
				Node padre= new Node(); 
				int val= Integer.valueOf(in.next()); 
				StringTokenizer line = new StringTokenizer(in.nextLine()); 
				padre.value=val;
				
				int nAgre; 
					
					while(line.hasMoreTokens()){
						
						nAgre= Integer.valueOf(line.nextToken()); 
						
						agregar(padre, nAgre, root);
					}
				
				}
			}
			
			LinkedList<Integer> respuesta=recorrer(root);
			for (int j = 0; j < respuesta.size(); j++) {
				System.out.print(respuesta.get(j)+" ");
			}
			
		}
		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;

public class Hash_B {
static class Dato {
	int num;
	int ocurencia; 
	public Dato(int num){
		this.num=num; 
		this.ocurencia=1; 
	}
	
}
	
public static void insertar(Dato ins, LinkedHashMap<Integer, Dato> lista,LinkedList<Integer> dat){
	
	if(lista.containsKey(ins.num)){
		lista.get(ins.num).ocurencia=lista.get(ins.num).ocurencia+1;
	}else{
		lista.put(ins.num, ins);
		dat.add(ins.num); 
	}
}
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int cases =in.nextInt(); 
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+ (i+1)+":");
			int cantidad=in.nextInt(); 
			LinkedList<Integer> dat= new LinkedList<>(); 
			LinkedHashMap<Integer, Dato> lista = new LinkedHashMap<>(cantidad);
			for (int j = 0; j < cantidad; j++) {
				int key=in.nextInt();
				Dato insert=new Dato(key); 
				insertar(insert, lista,dat);
			}
			for (int j = 0; j < lista.size(); j++) {
				System.out.println(lista.get(dat.getFirst()).num+" "+lista.get(dat.getFirst()).ocurencia);
				dat.removeFirst(); 
			}
		}
		

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles; 

import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;


public class KingKong {

	static class Node{
		
		int value;
		int nHijos; 
		LinkedList<Node> hijos= new LinkedList<>(); 
		boolean sentido;
		
	}
	static void aumentarHijo(Node nodo, Node padre){
		padre.hijos.add(nodo);
		padre.nHijos++; 
		nodo.sentido=!padre.sentido; 
	}
	static void recorridoIzDere(Node aux, LinkedList<Node> cola){
		for (int i = 0; i < aux.hijos.size(); i++) {
			cola.add(aux.hijos.removeLast()); 
		}	
		
	}
	static LinkedList<Node> recorridoDereIz(Node aux, LinkedList<Node> cola){
		for (int i = 0; i < aux.hijos.size(); i++) {
			cola.add(aux.hijos.removeFirst()); 
		}	
		return cola; 
	}
	static LinkedList<Integer>  recorrer(Node root){
			LinkedList<Node> cola = new LinkedList<Node>();  
			LinkedList<Node> colaR = new LinkedList<Node>();  
			
			cola.add(root); 
	        Node reco= root; 
	        LinkedList<Integer> res= new LinkedList<Integer>(); 
	         	
	        root.sentido=false;
	        
	        int i =0 ;
	        int primer=reco.hijos.size();
	        loop1: 
	        while(!cola.isEmpty()){
	        	colaR= (LinkedList<Node>) cola.clone(); 
	          loop2:
	        	while(!colaR.isEmpty()){
	        	  Node aux= colaR.getLast(); 
	        	  
	        	 	  if(!aux.hijos.isEmpty()){
		        	
	        			  if(aux.sentido){
	        				  
	        				  while(!aux.hijos.isEmpty()){
	        					 cola.add(aux.hijos.getFirst());
	        					 aux.hijos.removeFirst(); 
	        					  
	        				  }
	        			  }else{
	        				  
	        				  while(!aux.hijos.isEmpty()){
	        					  cola.add(aux.hijos.getLast());
	        					  aux.hijos.removeLast(); 
	        				  }
	        			  }
		        	  }else{
		        		  colaR.removeLast();
		        		  continue loop2; 
		        	  }
	        	 	 colaR.removeLast();
	          }
	        	/*  if(i==0){
	            	for (int j = 0; j < primer; j++) {
	            		cola.add(reco.hijos.getLast());
	            		reco.hijos.removeLast();
					}
	            }
	        	if(!cola.isEmpty() && i!=0){
	        		int paso=cola.size();
	        		for (int j = paso-1; j>=0; j--) {
						
	        			Node aux= cola.get(j); 
	        			
	        			if(!aux.hijos.isEmpty()){

        					int p=aux.hijos.size();
	        				if(aux.sentido){
	        					for (int m = 0; m <p;  m++) {
	        						cola.add(aux.hijos.getFirst()); 
	        						aux.hijos.removeFirst();
	        					}	
	        				}else{
	        					
	        					for (int m = 0; m < p; m++) {
	        						cola.add(aux.hijos.getLast()); 
	        						aux.hijos.removeLast();
	        					}	
	        					
	        				}
	        			}else{
	        				continue;
	        			}
					}
	        	}*/
	        	++i; 
	        	reco= cola.removeFirst();
	        	res.add(reco.value); 
	        	
		            //tEERMINA ASIGNAR HIJOS
	        }
	       return res;
	}
	
	static void agregar(Node padre,int value, Node root)
    {   
		Node nuevo= new Node(); 
		nuevo.value= value;
		
        if(padre.value==root.value){
           aumentarHijo(nuevo, root);
          
        }else{ 
        	
        	for (int i = 0; i < root.hijos.size(); i++) {
		
        		if(root.hijos.get(i).value==padre.value){
					
					aumentarHijo(nuevo, root.hijos.get(i));
					

				}else{
					agregar(padre, value,root.hijos.get(i));
				}
			}
        }
	 }
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int casos= in.nextInt(); 
		for (int i = 0; i < casos; i++) {
			System.out.println();
			System.out.println("Caso #"+(i+1)+": ");
			int nNodos= in.nextInt();	
			Node root=new Node(); 
			
			for (int j = 0; j < nNodos; j++) {
				
				if(j==0){
					
					
					String rootV=in.next(); 
					int value=	Integer.valueOf(rootV);	
					StringTokenizer line = new StringTokenizer(in.nextLine()); 
					root.value= value; 
					root.sentido=false;
					while(line.hasMoreTokens()){
					
						int nAgre=Integer.valueOf(line.nextToken()); 
						agregar(root, nAgre,root); 
					
					}
				}else{
				
				Node padre= new Node(); 
				int val= Integer.valueOf(in.next()); 
				StringTokenizer line = new StringTokenizer(in.nextLine()); 
				padre.value=val;
				
				int nAgre; 
					
					while(line.hasMoreTokens()){
						
						nAgre= Integer.valueOf(line.nextToken()); 
						
						agregar(padre, nAgre, root);
					}
				
				}
			}
			
			LinkedList<Integer> respuesta=recorrer(root);
			for (int j = 0; j < respuesta.size(); j++) {
				System.out.print(respuesta.get(j)+" ");
			}
			
		}
		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.HashMap;
import java.util.Scanner;

public class quick_union {
	
	private int[] id; 
	private int count ;
	private int[] sz;
	public quick_union(int N){
		count=N; 
		id= new int[N]; 
		sz = new int[N]; 
		for (int i = 0; i < N; i++) {
			id[i]=i; 
		}
		for (int i = 0; i < N; i++) {
			sz[i]=1; 
		}
	}
	
	public int tamanoConjun(int i){
		return sz[find(i)]; 
	}
	public int find(int p){
		
		while(p!=id[p]){
			
			id[p]=id[id[p]];
			p=id[p];
		}
		return p; 
	}
	
	public boolean find(int p,int q){
		
		return find(p)==find(q);
	}
	public void union(int p, int q){
		int i = find(p); 
		int j= find(q); 
		if(j==i){
			return;
		}
		if(sz[i]<sz[j]){
			
			id[i]=j;
			sz[j]+=sz[i];
		}else{
			id[j]=i; 
			sz[i]+=sz[j]; 
		}
	}

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int cases = in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+ (i+1)+":");
			HashMap<String, Integer> personas= new HashMap<>();
			int amiguitos=in.nextInt();
			quick_union conjuntos= new quick_union(amiguitos*2);
			int dato=0; 
			
			for (int j = 0; j < amiguitos; j++) {
				String amigui1= in.next(); 
				String amigui2=in.next();
				if(!personas.containsKey(amigui1)){
					personas.put( amigui1,dato); 
					dato++; 
				}
				if(!personas.containsKey(amigui2)){
					personas.put( amigui2,dato);
					dato++; 
				}
				conjuntos.union(personas.get(amigui1), personas.get(amigui2));
				System.out.println(conjuntos.tamanoConjun(personas.get(amigui1))); 
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles; 
import java.util.Scanner;

public class Problem_A {
	static class Node{
	    int value;
	    Node hijoDere;
	    Node HijoIzque;
	    
	}
		static boolean existe(int value, Node root){
			Node reco= root; 
	 
			while(reco!=null){
	 
				if(reco.value==value){
					return true;
	 
				}else if(reco.value<value){
	 
					reco=reco.hijoDere;
				}else{
	 
					reco=reco.HijoIzque; 
				}
			}
			return false; 
		}
		static Node ancestro(Node root,int v1,int v2)
	    {
			boolean ex1,ex2;
			ex1= existe(v1, root);
			ex2= existe(v2, root); 
			if(!ex1 || !ex2 ){
				return null; 
			}else{
			
	        if(root!=null){
	            if(root.value>v1 && root.value>v2){
	              return ancestro(root.HijoIzque,v1,v2); 
	            }
	            
	            if(root.value<v1 && root.value<v2){
	                return ancestro(root.hijoDere,v1,v2); 
	            }
	        }
	       return root; 
			}
		}

		static Node agregar(Node root,int value)
	    {   
	        if(root == null){
	            Node nodi= new Node();
	            nodi.value=value; 
	            
	            return nodi; 
	        }
	    Node nodo; 
	    
	               
	            if(root.value>value){
	                nodo=agregar(root.HijoIzque,value);
	                root.HijoIzque= nodo; 
	            }else{
	              nodo=agregar(root.hijoDere,value);   
	              root.hijoDere= nodo; 
	            }
	        
	       return root; 
	    }

		static int distancia (int n1, int n2, Node root){
			 
			boolean exn1, exn2; 
	 
			exn1=existe(n1,root);
			exn2=existe(n2,root); 
	 
			if(exn1 && exn2){
				Node reco1= ancestro( root, n1,n2);
				Node ancestro= ancestro(root,n1,n2); 
				Node reco2 = ancestro(root, n1, n2);
				if((n1>reco1.value && n2<reco1.value) || (n1<reco2.value && n2>reco2.value)){
					int dis1=0,dis2=0;
					
					while(reco1.value!=n1){
						
						if(n1>reco1.value){
						
							reco1=reco1.hijoDere; 
							dis1=dis1+1; 
						
						}else{
						
							reco1=reco1.HijoIzque; 
							dis1=dis1+1;
						
						}
					}
					
					while(reco2.value!=n2){
						
						if(n2>reco2.value){
						
							reco2=reco2.hijoDere; 
							dis2=dis2+1; 
						
						}else{
						
							reco2=reco2.HijoIzque; 
							dis2=dis2+1;
						
						}
					}
					return dis1+dis2; 
				}else{
					int dis=0; 
					
					if(reco1.value==n1){
						
						while(reco1.value!=n2){
							
							if(n2>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis;
						
					}else {
						
						while(reco1.value!=n1){	
							
							if(n1>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis; 
						
					}
				}
	         
			}else{
				return -1 ;
			}
		}
	    public static void main(String[] args) {
	       Scanner in = new Scanner(System.in); 
	       int casos=in.nextInt(); 
	       for (int i =0 ;i<casos ;i++){
	    	   
	    	   System.out.println("Caso #"+(i+1)+":");
	           int comad=in.nextInt(); 
	           Node root= null; 
	           int a =0; 
	           for (int j =0; j<comad ;j++){
	              
	              /* StringTokeni
	               * zer comando = new StringTokenizer(in.nextLine()); 
	                System.out.println(comando.nextToken().toString());*/
	               String comando= in.next(); 
	             //   System.out.println(comando); 
	               if(comando.equals("agregar")){
	                   int nodo= in.nextInt(); 
	                  a=a+1; 
	                   if(a==1){
	                       root=agregar(root,nodo); 

	                   }else{
	                        agregar(root,nodo); 
	                   }

	               }else if(comando.equals("ancestro")){
	                   int n1= in.nextInt();  
	                   int n2= in.nextInt(); 
	                   Node ances= ancestro(root,n1,n2); 
	                   if(ances==null){
	                	   System.out.println("ancestro: -1"); 
   
	                   }else{
	                   System.out.println("ancestro: "+ances.value); 
	                   }
	               }else if (comando.equals("distancia")){
	                   int n1= in.nextInt(); 
	                   int n2=in.nextInt();  
	                   int dista = distancia(n1,n2,root); 
	                   System.out.println("distancia: "+dista); 


	               }

	           }
	       }
	    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles; 

import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;


public class KingKong {

	static class Node{
		
		int value;
		int nHijos; 
		LinkedList<Node> hijos= new LinkedList<>(); 
		boolean sentido;
		
	}
	static void aumentarHijo(Node nodo, Node padre){
		padre.hijos.add(nodo);
		padre.nHijos++; 
		nodo.sentido=!padre.sentido; 
	}
	static void recorridoIzDere(Node aux, LinkedList<Node> cola){
		for (int i = 0; i < aux.hijos.size(); i++) {
			cola.add(aux.hijos.removeLast()); 
		}	
		
	}
	static LinkedList<Node> recorridoDereIz(Node aux, LinkedList<Node> cola){
		for (int i = 0; i < aux.hijos.size(); i++) {
			cola.add(aux.hijos.removeFirst()); 
		}	
		return cola; 
	}
	static LinkedList<Integer>  recorrer(Node root){
			LinkedList<Node> cola = new LinkedList<Node>();  
			LinkedList<Node> colaR = new LinkedList<Node>();  
			
			cola.add(root); 
	        Node reco= root; 
	        LinkedList<Integer> res= new LinkedList<Integer>(); 
	         	
	        root.sentido=false;
	        
	        int i =0 ;
	        int primer=reco.hijos.size();
	        loop1: 
	        while(!cola.isEmpty()){
	        	colaR= (LinkedList<Node>) cola.clone(); 
	          loop2:
	        	while(!colaR.isEmpty()){
	        	  Node aux= colaR.getLast(); 
	        	  
	        	 	  if(!aux.hijos.isEmpty()){
		        	
	        			  if(aux.sentido){
	        				  
	        				  while(!aux.hijos.isEmpty()){
	        					 cola.add(aux.hijos.getFirst());
	        					 aux.hijos.removeFirst(); 
	        					  
	        				  }
	        			  }else{
	        				  
	        				  while(!aux.hijos.isEmpty()){
	        					  cola.add(aux.hijos.getLast());
	        					  aux.hijos.removeLast(); 
	        				  }
	        			  }
		        	  }else{
		        		  colaR.removeLast();
		        		  continue loop2; 
		        	  }
	        	 	 colaR.removeLast();
	          }
	        	
	        	++i; 
	        	reco= cola.removeFirst();//NULLPOINTER
	        	res.add(reco.value); 
	        	
		            //tEERMINA ASIGNAR HIJOS
	        }
	       return res;
	}
	
	static void agregar(Node padre,int value, Node root)
    {   
		Node nuevo= new Node(); 
		nuevo.value= value;
		
        if(padre.value==root.value){
           aumentarHijo(nuevo, root);
          
        }else{ 
        	
        	for (int i = 0; i < root.hijos.size(); i++) {
		
        		if(root.hijos.get(i).value==padre.value){
					
					aumentarHijo(nuevo, root.hijos.get(i));
					

				}else{
					agregar(padre, value,root.hijos.get(i));
				}
			}
        }
	 }
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int casos= in.nextInt(); 
		for (int i = 0; i < casos; i++) {
			System.out.println();
			System.out.println("Caso #"+(i+1)+": ");
			int nNodos= in.nextInt();	
			Node root=new Node(); 
			
			String rootV=in.next(); 
			int value=	Integer.valueOf(rootV);	
			StringTokenizer line = new StringTokenizer(in.nextLine()); 
			root.value= value; 
			root.sentido=false;
			
			while(line.hasMoreTokens()){
			
				int nAgre=Integer.valueOf(line.nextToken()); 
				agregar(root, nAgre,root); 
			
			}
		
			for (int j = 1; j < nNodos; j++) {
				
					
				
				Node padre= new Node(); 
				int val= Integer.valueOf(in.next()); 
				StringTokenizer line2 = new StringTokenizer(in.nextLine()); 
				padre.value=val;
				
				int nAgre; 
					
					while(line2.hasMoreTokens()){
					
						nAgre= Integer.valueOf(line2.nextToken()); 
						
						agregar(padre, nAgre, root);
					}
				
				}
			LinkedList<Integer> respuesta=recorrer(root);
			for (int j = 0; j < respuesta.size(); j++) {
				System.out.print(respuesta.get(j)+" ");
			}
			
			}
			
			
		}
		
	

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles;

import java.util.LinkedList;
import java.util.Scanner;


public class Problem_e {
	static class Node{
	    int value;
	    Node hijoDere;
	    Node HijoIzque;
	    
	}
		static boolean existe(int value, Node root){
			Node reco= root; 
	 
			while(reco!=null){
	 
				if(reco.value==value){
					return true;
	 
				}else if(reco.value<value){
	 
					reco=reco.hijoDere;
				}else{
	 
					reco=reco.HijoIzque; 
				}
			}
			return false; 
		}
		
		
		
		static Node ancestro(Node root,int v1,int v2)
	    {
			boolean ex1,ex2;
			ex1= existe(v1, root);
			ex2= existe(v2, root); 
			if(!ex1 || !ex2 ){
				return null; 
			}else{
			
	        if(root!=null){
	            if(root.value>v1 && root.value>v2){
	              return ancestro(root.HijoIzque,v1,v2); 
	            }
	            
	            if(root.value<v1 && root.value<v2){
	                return ancestro(root.hijoDere,v1,v2); 
	            }
	        }
	       return root; 
			}
		}

		static Node agregar(Node root,int value)
	    {   
	        if(root == null){
	            Node nodi= new Node();
	            nodi.value=value; 
	            
	            return nodi; 
	        }
	    Node nodo; 
	    
	               
	            if(root.value>value){
	                nodo=agregar(root.HijoIzque,value);
	                root.HijoIzque= nodo; 
	            }else{
	              nodo=agregar(root.hijoDere,value);   
	              root.hijoDere= nodo; 
	            }
	        
	       return root; 
	    }

		static int distancia (int n1, int n2, Node root){
			 
			boolean exn1, exn2; 
	 
			exn1=existe(n1,root);
			exn2=existe(n2,root); 
	 
			if(exn1 && exn2){
				Node reco1= ancestro( root, n1,n2);
				Node ancestro= ancestro(root,n1,n2); 
				Node reco2 = ancestro(root, n1, n2);
				if((n1>reco1.value && n2<reco1.value) || (n1<reco2.value && n2>reco2.value)){
					int dis1=0,dis2=0;
					
					while(reco1.value!=n1){
						
						if(n1>reco1.value){
						
							reco1=reco1.hijoDere; 
							dis1=dis1+1; 
						
						}else{
						
							reco1=reco1.HijoIzque; 
							dis1=dis1+1;
						
						}
					}
					
					while(reco2.value!=n2){
						
						if(n2>reco2.value){
						
							reco2=reco2.hijoDere; 
							dis2=dis2+1; 
						
						}else{
						
							reco2=reco2.HijoIzque; 
							dis2=dis2+1;
						
						}
					}
					return dis1+dis2; 
				}else{
					int dis=0; 
					
					if(reco1.value==n1){
						
						while(reco1.value!=n2){
							
							if(n2>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis;
						
					}else {
						
						while(reco1.value!=n1){	
							
							if(n1>reco1.value){
								
								reco1=reco1.hijoDere; 
								dis=dis+1; 
							}else{
								
								reco1=reco1.HijoIzque; 
								dis=dis+1; 
							}
							
						}
						
						return dis; 
						
					}
				}
	         
			}else{
				return -1 ;
			}
		}
		
	static	public Node buscar(int d , Node raiz ){
			if(raiz==null){
				return null; 
			}else if(raiz.value==d){
				return raiz ; 
			}else if(raiz.value<d){
				return buscar(d,raiz.hijoDere); 
			}else{
				return buscar(d,raiz.HijoIzque);
			}
		}
		/*/*void Preorder(Node root) {
   if(root==null){
       
   }else{
      System.out.print(root.data+" ");
      if(root.left!=null){
          Preorder(root.left);
      }
       if(root.right!=null){
          Preorder(root.right);
      }
       
   }
}*/			static LinkedList<Integer> recorridoHijos(Node root, LinkedList<Integer> hijos){
				
				if(root!=null){
					recorridoHijos(root.HijoIzque, hijos);
					hijos.add(root.value);  
					recorridoHijos( root.hijoDere,hijos);
				}
				return hijos; 
			}
	
		static int contarU(int value, Node root){
			Node padre= buscar(value, root); 
			if(padre==null){
				return -1;
			}else{
				LinkedList<Integer> hijos= new LinkedList<>(); 
				return (recorridoHijos( padre,hijos).size()-1); 
				
			}
		}
		
	    public static void main(String[] args) {
	       Scanner in = new Scanner(System.in); 
	       int casos=in.nextInt(); 
	       for (int i =0 ;i<casos ;i++){
	    	   
	    	   System.out.println("Caso #"+(i+1)+":");
	           int comad=in.nextInt(); 
	           Node root= null; 
	           int a =0; 
	           for (int j =0; j<comad ;j++){
	              
	              /* StringTokeni
	               * zer comando = new StringTokenizer(in.nextLine()); 
	                System.out.println(comando.nextToken().toString());*/
	               String comando= in.next(); 
	             //   System.out.println(comando); 
	               if(comando.equals("agregar")){
	                   int nodo= in.nextInt(); 
	                  a=a+1; 
	                   if(a==1){
	                       root=agregar(root,nodo); 

	                   }else{
	                        agregar(root,nodo); 
	                   }

	               }else if(comando.equals("ancestro")){
	                   int n1= in.nextInt();  
	                   int n2= in.nextInt(); 
	                   Node ances= ancestro(root,n1,n2); 
	                   if(ances==null){
	                	   System.out.println("ancestro: -1"); 
   
	                   }else{
	                   System.out.println("ancestro: "+ances.value); 
	                   }
	               }else if (comando.equals("distancia")){
	                   int n1= in.nextInt(); 
	                   int n2=in.nextInt();  
	                   int dista = distancia(n1,n2,root); 
	                   System.out.println("distancia: "+dista); 


	               }else if(comando.equals("contar")){
	            	   int n=in.nextInt(); 
	            	  System.out.println("contar: "+contarU(n, root));  
	               }

	           }
	       }
	    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;

import hanshing.Hash_A.Persona;

public class Hash_A_2 {
	static public class Persona{
		int num;
		int equipo;
		int total_demora;
		int total_resueltos; 
		
		LinkedHashMap<Integer, Problema> problemas ;
		
		public Persona(int num){
			this.num=num; 
			this.problemas= new LinkedHashMap<>();
			this.total_demora=0;
			this.total_resueltos=0; 
		}
		
	}

	static public class Problema{
		int intentos_fall; 
		int demora_A;
		int nombre;
		boolean aprobado;
		int demoraT; 
		public Problema(int nombre){
			this.nombre= nombre;
			this.demora_A=0;
			this.intentos_fall=0;
			this.aprobado=false; 
			this.demoraT=0;
		}
	}
	
	static Persona[] arreglo ;
	static int tamano;
	static int contador; 
	static final int Has_MAX= 99991;
	
	public Hash_A_2(int tam){
		this.tamano=tam;
		this.arreglo= new Persona[tam];
		Persona a = new Persona(-1); 
		Arrays.fill(arreglo, a);
	}
	
	public static Persona[] ordenarArray() {
	    Persona aux;
	 
	    for (int i = 0; i < arreglo.length - 1; i++) {
	        for (int x = i + 1; x < arreglo.length; x++) {
	            if (arreglo[x].total_resueltos > arreglo[i].total_resueltos) {
	                aux = arreglo[i];
	                arreglo[i] = arreglo[x];
	                arreglo[x] = aux;
	            }
	            if(arreglo[x].total_resueltos == arreglo[i].total_resueltos){
	            	//ordenar tiempo 
	            	if (arreglo[x].total_demora< arreglo[i].total_demora) {
	            		aux = arreglo[i];
	            		arreglo[i] = arreglo[x];
	            		arreglo[x] = aux;
	            	}
	            	if(arreglo[x].total_demora== arreglo[i].total_demora){
	            		if (arreglo[x].num < arreglo[i].num) {
	                		aux = arreglo[i];
	                		arreglo[i] = arreglo[x];
	                		arreglo[x] = aux;
	                	}
	            	}
	           
	            }
	        }
	    }
	 
	    return arreglo;
	}
	public static int buscarClave(Persona p){
			
			int idx= p.num%tamano; 
			contador=0;
			while(arreglo[idx].num!=0){
				if(arreglo[idx].num==p.num){
					return idx;
				}
				idx++;
				idx%=tamano;
				contador++;
				if(contador>tamano){
					break;
				}
			}
			
			return 0; 
		}
		public static int funcionHash(Persona p){
			
			Persona agre=p;
			int indexA=	p.num%tamano ;
			//System.out.println("El indice es "+indexA );
			int idx=buscarClave(p);
			//coliciones
			
		//	System.out.println(idx);
			if(idx!=0){
				return idx; 
			}else{
				while(arreglo[indexA].num!=-1){
					indexA++;
					//System.out.println("occurrio una colision en el index"+(indexA-1));
					indexA%=tamano;
					
				}
				
				arreglo[indexA]=agre;	
				return indexA; 
			}
			
			 
		}
	public static void todo_problema(int person , int demora, String cali, int nombre){

		if(arreglo[person].problemas.containsKey(nombre)){
			if(cali.equals("C")){
				arreglo[person].problemas.get(nombre).demora_A=demora; 
				arreglo[person].problemas.get(nombre).aprobado=true; 
				arreglo[person].problemas.get(nombre).demoraT=demora+((arreglo[person].problemas.get(nombre).intentos_fall)*20); 
				
				arreglo[person].total_demora=arreglo[person].total_demora+arreglo[person].problemas.get(nombre).demoraT;
				arreglo[person].total_resueltos=arreglo[person].total_resueltos+1; 
				
			}else{
				arreglo[person].problemas.get(nombre).intentos_fall=arreglo[person].problemas.get(nombre).intentos_fall+1;; 
			}
		}else{
			arreglo[person].problemas.put(nombre, new Problema(nombre)); 
			
		}
	}


	//mostrar
		public static void mostrar(LinkedList< Persona> res){
			int tam=res.size();
			for (int i = 0; i < tam; i++) {
				System.out.println(res.getFirst().num+ " "+res.getFirst().total_resueltos+" "+res.getFirst().total_demora);
				res.removeFirst(); 
			}
			
		}
		public static LinkedList<Persona> arreglar_respuesta(Persona[] arrayOrga){
			LinkedHashMap<Integer,Persona> resul= new LinkedHashMap<>();  
			LinkedList<Persona> resultado = new LinkedList<>(); 
			for (int i = 0; i < arrayOrga.length; i++) {
					if(arrayOrga[i].num!=-1){
						if(!resul.containsKey(arrayOrga[i].num)){
							resul.put(arrayOrga[i].num, arrayOrga[i]); 
							resultado.add(arrayOrga[i]); 
						}
					}
			}
			return resultado; 
		}
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int cases =in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+ (i+1)+":");
			LinkedList<Persona> res;
			int nEquipo=in.nextInt();
			int envios= in.nextInt();
			Hash_A_2 table= new Hash_A_2(envios);
			 for (int j = 0; j < envios; j++) {
			
				int numP=in.nextInt();
				int problem=in.nextInt();
				int tiempo= in.nextInt(); 
				String califi=in.next(); 
				Persona p = new Persona(numP);
				Problema pro= new Problema(problem);
				
				int idxP= funcionHash(p); 
				if(!arreglo[idxP].problemas.containsKey(problem)){
					arreglo[idxP].problemas.put(problem, pro);
				}
				//System.out.println(idxP);
				todo_problema(idxP, tiempo, califi, problem);
				
			 }
			
			 res=arreglar_respuesta(ordenarArray()); 
			 mostrar(res);
		}
		

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;


public class Hash_A_2 {
	static public class Persona{
		int num;
		int equipo;
		int total_demora;
		int total_resueltos; 
		
		LinkedHashMap<Integer, Problema> problemas ;
		
		public Persona(int num){
			this.num=num; 
			this.problemas= new LinkedHashMap<>();
			this.total_demora=0;
			this.total_resueltos=0; 
		}
		
	}

	static public class Problema{
		int intentos_fall; 
		int demora_A;
		int nombre;
		boolean aprobado;
		int demoraT; 
		public Problema(int nombre){
			this.nombre= nombre;
			this.demora_A=0;
			this.intentos_fall=0;
			this.aprobado=false; 
			this.demoraT=0;
		}
	}
	
	static Persona[] arreglo ;
	static int tamano;
	static int contador; 
	static final int Has_MAX= 99991;
	
	public Hash_A_2(int tam){
		this.tamano=tam;
		this.arreglo= new Persona[tam];
		Persona a = new Persona(-1); 
		Arrays.fill(arreglo, a);
	}
	
	public static Persona[] ordenarArray() {
	    Persona aux;
	 
	    for (int i = 0; i < arreglo.length - 1; i++) {
	        for (int x = i + 1; x < arreglo.length; x++) {
	            if (arreglo[x].total_resueltos > arreglo[i].total_resueltos) {
	                aux = arreglo[i];
	                arreglo[i] = arreglo[x];
	                arreglo[x] = aux;
	            }
	            if(arreglo[x].total_resueltos == arreglo[i].total_resueltos){
	            	//ordenar tiempo 
	            	if (arreglo[x].total_demora< arreglo[i].total_demora) {
	            		aux = arreglo[i];
	            		arreglo[i] = arreglo[x];
	            		arreglo[x] = aux;
	            	}
	            	if(arreglo[x].total_demora== arreglo[i].total_demora){
	            		if (arreglo[x].num < arreglo[i].num) {
	                		aux = arreglo[i];
	                		arreglo[i] = arreglo[x];
	                		arreglo[x] = aux;
	                	}
	            	}
	           
	            }
	        }
	    }
	 
	    return arreglo;
	}
	public static int buscarClave(Persona p){
			
			int idx= p.num%tamano; 
			contador=0;
			while(arreglo[idx].num!=0){
				if(arreglo[idx].num==p.num){
					return idx;
				}
				idx++;
				idx%=tamano;
				contador++;
				if(contador>tamano){
					break;
				}
			}
			
			return 0; 
		}
		public static int funcionHash(Persona p){
			
			Persona agre=p;
			int indexA=	p.num%tamano ;
			//System.out.println("El indice es "+indexA );
			int idx=buscarClave(p);
			//coliciones
			
		//	System.out.println(idx);
			if(idx!=0){
				return idx; 
			}else{
				while(arreglo[indexA].num!=-1){
					indexA++;
					//System.out.println("occurrio una colision en el index"+(indexA-1));
					indexA%=tamano;
					
				}
				
				arreglo[indexA]=agre;	
				return indexA; 
			}
			
			 
		}
	public static void todo_problema(int person , int demora, String cali, int nombre){

		if(arreglo[person].problemas.containsKey(nombre)){
			if(cali.equals("C")){
				arreglo[person].problemas.get(nombre).demora_A=demora; 
				arreglo[person].problemas.get(nombre).aprobado=true; 
				arreglo[person].problemas.get(nombre).demoraT=demora+((arreglo[person].problemas.get(nombre).intentos_fall)*20); 
				
				arreglo[person].total_demora=arreglo[person].total_demora+arreglo[person].problemas.get(nombre).demoraT;
				arreglo[person].total_resueltos=arreglo[person].total_resueltos+1; 
				
			}else{
				arreglo[person].problemas.get(nombre).intentos_fall=arreglo[person].problemas.get(nombre).intentos_fall+1;; 
			}
		}else{
			arreglo[person].problemas.put(nombre, new Problema(nombre)); 
			
		}
	}


	//mostrar
		public static void mostrar(LinkedList< Persona> res){
			int tam=res.size();
			for (int i = 0; i < tam; i++) {
				System.out.println(res.getFirst().num+ " "+res.getFirst().total_resueltos+" "+res.getFirst().total_demora);
				res.removeFirst(); 
			}
			
		}
		public static LinkedList<Persona> arreglar_respuesta(Persona[] arrayOrga){
			LinkedHashMap<Integer,Persona> resul= new LinkedHashMap<>();  
			LinkedList<Persona> resultado = new LinkedList<>(); 
			for (int i = 0; i < arrayOrga.length; i++) {
					if(arrayOrga[i].num!=-1){
						if(!resul.containsKey(arrayOrga[i].num)){
							resul.put(arrayOrga[i].num, arrayOrga[i]); 
							resultado.add(arrayOrga[i]); 
						}
					}
			}
			return resultado; 
		}
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int cases =in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+ (i+1)+":");
			LinkedList<Persona> res;
			int nEquipo=in.nextInt();
			int envios= in.nextInt();
			Hash_A_2 table= new Hash_A_2(envios);
			 for (int j = 0; j < envios; j++) {
			
				int numP=in.nextInt();
				int problem=in.nextInt();
				int tiempo= in.nextInt(); 
				String califi=in.next(); 
				Persona p = new Persona(numP);
				Problema pro= new Problema(problem);
				
				int idxP= funcionHash(p); 
				if(!arreglo[idxP].problemas.containsKey(problem)){
					arreglo[idxP].problemas.put(problem, pro);
				}
				//System.out.println(idxP);
				todo_problema(idxP, tiempo, califi, problem);
				
			 }
			
			 res=arreglar_respuesta(ordenarArray()); 
			 mostrar(res);
		}
		

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hanshing;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;

public class Hash_B {
static class Dato {
	int num;
	int ocurencia; 
	public Dato(int num){
		this.num=num; 
		this.ocurencia=1; 
	}
	
}
	
public static void insertar(Dato ins, LinkedHashMap<Integer, Dato> lista,LinkedList<Integer> dat){
	
	if(lista.containsKey(ins.num)){
		lista.get(ins.num).ocurencia=lista.get(ins.num).ocurencia+1;
	}else{
		lista.put(ins.num, ins);
		dat.add(ins.num); 
	}
}
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int cases =in.nextInt(); 
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+ (i+1)+":");
			int cantidad=in.nextInt(); 
			LinkedList<Integer> dat= new LinkedList<>(); 
			LinkedHashMap<Integer, Dato> lista = new LinkedHashMap<>(cantidad);
			for (int j = 0; j < cantidad; j++) {
				int key=in.nextInt();
				Dato insert=new Dato(key); 
				insertar(insert, lista,dat);
			}
			for (int j = 0; j < lista.size(); j++) {
				System.out.println(lista.get(dat.getFirst()).num+" "+lista.get(dat.getFirst()).ocurencia);
				dat.removeFirst(); 
			}
		}
		

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap;

import java.util.Scanner;
import java.util.Stack;

public class Problem_A {

	public static void main(String[] args) throws Exception {
		Scanner in = new Scanner(System.in);
		int nNumeros= in.nextInt(); 
		Problem_A heap1= new Problem_A(); 
		BinaryHeap<Integer> heap= heap1.new BinaryHeap<Integer>(nNumeros); 
		loop:
		for (int i = 0; i < nNumeros; i++) {
			int num= in.nextInt(); 
			heap.insert(num);	
			
			if(heap.size()<3){
				System.out.println("-1");
			}else if(heap.size()==3){
				Stack<Integer> mayores= new Stack<>(); 
				int answ=1;
				for (int j = 0; j < 3; j++) {
					mayores.push(heap.deleteMin()); 
				}
			
	                for (int j = 1; j <= 3; j++) {
	                    int multi = mayores.pop();
	                    answ *= multi;
	                    heap.insert(multi);
	                }
	                System.out.println(answ);
	                
			}else if(heap.size()>3){
				
				heap.deleteMin(); 
				Stack<Integer> mayores= new Stack<>(); 
				int answ=1;
				for (int j = 0; j < 3; j++) {
					mayores.push(heap.deleteMin()); 
				}
			
	                for (int j = 1; j <= 3; j++) {
	                    int multi = mayores.pop();
	                    answ *= multi;
	                    heap.insert(multi);
	                }
	                System.out.println(answ);
	               
				
			}
		}
		
		

	}

private class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

    /**
     * Construct the binary heap.
     */
    public BinaryHeap() {
        this(DEFAULT_CAPACITY);
    }

    /**
     * Construct the binary heap.
     *
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap(int capacity) {
        currentSize = 0;
        array = (AnyType[]) new Comparable[capacity + 1];
    }

    /**
     * Construct the binary heap given an array of items.
     *
     * @param items
     */
    public BinaryHeap(AnyType[] items) {
        currentSize = items.length;
        array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

        int i = 1;
        for (AnyType item : items) {
            array[i++] = item;
        }
        buildHeap();
    }

    /**
     * Insert into the priority queue, maintaining heap order. Duplicates
     * are allowed.
     *
     * @param x the item to insert.
     */
    public void insert(AnyType x) {
        if (currentSize == array.length - 1) {
            enlargeArray(array.length * 2 + 1);
        }

        // Percolate up
        int hole = ++currentSize;
        for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
            array[hole] = array[hole / 2];
        }
        array[hole] = x;
    }

    private void enlargeArray(int newSize) {
        AnyType[] old = array;
        array = (AnyType[]) new Comparable[newSize];
        for (int i = 0; i < old.length; i++) {
            array[i] = old[i];
        }
    }

    /**
     * Find the smallest item in the priority queue.
     *
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin() throws Exception {
        if (isEmpty()) {
            throw new Exception();
        }
        return array[1];
    }

    public AnyType findMax() throws Exception {
        if (isEmpty()) {
            throw new Exception();
        }
        
        int i = 1;
        while(i < currentSize) {
            i = (2*i) + 1;
        }
        return array [i];
    }
    
    public void printHeap() {
        for(int i = 0; i <= currentSize; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
    
    /**
     * Remove the smallest item from the priority queue.
     *
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin() throws Exception {
        if (isEmpty()) {
            throw new Exception();
        }

        AnyType minItem = findMin();
        array[1] = array[currentSize--];
        percolateDown(1);

        return minItem;
    }


    /**
     * Establish heap order property from an arbitrary arrangement of items.
     * Runs in linear time.
     */
    private void buildHeap() {
        for (int i = currentSize / 2; i > 0; i--) {
            percolateDown(i);
        }
    }

    /**
     * Test if the priority queue is logically empty.
     *
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty() {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty() {
        currentSize = 0;
    }

    public int size() {
        return currentSize;
    }

    private static final int DEFAULT_CAPACITY = 10;
    private int currentSize;      // Number of elements in heap
    private AnyType[] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     *
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown(int hole) {
        int child;
        AnyType tmp = array[hole];

        for (; hole * 2 <= currentSize; hole = child) {
            child = hole * 2;
            if (child != currentSize
                    && array[child + 1].compareTo(array[child]) < 0) {
                child++;
            }
            if (array[child].compareTo(tmp) < 0) {
                array[hole] = array[child];
            } else {
                break;
            }
        }
        array[hole] = tmp;
    }

}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles;

import java.util.LinkedList;
import java.util.Scanner;

import Arboles.problemD_RepetOchentamil.AVLnodo;
import hanshing.quick_union;

public class problemD_RepetOchentamil {
	static class AVLnodo{
        int dato;
        int fe; 
        int ocurrencia;
        AVLnodo hijoIzq;
        AVLnodo hijoDere;
        
        public AVLnodo(int d) {
            this.dato=d;
            this.fe = 0;
            this.hijoDere=null;
            this.hijoIzq=null;
            this.ocurrencia=1;
        } 
    }
    
    static class AVLarbol{
     
    	private AVLnodo raiz;
    	int identificador; 
    	
    	public AVLarbol(AVLnodo root, int dx){
    		this.raiz= root;
    		raiz.ocurrencia=1;
    		this.identificador=dx; 
    	}	
        
        //buscar nodo en el arbol
        public AVLnodo buscar(int d, AVLnodo r){
            if(r== null){
                return null;
            }else if(r.dato==d){
                return r;
            }else if(r.dato<d){
                return buscar( d, r.hijoDere);
            }else{
                return buscar(d, r.hijoIzq);
            }
        }
        
        //obtener Raiz
        public AVLnodo obtenerRaiz(){
            return raiz;
        }
        
       
        public int ObtenerFE(AVLnodo x){
            if(x==null){
                return -1;
            }else{
                return x.fe;
            }
        }
        
        //rotacion simple izquierda
        public AVLnodo rotacionSimpleIzquierda(AVLnodo c){
            AVLnodo auxiliar = c.hijoIzq;
            c.hijoIzq=auxiliar.hijoDere;
            auxiliar.hijoDere=c;
            c.fe=Math.max(ObtenerFE(c.hijoIzq), ObtenerFE(c.hijoDere))+1;
            auxiliar.fe=Math.max(ObtenerFE(auxiliar.hijoIzq), ObtenerFE(auxiliar.hijoDere))+1;
            return auxiliar;
        }
        
        //rotacion simple derecha
        public AVLnodo rotacionSimpleDerecha(AVLnodo c){
            AVLnodo auxiliar = c.hijoDere;
            c.hijoDere=auxiliar.hijoIzq;
            auxiliar.hijoIzq=c;
            c.fe=Math.max(ObtenerFE(c.hijoIzq), ObtenerFE(c.hijoDere))+1;
            auxiliar.fe=Math.max(ObtenerFE(auxiliar.hijoIzq), ObtenerFE(auxiliar.hijoDere))+1;
            return auxiliar;
        }
        
        //Rotacion Doble a la Izquierda
        public AVLnodo rotacionDobleIzquierda(AVLnodo c){
            AVLnodo temporal;
            c.hijoIzq=rotacionSimpleDerecha(c.hijoIzq);
            temporal=rotacionSimpleIzquierda(c);
            return temporal;
        }
        
        //Rotacion doble a la Derecha
        public AVLnodo rotacionDobleDerecha(AVLnodo c){
            AVLnodo temporal;
            c.hijoDere = rotacionSimpleIzquierda(c.hijoDere);
            temporal = rotacionSimpleDerecha(c);
            return temporal;
        }
        
        public AVLnodo insertarAVL(AVLnodo nuevo, AVLnodo subAr){
            AVLnodo nuevoPadre = subAr;
            if(nuevo.dato<subAr.dato){
                if(subAr.hijoIzq==null){
                    subAr.hijoIzq=nuevo;
                }else{
                    subAr.hijoIzq=insertarAVL(nuevo, subAr.hijoIzq);
                    if((ObtenerFE(subAr.hijoIzq) - ObtenerFE(subAr.hijoDere))==2){
                        if(nuevo.dato<subAr.hijoIzq.dato){
                            nuevoPadre=rotacionSimpleIzquierda(subAr);
                        }else{
                            nuevoPadre=rotacionDobleIzquierda(subAr);
                        }
                    }
                    
                }
            }else if(nuevo.dato>subAr.dato){
                if(subAr.hijoDere==null){
                    subAr.hijoDere=nuevo;
                }else{
                    subAr.hijoDere=insertarAVL(nuevo, subAr.hijoDere);
                    if((ObtenerFE(subAr.hijoDere)-ObtenerFE(subAr.hijoIzq)==2)){
                        if(nuevo.dato>subAr.hijoDere.dato){
                            nuevoPadre=rotacionSimpleDerecha(subAr);
                        }else{
                            nuevoPadre=rotacionDobleDerecha(subAr);
                        }
                    }
                }
            }else{
               
                nuevoPadre.ocurrencia=nuevoPadre.ocurrencia+nuevo.ocurrencia;
                
            }
            //actualizar altura
            if((subAr.hijoIzq==null)&& (subAr.hijoDere!=null)){
                subAr.fe = subAr.hijoDere.fe+1;
            }else if((subAr.hijoDere==null) && (subAr.hijoIzq!=null)){
                subAr.fe=subAr.hijoIzq.fe+1;
            }else{
                subAr.fe=Math.max(ObtenerFE(subAr.hijoDere), ObtenerFE(subAr.hijoIzq))+1;
            }
            return nuevoPadre;
        }
        
        //Metodo de insertar
        public void insert(int d){
            AVLnodo nuevo = new AVLnodo(d);
            if(raiz==null){
                raiz=nuevo;
            }else{
                raiz=insertarAVL(nuevo, raiz);
            }
        }
        
        public void insert_Unir(AVLnodo nodo, AVLnodo root){
        	raiz= insertarAVL(nodo, root); 
        }
        
        
        public void Preorder(AVLnodo root) {
            if(root != null){
                System.out.print(root.dato+" ");
            if(root.hijoIzq!=null){
                Preorder(root.hijoIzq);
            }
            if(root.hijoDere!= null){
                Preorder(root.hijoDere);
            }
        }
        }
        
        // volveer vacio un arbol 
       
        public void makeEmpty() {
            raiz = null;
        }
        
       
        
        public void Unir( AVLnodo arbol2){
        if(arbol2!= null){    
            if(arbol2.hijoIzq!=null){
                Unir(arbol2.hijoIzq);
            }
            raiz=insertarAVL(arbol2, raiz);
            System.out.print(arbol2.dato+","+arbol2.ocurrencia+" ");
            if(arbol2.hijoDere!= null){
                Unir( arbol2.hijoDere);
            }
        }
        }
        
        
    }
    static void insertar_uni(AVLnodo nodo , int dx, AVLnodo root){
		
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					arboles.get(i).insert_Unir(nodo, root);
					break;
				}
			}
		}
	}
	static LinkedList<AVLarbol> arboles= new LinkedList<>() ;
	
	public static LinkedList<AVLnodo> Inorder(AVLnodo root, LinkedList<AVLnodo> nodos) {
	    if(root != null){
	        if(root.hijoIzq!=null){
	            Inorder(root.hijoIzq,nodos);
	        }
	        nodos.add(root);
	        if(root.hijoDere!= null){
	            Inorder(root.hijoDere,nodos);
	        }
	    }
	    return nodos; 
	}

	static boolean existe(int dx){
		
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					return true;
				}
			}
		}
		return false; 
		
	}
	
	static AVLarbol arbol_exisstente(int dx){
		
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					return arboles.get(i);
					 
				}
			}
		}
		return null; 
		
	}
	static void crearArbol(int dx, int x){
		
		AVLnodo root = new AVLnodo(x); 
		
		if(!existe(dx)){
				
			AVLarbol arbol= new AVLarbol(root,dx); 
			arboles.add(arbol);
		}
	}

	static void insertar(int x , int dx){
		
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					arboles.get(i).insert(x);
					break;
				}
			}
		}
	}
	
	
	static void ocurrencia(int x , int dx ){
		AVLnodo nodo;  
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				
				if(arboles.get(i).identificador==dx){ 
					
					nodo=arboles.get(i).buscar(x, arboles.get(i).raiz);
					
					if(nodo!=null){
						
						System.out.println("ocurrencia: "+nodo.ocurrencia);
						break; 
					}else{
						System.out.println("ocurrencia: 0");
						break;
					}
					
				}
			}
			
		}	
	}
	
	
	static boolean comparation(AVLnodo raizDx, AVLnodo raizDy){
		if(raizDy==null &&  raizDx==null){
			return true;  
		}else{
			//comparar 
			if(raizDy.dato==raizDx.dato){
			
				if(raizDx.hijoIzq!=null){
						
					comparation(raizDx.hijoIzq, raizDy.hijoIzq);
				}
				
				if(raizDx.hijoDere!=null){
					
					comparation(raizDx.hijoDere, raizDy.hijoDere);
				}
			
			}else{
				return false;  
			}
		}
		return false; 
		
	}
	static void contiene(int dx , int dy){
		AVLarbol  dx1, dy2; 
		boolean iguales;
		dx1= arbol_exisstente(dx); 
		dy2= arbol_exisstente(dy); 
		
		if((dx1!=null) &&  (dy2!=null)){
			AVLnodo raizdy= dx1.buscar(dy2.raiz.dato, dx1.raiz); 
					
			
			if(raizdy!=null){
				iguales= comparation(raizdy, dy2.raiz); 
				if(iguales){
					System.out.println("contiene: Yes");
				}else{
					System.out.println("contiene: No");
				}
			}else{
				System.out.println("contiene: No");
			}
			
		}
	}
		

	static void contiene2(int dx , int dy){
		AVLarbol  dx1, dy2; 
		
		dx1= arbol_exisstente(dx); 
		dy2= arbol_exisstente(dy); 
		
		if((dx1!=null) &&  (dy2!=null)){
			AVLnodo raizdy= dx1.buscar(dy2.raiz.dato, dx1.raiz); 
			
		
			if(raizdy!=null){
		
				LinkedList<AVLnodo>	nodosx = new LinkedList<>();	
				LinkedList<AVLnodo>	nodosy = new LinkedList<>();	
				
				nodosx=Inorder(raizdy, nodosx);
				nodosy=Inorder(dy2.raiz, nodosy); 
				
				
				while(!nodosx.isEmpty()){
					if(!nodosx.isEmpty() && nodosy.isEmpty()){
						System.out.println("contiene: No");
						return; 
					}
					if(nodosx.removeFirst().dato==nodosy.removeFirst().dato){
						continue; 
					}else{
						System.out.println("contiene: No");
						return; 
					}
				}
				System.out.println("contiene: Yes");
				
			}else{
				System.out.println("contiene: No");
				return; 
			}		
		}
	}
		

	static void quitar_arbol(int dx){
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					arboles.remove(i); 
					 
				}
			}
		}
	}
	 
	
	static void agregarArbol_otro(int dx , nodoAVL root){
		
		if(root!=null){
			agregarArbol_otro(dx,root.hijoIzq);
			insertar(root.dato, dx);
			agregarArbol_otro(dx, root.hijoDere);
		}

	}   
	public static void main(String[] args){
     	   Scanner in = new Scanner(System.in); 
	        int comandos = in.nextInt(); 
	        for(int i =0; i<comandos; i++){
	            
	            String comando= in.next(); 
	            
	            if(comando.equals("crear")){
	                int dx= in.nextInt(); 
	                int x= in.nextInt(); 
	                crearArbol(dx, x);
	                
	            }else if(comando.equals("insertar")){
	                int dx= in.nextInt(); 
	                int x = in.nextInt(); 
	                insertar(x, dx);
	            }else if(comando.equals("ocurrencia")){
	            	int dx= in.nextInt(); 
	            	int x = in.nextInt(); 
	            	ocurrencia(x, dx);
	            }else if(comando.equals("contiene")){
	                int dx=in.nextInt(); 
	                int dy= in.nextInt(); 
	                contiene2(dx, dy);
	            }else if(comando.equals("unir")){
	            	int dx=in.nextInt(); 
	                int dy= in.nextInt(); 
	                
	                AVLarbol arbol1= arbol_exisstente(dx); 
	                AVLarbol arbol2= arbol_exisstente(dy); 
	                if (arbol1!=null && arbol2!=null) {
	                		LinkedList<AVLnodo> nodosA= new LinkedList<>(); 
	                		nodosA =Inorder(arbol2.raiz,nodosA);
	                		
	                		AVLnodo agre; 
	                		arbol2.makeEmpty();
	                		quitar_arbol(arbol2.identificador);
	                		
	                		while(!nodosA.isEmpty()){
	                			agre=nodosA.getFirst();
	                			nodosA.removeFirst(); 
	                			insertar_uni(agre, arbol1.identificador, arbol1.raiz);;
	                		}
	                		
					}
	            }
  
	        }
		}
	}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Arboles;

import java.util.LinkedList;
import java.util.Scanner;


public class problemD_RepetOchentamil {
	static class AVLnodo{
        int dato;
        int fe; 
        int ocurrencia;
        AVLnodo hijoIzq;
        AVLnodo hijoDere;
        
        public AVLnodo(int d) {
            this.dato=d;
            this.fe = 0;
            this.hijoDere=null;
            this.hijoIzq=null;
            this.ocurrencia=1;
        } 
    }
    
    static class AVLarbol{
     
    	private AVLnodo raiz;
    	int identificador; 
    	
    	public AVLarbol(AVLnodo root, int dx){
    		this.raiz= root;
    		raiz.ocurrencia=1;
    		this.identificador=dx; 
    	}	
        
        //buscar nodo en el arbol
        public AVLnodo buscar(int d, AVLnodo r){
            if(r== null){
                return null;
            }else if(r.dato==d){
                return r;
            }else if(r.dato<d){
                return buscar( d, r.hijoDere);
            }else{
                return buscar(d, r.hijoIzq);
            }
        }
        
        //obtener Raiz
        public AVLnodo obtenerRaiz(){
            return raiz;
        }
        
       
        public int ObtenerFE(AVLnodo x){
            if(x==null){
                return -1;
            }else{
                return x.fe;
            }
        }
        
        //rotacion simple izquierda
        public AVLnodo rotacionSimpleIzquierda(AVLnodo c){
            AVLnodo auxiliar = c.hijoIzq;
            c.hijoIzq=auxiliar.hijoDere;
            auxiliar.hijoDere=c;
            c.fe=Math.max(ObtenerFE(c.hijoIzq), ObtenerFE(c.hijoDere))+1;
            auxiliar.fe=Math.max(ObtenerFE(auxiliar.hijoIzq), ObtenerFE(auxiliar.hijoDere))+1;
            return auxiliar;
        }
        
        //rotacion simple derecha
        public AVLnodo rotacionSimpleDerecha(AVLnodo c){
            AVLnodo auxiliar = c.hijoDere;
            c.hijoDere=auxiliar.hijoIzq;
            auxiliar.hijoIzq=c;
            c.fe=Math.max(ObtenerFE(c.hijoIzq), ObtenerFE(c.hijoDere))+1;
            auxiliar.fe=Math.max(ObtenerFE(auxiliar.hijoIzq), ObtenerFE(auxiliar.hijoDere))+1;
            return auxiliar;
        }
        
        //Rotacion Doble a la Izquierda
        public AVLnodo rotacionDobleIzquierda(AVLnodo c){
            AVLnodo temporal;
            c.hijoIzq=rotacionSimpleDerecha(c.hijoIzq);
            temporal=rotacionSimpleIzquierda(c);
            return temporal;
        }
        
        //Rotacion doble a la Derecha
        public AVLnodo rotacionDobleDerecha(AVLnodo c){
            AVLnodo temporal;
            c.hijoDere = rotacionSimpleIzquierda(c.hijoDere);
            temporal = rotacionSimpleDerecha(c);
            return temporal;
        }
        
        public AVLnodo insertarAVL(AVLnodo nuevo, AVLnodo subAr){
            AVLnodo nuevoPadre = subAr;
            if(nuevo.dato<subAr.dato){
                if(subAr.hijoIzq==null){
                    subAr.hijoIzq=nuevo;
                }else{
                    subAr.hijoIzq=insertarAVL(nuevo, subAr.hijoIzq);
                    if((ObtenerFE(subAr.hijoIzq) - ObtenerFE(subAr.hijoDere))==2){
                        if(nuevo.dato<subAr.hijoIzq.dato){
                            nuevoPadre=rotacionSimpleIzquierda(subAr);
                        }else{
                            nuevoPadre=rotacionDobleIzquierda(subAr);
                        }
                    }
                    
                }
            }else if(nuevo.dato>subAr.dato){
                if(subAr.hijoDere==null){
                    subAr.hijoDere=nuevo;
                }else{
                    subAr.hijoDere=insertarAVL(nuevo, subAr.hijoDere);
                    if((ObtenerFE(subAr.hijoDere)-ObtenerFE(subAr.hijoIzq)==2)){
                        if(nuevo.dato>subAr.hijoDere.dato){
                            nuevoPadre=rotacionSimpleDerecha(subAr);
                        }else{
                            nuevoPadre=rotacionDobleDerecha(subAr);
                        }
                    }
                }
            }else{
               
                nuevoPadre.ocurrencia=nuevoPadre.ocurrencia+nuevo.ocurrencia;
                
            }
            //actualizar altura
            if((subAr.hijoIzq==null)&& (subAr.hijoDere!=null)){
                subAr.fe = subAr.hijoDere.fe+1;
            }else if((subAr.hijoDere==null) && (subAr.hijoIzq!=null)){
                subAr.fe=subAr.hijoIzq.fe+1;
            }else{
                subAr.fe=Math.max(ObtenerFE(subAr.hijoDere), ObtenerFE(subAr.hijoIzq))+1;
            }
            return nuevoPadre;
        }
        
        //Metodo de insertar
        public void insert(int d){
            AVLnodo nuevo = new AVLnodo(d);
            if(raiz==null){
                raiz=nuevo;
            }else{
                raiz=insertarAVL(nuevo, raiz);
            }
        }
        
        public void insert_Unir(AVLnodo nodo, AVLnodo root){
        	raiz= insertarAVL(nodo, root); 
        }
        
        
        public void Preorder(AVLnodo root) {
            if(root != null){
                System.out.print(root.dato+" ");
            if(root.hijoIzq!=null){
                Preorder(root.hijoIzq);
            }
            if(root.hijoDere!= null){
                Preorder(root.hijoDere);
            }
        }
        }
        
        // volveer vacio un arbol 
       
        public void makeEmpty() {
            raiz = null;
        }
        
       
        
        public void Unir( AVLnodo arbol2){
        if(arbol2!= null){    
            if(arbol2.hijoIzq!=null){
                Unir(arbol2.hijoIzq);
            }
            raiz=insertarAVL(arbol2, raiz);
            System.out.print(arbol2.dato+","+arbol2.ocurrencia+" ");
            if(arbol2.hijoDere!= null){
                Unir( arbol2.hijoDere);
            }
        }
        }
        
        
    }
    static void insertar_uni(AVLnodo nodo , int dx, AVLnodo root){
		
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					arboles.get(i).insert_Unir(nodo, root);
					break;
				}
			}
		}
	}
	static LinkedList<AVLarbol> arboles= new LinkedList<>() ;
	
	public static LinkedList<AVLnodo> Inorder(AVLnodo root, LinkedList<AVLnodo> nodos) {
	    if(root != null){
	        if(root.hijoIzq!=null){
	            Inorder(root.hijoIzq,nodos);
	        }
	        nodos.add(root);
	        if(root.hijoDere!= null){
	            Inorder(root.hijoDere,nodos);
	        }
	    }
	    return nodos; 
	}

	static boolean existe(int dx){
		
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					return true;
				}
			}
		}
		return false; 
		
	}
	
	static AVLarbol arbol_exisstente(int dx){
		
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					return arboles.get(i);
					 
				}
			}
		}
		return null; 
		
	}
	static void crearArbol(int dx, int x){
		
		AVLnodo root = new AVLnodo(x); 
		
		if(!existe(dx)){
				
			AVLarbol arbol= new AVLarbol(root,dx); 
			arboles.add(arbol);
		}
	}

	static void insertar(int x , int dx){
		
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					arboles.get(i).insert(x);
					break;
				}
			}
		}
	}
	
	
	static void ocurrencia(int x , int dx ){
		AVLnodo nodo;  
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				
				if(arboles.get(i).identificador==dx){ 
					
					nodo=arboles.get(i).buscar(x, arboles.get(i).raiz);
					
					if(nodo!=null){
						
						System.out.println("ocurrencia: "+nodo.ocurrencia);
						break; 
					}else{
						System.out.println("ocurrencia: 0");
						break;
					}
					
				}
			}
			
		}	
	}
	
	
	static boolean comparation(AVLnodo raizDx, AVLnodo raizDy){
		if(raizDy==null &&  raizDx==null){
			return true;  
		}else{
			//comparar 
			if(raizDy.dato==raizDx.dato){
			
				if(raizDx.hijoIzq!=null){
						
					comparation(raizDx.hijoIzq, raizDy.hijoIzq);
				}
				
				if(raizDx.hijoDere!=null){
					
					comparation(raizDx.hijoDere, raizDy.hijoDere);
				}
			
			}else{
				return false;  
			}
		}
		return false; 
		
	}
	
		

	static void contiene2(int dx , int dy){
		AVLarbol  dx1, dy2; 
		
		dx1= arbol_exisstente(dx); 
		dy2= arbol_exisstente(dy); 
		
		if((dx1!=null) &&  (dy2!=null)){
			AVLnodo raizdy= dx1.buscar(dy2.raiz.dato, dx1.raiz); 
			
		
			if(raizdy!=null){
		
				LinkedList<AVLnodo>	nodosx = new LinkedList<>();	
				LinkedList<AVLnodo>	nodosy = new LinkedList<>();	
				
				nodosx=Inorder(raizdy, nodosx);
				nodosy=Inorder(dy2.raiz, nodosy); 
				
				
				while(!nodosx.isEmpty()){
					if(!nodosx.isEmpty() && nodosy.isEmpty()){
						System.out.println("contiene: No");
						return; 
					}
					if(nodosx.removeFirst().dato==nodosy.removeFirst().dato){
						continue; 
					}else{
						System.out.println("contiene: No");
						return; 
					}
				}
				System.out.println("contiene: Yes");
				
			}else{
				System.out.println("contiene: No");
				return; 
			}		
		}
	}
		

	static void quitar_arbol(int dx){
		if(!arboles.isEmpty()){
			for (int i = 0; i < arboles.size(); i++) {
				if(arboles.get(i).identificador==dx){
					arboles.remove(i); 
					 
				}
			}
		}
	}
	 
	
  
	public static void main(String[] args){
     	   Scanner in = new Scanner(System.in); 
	        int comandos = in.nextInt(); 
	        for(int i =0; i<comandos; i++){
	            
	            String comando= in.next(); 
	            
	            if(comando.equals("crear")){
	                int dx= in.nextInt(); 
	                int x= in.nextInt(); 
	                crearArbol(dx, x);
	                
	            }else if(comando.equals("insertar")){
	                int dx= in.nextInt(); 
	                int x = in.nextInt(); 
	                insertar(x, dx);
	            }else if(comando.equals("ocurrencia")){
	            	int dx= in.nextInt(); 
	            	int x = in.nextInt(); 
	            	ocurrencia(x, dx);
	            }else if(comando.equals("contiene")){
	                int dx=in.nextInt(); 
	                int dy= in.nextInt(); 
	                contiene2(dx, dy);
	            }else if(comando.equals("unir")){
	            	int dx=in.nextInt(); 
	                int dy= in.nextInt(); 
	                
	                AVLarbol arbol1= arbol_exisstente(dx); 
	                AVLarbol arbol2= arbol_exisstente(dy); 
	                if (arbol1!=null && arbol2!=null) {
	                		LinkedList<AVLnodo> nodosA= new LinkedList<>(); 
	                		nodosA =Inorder(arbol2.raiz,nodosA);
	                		
	                		AVLnodo agre; 
	                		arbol2.makeEmpty();
	                		quitar_arbol(arbol2.identificador);
	                		
	                		while(!nodosA.isEmpty()){
	                			agre=nodosA.getFirst();
	                			nodosA.removeFirst(); 
	                			insertar_uni(agre, arbol1.identificador, arbol1.raiz);;
	                		}
	                		
					}
	            }
  
	        }
		}
	}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package correciones;


import java.util.Enumeration;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;




public class Hash_A_2 {
	static public class Persona{
		int num;
		int equipo;
		int total_demora;
		int total_resueltos; 
		
		LinkedHashMap<Integer, Problema> problemas ;
		
		public Persona(int num){
			this.num=num; 
			this.problemas= new LinkedHashMap<>();
			this.total_demora=0;
			this.total_resueltos=0; 
		}
		
	}

	static public class Problema{
		int intentos_fall; 
		int demora_A;
		int nombre;
		boolean aprobado;
		int demoraT; 
		public Problema(int nombre){
			this.nombre= nombre;
			this.demora_A=0;
			this.intentos_fall=0;
			this.aprobado=false; 
			this.demoraT=0;
		}
	}
	
	static Hashtable<Integer, Persona> arreglo ;
	static int tamano;
	static int contador; 
	static final int Has_MAX= 99991;
	
	public Hash_A_2(int tam){
		this.tamano=tam;
		this.arreglo= new Hashtable<>(tam);
		
	
	}
	
			
			 
	public static void todo_problema(int person , int demora, String cali, int nombre){

			if(cali.equals("C")){
				arreglo.get(person).problemas.get(nombre).demora_A=demora; 
				arreglo.get(person).problemas.get(nombre).aprobado=true; 
				arreglo.get(person).problemas.get(nombre).demoraT=demora+((arreglo.get(person).problemas.get(nombre).intentos_fall)*20); 
				
				arreglo.get(person).total_demora=arreglo.get(person).total_demora+arreglo.get(person).problemas.get(nombre).demoraT;
				arreglo.get(person).total_resueltos=arreglo.get(person).total_resueltos+1; 
				
			}else{
				arreglo.get(person).problemas.get(nombre).intentos_fall=arreglo.get(person).problemas.get(nombre).intentos_fall+1;; 
			}
		
	}


	//mostrar
		public static void mostrar(Hashtable<Integer, Persona> table){
			
			Enumeration<Persona> res = table.elements(); 
			Persona p;
			LinkedList<Persona> resp= new LinkedList<>();
			while(res.hasMoreElements()){
				p=res.nextElement(); 
				resp.add(p);
			}
			
			Persona[] verd= new Persona[resp.size()]; 
			for (int i = 0; i < verd.length; i++) {
				verd[i]=resp.removeFirst(); 
			}
			verd=ordenarArray(verd);
			for (int i = 0; i < verd.length; i++) {
				System.out.println(verd[i].num+" "+verd[i].total_resueltos+" "+verd[i].total_demora);
			}
			
		}
		public static Persona[] ordenarArray(Persona[] arreglo) {
		    Persona aux;
		 
		    for (int i = 0; i < arreglo.length - 1; i++) {
		        for (int x = i + 1; x < arreglo.length; x++) {
		            if (arreglo[x].total_resueltos > arreglo[i].total_resueltos) {
		                aux = arreglo[i];
		                arreglo[i] = arreglo[x];
		                arreglo[x] = aux;
		            }
		            if(arreglo[x].total_resueltos == arreglo[i].total_resueltos){
		            	//ordenar tiempo 
		            	if (arreglo[x].total_demora< arreglo[i].total_demora) {
		            		aux = arreglo[i];
		            		arreglo[i] = arreglo[x];
		            		arreglo[x] = aux;
		            	}
		            	if(arreglo[x].total_demora== arreglo[i].total_demora){
		            		if (arreglo[x].num < arreglo[i].num) {
		                		aux = arreglo[i];
		                		arreglo[i] = arreglo[x];
		                		arreglo[x] = aux;
		                	}
		            	}
		           
		            }
		        }
		    }
		 
		    return arreglo;
		}
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int cases =in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+ (i+1)+":");
			LinkedList<Persona> res;
			int nEquipo=in.nextInt();
			int envios= in.nextInt();
			Hash_A_2 table= new Hash_A_2(envios);
			 for (int j = 0; j < envios; j++) {
			
				int numP=in.nextInt();
				int problem=in.nextInt();
				int tiempo= in.nextInt(); 
				String califi=in.next(); 
				Persona p = new Persona(numP);
				Problema pro= new Problema(problem);
				
				if(arreglo.containsKey(numP)){
					if(!arreglo.get(numP).problemas.containsKey(problem)){
						arreglo.get(numP).problemas.put(problem, pro);
					}
					
				}else{
					arreglo.put(numP, p); 
					arreglo.get(numP).problemas.put(problem, pro);
				}
				
				todo_problema(numP, tiempo, califi, problem);
				/*if(!arreglo[idxP].problemas.containsKey(problem)){
					arreglo[idxP].problemas.put(problem, pro);
				}
				//System.out.println(idxP);
				todo_problema(idxP, tiempo, califi, problem);
				
			 }*/
			
		
			 }
		
			 mostrar(arreglo);
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap;

import java.util.Arrays;
import java.util.Scanner;

public class Problem_c {
	static Integer[] arreglo; 
	static Integer[] query; 
	
	public static void cambiar(int dx, int x ){
		int div=arreglo[dx]; 
		int len= (int)Math.sqrt(arreglo.length)+1;
		int ent=query[dx/len];
		arreglo[dx]=x;
		
		if(div!=0){
			
			int nuevo=((ent)/div)*x;
			 
			query[dx/len]=nuevo;
		//	System.out.println(nuevo);
		
		}else{
			query();
		} 
	}
	
	public static void query( ){
		
		int len = (int)Math.sqrt(arreglo.length)+1;
		query= new Integer[len]; 
		Arrays.fill(query, 1);
		
		for (int i = 0; i < arreglo.length; i++) {
			query[i/len]*=arreglo[i]; 
		}
	}
	
	public static int multi(int low, int high){
		int multi=1; 
		
		for (int i = low; i <= high;) {
		
			if(i % query.length==0 && i+query.length-1<=high){
				
				multi*=query[i/query.length]; 
				i+=query.length; 
				
				
			}else{
				multi*=arreglo[i];
				i++; 
			}
		}
		
		return multi; 
		
		
		
	}
	public static void main(String[] args) {
		Scanner in = new  Scanner(System.in); 
		int cases= in.nextInt(); 
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+(i+1)+":");
			int tam= in.nextInt(); 
			int comand=in.nextInt(); 
			arreglo= new Integer[tam];
			
			for (int j = 0; j <tam; j++) {
				arreglo[j]=in.nextInt(); 

			}
			query();
			
			for (int j = 0; j < comand; j++) {
				String comando= in.next(); 
				if(comando.equals("cambio")){
					int dx= in.nextInt()-1;
					int x=in.nextInt();
					cambiar(dx, x);
					
					
					
				}
				if(comando.equals("multiplicar")){
					int low=(in.nextInt()-1);
					int high= (in.nextInt()-1); 
					int res=multi(low, high); 
					if(res>0){
						System.out.println("+");
					}else if(res<0){
						System.out.println("-");
					}else{
					System.out.println(res);
					}
				}
			}
		}
		
		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap;

import java.util.Scanner;
import java.util.Stack;

public class Problem_A {

	public static void main(String[] args) throws Exception {
		Scanner in = new Scanner(System.in);
		int nNumeros= in.nextInt(); 
		Problem_A heap1= new Problem_A(); 
		BinaryHeap<Integer> heap= heap1.new BinaryHeap<Integer>(nNumeros); 
		loop:
		for (int i = 0; i < nNumeros; i++) {
			int num= in.nextInt(); 
			heap.insert(num);	
	
			if(heap.size()<3){
				System.out.println("-1");
			}else{
				Stack<Integer> back=new Stack<>();  
				while(heap.size()>3){
					
					back.push(heap.deleteMin()); 
				}
				int res= 1; 
				while(!heap.isEmpty()){
					back.push(heap.findMin()); 
					res=res*heap.deleteMin(); 
				}
				System.out.println(res);
				while(!back.isEmpty()){
					heap.insert(back.pop());
				}
				
			}
		}
		
		

	}

private class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

    /**
     * Construct the binary heap.
     */
    public BinaryHeap() {
        this(DEFAULT_CAPACITY);
    }

    /**
     * Construct the binary heap.
     *
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap(int capacity) {
        currentSize = 0;
        array = (AnyType[]) new Comparable[capacity + 1];
    }

    /**
     * Construct the binary heap given an array of items.
     *
     * @param items
     */
    public BinaryHeap(AnyType[] items) {
        currentSize = items.length;
        array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

        int i = 1;
        for (AnyType item : items) {
            array[i++] = item;
        }
        buildHeap();
    }

    /**
     * Insert into the priority queue, maintaining heap order. Duplicates
     * are allowed.
     *
     * @param x the item to insert.
     */
    public void insert(AnyType x) {
        if (currentSize == array.length - 1) {
            enlargeArray(array.length * 2 + 1);
        }

        // Percolate up
        int hole = ++currentSize;
        for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
            array[hole] = array[hole / 2];
        }
        array[hole] = x;
    }

    private void enlargeArray(int newSize) {
        AnyType[] old = array;
        array = (AnyType[]) new Comparable[newSize];
        for (int i = 0; i < old.length; i++) {
            array[i] = old[i];
        }
    }

    /**
     * Find the smallest item in the priority queue.
     *
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin() throws Exception {
        if (isEmpty()) {
            throw new Exception();
        }
        return array[1];
    }

    public AnyType findMax() throws Exception {
        if (isEmpty()) {
            throw new Exception();
        }
        
        int i = 1;
        while(i < currentSize) {
            i = (2*i) + 1;
        }
        return array [i];
    }
    
    public void printHeap() {
        for(int i = 0; i <= currentSize; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
    
    /**
     * Remove the smallest item from the priority queue.
     *
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin() throws Exception {
        if (isEmpty()) {
            throw new Exception();
        }

        AnyType minItem = findMin();
        array[1] = array[currentSize--];
        percolateDown(1);

        return minItem;
    }


    /**
     * Establish heap order property from an arbitrary arrangement of items.
     * Runs in linear time.
     */
    private void buildHeap() {
        for (int i = currentSize / 2; i > 0; i--) {
            percolateDown(i);
        }
    }

    /**
     * Test if the priority queue is logically empty.
     *
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty() {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty() {
        currentSize = 0;
    }

    public int size() {
        return currentSize;
    }

    public static final int DEFAULT_CAPACITY = 10;
    public int currentSize;      // Number of elements in heap
    public AnyType[] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     *
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown(int hole) {
        int child;
        AnyType tmp = array[hole];

        for (; hole * 2 <= currentSize; hole = child) {
            child = hole * 2;
            if (child != currentSize
                    && array[child + 1].compareTo(array[child]) < 0) {
                child++;
            }
            if (array[child].compareTo(tmp) < 0) {
                array[hole] = array[child];
            } else {
                break;
            }
        }
        array[hole] = tmp;
    }

}

}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package correciones;

import java.util.Hashtable;
import java.util.LinkedList;
import java.util.Scanner;

public class Problem_D_Arboles {


	

		static class AVLnodo{
	        int dato;
	        int fe; 
	        int ocurrencia;
	        AVLnodo hijoIzq;
	        AVLnodo hijoDere;
	        
	        public AVLnodo(int d) {
	            this.dato=d;
	            this.fe = 0;
	            this.hijoDere=null;
	            this.hijoIzq=null;
	            this.ocurrencia=1;
	        } 
	    }
	    
	    static class AVLarbol{
	     
	    	private AVLnodo raiz;
	    	int identificador; 
	    	
	    	public AVLarbol(AVLnodo root, int dx){
	    		this.raiz= root;
	    		raiz.ocurrencia=1;
	    		this.identificador=dx; 
	    	}	
	        
	        //buscar nodo en el arbol
	        public AVLnodo buscar(int d, AVLnodo r){
	            if(r== null){
	                return null;
	            }else if(r.dato==d){
	                return r;
	            }else if(r.dato<d){
	                return buscar( d, r.hijoDere);
	            }else{
	                return buscar(d, r.hijoIzq);
	            }
	        }
	        
	        //obtener Raiz
	        public AVLnodo obtenerRaiz(){
	            return raiz;
	        }
	        
	       
	        public int ObtenerFE(AVLnodo x){
	            if(x==null){
	                return -1;
	            }else{
	                return x.fe;
	            }
	        }
	        
	        //rotacion simple izquierda
	        public AVLnodo rotacionSimpleIzquierda(AVLnodo c){
	            AVLnodo auxiliar = c.hijoIzq;
	            c.hijoIzq=auxiliar.hijoDere;
	            auxiliar.hijoDere=c;
	            c.fe=Math.max(ObtenerFE(c.hijoIzq), ObtenerFE(c.hijoDere))+1;
	            auxiliar.fe=Math.max(ObtenerFE(auxiliar.hijoIzq), ObtenerFE(auxiliar.hijoDere))+1;
	            return auxiliar;
	        }
	        
	        //rotacion simple derecha
	        public AVLnodo rotacionSimpleDerecha(AVLnodo c){
	            AVLnodo auxiliar = c.hijoDere;
	            c.hijoDere=auxiliar.hijoIzq;
	            auxiliar.hijoIzq=c;
	            c.fe=Math.max(ObtenerFE(c.hijoIzq), ObtenerFE(c.hijoDere))+1;
	            auxiliar.fe=Math.max(ObtenerFE(auxiliar.hijoIzq), ObtenerFE(auxiliar.hijoDere))+1;
	            return auxiliar;
	        }
	        
	        //Rotacion Doble a la Izquierda
	        public AVLnodo rotacionDobleIzquierda(AVLnodo c){
	            AVLnodo temporal;
	            c.hijoIzq=rotacionSimpleDerecha(c.hijoIzq);
	            temporal=rotacionSimpleIzquierda(c);
	            return temporal;
	        }
	        
	        //Rotacion doble a la Derecha
	        public AVLnodo rotacionDobleDerecha(AVLnodo c){
	            AVLnodo temporal;
	            c.hijoDere = rotacionSimpleIzquierda(c.hijoDere);
	            temporal = rotacionSimpleDerecha(c);
	            return temporal;
	        }
	        
	        public AVLnodo insertarAVL(AVLnodo nuevo, AVLnodo subAr){
	            AVLnodo nuevoPadre = subAr;
	            if(nuevo.dato<subAr.dato){
	                if(subAr.hijoIzq==null){
	                    subAr.hijoIzq=nuevo;
	                }else{
	                    subAr.hijoIzq=insertarAVL(nuevo, subAr.hijoIzq);
	                    if((ObtenerFE(subAr.hijoIzq) - ObtenerFE(subAr.hijoDere))==2){
	                        if(nuevo.dato<subAr.hijoIzq.dato){
	                            nuevoPadre=rotacionSimpleIzquierda(subAr);
	                        }else{
	                            nuevoPadre=rotacionDobleIzquierda(subAr);
	                        }
	                    }
	                    
	                }
	            }else if(nuevo.dato>subAr.dato){
	                if(subAr.hijoDere==null){
	                    subAr.hijoDere=nuevo;
	                }else{
	                    subAr.hijoDere=insertarAVL(nuevo, subAr.hijoDere);
	                    if((ObtenerFE(subAr.hijoDere)-ObtenerFE(subAr.hijoIzq)==2)){
	                        if(nuevo.dato>subAr.hijoDere.dato){
	                            nuevoPadre=rotacionSimpleDerecha(subAr);
	                        }else{
	                            nuevoPadre=rotacionDobleDerecha(subAr);
	                        }
	                    }
	                }
	            }else{
	               
	                nuevoPadre.ocurrencia=nuevoPadre.ocurrencia+nuevo.ocurrencia;
	                
	            }
	            //actualizar altura
	            if((subAr.hijoIzq==null)&& (subAr.hijoDere!=null)){
	                subAr.fe = subAr.hijoDere.fe+1;
	            }else if((subAr.hijoDere==null) && (subAr.hijoIzq!=null)){
	                subAr.fe=subAr.hijoIzq.fe+1;
	            }else{
	                subAr.fe=Math.max(ObtenerFE(subAr.hijoDere), ObtenerFE(subAr.hijoIzq))+1;
	            }
	            return nuevoPadre;
	        }
	        
	        //Metodo de insertar
	        public void insert(int d){
	            AVLnodo nuevo = new AVLnodo(d);
	            if(raiz==null){
	                raiz=nuevo;
	            }else{
	                raiz=insertarAVL(nuevo, raiz);
	            }
	        }
	        
	        public void insert_Unir(AVLnodo nodo, AVLnodo root){
	        	raiz= insertarAVL(nodo, root); 
	        }
	        
	        
	        public void Preorder(AVLnodo root) {
	            if(root != null){
	                System.out.print(root.dato+" ");
	            if(root.hijoIzq!=null){
	                Preorder(root.hijoIzq);
	            }
	            if(root.hijoDere!= null){
	                Preorder(root.hijoDere);
	            }
	        }
	        }
	        
	        // volveer vacio un arbol 
	       
	        public void makeEmpty() {
	            raiz = null;
	        }
	        
	       
	        
	        public void Unir( AVLnodo arbol2){
	        if(arbol2!= null){    
	            if(arbol2.hijoIzq!=null){
	                Unir(arbol2.hijoIzq);
	            }
	            raiz=insertarAVL(arbol2, raiz);
	            System.out.print(arbol2.dato+","+arbol2.ocurrencia+" ");
	            if(arbol2.hijoDere!= null){
	                Unir( arbol2.hijoDere);
	            }
	        }
	        }
	        
	        
	    }
	    static void insertar_uni(AVLnodo nodo , int dx, AVLnodo root){
			
			if(!arboles.isEmpty()){
					if(arboles.containsKey(dx)){
						arboles.get(dx).insert_Unir(nodo, root);
						return;
					}else{
						return;
					}
			}else{
				return ;
			}
			
		}
		
		
		public static LinkedList<AVLnodo> Inorder(AVLnodo root, LinkedList<AVLnodo> nodos) {
		    if(root != null){
		        if(root.hijoIzq!=null){
		            Inorder(root.hijoIzq,nodos);
		        }
		        nodos.add(root);
		        if(root.hijoDere!= null){
		            Inorder(root.hijoDere,nodos);
		        }
		    }
		    return nodos; 
		}

		static boolean existe(int dx){
			
			if(!arboles.isEmpty()){
				arboles.containsKey(dx); 
			}
			return false; 
			
		}
		
		static AVLarbol arbol_exisstente(int dx){
			
			if(!arboles.isEmpty()){

				if(arboles.containsKey(dx)){
					return arboles.get(dx);
						 
				}else{
					return null; 
				}
			}
			
			return null; 
			
		}
		static void crearArbol(int dx, int x){
			
			AVLnodo root = new AVLnodo(x); 
			
			if(!existe(dx)){
					
				AVLarbol arbol= new AVLarbol(root,dx); 
				arboles.put(dx, arbol);
			}
		}

		static void insertar(int x , int dx){
			
			if(!arboles.isEmpty()){
				if(arboles.containsKey(dx)){
					arboles.get(dx).insert(x);
				}else{
					return; 
				}
			}
		}
		
		static void ocurrencia(int x , int dx ){
			AVLnodo nodo;  
			if(!arboles.isEmpty()){
					
					if(arboles.containsKey(dx)){ 
						
						nodo=arboles.get(dx).buscar(x, arboles.get(dx).raiz);
						
						if(nodo!=null){
							
							System.out.println("ocurrencia: "+nodo.ocurrencia);
							return; 
						}else{
							System.out.println("ocurrencia: 0");
							return;
						}
						
					}else{
						return; 
					}
			}else{
					return;
			}
				
		}	
		
		
		
		static boolean comparation(AVLnodo raizDx, AVLnodo raizDy){
			if(raizDy==null &&  raizDx==null){
				return true;  
			}else{
				//comparar 
				if(raizDy.dato==raizDx.dato){
				
					if(raizDx.hijoIzq!=null){
							
						comparation(raizDx.hijoIzq, raizDy.hijoIzq);
					}
					
					if(raizDx.hijoDere!=null){
						
						comparation(raizDx.hijoDere, raizDy.hijoDere);
					}
				
				}else{
					return false;  
				}
			}
			return false; 
			
		}
		
			

		static void contiene2(int dx , int dy){
			AVLarbol  dx1, dy2; 
			
			dx1= arbol_exisstente(dx); 
			dy2= arbol_exisstente(dy); 
			
			if((dx1!=null) &&  (dy2!=null)){
				AVLnodo raizdy= dx1.buscar(dy2.raiz.dato, dx1.raiz); 
				
			
				if(raizdy!=null){
			
					LinkedList<AVLnodo>	nodosx = new LinkedList<>();	
					LinkedList<AVLnodo>	nodosy = new LinkedList<>();	
					
					nodosx=Inorder(raizdy, nodosx);
					nodosy=Inorder(dy2.raiz, nodosy); 
					
					
					while(!nodosx.isEmpty()){
						if(!nodosx.isEmpty() && nodosy.isEmpty()){
							System.out.println("contiene: No");
							return; 
						}
						if(nodosx.removeFirst().dato==nodosy.removeFirst().dato){
							continue; 
						}else{
							System.out.println("contiene: No");
							return; 
						}
					}
					System.out.println("contiene: Yes");
					
				}else{
					System.out.println("contiene: No");
					return; 
				}		
			}return; 
		}
			

		static void quitar_arbol(int dx){
			if(!arboles.isEmpty()){
				
					if(arboles.containsKey(dx)){
						arboles.remove(dx); 
						return;
						 
					}else{
						return; 
					}
			}else{
				return; 
			}
			
		}
		 
		static  Hashtable<Integer, AVLarbol> arboles = new Hashtable<>(); 
	  
		public static void main(String[] args){
	     	   Scanner in = new Scanner(System.in); 
		        int comandos = in.nextInt(); 
		       
		        for(int i =0; i<comandos; i++){
		            
		            String comando= in.next(); 
		            
		            if(comando.equals("crear")){
		                int dx= in.nextInt(); 
		                int x= in.nextInt(); 
		                crearArbol(dx, x);
		                
		            }else if(comando.equals("insertar")){
		                int dx= in.nextInt(); 
		                int x = in.nextInt(); 
		                insertar(x, dx);
		            }else if(comando.equals("ocurrencia")){
		            	int dx= in.nextInt(); 
		            	int x = in.nextInt(); 
		            	ocurrencia(x, dx);
		            }else if(comando.equals("contiene")){
		                int dx=in.nextInt(); 
		                int dy= in.nextInt(); 
		                contiene2(dx, dy);
		            }else if(comando.equals("unir")){
		            	int dx=in.nextInt(); 
		                int dy= in.nextInt(); 
		                
		                AVLarbol arbol1= arbol_exisstente(dx); 
		                AVLarbol arbol2= arbol_exisstente(dy); 
		                if (arbol1!=null && arbol2!=null) {
		                		LinkedList<AVLnodo> nodosA= new LinkedList<>(); 
		                		nodosA =Inorder(arbol2.raiz,nodosA);
		                		
		                		AVLnodo agre; 
		                		arbol2.makeEmpty();
		                		quitar_arbol(arbol2.identificador);
		                		
		                		while(!nodosA.isEmpty()){
		                			agre=nodosA.getFirst();
		                			nodosA.removeFirst(); 
		                			insertar_uni(agre, arbol1.identificador, arbol1.raiz);;
		                		}
		                		
						}
		            }
	  
		        }
			}
		

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package correciones;


import java.util.Enumeration;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;




public class Hash_A_2 {
	static public class Persona{
		int num;
		int equipo;
		int total_demora;
		int total_resueltos; 
		
		LinkedHashMap<Integer, Problema> problemas ;
		
		public Persona(int num){
			this.num=num; 
			this.problemas= new LinkedHashMap<>();
			this.total_demora=0;
			this.total_resueltos=0; 
		}
		
	}

	static public class Problema{
		int intentos_fall; 
		int demora_A;
		int nombre;
		boolean aprobado;
		int demoraT; 
		public Problema(int nombre){
			this.nombre= nombre;
			this.demora_A=0;
			this.intentos_fall=0;
			this.aprobado=false; 
			this.demoraT=0;
		}
	}
	
	static Hashtable<Integer, Persona> arreglo ;
	static int tamano;
	static int contador; 
	static final int Has_MAX= 99991;
	
	public Hash_A_2(int tam){
		this.tamano=tam;
		this.arreglo= new Hashtable<>(tam);
		
	
	}
	
			
			 
	public static void todo_problema(int person , int demora, String cali, int nombre){

			if(cali.equals("C")){
				arreglo.get(person).problemas.get(nombre).demora_A=demora; 
				arreglo.get(person).problemas.get(nombre).aprobado=true; 
				arreglo.get(person).problemas.get(nombre).demoraT=demora+((arreglo.get(person).problemas.get(nombre).intentos_fall)*20); 
				
				arreglo.get(person).total_demora=arreglo.get(person).total_demora+arreglo.get(person).problemas.get(nombre).demoraT;
				arreglo.get(person).total_resueltos=arreglo.get(person).total_resueltos+1; 
				
			}else{
				arreglo.get(person).problemas.get(nombre).intentos_fall=arreglo.get(person).problemas.get(nombre).intentos_fall+1;; 
			}
		
	}


	//mostrar
		public static void mostrar(Hashtable<Integer, Persona> table){
			
			Enumeration<Persona> res = table.elements(); 
			Persona p;
			LinkedList<Persona> resp= new LinkedList<>();
			while(res.hasMoreElements()){
				p=res.nextElement(); 
				resp.add(p);
			}
			
			Persona[] verd= new Persona[resp.size()]; 
			for (int i = 0; i < verd.length; i++) {
				verd[i]=resp.removeFirst(); 
			}
			verd=ordenarArray(verd);
			for (int i = 0; i < verd.length; i++) {
				System.out.println(verd[i].num+" "+verd[i].total_resueltos+" "+verd[i].total_demora);
			}
			
		}
		public static Persona[] ordenarArray(Persona[] arreglo) {
		    Persona aux;
		 
		    for (int i = 0; i < arreglo.length - 1; i++) {
		        for (int x = i + 1; x < arreglo.length; x++) {
		            if (arreglo[x].total_resueltos > arreglo[i].total_resueltos) {
		                aux = arreglo[i];
		                arreglo[i] = arreglo[x];
		                arreglo[x] = aux;
		            }
		            if(arreglo[x].total_resueltos == arreglo[i].total_resueltos){
		            	//ordenar tiempo 
		            	if (arreglo[x].total_demora< arreglo[i].total_demora) {
		            		aux = arreglo[i];
		            		arreglo[i] = arreglo[x];
		            		arreglo[x] = aux;
		            	}
		            	if(arreglo[x].total_demora== arreglo[i].total_demora){
		            		if (arreglo[x].num < arreglo[i].num) {
		                		aux = arreglo[i];
		                		arreglo[i] = arreglo[x];
		                		arreglo[x] = aux;
		                	}
		            	}
		           
		            }
		        }
		    }
		 
		    return arreglo;
		}
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int cases =in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+ (i+1)+":");
			LinkedList<Persona> res;
			int nEquipo=in.nextInt();
			int envios= in.nextInt();
			arreglo= new Hashtable<>(envios);
			for (int j = 0; j < envios; j++) {
			
				int numP=in.nextInt();
				int problem=in.nextInt();
				int tiempo= in.nextInt(); 
				String califi=in.next(); 
				Persona p = new Persona(numP);
				Problema pro= new Problema(problem);
				
				if(arreglo.containsKey(numP)){
					if(!arreglo.get(numP).problemas.containsKey(problem)){
						arreglo.get(numP).problemas.put(problem, pro);
					}
					
				}else{
					arreglo.put(numP, p); 
					arreglo.get(numP).problemas.put(problem, pro);
				}
				
				todo_problema(numP, tiempo, califi, problem);
				/*if(!arreglo[idxP].problemas.containsKey(problem)){
					arreglo[idxP].problemas.put(problem, pro);
				}
				//System.out.println(idxP);
				todo_problema(idxP, tiempo, califi, problem);
				
			 }*/
			
		
			 }
		
			 mostrar(arreglo);
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;
import java.util.Stack;


public class Problem_e {

	public static void main(String[] args) throws Exception {
		Scanner in = new Scanner(System.in);
		int nNumeros= in.nextInt(); 
		int k = in.nextInt(); 
		Problem_e heap1= new Problem_e(); 
		BinaryHeap<Integer> heap= heap1.new BinaryHeap<Integer>(nNumeros); 
		loop:

		for (int i = 0; i < nNumeros; i++) {
			int num= in.nextInt(); 
			
			heap.insert(num);	
	
			if(heap.size()<k){
				System.out.println("-1");
			}else{
				Stack<Integer> back=new Stack<>();  
	
				while(heap.size()>k){
					
					back.push(heap.deleteMin()); 
				}
				
				int res= 1; 
				while(!heap.isEmpty()){
					back.push(heap.findMin()); 
					res=res*heap.deleteMin(); 
				}
				System.out.println(res);
				while(!back.isEmpty()){
					heap.insert(back.pop());
				}
				
			}
		}
		


	}

	private class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap() {
	        this(DEFAULT_CAPACITY);
	    }

	    /**
	     * Construct the binary heap.
	     *
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap(int capacity) {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[capacity + 1];
	    }

	    /**
	     * Construct the binary heap given an array of items.
	     *
	     * @param items
	     */
	    public BinaryHeap(AnyType[] items) {
	        currentSize = items.length;
	        array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

	        int i = 1;
	        for (AnyType item : items) {
	            array[i++] = item;
	        }
	        buildHeap();
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order. Duplicates
	     * are allowed.
	     *
	     * @param x the item to insert.
	     */
	    public void insert(AnyType x) {
	        if (currentSize == array.length - 1) {
	            enlargeArray(array.length * 2 + 1);
	        }

	        // Percolate up
	        int hole = ++currentSize;
	        for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2) {
	            array[hole] = array[hole / 2];
	        }
	        array[hole] = x;
	    }

	    private void enlargeArray(int newSize) {
	        AnyType[] old = array;
	        array = (AnyType[]) new Comparable[newSize];
	        for (int i = 0; i < old.length; i++) {
	            array[i] = old[i];
	        }
	    }

	    /**
	     * Find the smallest item in the priority queue.
	     *
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin() throws Exception {
	        if (isEmpty()) {
	            throw new Exception();
	        }
	        return array[1];
	    }

	    public AnyType findMax() throws Exception {
	        if (isEmpty()) {
	            throw new Exception();
	        }
	        
	        int i = 1;
	        while(i < currentSize) {
	            i = (2*i) + 1;
	        }
	        return array [i];
	    }
	    
	    public void printHeap() {
	        for(int i = 0; i <= currentSize; i++) {
	            System.out.print(array[i] + " ");
	        }
	        System.out.println();
	    }
	    
	    /**
	     * Remove the smallest item from the priority queue.
	     *
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin() throws Exception {
	        if (isEmpty()) {
	            throw new Exception();
	        }

	        AnyType minItem = findMin();
	        array[1] = array[currentSize--];
	        percolateDown(1);

	        return minItem;
	    }


	    /**
	     * Establish heap order property from an arbitrary arrangement of items.
	     * Runs in linear time.
	     */
	    private void buildHeap() {
	        for (int i = currentSize / 2; i > 0; i--) {
	            percolateDown(i);
	        }
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     *
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty() {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty() {
	        currentSize = 0;
	    }

	    public int size() {
	        return currentSize;
	    }

	    public static final int DEFAULT_CAPACITY = 10;
	    public int currentSize;      // Number of elements in heap
	    public AnyType[] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     *
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown(int hole) {
	        int child;
	        AnyType tmp = array[hole];

	        for (; hole * 2 <= currentSize; hole = child) {
	            child = hole * 2;
	            if (child != currentSize
	                    && array[child + 1].compareTo(array[child]) < 0) {
	                child++;
	            }
	            if (array[child].compareTo(tmp) < 0) {
	                array[hole] = array[child];
	            } else {
	                break;
	            }
	        }
	        array[hole] = tmp;
	    }

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package correciones;


import java.util.Enumeration;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;





public class Hash_A_2 {
	static public class Persona implements Comparable{
		Integer num;
		Integer equipo;
		Integer total_demora;
		Integer total_resueltos; 
		
		LinkedHashMap<Integer, Problema> problemas ;
		
		public Persona(int num){
			this.num=num; 
			this.problemas= new LinkedHashMap<>();
			this.total_demora=0;
			this.total_resueltos=0; 
		}

		@Override
		public int compareTo(Object o) {
			Persona obj = (Persona) o;
			int compare = total_resueltos.compareTo(obj.total_resueltos);
			if (compare == 0) {
				compare = -1 * total_demora.compareTo(obj.total_demora);
				if (compare == 0) {
					compare = -num.compareTo(obj.num);
				}
			}
			return -compare;
		}

		
	}

	static public class Problema{
		int intentos_fall; 
		int demora_A;
		int nombre;
		boolean aprobado;
		int demoraT; 
		public Problema(int nombre){
			this.nombre= nombre;
			this.demora_A=0;
			this.intentos_fall=0;
			this.aprobado=false; 
			this.demoraT=0;
		}
	}
	
	static Hashtable<Integer, Persona> arreglo ;
	static int tamano;
	static int contador; 
	static final int Has_MAX= 99991;
	static TreeSet<Persona> orden; 
	public Hash_A_2(int tam){
		this.tamano=tam;
		this.arreglo= new Hashtable<>(tam);
		
	
	}
	
			
			 
	public static void todo_problema(int person , int demora, String cali, int nombre){

			if(cali.equals("C")){
				arreglo.get(person).problemas.get(nombre).demora_A=demora; 
				arreglo.get(person).problemas.get(nombre).aprobado=true; 
				arreglo.get(person).problemas.get(nombre).demoraT=demora+((arreglo.get(person).problemas.get(nombre).intentos_fall)*20); 
				
				arreglo.get(person).total_demora=arreglo.get(person).total_demora+arreglo.get(person).problemas.get(nombre).demoraT;
				arreglo.get(person).total_resueltos=arreglo.get(person).total_resueltos+1; 
				
			}else{
				arreglo.get(person).problemas.get(nombre).intentos_fall=arreglo.get(person).problemas.get(nombre).intentos_fall+1;; 
			}
		
	}


	//mostrar
		public static void mostrar(Hashtable<Integer, Persona> table){
			
			Enumeration<Persona> res = table.elements(); 
			Persona p;
			while(res.hasMoreElements()){
				p=res.nextElement(); 
				orden.add(p);
			}
			int tam=orden.size(); 
			for (int i = 0; i < tam; i++) {
				p= orden.pollFirst(); 
				System.out.println(p.num+" "+p.total_resueltos+" "+p.total_demora);
			}
			
		}
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in); 
		int cases =in.nextInt();
		for (int i = 0; i < cases; i++) {
			System.out.println("Caso #"+ (i+1)+":");

			
			int nEquipo=in.nextInt();
			int envios= in.nextInt();
			arreglo= new Hashtable<>(envios);
			orden= new TreeSet<>(); 
			for (int j = 0; j < envios; j++) {
			
				int numP=in.nextInt();
				int problem=in.nextInt();
				int tiempo= in.nextInt(); 
				String califi=in.next(); 
				Persona p = new Persona(numP);
				Problema pro= new Problema(problem);
				
				if(arreglo.containsKey(numP)){
					if(!arreglo.get(numP).problemas.containsKey(problem)){
						arreglo.get(numP).problemas.put(problem, pro);
					}
					
				}else{
					arreglo.put(numP, p); 
					arreglo.get(numP).problemas.put(problem, pro);
				}
				
				todo_problema(numP, tiempo, califi, problem);
			
			 }
		
			 mostrar(arreglo);
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
