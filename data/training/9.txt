/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemaa;

import java.util.Scanner;

/**
 *
 */
public class ProblemaA {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N,K,i=1;
        int n=1;
        int menor=0, mayor=0,igual=0;
        int[] vectorA=new int[10000];
        N=in.nextInt();
        do{
            K=in.nextInt();
            for(i=1; i<=K ; i++){
                vectorA[i]=in.nextInt();
            }
            for(int h=1;h<=K;h++){
                for(i=1; i<=K ; i++){
                    if(vectorA[h]<vectorA[i] && h!=i){
                        menor=menor+1;
                    }
                    if(vectorA[h]>vectorA[i] && h!=i){
                        mayor=mayor+1;
                    }
                    if(vectorA[h]==vectorA[i] && h!=i){
                        igual=igual+1;
                    }           
                }
            }
            System.out.println("Case #"+n+":");
            System.out.println(mayor);
            System.out.println(menor);
            System.out.println(igual);
            n++;
            mayor=0;
            menor=0;
            igual=0;
        }while(n<=N);
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemab;

import java.util.Scanner;

/**
 *
 */
public class ProblemaB {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[][] tab=new int[1000][1000];
        int N,fil=0,col=0,win=0;
        N=in.nextInt();
        for(int i=0;i<N;i++){
            for(int k=0; k<N; k++){
                tab[i][k]=in.nextInt();
            }      
        }
            for(int i=0;i<N;i++){
                for(int k=0; k<N; k++){
                    for(int m=0; m<N; m++){
                        fil=fil+tab[i][m];
                    }
                    for(int p=0; p<N; p++){
                        col=col+tab[p][k];
                    }
                    if(fil<col){
                        win=win+1;
                    }
                    fil=0;
                    col=0;
                }      
            }
        System.out.println(win);
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemab;

import java.util.Scanner;

/**
 *
 */
public class ProblemaB {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[][] tab=new int[1000][1000];
        int N,fil=0,col=0,win=0;
        N=in.nextInt();
        for(int i=0;i<N;i++){
            for(int k=0; k<N; k++){
                tab[i][k]=in.nextInt();
            }      
        }
            for(int i=0;i<N;i++){
                for(int k=0; k<N; k++){
                    for(int m=0; m<N; m++){
                        fil=fil+tab[i][m];
                    }
                    for(int p=0; p<N; p++){
                        col=col+tab[p][k];
                    }
                    if(fil<col){
                        win=win+1;
                    }
                    fil=0;
                    col=0;
                }      
            }
        System.out.println(win);
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemab;

import java.util.Scanner;

/**
 *
 */
public class ProblemaB {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[][] tab=new int[1000][1000];
        int N,fil=0,col=0,win=0;
        N=in.nextInt();
        for(int i=0;i<N;i++){
            for(int k=0; k<N; k++){
                tab[i][k]=in.nextInt();
            }      
        }
            for(int i=0;i<N;i++){
                for(int k=0; k<N; k++){
                    for(int m=0; m<N; m++){
                        fil=fil+tab[i][m];
                    }
                    for(int p=0; p<N; p++){
                        col=col+tab[p][k];
                    }
                    if(fil<col){
                        win=win+1;
                    }
                    fil=0;
                    col=0;
                }      
            }
        System.out.println(win);
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemab;

import java.util.Scanner;

/**
 *
 */
public class ProblemaB {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[][] tab=new int[1000][1000];
        int N,fil=0,col=0,win=0;
        int n=1;
        do{
            N=in.nextInt();
            for(int i=0;i<N;i++){
                for(int k=0; k<N; k++){
                    tab[i][k]=in.nextInt();
                }      
            }
                for(int i=0;i<N;i++){
                    for(int k=0; k<N; k++){
                        for(int m=0; m<N; m++){
                            fil=fil+tab[i][m];
                        }
                        for(int p=0; p<N; p++){
                            col=col+tab[p][k];
                        }
                        if(fil<col){
                            win=win+1;
                        }
                        fil=0;
                        col=0;
                    }      
                }
            System.out.println("Case # "+n+" :");
            System.out.println(win);
            win=0;
            n++;
        }while(in.hasNext());
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemab;

import java.util.Scanner;

/**
 *
 */
public class ProblemaB {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[][] tab=new int[1000][1000];
        int N,fil=0,col=0,win=0;
        int n=1;
        do{
            N=in.nextInt();
            for(int i=0;i<N;i++){
                for(int k=0; k<N; k++){
                    tab[i][k]=in.nextInt();
                }      
            }
                for(int i=0;i<N;i++){
                    for(int k=0; k<N; k++){
                        for(int m=0; m<N; m++){
                            fil=fil+tab[i][m];
                        }
                        for(int p=0; p<N; p++){
                            col=col+tab[p][k];
                        }
                        if(fil<col){
                            win=win+1;
                        }
                        fil=0;
                        col=0;
                    }      
                }
            System.out.println("Case #"+n+" :");
            System.out.println(win);
            win=0;
            n++;
        }while(in.hasNext());
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemab;

import java.util.Scanner;

/**
 *
 */
public class ProblemaB {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[][] tab=new int[1000][1000];
        int N,fil=0,col=0,win=0;
        int n=1;
        do{
            N=in.nextInt();
            for(int i=0;i<N;i++){
                for(int k=0; k<N; k++){
                    tab[i][k]=in.nextInt();
                }
            }
                for(int i=0;i<N;i++){
                    for(int k=0; k<N; k++){
                        for(int m=0; m<N; m++){
                            fil=fil+tab[i][m];
                        }
                        for(int p=0; p<N; p++){
                            col=col+tab[p][k];
                        }
                        if(fil<col){
                            win=win+1;
                        }
                        fil=0;
                        col=0;
                    }
                }
            System.out.println("Case #"+n+":");
            System.out.println(win);
            win=0;
            n++;
        }while(in.hasNext());
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad;

import java.util.Scanner;

/**
 *
 */
public class ProblemaD {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int T,t=1,N;
        Scanner ent= new Scanner(System.in);
        Scanner str= new Scanner(System.in);
        String uniforme;
        char uniforme1,uniforme2;
        T=ent.nextInt();
        int[] uniformeA;
        int[] uniformeB;
        int suma=0;
        do{
            uniformeA=new int[1000];
            uniformeB= new int[1000];
            N=ent.nextInt();
            for(int i=0;i<N;i++){
                uniforme=str.nextLine();
                uniforme1=uniforme.charAt(0);
                uniforme2=uniforme.charAt(2);
                uniformeA[i]=Integer.parseInt(""+uniforme1);
                uniformeB[i]=Integer.parseInt(""+uniforme2);
            }
            for(int i=0; i<N; i++){
                for(int k=0; k<N; k++){
                    if(!(i==k)){
                        if(uniformeA[i]==uniformeB[k]){
                            suma=suma+1;
                        }
                    }
                }
            }
            System.out.println("case #"+t+":");
            System.out.println(suma);
            t++;
            suma=0;
        }while(t<=T);
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad;

import java.util.Scanner;

/**
 *
 */
public class ProblemaD {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int T,t=1,N;
        Scanner ent= new Scanner(System.in);
        Scanner str= new Scanner(System.in);
        String uniforme;
        char uniforme1,uniforme2;
        T=ent.nextInt();
        int[] uniformeA;
        int[] uniformeB;
        int suma=0;
        
        do{
            uniformeA=new int[1000];
            uniformeB= new int[1000];
            N=ent.nextInt();
            for(int i=0;i<N;i++){
                uniforme=str.nextLine();
                uniformeA[i]=readInts(uniforme,2)[0];
                uniformeB[i]=readInts(uniforme,2)[1];
            }
            for(int i=0; i<N; i++){
                for(int k=0; k<N; k++){
                    if(!(i==k)){
                        if(uniformeA[i]==uniformeB[k]){
                            suma=suma+1;
                        }
                    }
                }
            }
            System.out.println("case #"+t+":");
            System.out.println(suma);
            t++;
            suma=0;
        }while(t<=T);
    }
    public static int[] readInts(String s, int n){
        String split[]=s.split(" ");
        int arr[]= new int[n];
        for(int i=0; i< arr.length;i++){
            arr[i]=Integer.parseInt(split[i]);
        }
        return arr;
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad;

import java.util.Scanner;

/**
 *
 */
public class ProblemaD {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int T,t=1,N;
        Scanner ent= new Scanner(System.in);
        Scanner str= new Scanner(System.in);
        String uniforme;
        char uniforme1,uniforme2;
        T=ent.nextInt();
        int[] uniformeA;
        int[] uniformeB;
        int suma=0;
        
        do{
            uniformeA=new int[1000];
            uniformeB= new int[1000];
            N=ent.nextInt();
            for(int i=0;i<N;i++){
                uniforme=str.nextLine();
                uniformeA[i]=readInts(uniforme,2)[0];
                uniformeB[i]=readInts(uniforme,2)[1];
            }
            for(int i=0; i<N; i++){
                for(int k=0; k<N; k++){
                    if(!(i==k)){
                        if(uniformeA[i]==uniformeB[k]){
                            suma=suma+1;
                        }
                    }
                }
            }
            System.out.println("case #"+t+":");
            System.out.println(suma);
            t++;
            suma=0;
        }while(t<=T);
    }
    public static int[] readInts(String s, int n){
        String split[]=s.split(" ");
        int arr[]= new int[n];
        for(int i=0; i< arr.length;i++){
            arr[i]=Integer.parseInt(split[i]);
        }
        return arr;
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad;

import java.util.Scanner;

/**
 *
 */
public class ProblemaD {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int T,t=1,N;
        Scanner ent= new Scanner(System.in);
        Scanner str= new Scanner(System.in);
        String uniforme;
        T=ent.nextInt();
        int[] uniformeA;
        int[] uniformeB;
        int suma=0;
        
        do{
            uniformeA=new int[1000];
            uniformeB= new int[1000];
            N=ent.nextInt();
            for(int i=0;i<N;i++){
                uniforme=str.nextLine();
                uniformeA[i]=readInts(uniforme,2)[0];
                uniformeB[i]=readInts(uniforme,2)[1];
            }
            for(int i=0; i<N; i++){
                for(int k=0; k<N; k++){
                    if(!(i==k)){
                        if(uniformeA[i]==uniformeB[k]){
                            suma=suma+1;
                        }
                    }
                }
            }
            System.out.println("case #"+t+":");
            System.out.println(suma);
            t++;
            suma=0;
        }while(t<=T);
    }
    public static int[] readInts(String s, int n){
        String split[]=s.split(" ");
        int arr[]= new int[n];
        for(int i=0; i< arr.length;i++){
            arr[i]=Integer.parseInt(split[i]);
        }
        return arr;
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad;

import java.util.Scanner;

/**
 *
 */
public class ProblemaD {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int T,t=1,N;
        Scanner ent= new Scanner(System.in);
        String uniforme;
        T=Integer.parseInt(ent.nextLine());
        int[] uniformeA;
        int[] uniformeB;
        int suma=0;
        
        do{
            uniformeA=new int[1000];
            uniformeB= new int[1000];
            N=Integer.parseInt(ent.nextLine());
            for(int i=0;i<N;i++){
                
                uniforme=ent.nextLine();
                uniformeA[i]=readInts(uniforme,2)[0];
                uniformeB[i]=readInts(uniforme,2)[1];
            }
            for(int i=0; i<N; i++){
                for(int k=0; k<N; k++){
                    if(!(i==k)){
                        if(uniformeA[i]==uniformeB[k]){
                            suma=suma+1;
                        }
                    }
                }
            }
            System.out.println("case #"+t+":");
            System.out.println(suma);
            t++;
            suma=0;
        }while(t<=T);
    }
    public static int[] readInts(String s, int n){
        String split[]=s.split(" ");
        int arr[]= new int[n];
        for(int i=0; i< arr.length;i++){
            arr[i]=Integer.parseInt(split[i]);
        }
        return arr;
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad;

import java.util.Scanner;

/**
 *
 */
public class ProblemaD {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        int T,t=1,N;
        Scanner ent= new Scanner(System.in);
        String uniforme;
        T=Integer.parseInt(ent.nextLine());
        int[] uniformeA;
        int[] uniformeB;
        int suma=0;
        
        do{
            uniformeA=new int[1000];
            uniformeB= new int[1000];
            N=Integer.parseInt(ent.nextLine());
            for(int i=0;i<N;i++){
                
                uniforme=ent.nextLine();
                uniformeA[i]=readInts(uniforme,2)[0];
                uniformeB[i]=readInts(uniforme,2)[1];
            }
            for(int i=0; i<N; i++){
                for(int k=0; k<N; k++){
                    if(!(i==k)){
                        if(uniformeA[i]==uniformeB[k]){
                            suma=suma+1;
                        }
                    }
                }
            }
            System.out.println("Case #"+t+":");
            System.out.println(suma);
            t++;
            suma=0;
        }while(t<=T);
    }
    public static int[] readInts(String s, int n){
        String split[]=s.split(" ");
        int arr[]= new int[n];
        for(int i=0; i< arr.length;i++){
            arr[i]=Integer.parseInt(split[i]);
        }
        return arr;
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemac;

import java.util.Scanner;

/**
 *
 */
public class ProblemaC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args){

       int t;
        Scanner str= new Scanner(System.in);
        Scanner ent= new Scanner(System.in);
        t=ent.nextInt();
        int T=1;
        int N;
        String cadena;
        String pre;
        char[] colores = new char[100];
        do{
            N=ent.nextInt();
            cadena= str.nextLine();
            System.out.println("Case "+T+":");
            int k=1;
            for(int i=0; i<=((N*2)-2);i=i+2){
                    colores[k]=cadena.charAt(i);
                    k++;               
            }
            switch(N){
                case 1: 
                    System.out.println(colores[1]);
                    break;
                case 2:
                    if(!(colores[1]==colores[2])){
                        System.out.println(colores[1]+" "+colores[2]);
                        System.out.println(colores[2]+" "+colores[1]);
                    }else{
                        System.out.println(colores[1]+" "+colores[2]);
                    }
                    break;
                case 3:
                    for(int a=1;a<=3;a++){
                        for(int b=1;b<=3;b++){
                            for(int c=1;c<=3;c++){   
                                if(!(a==b) && !(a==c) && !(b==c)){
                                    pre=colores[a]+" "+colores[b]+" "+colores[c];
                                    System.out.println();
                                }
                            }
                        }  
                    }
                    break;
                case 4:
                    for(int a=1;a<=4;a++){
                        for(int b=1;b<=4;b++){
                            for(int c=1;c<=4;c++){  
                                for(int d=1;d<=4;d++){
                                    if(!(a==b) && !(a==c) && !(a==d) && !(b==c) && !(b==d) && !(c==d)){
                                        System.out.println(colores[a]+" "+colores[b]+" "+colores[c]+" "+colores[d]);
                                    }
                                }
                            }
                        }  
                    }
                    break;
                case 5:
                    for(int a=1;a<=5;a++){
                        for(int b=1;b<=5;b++){
                            for(int c=1;c<=5;c++){  
                                for(int d=1;d<=5;d++){
                                    for(int e=1;e<=5;e++){
                                        if(!(a==b) && !(a==c) && !(a==d) && !(a==e) && !(b==c) && !(b==d) && !(b==e) && !(c==d) && !(c==e) && !(d==e)){
                                            System.out.println(colores[a]+" "+colores[b]+" "+colores[c]+" "+colores[d]+" "+colores[e]);
                                        }
                                    }
                                }
                            }
                        }  
                    }
                    break;
                case 6:
                    for(int a=1;a<=6;a++){
                        for(int b=1;b<=6;b++){
                            for(int c=1;c<=6;c++){  
                                for(int d=1;d<=6;d++){
                                    for(int e=1;e<=6;e++){
                                        for(int f=1;f<=6;f++){
                                            if(!(a==b) && !(a==c) && !(a==d) && !(a==e) && !(a==f) && !(b==c) && !(b==d) && !(b==e) && !(b==f) && !(c==d) && !(c==e) && !(c==f) && !(d==e) && !(d==f) && !(e==f)){
                                                System.out.println(colores[a]+" "+colores[b]+" "+colores[c]+" "+colores[d]+" "+colores[e]+ " "+colores[f]);
                                            }
                                        }
                                    }
                                }
                            }
                        }  
                    }
                    break;
            }
            T++;
            N=0;
        }while(T<=t);
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problema6c;

import java.io.File;
import java.io.FileNotFoundException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

/**
 *
 */
public class Problema6C {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, Exception {
         Scanner scan;
        File f = new File( "C_2.txt" );
        Map<Integer, Integer> mapa;
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            mapa = new HashMap<>();
            int[] nombres = readInts(scan.nextLine());
            int[] N = readInts(scan.nextLine());
            int[] M = readInts(scan.nextLine());
            int[] P = readInts(scan.nextLine());          
            for (int i = 0; i < N.length; i++) {
                if(mapa.containsKey(N[i]))
                    mapa.put(N[i], 4);
                else
                    mapa.put(N[i], 1);
            }
            for (int i = 0; i < M.length; i++) {
                if(mapa.containsKey(M[i]))
                    mapa.put(M[i], 4);
                else
                    mapa.put(M[i], 2);
            }
            for (int i = 0; i < P.length; i++) {
                if(mapa.containsKey(P[i]))
                    mapa.put(P[i], 4);
                else
                    mapa.put(P[i], 3);
            }
            Object[] s= mapa.keySet().toArray();
            TreeSet Nn = new TreeSet();
            TreeSet Mm = new TreeSet();
            TreeSet Pp = new TreeSet();
            for (int i = 0; i < s.length; i++) {
                if(Integer.parseInt(mapa.get(s[i]).toString()) == 1)
                    Nn.add(s[i]);
                if(Integer.parseInt(mapa.get(s[i]).toString()) == 2)
                    Mm.add(s[i]);
                if(Integer.parseInt(mapa.get(s[i]).toString()) == 3)
                    Pp.add(s[i]);            
            }
            System.out.println("Case #" + test + ":"); 
            if(Nn.size() > Mm.size() && Nn.size() > Pp.size()){
                String aux = Nn.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Norma " + Nn.size() +" " + aux);
            }
            if(Mm.size() > Nn.size() && Mm.size() > Pp.size()){
                String aux = Mm.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Mario " + Mm.size() +" " + aux);
            }
            if(Pp.size() > Mm.size() && Pp.size() > Nn.size()){
                String aux = Pp.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Pipe " + Pp.size() +" " + aux);
            }
            if(Pp.size() == Mm.size() && Pp.size() == Nn.size()){
                String aux = Nn.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Norma " + Nn.size() +" " + aux);
                aux = Mm.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Mario " + Mm.size() +" " + aux);
                aux = Pp.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Pipe " + Pp.size() +" " + aux); 
            }
            if(Nn.size() == Mm.size() && Nn.size() > Pp.size()){
                String aux = Nn.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Norma " + Nn.size() +" " + aux);
                aux = Mm.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Mario " + Mm.size() +" " + aux);
            }
            if(Nn.size() == Pp.size() && Nn.size() > Mm.size()){
                String aux = Nn.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Norma " + Nn.size() +" " + aux);
                aux = Pp.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Pipe " + Pp.size() +" " + aux); 
            }   
            if(Mm.size() == Pp.size() && Mm.size() > Nn.size()){
                String aux = Mm.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Mario " + Mm.size() +" " + aux);
                aux = Pp.toString();
                aux = aux.replace(",", "");
                aux = aux.replace("[", "");
                aux= aux.replace("]", "");
                System.out.println("Pipe " + Pp.size() +" " + aux);  
            }
        }
    }
    public static int[] readInts(String cad){
        String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problema6d;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

/**
 *
 */
public class Problema6D {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, Exception {
        Scanner scan;
        Map<String, String> mapa;
        Map<String, Integer> mapa2;
        BinaryHeap <resultado>resultados;
        File f = new File( "D_2.txt" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int n = Integer.parseInt( scan.nextLine() );
            mapa = new HashMap<>();
            mapa2 = new HashMap<>();
            resultados = new BinaryHeap<resultado>();
            for (int i = 0; i < n; i++) {
                String[] aux = scan.nextLine().split(" ");
                mapa.put(aux[0], aux[1]);
            }
            int q = Integer.parseInt( scan.nextLine() );
            for (int i = 0; i < q; i++) {
                String mam = scan.nextLine();
                if(mapa2.containsKey(mapa.get(mam))){
                    int s = mapa2.get(mapa.get(mam));
                    s++;
                    mapa2.put(mapa.get(mam), s);
                }else{
                    mapa2.put(mapa.get(mam), 1);
                }              
            }
            Object[] ss = mapa2.values().toArray();
            Object[] sss = mapa2.keySet().toArray();
            for (int i = 0; i < mapa2.size(); i++) {
                resultados.insert(new resultado(-Integer.parseInt(ss[i].toString()),sss[i].toString()));
            }
            System.out.println("Case #" + test + ":"); 
            System.out.println(resultados.findMin().toString());
            int s = -resultados.findMin().getVotos();
            resultados.deleteMin();
            while(!resultados.isEmpty() && s == -resultados.findMin().getVotos()){
                System.out.println(resultados.findMin().toString());
                resultados.deleteMin();
            }
        }
    }
    public static class resultado implements Comparable<resultado>{
        int votos;
        String partido;

        public int getVotos() {
            return votos;
        }

        

        public resultado(int votos, String partido) {
            this.votos = votos;
            this.partido = partido;
        }

        @Override
	public int compareTo(resultado x) {
            if (votos < x.votos){
        	return -1;
            }
            if(votos == x.votos){
                if(partido.hashCode() > x.partido.hashCode()){
                    return -1;
                }
                return 0;
            }
            return 0;             
	}

        @Override
        public String toString() {
            return partido;
        }
        
    }
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problema6d;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

/**
 *
 */
public class Problema6D {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, Exception {
        Scanner scan;
        Map<String, String> mapa;
        Map<String, Integer> mapa2;
        BinaryHeap <resultado>resultados;
        File f = new File( "D_2.txt" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int n = Integer.parseInt( scan.nextLine() );
            mapa = new HashMap<>();
            mapa2 = new HashMap<>();
            resultados = new BinaryHeap<resultado>();
            for (int i = 0; i < n; i++) {
                String[] aux = scan.nextLine().split(" ");
                mapa.put(aux[0], aux[1]);
            }
            int q = Integer.parseInt( scan.nextLine() );
            for (int i = 0; i < q; i++) {
                String mam = scan.nextLine();
                if(mapa2.containsKey(mapa.get(mam))){
                    int s = mapa2.get(mapa.get(mam));
                    s++;
                    mapa2.put(mapa.get(mam), s);
                }else{
                    mapa2.put(mapa.get(mam), 1);
                }              
            }
            Object[] ss = mapa2.values().toArray();
            Object[] sss = mapa2.keySet().toArray();
            for (int i = 0; i < mapa2.size(); i++) {
                resultados.insert(new resultado(-Integer.parseInt(ss[i].toString()),sss[i].toString()));
            }
            System.out.println("Case #" + test + ":"); 
            System.out.println(resultados.findMin().toString());
            int s = -resultados.findMin().getVotos();
            resultados.deleteMin();
            while(!resultados.isEmpty() && s == -resultados.findMin().getVotos()){
                System.out.println(resultados.findMin().toString());
                resultados.deleteMin();
            }
        }
    }
    public static class resultado implements Comparable<resultado>{
        int votos;
        String partido;

        public int getVotos() {
            return votos;
        }

        

        public resultado(int votos, String partido) {
            this.votos = votos;
            this.partido = partido;
        }

        @Override
	public int compareTo(resultado x) {
            if (votos < x.votos){
        	return -1;
            }
            if(votos == x.votos){
                if(partido.hashCode() < x.partido.hashCode()){
                    return -1;
                }
                return 0;
            }
            return 0;             
	}

        @Override
        public String toString() {
            return partido;
        }
        
    }
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problema6d;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

/**
 *
 */
public class Problema6D {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, Exception {
        Scanner scan;
        Map<String, String> mapa;
        Map<String, Integer> mapa2;
        BinaryHeap <resultado>resultados;
        File f = new File( "D_1.txt" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int n = Integer.parseInt( scan.nextLine() );
            mapa = new HashMap<>();
            mapa2 = new HashMap<>();
            resultados = new BinaryHeap<resultado>();
            for (int i = 0; i < n; i++) {
                String[] aux = scan.nextLine().split(" ");
                mapa.put(aux[0], aux[1]);
            }
            int q = Integer.parseInt( scan.nextLine() );
            for (int i = 0; i < q; i++) {
                String mam = scan.nextLine();
                if(mapa2.containsKey(mapa.get(mam))){
                    int s = mapa2.get(mapa.get(mam));
                    s++;
                    mapa2.put(mapa.get(mam), s);
                }else{
                    mapa2.put(mapa.get(mam), 1);
                }              
            }
            Object[] ss = mapa2.values().toArray();
            Object[] sss = mapa2.keySet().toArray();
            for (int i = 0; i < mapa2.size(); i++) {
                resultados.insert(new resultado(-Integer.parseInt(ss[i].toString()),sss[i].toString()));
            }
            System.out.println("Case #" + test + ":"); 
            System.out.println(resultados.findMin().toString());
            int s = -resultados.findMin().getVotos();
            resultados.deleteMin();
            while(!resultados.isEmpty() && s == -resultados.findMin().getVotos()){
                System.out.println(resultados.findMin().toString());
                resultados.deleteMin();
            }
        }
    }
    public static class resultado implements Comparable<resultado>{
        int votos;
        String partido;

        public int getVotos() {
            return votos;
        }

        

        public resultado(int votos, String partido) {
            this.votos = votos;
            this.partido = partido;
        }

        @Override
	public int compareTo(resultado x) {
            if (votos < x.votos){
        	return -1;
            }
            if(votos == x.votos){
                if(partido.compareTo(x.partido) < 0){
                    return -1;
                }
                return 0;
            }
            return 0;             
	}

        @Override
        public String toString() {
            return partido;
        }
        
    }
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problema6a;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

/**
 *
 */
public class Problema6A {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, Exception {
        Scanner scan;
        SeparateChainingHashTable funcion = new SeparateChainingHashTable();
        BinaryHeap resul;
        File f = new File( "A_2.txt" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int[] aux = readInts(scan.nextLine());
            int[] num = readInts(scan.nextLine());
            int[] fun = readInts(scan.nextLine());
            resul = new BinaryHeap();
            for (int i = 0; i < aux[1]; i++) {
                funcion = new SeparateChainingHashTable();
                for (int j = 0; j < aux[0]; j++) {
                    funcion.insert(num[j], fun[i]);
                }
                resul.insert(new resultado(fun[i], funcion.colision()));
            }
            System.out.println("Case #" + test + ":");         
            System.out.println(resul.findMin());
            for (int i = funcion.lista().size()-1; i >= 0; i--) {
                LinkedList<Integer> list = (LinkedList<Integer>) funcion.lista().get(i);
                for( int j = 0; j < list.size(); j++ ){
                    if( j>0)
                        System.out.print(" ");
                    System.out.print(list.get(j));
                }
                System.out.println("");
            }
        }
    }
    public static class resultado implements Comparable<resultado> {
        int funcion;
        int colision;
        public resultado(int funcion, int colision) {
            this.funcion = funcion;
            this.colision = colision;
        } 
        @Override
	public int compareTo(resultado x) {
		if (colision < x.colision)
			return -1;
                return 0;
	}

        @Override
        public String toString() {
            return funcion +"\n"+ colision ; //To change body of generated methods, choose Tools | Templates.
        }
        
        
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class SeparateChainingHashTable<AnyType>{
    /**
     * Construct the hash table.
     */
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {
        theLists = new LinkedList[ nextPrime( size ) ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x, int k )
    {
        List<AnyType> whichList = theLists[ myhash( x, k ) ];
        if( !whichList.contains( x ) )
        {
            whichList.add( x );

                // Rehash; see Section 5.5
            if( ++currentSize > theLists.length )
                rehash( k);
        }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x, int k )
    {
        List<AnyType> whichList = theLists[ myhash( x , k) ];
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
    }



    private void rehash(int k )
    {
        List<AnyType> [ ]  oldLists = theLists;

            // Create new double-sized, empty table
        theLists = new List[ nextPrime( 2 * theLists.length ) ];
        for( int j = 0; j < theLists.length; j++ )
            theLists[ j ] = new LinkedList<>( );

            // Copy table over
        currentSize = 0;
        for( List<AnyType> list : oldLists )
            for( AnyType item : list )
                insert( item, k );
    }

    private int myhash( AnyType x, int k )
    {
        int hashVal = x.hashCode( );
        return hashVal % k;
    }
    public int colision(){
        int m = 0;
        for (int i = 0; i < theLists.length; i++) {
            if(theLists[i] != null && theLists[i].size() > 1){
                m = m + (theLists[i].size() - 1);
            }
        }
        return m;
    }
    public MyArrayList lista(){
        MyArrayList lista = new MyArrayList();
        for (int i = 0; i < theLists.length; i++) {
            if(theLists[i] != null && theLists[i].size() > 1){
                lista.add(theLists[i]);
            }
        }
        return lista;
    }
    private static final int DEFAULT_TABLE_SIZE = 101;

        /** The array of Lists. */
    private List<AnyType> [ ] theLists; 
    private int currentSize;

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }
    }
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }
}
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problema6b;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;

/**
 *
 */
public class Problema6B {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException {
        Scanner scan;
        Map<Integer, Integer> mapa;
        File f = new File( "B_2.txt" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            mapa = new HashMap<>();
            int m = 1;
            int n = Integer.parseInt( scan.nextLine() );
            for (int i = 0; i < n; i++) {
                int[] aux = readInts(scan.nextLine());
                if(aux[0] != aux[1]){
                    if(mapa.isEmpty()){
                        mapa.put(aux[0], aux[1]);
                    }else{
                        if(mapa.containsKey(aux[1])){
                            int s = mapa.get(aux[1]);
                            mapa.put(s, 0);
                            mapa.put(-1, aux[1]);
                        }else{
                            mapa.put(aux[0], aux[1]);
                        }
                    }
                }
            }
            System.out.println("Case #" + test + ":"); 
            System.out.println(mapa.values().size());

        }
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package p2;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

// SeparateChaining Hash table class
//
// CONSTRUCTION: an approximate initial size or default of 101
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// void makeEmpty( )      --> Remove all items

/**
 * Separate chaining table implementation of hash tables. Note that all
 * "matching" is based on the equals method.
 * 
 * @param <AnyType>
 */
class SeparateChainingHashTable<AnyType> {
	/**
	 * Construct the hash table.
	 */
	public SeparateChainingHashTable() {
		this(DEFAULT_TABLE_SIZE);
	}

	/**
	 * Construct the hash table.
	 * 
	 * @param size
	 *            approximate table size.
	 */
	public SeparateChainingHashTable(int size) {
		theLists = new LinkedList[nextPrime(size)];
		for (int i = 0; i < theLists.length; i++)
			theLists[i] = new LinkedList<>();
	}

	/**
	 * Insert into the hash table. If the item is already present, then do
	 * nothing.
	 * 
	 * @param x
	 *            the item to insert.
	 */
	public void insert(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		//if (!whichList.contains(x)) {
			whichList.add(x);

			// Rehash; see Section 5.5
			if (++currentSize > theLists.length)
				rehash();
		}
	//}

	/**
	 * Remove from the hash table.
	 * 
	 * @param x
	 *            the item to remove.
	 */
	public void remove(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		if (whichList.contains(x)) {
			whichList.remove(x);
			currentSize--;
		}
	}

	/**
	 * Find an item in the hash table.
	 * 
	 * @param x
	 *            the item to search for.
	 * @return true if x is found.
	 */
	public boolean contains(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		return whichList.contains(x);
	}

	/**
	 * Make the hash table logically empty.
	 */
	public void makeEmpty() {
		for (int i = 0; i < theLists.length; i++)
			theLists[i].clear();
		currentSize = 0;
	}

	/**
	 * A hash routine for String objects.
	 * 
	 * @param key
	 *            the String to hash.
	 * @param tableSize
	 *            the size of the hash table.
	 * @return the hash value.
	 */
	public static int hash(String key, int tableSize) {
		int hashVal = 0;

		for (int i = 0; i < key.length(); i++)
			hashVal = 37 * hashVal + key.charAt(i);

		hashVal %= tableSize;
		if (hashVal < 0)
			hashVal += tableSize;

		return hashVal;
	}

	private void rehash() {
		List<AnyType>[] oldLists = theLists;

		// Create new double-sized, empty table
		theLists = new List[nextPrime(2 * theLists.length)];
		for (int j = 0; j < theLists.length; j++)
			theLists[j] = new LinkedList<>();

		// Copy table over
		currentSize = 0;
		for (List<AnyType> list : oldLists)
			for (AnyType item : list)
				insert(item);
	}

	private int myhash(AnyType x) {
		int hashVal = x.hashCode();

		hashVal %= theLists.length;
		if (hashVal < 0)
			hashVal += theLists.length;

		return hashVal;
	}

	private static final int DEFAULT_TABLE_SIZE = 101;

	/** The array of Lists. */
	private List<AnyType>[] theLists;
	private int currentSize;

	/**
	 * Internal method to find a prime number at least as large as n.
	 * 
	 * @param n
	 *            the starting number (must be positive).
	 * @return a prime number larger than or equal to n.
	 */
	@SuppressWarnings("empty-statement")
	private static int nextPrime(int n) {
		if (n % 2 == 0)
			n++;

		for (; !isPrime(n); n += 2)
			;

		return n;
	}

	/**
	 * Internal method to test if a number is prime. Not an efficient algorithm.
	 * 
	 * @param n
	 *            the number to test.
	 * @return the result of the test.
	 */
	private static boolean isPrime(int n) {
		if (n == 2 || n == 3)
			return true;

		if (n == 1 || n % 2 == 0)
			return false;

		for (int i = 3; i * i <= n; i += 2)
			if (n % i == 0)
				return false;

		return true;
	}

	// Simple main

}

public class EjercicioB {
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("B_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < cases; test++) {
			System.out.println("Case #"+(test+1)+":");
			int estanques= scan.nextInt();
			int llevar=0;
			SeparateChainingHashTable<Integer> pokemon= new SeparateChainingHashTable<Integer>();
			for(int i=0; i<estanques; i++ ){
				int food=scan.nextInt();
				int poke=scan.nextInt();
				
				pokemon.insert(food);
				
				if(!pokemon.contains(poke)){
					llevar++;
				}else{
					pokemon.remove(poke);
				}
			}
			
			System.out.println(llevar);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyecto7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashSet;
import java.util.Scanner;

public class Problema7A {

    /**
     * @param args the command line arguments
     */
    public static MyArrayList<MyArrayList> grafo;
    public static int m;
    public static HashSet conteo = new HashSet();
    public static void main(String[] args) throws FileNotFoundException {
        Scanner scan;
        MyArrayList lista, lista2;
        File f = new File( "P7A_15_2_1.in" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            conteo = new HashSet();
            int[] aux = readInts(scan.nextLine());
            grafo = new MyArrayList<>();
            for (int i = 0; i < aux[0]; i++) {
                grafo.add(i, new MyArrayList<>());                
            }
            for (int i = 0; i < aux[1]; i++) {
                int[] aux2 = readInts(scan.nextLine());
                lista = new MyArrayList();
                lista = grafo.get(aux2[0]);
                lista.add(aux2[1]);
                grafo.set(aux2[0], lista);
                lista = new MyArrayList();
                lista = grafo.get(aux2[1]);
                lista.add(aux2[0]);
                grafo.set(aux2[1], lista);
            }
            System.out.println("Case #" + test + ":");  
            m = Integer.parseInt( scan.nextLine() );
            contar(m);
            System.out.println(conteo.size());
        }
    }
    public static void contar(int n){
        for (int i = 0; i < grafo.get(n).size(); i++) {
            if(m != (int) grafo.get(n).get(i) && !conteo.contains((int) grafo.get(n).get(i))){
                conteo.add((int) grafo.get(n).get(i));
                contar((int) grafo.get(n).get(i));
            }
        }
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class MyLinkedList<AnyType> implements Iterable<AnyType>{
        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList( )
        {
            doClear( );
        }

        private void clear( )
        {
            doClear( );
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear( )
        {
            beginMarker = new Node<>( null, null, null );
            endMarker = new Node<>( null, beginMarker, null );
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         * @return the number of items in this collection.
         */
        public int size( )
        {
            return theSize;
        }

        public boolean isEmpty( )
        {
            return size( ) == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         * @param x any object.
         * @return true.
         */
        public boolean add( AnyType x )
        {

            add( size( ), x );   
            return true;         
        }

        /**
         * Adds an item to this collection, at specified position.
         * Items at or after that position are slid one position higher.
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
         */
        public void add( int idx, AnyType x )
        {
            addBefore( getNode( idx, 0, size( ) ), x );
        }

        /**
         * Adds an item to this collection, at specified position p.
         * Items at or after that position are slid one position higher.
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
         */    
        private void addBefore( Node<AnyType> p, AnyType x )
        {
            Node<AnyType> newNode = new Node<>( x, p.prev, p );
            newNode.prev.next = newNode;
            p.prev = newNode;         
            theSize++;
            modCount++;
        }   


        /**
         * Returns the item at position idx.
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get( int idx )
        {
            return getNode( idx ).data;
        }

        /**
         * Changes the item at position idx.
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set( int idx, AnyType newVal )
        {
            Node<AnyType> p = getNode( idx );
            AnyType oldVal = p.data;

            p.data = newVal;   
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) - 1.
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
         */
        private Node<AnyType> getNode( int idx )
        {
            return getNode( idx, 0, size( ) - 1 );
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
         */    
        private Node<AnyType> getNode( int idx, int lower, int upper )
        {
            Node<AnyType> p;  
            if( idx < lower || idx > upper )
                throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
            if( idx < size( ) / 2 ){
                p = beginMarker.next;
                for( int i = 0; i < idx; i++ )
                    p = p.next;            
            }
            else{
                p = endMarker;
                for( int i = size( ); i > idx; i-- )
                    p = p.prev;
            }         
            return p;
        }

        /**
         * Removes an item from this collection.
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove( int idx )
        {
            return remove( getNode( idx ) );
        }

        /**
         * Removes the object contained in Node p.
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove( Node<AnyType> p )
        {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString( )
        {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator( )
        {
            return new LinkedListIterator( );
        }

        /**
         * This is the implementation of the LinkedListIterator.
         * It maintains a notion of a current position and of
         * course the implicit reference to the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType>
        {
            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext( )
            {
                return current != endMarker;
            }

            public AnyType next( )
            {
                if( modCount != expectedModCount )
                    throw new java.util.ConcurrentModificationException( );
                if( !hasNext( ) )
                    throw new java.util.NoSuchElementException( ); 

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove( )
            {
                if( modCount != expectedModCount )
                    throw new java.util.ConcurrentModificationException( );
                if( !okToRemove )
                    throw new IllegalStateException( );

                MyLinkedList.this.remove( current.prev );
                expectedModCount++;
                okToRemove = false;       
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType>
        {
            public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
            {
                data = d; prev = p; next = n;
            }

            public AnyType data;
            public Node<AnyType>   prev;
            public Node<AnyType>   next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyecto7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema7B {

    /**
     * @param args the command line arguments
     */
    public static MyArrayList<Nodo> grafo;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner scan;         
        MyArrayList lista;
        File f = new File( "P7B_15_2_2.in" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int[] aux = readInts(scan.nextLine());
            grafo = new MyArrayList<>();
            for (int i = 0; i < aux[0]; i++) {
                grafo.add(i, new Nodo(false, -1 , new MyArrayList()));                
            }
            for (int i = 0; i < aux[1]; i++) {
                int[] aux2 = readInts(scan.nextLine());
                lista = new MyArrayList();
                lista = grafo.get(aux2[0]).vertices;
                lista.add(aux2[1]);
                grafo.set(aux2[0], new Nodo(false, -1, lista));
            }
            System.out.println("Case #" + test + ":");
            Colas cola = new Colas();
            int[] p = entrada();
            int w = 0;
            int l = 0;
            for (int j = p.length-1; j >= 0 ; j--) {
                if(p[j] == 0){
                    w = j;
                    l++;
                }
            }
                grafo.get(w).distancia = 0;
                grafo.get(w).estado = true;
                cola.encolar(grafo.get(w));
                while(!cola.isEmpty()){
                    Nodo vertice = (Nodo) cola.peak();
                    cola.desencolar();
                    for (int i = 0; i < vertice.vertices.size(); i++) {
                        //if(!grafo.get((int) vertice.vertices.get(i)).estado){
                            grafo.get((int) vertice.vertices.get(i)).distancia =vertice.distancia +1;
                            //grafo.get((int) vertice.vertices.get(i)).estado = true;
                            cola.encolar(grafo.get((int) vertice.vertices.get(i)));
                        //}
                    }              
                }
                boolean ww = false;
                for (int i = 0; i < grafo.size(); i++) {
                    if(grafo.get(i).distancia >= (grafo.size()-1))
                        ww = true;
                }
                if(ww)
                   System.out.println("Deberia empezar a estudiar");
                else
        }
    }
    public static class Nodo{
        boolean estado;
        int distancia;
        MyArrayList vertices;
        public Nodo(boolean estado, int distancia, MyArrayList vertices) {
            this.estado = estado;
            this.distancia = distancia;
            this.vertices = vertices;
        }
        
    }
    public static int[] entrada(){
        int[] s = new int[grafo.size()];
        for (int i = 0; i < grafo.size(); i++) {
            for (int j = 0; j < grafo.get(i).vertices.size(); j++)
                s[(int) grafo.get(i).vertices.get(j)]++;           
        }
        return s;
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class Colas<AnyType>{

    /**
     * @param args the command line arguments
     */
    
    /**
     * Construct an empty ArrayList.
     */
    public Colas( )
    {
        theSize = 0;
        back = 0;
        front = 0;
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ){
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( ){
        return size( ) == 0;
    }
    


    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ ){
            theItems[ i ] = old[ front ];
            front = (front+1)%old.length;
        }
        front = 0;
        back = size()-1;
            
    }
    
    //metodo que permite    encolar
    public void encolar(AnyType x){
        if( theItems.length == size( ) ){
            ensureCapacity( size( ) * 2 + 1 );
        }
        theSize++;
        back++;
        if(back>=theItems.length){
            back=0;
        }
        theItems [back]=x;
         
    }
    //metodo que permite    desencolar
    public AnyType desencolar(){
        theSize--;
        AnyType x = theItems[front];
        front++;
        if(front==theItems.length){
            front=0;
        }
        return x;
    }
    public AnyType peak(){
        return theItems[front];
    }
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    private int back;
    private int front;
    
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyecto7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema7B {

    /**
     * @param args the command line arguments
     */
    public static MyArrayList<Nodo> grafo;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner scan;         
        MyLinkedList lista;
        File f = new File( "P7B_15_2_2.in" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int[] aux = readInts(scan.nextLine());
            grafo = new MyArrayList<>();
            for (int i = 0; i < aux[0]; i++) {
                grafo.add(i, new Nodo(false, -1 , new MyLinkedList()));                
            }
            for (int i = 0; i < aux[1]; i++) {
                int[] aux2 = readInts(scan.nextLine());
                lista = new MyLinkedList();
                lista = grafo.get(aux2[0]).vertices;
                lista.add(aux2[1]);
                grafo.set(aux2[0], new Nodo(false, -1, lista));
            }
            System.out.println("Case #" + test + ":");
            Colas cola = new Colas();
            int[] p = entrada();
            int w = 0;
            int l = 0;
            for (int j = p.length-1; j >= 0 ; j--) {
                if(p[j] == 0){
                    w = j;
                    l++;
                }
            }
                grafo.get(w).distancia = 0;
                grafo.get(w).estado = true;
                cola.encolar(grafo.get(w));
                while(!cola.isEmpty()){
                    Nodo vertice = (Nodo) cola.peak();
                    cola.desencolar();
                    for (int i = 0; i < vertice.vertices.size(); i++) {
                            grafo.get((int) vertice.vertices.get(i)).distancia =vertice.distancia +1;
                            cola.encolar(grafo.get((int) vertice.vertices.get(i)));
                    }              
                }
                boolean ww = false;
                for (int i = 0; i < grafo.size(); i++) {
                    if(grafo.get(i).distancia >= (grafo.size()-1))
                        ww = true;
                }
                if(ww)
                   System.out.println("Deberia empezar a estudiar");
                else
        }
    }
    public static class Nodo{
        boolean estado;
        int distancia;
        MyLinkedList vertices;
        public Nodo(boolean estado, int distancia, MyLinkedList vertices) {
            this.estado = estado;
            this.distancia = distancia;
            this.vertices = vertices;
        }
        
    }
    public static int[] entrada(){
        int[] s = new int[grafo.size()];
        for (int i = 0; i < grafo.size(); i++) {
            for (int j = 0; j < grafo.get(i).vertices.size(); j++)
                s[(int) grafo.get(i).vertices.get(j)]++;           
        }
        return s;
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class Colas<AnyType>{

    /**
     * @param args the command line arguments
     */
    
    /**
     * Construct an empty ArrayList.
     */
    public Colas( )
    {
        theSize = 0;
        back = 0;
        front = 0;
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ){
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( ){
        return size( ) == 0;
    }
    


    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ ){
            theItems[ i ] = old[ front ];
            front = (front+1)%old.length;
        }
        front = 0;
        back = size()-1;
            
    }
    
    //metodo que permite    encolar
    public void encolar(AnyType x){
        if( theItems.length == size( ) ){
            ensureCapacity( size( ) * 2 + 1 );
        }
        theSize++;
        back++;
        if(back>=theItems.length){
            back=0;
        }
        theItems [back]=x;
         
    }
    //metodo que permite    desencolar
    public AnyType desencolar(){
        theSize--;
        AnyType x = theItems[front];
        front++;
        if(front==theItems.length){
            front=0;
        }
        return x;
    }
    public AnyType peak(){
        return theItems[front];
    }
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    private int back;
    private int front;
    
}
public static class MyLinkedList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyecto7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema7B {

    /**
     * @param args the command line arguments
     */
    public static MyArrayList<Nodo> grafo;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner scan;         
        MyLinkedList lista;
        File f = new File( "P7B_15_2_2.in" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int[] aux = readInts(scan.nextLine());
            grafo = new MyArrayList<>();
            for (int i = 0; i < aux[0]; i++) {
                grafo.add(i, new Nodo(false, -1 , new MyLinkedList()));                
            }
            for (int i = 0; i < aux[1]; i++) {
                int[] aux2 = readInts(scan.nextLine());
                lista = new MyLinkedList<Integer>();
                lista = grafo.get(aux2[0]).vertices;
                lista.add(aux2[1]);
                grafo.set(aux2[0], new Nodo(false, -1, lista));
            }
            System.out.println("Case #" + test + ":");
            Colas cola = new Colas();
            int[] p = entrada();
            int w = 0;
            int l = 0;
            for (int j = p.length-1; j >= 0 ; j--) {
                if(p[j] == 0){
                    w = j;
                    l++;
                }
            }
                grafo.get(w).distancia = 0;
                grafo.get(w).estado = true;
                cola.encolar(grafo.get(w));
                while(!cola.isEmpty()){
                    Nodo vertice = (Nodo) cola.peak();
                    cola.desencolar();
                    for (Integer i : vertice.vertices) {
                            grafo.get(i).distancia =vertice.distancia +1;
                            cola.encolar(grafo.get(i));
                    }              
                }
                boolean ww = false;
                for (int i = 0; i < grafo.size(); i++) {
                    if(grafo.get(i).distancia >= (grafo.size()-1))
                        ww = true;
                }
                if(ww)
                   System.out.println("Deberia empezar a estudiar");
                else
        }
    }
    public static class Nodo{
        boolean estado;
        int distancia;
        MyLinkedList<Integer> vertices;
        public Nodo(boolean estado, int distancia, MyLinkedList vertices) {
            this.estado = estado;
            this.distancia = distancia;
            this.vertices = vertices;
        }
        
    }
    public static int[] entrada(){
        int[] s = new int[grafo.size()];
        for (int i = 0; i < grafo.size(); i++) {
            for (int j = 0; j < grafo.get(i).vertices.size(); j++)
                s[(int) grafo.get(i).vertices.get(j)]++;           
        }
        return s;
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class Colas<AnyType>{

    /**
     * @param args the command line arguments
     */
    
    /**
     * Construct an empty ArrayList.
     */
    public Colas( )
    {
        theSize = 0;
        back = 0;
        front = 0;
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ){
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( ){
        return size( ) == 0;
    }
    


    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ ){
            theItems[ i ] = old[ front ];
            front = (front+1)%old.length;
        }
        front = 0;
        back = size()-1;
            
    }
    
    //metodo que permite    encolar
    public void encolar(AnyType x){
        if( theItems.length == size( ) ){
            ensureCapacity( size( ) * 2 + 1 );
        }
        theSize++;
        back++;
        if(back>=theItems.length){
            back=0;
        }
        theItems [back]=x;
         
    }
    //metodo que permite    desencolar
    public AnyType desencolar(){
        theSize--;
        AnyType x = theItems[front];
        front++;
        if(front==theItems.length){
            front=0;
        }
        return x;
    }
    public AnyType peak(){
        return theItems[front];
    }
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    private int back;
    private int front;
    
}
public static class MyLinkedList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyecto7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema7B {

    /**
     * @param args the command line arguments
     */
    public static MyArrayList<Nodo> grafo;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner scan;         
        MyLinkedList lista;
        File f = new File( "P7B_15_2_2.in" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int[] aux = readInts(scan.nextLine());
            grafo = new MyArrayList<>();
            for (int i = 0; i < aux[0]; i++) {
                grafo.add(i, new Nodo(false, -1 , new MyLinkedList()));                
            }
            for (int i = 0; i < aux[1]; i++) {
                int[] aux2 = readInts(scan.nextLine());
                lista = new MyLinkedList<Integer>();
                lista = grafo.get(aux2[0]).vertices;
                lista.add(aux2[1]);
                grafo.set(aux2[0], new Nodo(false, -1, lista));
            }
            System.out.println("Case #" + test + ":");
            Colas cola = new Colas();
            int[] p = entrada();
            int w = 0;
            int l = 0;
            for (int j = p.length-1; j >= 0 ; j--) {
                if(p[j] == 0){
                    w = j;
                    l++;
                }
            }
                grafo.get(w).distancia = 0;
                grafo.get(w).estado = true;
                cola.encolar(grafo.get(w));
                while(!cola.isEmpty()){
                    Nodo vertice = (Nodo) cola.peak();
                    cola.desencolar();
                    for (Integer i : vertice.vertices) {
                            grafo.get(i).distancia =vertice.distancia +1;
                            cola.encolar(grafo.get(i));
                    }              
                }
                boolean ww = false;
                for (int i = 0; i < grafo.size(); i++) {
                    if(grafo.get(i).distancia >= (grafo.size()-1))
                        ww = true;
                }
                if(ww)
                   System.out.println("Deberia empezar a estudiar");
                else
        }
    }
    public static class Nodo{
        boolean estado;
        int distancia;
        MyLinkedList<Integer> vertices;
        public Nodo(boolean estado, int distancia, MyLinkedList vertices) {
            this.estado = estado;
            this.distancia = distancia;
            this.vertices = vertices;
        }
        
    }
    public static int[] entrada(){
        int[] s = new int[grafo.size()];
        for (int i = 0; i < grafo.size(); i++) {
            for (int j = 0; j < grafo.get(i).vertices.size(); j++)
                s[(int) grafo.get(i).vertices.get(j)]++;           
        }
        return s;
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class Colas<AnyType>{

    /**
     * @param args the command line arguments
     */
    
    /**
     * Construct an empty ArrayList.
     */
    public Colas( )
    {
        theSize = 0;
        back = 0;
        front = 0;
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ){
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( ){
        return size( ) == 0;
    }
    


    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ ){
            theItems[ i ] = old[ front ];
            front = (front+1)%old.length;
        }
        front = 0;
        back = size()-1;
            
    }
    
    //metodo que permite    encolar
    public void encolar(AnyType x){
        if( theItems.length == size( ) ){
            ensureCapacity( size( ) * 2 + 1 );
        }
        theSize++;
        back++;
        if(back>=theItems.length){
            back=0;
        }
        theItems [back]=x;
         
    }
    //metodo que permite    desencolar
    public AnyType desencolar(){
        theSize--;
        AnyType x = theItems[front];
        front++;
        if(front==theItems.length){
            front=0;
        }
        return x;
    }
    public AnyType peak(){
        return theItems[front];
    }
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    private static final int DEFAULT_CAPACITY = 1000;
    
    private AnyType [ ] theItems;
    private int theSize;
    private int back;
    private int front;
    
}
public static class MyLinkedList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyecto7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema7B {

    /**
     * @param args the command line arguments
     */
    public static MyArrayList<Nodo> grafo;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner scan;         
        MyLinkedList lista;
        File f = new File( "P7B_15_2_2.in" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int[] aux = readInts(scan.nextLine());
            grafo = new MyArrayList<>();
            for (int i = 0; i < aux[0]; i++) {
                grafo.add(i, new Nodo(false, -1 , new MyLinkedList()));                
            }
            for (int i = 0; i < aux[1]; i++) {
                int[] aux2 = readInts(scan.nextLine());
                lista = new MyLinkedList<Integer>();
                lista = grafo.get(aux2[0]).vertices;
                lista.add(aux2[1]);
                grafo.set(aux2[0], new Nodo(false, -1, lista));
            }
            System.out.println("Case #" + test + ":");
            Colas cola = new Colas();
            int[] p = entrada();
            int w = 0;
            int l = 0;
            for (int j = p.length-1; j >= 0 ; j--) {
                if(p[j] == 0){
                    w = j;
                    l++;
                }
            }
                grafo.get(w).distancia = 0;
                grafo.get(w).estado = true;
                cola.encolar(grafo.get(w));
                while(!cola.isEmpty()){
                    Nodo vertice = (Nodo) cola.peak();
                    cola.desencolar();
                    for (Integer i : vertice.vertices) {
                            grafo.get(i).distancia =vertice.distancia +1;
                            cola.encolar(grafo.get(i));
                    }              
                }
                boolean ww = false;
                for (int i = 0; i < grafo.size(); i++) {
                    if(grafo.get(i).distancia >= (grafo.size()-1))
                        ww = true;
                }
                if(ww)
                   System.out.println("Deberia empezar a estudiar");
                else
        }
    }
    public static class Nodo{
        boolean estado;
        int distancia;
        MyLinkedList<Integer> vertices;
        public Nodo(boolean estado, int distancia, MyLinkedList vertices) {
            this.estado = estado;
            this.distancia = distancia;
            this.vertices = vertices;
        }
        
    }
    public static int[] entrada(){
        int[] s = new int[grafo.size()];
        for (int i = 0; i < grafo.size(); i++) {
            for (int j = 0; j < grafo.get(i).vertices.size(); j++)
                s[(int) grafo.get(i).vertices.get(j)]++;           
        }
        return s;
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class Colas<AnyType>{

    /**
     * @param args the command line arguments
     */
    
    /**
     * Construct an empty ArrayList.
     */
    public Colas( )
    {
        theSize = 0;
        back = 0;
        front = 0;
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ){
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( ){
        return size( ) == 0;
    }
    


    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ ){
            theItems[ i ] = old[ front ];
            front = (front+1)%old.length;
        }
        front = 0;
        back = size()-1;
            
    }
    
    //metodo que permite    encolar
    public void encolar(AnyType x){
        if( theItems.length == size( ) ){
            ensureCapacity( size( ) * 2 + 1 );
        }
        theSize++;
        back++;
        if(back>=theItems.length){
            back=0;
        }
        theItems [back]=x;
         
    }
    //metodo que permite    desencolar
    public AnyType desencolar(){
        theSize--;
        AnyType x = theItems[front];
        front++;
        if(front==theItems.length){
            front=0;
        }
        return x;
    }
    public AnyType peak(){
        return theItems[front];
    }
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    private static final int DEFAULT_CAPACITY = 100000;
    
    private AnyType [ ] theItems;
    private int theSize;
    private int back;
    private int front;
    
}
public static class MyLinkedList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyecto7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Problema7B {

    /**
     * @param args the command line arguments
     */
    public static MyArrayList<Nodo> grafo;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner scan;         
        MyLinkedList lista;
        File f = new File( "P7B_15_2_2.in" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        for ( int test = 1; test <= t; test++ ) {
            int[] aux = readInts(scan.nextLine());
            grafo = new MyArrayList<>();
            for (int i = 0; i < aux[0]; i++) {
                grafo.add(i, new Nodo(false, -1 , new MyLinkedList()));                
            }
            for (int i = 0; i < aux[1]; i++) {
                int[] aux2 = readInts(scan.nextLine());
                lista = new MyLinkedList<Integer>();
                lista = grafo.get(aux2[0]).vertices;
                lista.add(aux2[1]);
                grafo.set(aux2[0], new Nodo(false, -1, lista));
            }
            System.out.println("Case #" + test + ":");
            Colas cola = new Colas();
            int[] p = entrada();
            int w = 0;
            int l = 0;
            for (int j = p.length-1; j >= 0 ; j--) {
                if(p[j] == 0){
                    w = j;
                    l++;
                }
            }
                grafo.get(w).distancia = 0;
                grafo.get(w).estado = true;
                cola.encolar(grafo.get(w));
                while(!cola.isEmpty()){
                    Nodo vertice = (Nodo) cola.peak();
                    cola.desencolar();
                    for (Integer i : vertice.vertices) {
                            grafo.get(i).distancia =vertice.distancia +1;
                            cola.encolar(grafo.get(i));
                    }              
                }
                boolean ww = false;
                for (int i = 0; i < grafo.size(); i++) {
                    if(grafo.get(i).distancia >= (grafo.size()-1))
                        ww = true;
                }
                if(ww)
                   System.out.println("Deberia empezar a estudiar");
                else
        }
    }
    public static class Nodo{
        boolean estado;
        int distancia;
        MyLinkedList<Integer> vertices;
        public Nodo(boolean estado, int distancia, MyLinkedList vertices) {
            this.estado = estado;
            this.distancia = distancia;
            this.vertices = vertices;
        }
        
    }
    public static int[] entrada(){
        int[] s = new int[grafo.size()];
        for (int i = 0; i < grafo.size(); i++) {
            for (int j = 0; j < grafo.get(i).vertices.size(); j++)
                s[(int) grafo.get(i).vertices.get(j)]++;           
        }
        return s;
    }
    public static int[] readInts(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class Colas<AnyType>{

    /**
     * @param args the command line arguments
     */
    
    /**
     * Construct an empty ArrayList.
     */
    public Colas( )
    {
        theSize = 0;
        back = 0;
        front = 0;
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ){
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( ){
        return size( ) == 0;
    }
    


    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ ){
            theItems[ i ] = old[ front ];
            front = (front+1)%old.length;
        }
        front = 0;
        back = size()-1;
            
    }
    
    //metodo que permite    encolar
    public void encolar(AnyType x){
        if( theItems.length == size( ) ){
            ensureCapacity( size( ) * 2 + 1 );
        }
        theSize++;
        back++;
        if(back>=theItems.length){
            back=0;
        }
        theItems [back]=x;
         
    }
    //metodo que permite    desencolar
    public AnyType desencolar(){
        theSize--;
        AnyType x = theItems[front];
        front++;
        if(front==theItems.length){
            front=0;
        }
        return x;
    }
    public AnyType peak(){
        return theItems[front];
    }
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    private static final int DEFAULT_CAPACITY = 1000;
    
    private AnyType [ ] theItems;
    private int theSize;
    private int back;
    private int front;
    
}
public static class MyLinkedList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
