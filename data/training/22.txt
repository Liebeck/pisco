/**
 * 
 */
package primerTaller;

/**
 *
 *
 */
import java.util.ArrayList;
import java.util.Scanner;

import java.io.File;

import java.io.IOException;

import java.io.PrintStream;

public class problemaA {
		private static int contador1=0;
		private static int contador2=0;
		private static int contador3=0;
		private static int contadorA=0;
		private static int contadorB=0;
		private static int contadorTotal=0;
		private static int [] arrayRespuesta;
		@SuppressWarnings("resource")
		public static void main(String[] args) throws Exception {
			Scanner scan = null;
			File f = new File("C:/Users/andres/workspace/todoslosexerccios/src/entraCSD.txt");
			if (f.exists()) {
				scan = new Scanner(f);
							int n = scan.nextInt();
							arrayRespuesta= new int [n*3];
							for (int i = 0; i < n; i++) {
								int  k = scan.nextInt();
								
								ArrayList<Integer> datos = new ArrayList<Integer>();
								
								for (int j= 0; j < k; j++) {

									
								datos.add(scan.nextInt());	
								
								}
																CalculoOperadores(datos,n);
													}
							imprimir( n);
							imprimirArchivo(n);
			 
			} else{
					scan = new Scanner(System.in);
				
					int n = Integer.parseInt(scan.nextLine());
					arrayRespuesta= new int [n*3];
					int k = 0;
					for (int i = 0; i < n; i++) {
					 k = scan.nextInt();
					
					ArrayList<Integer> datos = new ArrayList<Integer>();
					
					for (int j= 0; j < k; j++) {

						
					datos.add(scan.nextInt());	
					
					}
					CalculoOperadores(datos,n);
					}
					imprimir( n);
					imprimirArchivo(n);
				}

		}
		
		public static  void CalculoOperadores(ArrayList<Integer> dato,int n ){
		 
			for (int x=0;x<dato.size();x++)			 {
				contadorA=(int) dato.get(x);
				for (int y=0;y<dato.size();y++) 	{
					contadorB=(int) dato.get(y);
					if(x!=y)					{
						if(contadorA==contadorB){
							contador3++;}
						if(contadorA>contadorB){
							contador1++;}
						if(contadorA<contadorB){
							contador2++;}		}	}
													}
			
			arrayRespuesta[contadorTotal]=contador1;
			;
			contadorTotal++;
			arrayRespuesta[contadorTotal]=contador2;
			
			contadorTotal++;
			arrayRespuesta[contadorTotal]=contador3;
			
			contadorTotal++;
			
			contador1=0;
			contador2=0;
			contador3=0;
			dato.clear();
			
			
		}

		public static void imprimir(int n) throws IOException{
			int k=0;
			for (int y=0;y<(n*3);y++) {
				if(y==(k*3)){
					System.out.println("Case #"+(k+1)+":");
					k++;
				}
				System.out.println(arrayRespuesta[y]);
			}
		}
		public static void imprimirArchivo(int n) throws IOException{
			int k=0;
			System.setOut(new PrintStream(new File("C:/Users/andres/workspace/todoslosexerccios/src/salida1.txt")));
			for (int y=0;y<(n*3);y++) {
				if(y==(k*3)){	
					System.out.println("Case #"+(k+1)+":");
					k++;
				}
				System.out.println(arrayRespuesta[y]);	
			}
		}
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package primerTaller;

import java.io.File;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 */
public class problemaB {
	@SuppressWarnings("unused")
	private static int contador1=0;
	private static int contador2=0;
	private static int contador3=0;
	
	private static int contadorTotal=0;
	private static int [] arrayRespuesta1;
	private static int [] arrayRespuesta2;
	private static int mat[][];
			public static void main(String[] args) throws Exception {
		
		Scanner scan = null;
		File f = new File("C:/Users/andres/workspace/todoslosexerccios/src/entrad.txt");
		ArrayList<Integer> datos = new ArrayList<Integer>();
		
		
		int n=0;
		if (f.exists()) {
			scan = new Scanner(f);
			while(scan.hasNext()){
				contador3++;
						 n = scan.nextInt();
						// System.out.println(+n);
						 mat=new int[n][n];
						//arrayRespuesta= new int [n*3];
						for (int i = 0; i < (n); i++) {

							
							for(int j = 0; j < (n); j++){
								
								
								datos.add(scan.nextInt());	
								mat[i][j]=datos.get(contadorTotal);
							
								
								contadorTotal++;
								
								
							}
	
						}
					contador1++;
			maximoValor(mat,n);
	 
			}
			
			scan.close();
		} else{scan = new Scanner(System.in);
boolean terminar=false;
while(terminar==false){
	contador3++;
	n = scan.nextInt();
		mat=new int[n][n]; 	
			for (int i = 0; i < (n); i++) { 
				for(int j = 0; j < (n); j++){
					
					
					datos.add(scan.nextInt());	
					mat[i][j]=datos.get(contadorTotal);

					contadorTotal++;
					
				}

				
			}
		contador1++;
		
				
			maximoValor(mat,n);
		
	 
}

		}
		}
			
			public static void maximoValor(int[][] mat, int n){ 
				 arrayRespuesta1= new int[n];
				 arrayRespuesta2= new int[n];
				int sumf=0;
				      for (int i = 0; i < mat.length; i++) {  
				        sumf=0;  
				        for (int j = 0; j < mat[i].length; j++) {  
				          sumf=sumf+mat[i][j];  
				        } 

				     arrayRespuesta1[i]=sumf;
				      }

				      int sumc=0;
				            for (int i = 0; i < mat[0].length; i++) {  
				              sumc=0;  
				              for (int j = 0; j < mat.length; j++) {  
				                sumc=sumc+mat[j][i];  
				              }  
				              
				              arrayRespuesta2[i]=sumc;

				          }
				            for (int i = 0; i < n; i++) {  
					              for (int j = 0; j < n;j++) {  
					            	  if(arrayRespuesta1[i]< arrayRespuesta2[j]){
					            		  contador2++;
					            		  
					            	  }
					              } }
				            
				            System.out.println("Case #"+contador3+":");
				            System.out.println(contador2);
				            contador2=0;
				            
			}




}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package primerTaller;

/**
 *
 *
 */
import java.util.ArrayList;
import java.util.Scanner;

import java.io.File;

import java.io.IOException;

import java.io.PrintStream;

public class problemaA {
		private static int contador1=0;
		private static int contador2=0;
		private static int contador3=0;
		private static int contadorA=0;
		private static int contadorB=0;
		private static int contadorTotal=0;
		private static int [] arrayRespuesta;
		@SuppressWarnings("resource")
		public static void main(String[] args) throws Exception {
			Scanner scan = null;
			File f = new File("entrada.in");
			if (f.exists()) {
				scan = new Scanner(f);
							int n = scan.nextInt();
							arrayRespuesta= new int [n*3];
							for (int i = 0; i < n; i++) {
								int  k = scan.nextInt();
								
								ArrayList<Integer> datos = new ArrayList<Integer>();
								
								for (int j= 0; j < k; j++) {

									
								datos.add(scan.nextInt());	
								
								}
																CalculoOperadores(datos,n);
													}
							imprimir( n);
							imprimirArchivo(n);
			 
			} else{
					scan = new Scanner(System.in);
				
					int n = Integer.parseInt(scan.nextLine());
					arrayRespuesta= new int [n*3];
					int k = 0;
					for (int i = 0; i < n; i++) {
					 k = scan.nextInt();
					
					ArrayList<Integer> datos = new ArrayList<Integer>();
					
					for (int j= 0; j < k; j++) {

						
					datos.add(scan.nextInt());	
					
					}
					CalculoOperadores(datos,n);
					}
					imprimir( n);
					imprimirArchivo(n);
				}

		}
		
		public static  void CalculoOperadores(ArrayList<Integer> dato,int n ){
		 
			for (int x=0;x<dato.size();x++)			 {
				contadorA=(int) dato.get(x);
				for (int y=0;y<dato.size();y++) 	{
					contadorB=(int) dato.get(y);
					if(x!=y)					{
						if(contadorA==contadorB){
							contador3++;}
						if(contadorA>contadorB){
							contador1++;}
						if(contadorA<contadorB){
							contador2++;}		}	}
													}
			
			arrayRespuesta[contadorTotal]=contador1;
			;
			contadorTotal++;
			arrayRespuesta[contadorTotal]=contador2;
			
			contadorTotal++;
			arrayRespuesta[contadorTotal]=contador3;
			
			contadorTotal++;
			
			contador1=0;
			contador2=0;
			contador3=0;
			dato.clear();
			
			
		}

		public static void imprimir(int n) throws IOException{
			int k=0;
			for (int y=0;y<(n*3);y++) {
				if(y==(k*3)){
					System.out.println("Case #"+(k+1)+":");
					k++;
				}
				System.out.println(arrayRespuesta[y]);
			}
		}
		public static void imprimirArchivo(int n) throws IOException{
			int k=0;
			System.setOut(new PrintStream(new File("salida.out")));
			for (int y=0;y<(n*3);y++) {
				if(y==(k*3)){	
					System.out.println("Case #"+(k+1)+":");
					k++;
				}
				System.out.println(arrayRespuesta[y]);	
			}
		}
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package primerTaller;

/**
 *
 *
 */
import java.util.ArrayList;
import java.util.Scanner;

import java.io.File;

import java.io.IOException;

import java.io.PrintStream;

public class problemaA {
		private static int contador1=0;
		private static int contador2=0;
		private static int contador3=0;
		private static int contadorA=0;
		private static int contadorB=0;
		private static int contadorTotal=0;
		private static int [] arrayRespuesta;
		@SuppressWarnings("resource")
		public static void main(String[] args) throws Exception {
			Scanner scan = null;
			File f = new File("entrada.in");
			if (f.exists()) {
				scan = new Scanner(f);
							int n = scan.nextInt();
							arrayRespuesta= new int [n*3];
							for (int i = 0; i < n; i++) {
								int  k = scan.nextInt();
								
								ArrayList<Integer> datos = new ArrayList<Integer>();
								
								for (int j= 0; j < k; j++) {

									
								datos.add(scan.nextInt());	
								
								}
																CalculoOperadores(datos,n);
													}
							imprimir( n);
							
			 
			} else{
					scan = new Scanner(System.in);
				
					int n = Integer.parseInt(scan.nextLine());
					arrayRespuesta= new int [n*3];
					int k = 0;
					for (int i = 0; i < n; i++) {
					 k = scan.nextInt();
					
					ArrayList<Integer> datos = new ArrayList<Integer>();
					
					for (int j= 0; j < k; j++) {

						
					datos.add(scan.nextInt());	
					
					}
					CalculoOperadores(datos,n);
					}
					imprimir( n);
				
				}

		}
		
		public static  void CalculoOperadores(ArrayList<Integer> dato,int n ){
		 
			for (int x=0;x<dato.size();x++)			 {
				contadorA=(int) dato.get(x);
				for (int y=0;y<dato.size();y++) 	{
					contadorB=(int) dato.get(y);
					if(x!=y)					{
						if(contadorA==contadorB){
							contador3++;}
						if(contadorA>contadorB){
							contador1++;}
						if(contadorA<contadorB){
							contador2++;}		}	}
													}
			
			arrayRespuesta[contadorTotal]=contador1;
			;
			contadorTotal++;
			arrayRespuesta[contadorTotal]=contador2;
			
			contadorTotal++;
			arrayRespuesta[contadorTotal]=contador3;
			
			contadorTotal++;
			
			contador1=0;
			contador2=0;
			contador3=0;
			dato.clear();
			
			
		}

		public static void imprimir(int n) throws IOException{
			int k=0;
			for (int y=0;y<(n*3);y++) {
				if(y==(k*3)){
					System.out.println("Case #"+(k+1)+":");
					k++;
				}
				System.out.println(arrayRespuesta[y]);
			}
		}
	
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package primerTaller;

import java.io.File;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 */
public class problemaB {
	@SuppressWarnings("unused")
	private static int contador1=0;
	private static int contador2=0;
	private static int contador3=0;
	
	private static int contadorTotal=0;
	private static int [] arrayRespuesta1;
	private static int [] arrayRespuesta2;
	private static int mat[][];
			public static void main(String[] args) throws Exception {
		
		Scanner scan = null;
		File f = new File("C:/Users/andres/workspace/todoslosexerccios/src/entrad.txt");
		ArrayList<Integer> datos = new ArrayList<Integer>();
		
		
		int n=0;
		if (f.exists()) {
			scan = new Scanner(f);
			while(scan.hasNext()){
				contador3++;
						 n = scan.nextInt();
						// System.out.println(+n);
						 mat=new int[n][n];
						//arrayRespuesta= new int [n*3];
						for (int i = 0; i < (n); i++) {

							
							for(int j = 0; j < (n); j++){
								
								
								datos.add(scan.nextInt());	
								mat[i][j]=datos.get(contadorTotal);
							
								
								contadorTotal++;
								
								
							}
	
						}
					contador1++;
			maximoValor(mat,n);
	 
			}
			
			scan.close();
		} else{scan = new Scanner(System.in);

while(scan.hasNext()){
	contador3++;
	n = scan.nextInt();
		mat=new int[n][n]; 	
			for (int i = 0; i < (n); i++) { 
				for(int j = 0; j < (n); j++){
					
					
					datos.add(scan.nextInt());	
					mat[i][j]=datos.get(contadorTotal);

					contadorTotal++;
					
				}

				
			}
		contador1++;
		
				
			maximoValor(mat,n);
		
	 
}

		}
		}
			
			public static void maximoValor(int[][] mat, int n){ 
				 arrayRespuesta1= new int[n];
				 arrayRespuesta2= new int[n];
				int sumf=0;
				      for (int i = 0; i < mat.length; i++) {  
				        sumf=0;  
				        for (int j = 0; j < mat[i].length; j++) {  
				          sumf=sumf+mat[i][j];  
				        } 

				     arrayRespuesta1[i]=sumf;
				      }

				      int sumc=0;
				            for (int i = 0; i < mat[0].length; i++) {  
				              sumc=0;  
				              for (int j = 0; j < mat.length; j++) {  
				                sumc=sumc+mat[j][i];  
				              }  
				              
				              arrayRespuesta2[i]=sumc;

				          }
				            for (int i = 0; i < n; i++) {  
					              for (int j = 0; j < n;j++) {  
					            	  if(arrayRespuesta1[i]< arrayRespuesta2[j]){
					            		  contador2++;
					            		  
					            	  }
					              } }
				            
				            System.out.println("Case #"+contador3+":");
				            System.out.println(contador2);
				            contador2=0;
				            
			}




}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package primerTaller;

import java.util.Comparator;

/**
 *
 */
class Comparador implements Comparator<String> {
    public int compare(String s1, String s2)
    {        	
		return s1.toLowerCase().compareTo(s2.toLowerCase());
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package primerTaller;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;



/**
 *
 */
public class problemaC {
	static ArrayList<String> respuesta ;
	 
	private static int contador=1;
	public static void main(String[] args) throws Exception {


		int n=0;
		int k=0;
		Scanner scan = null;
		File f = new File("entrada.in");
		String p ="";
		if (f.exists()) {
			scan = new Scanner(f);
		 n = scan.nextInt();
		 for(int x=0;x<n;x++){
			 k = scan.nextInt();

			for(int y=0;y<k;y++){

				p= p+ scan.next();
			}
			 int pr = getFactorial(p.length()); 
				String[] ne = permutar(p,pr);
		 
				mostrar( ne );
				eliminar(ne);

				ordenarLexicograficamente(respuesta);

				 p ="";
		}
scan.close();
		} else{
		
					scan = new Scanner(System.in);
				
					n = scan.nextInt();
					for(int x=0;x<n;x++){
						 k = scan.nextInt();
				
						for(int y=0;y<k;y++){
							p= p+ scan.next();
						}
						
						 int pr = getFactorial(p.length()); 
							String[] ne = permutar(p,pr);
					 
							mostrar( ne );
							eliminar(ne);
							ordenarLexicograficamente(respuesta);
							 p ="";
					}



		}
		}
	
	
public static void ordenarLexicograficamente(ArrayList<String> miVector){
	Collections.sort(miVector,new Comparador());
	
	System.out.println("Case #"+(contador++)+":");	
	for(String sElemento: miVector){
		
		 
		   System.out.println(sElemento);	
		
		}
	
}

public static String[]  permutar(String cadena,int p)
{
	String[] per=new String[p];
	int l = cadena.length();
	
	String[] aux = permutacion(cadena);
	int pos =0;

	if(p==1||l==1)
	{
		per[0] = cadena;
		return per;
	}

	for(int i=0;i<aux.length;i++)
	{
		String[] auxiliar = permutar(aux[i].substring(1),getFactorial(l-1)); 
		for(int j=0;j<auxiliar.length;j++)
		{
			per[pos]=aux[i].charAt(0)+auxiliar[j];
			pos++;
		}			
	}
	return per;

}
public static String[] permutacion(String cadena)
{
	int n = cadena.length();
	String temporal="";
	String[] vector = new String[n];
	vector[0]=cadena;
	for(int i=1;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			if(j==n-1)
					temporal = cadena.charAt(j)+temporal;
			else temporal += cadena.charAt(j);
		}
		cadena=temporal;
		vector[i]=temporal;
		temporal="";
	}
	return vector;
}
public static int getFactorial (int n)
{
	int result;
	if(n==1||n==0)
		return 1;

	result = getFactorial(n-1)*n;
	return result;
}
public static void mostrar (String[] vector)
{
	
for(int i=0;i<vector.length;i++){
   for(int j=0;j<vector.length-1;j++){
       if(i!=j){
           if(vector[i].equals(vector[j])){
               vector[j]="1";
              
           }
       }
       
   }
}
}

public static void eliminar(String[] arraycar){
	 respuesta = new ArrayList<String>();
	 String aux="1";	

   for(int i=0;i<arraycar.length;i++){
       
               if(arraycar[i].equals(aux)){
               	
               }else {
               	
               	respuesta.add(arraycar[i]);
               	
               }
           
           
           
       }
   
}
   public static void mostrar2 (ArrayList<String> vector)
   {System.out.println("segunda");
   	for(int i= 0; i< vector.size();i++)
   	{
   		System.out.println(vector.get(i));
   	}
   }
   public static void mostrar3 (String[] vector)
   {System.out.println("tercera");
   	for(int i= 0; i< vector.length;i++)
   	{
   		System.out.println(vector[i]);
   	}
   }

	


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package primerTaller;

import java.io.File;
import java.util.ArrayList;
import java.util.Scanner;



/**
 *
 */
public class problemaD {
	private  int local;
	private  int visitante;
	private static ArrayList<problemaD> respuesta ;
	private static int contador1;
	private static int contador2;
	
	public problemaD(int local,int visitante){
	this.local=local;	
	this.visitante=visitante;		
	}
	public static void main(String[] args) throws Exception {
		contador2=1;	
		respuesta  = new ArrayList<problemaD>();
		int n=0;
		int k=0;
		Scanner scan = null;
		File f = new File("entrada.in");
		
		if (f.exists()) {
			scan = new Scanner(f);
			n = scan.nextInt();
			for(int x=0;x<n;x++){
				 k = scan.nextInt();
				
				for(int y=0;y<k;y++){
					
					respuesta.add(new problemaD(scan.nextInt(),scan.nextInt()));
					
				}
				for(int y=0;y<respuesta.size();y++){
					respuesta.get(y).mismoLocal(respuesta.get(y),k,y);
					
				}
				imprimirRespuesta();
				respuesta.clear();
			}
			scan.close();
}
		 else{
					scan = new Scanner(System.in);
					n = scan.nextInt();
					for(int x=0;x<n;x++){
						 k = scan.nextInt();
						
						for(int y=0;y<k;y++){
							
							respuesta.add(new problemaD(scan.nextInt(),scan.nextInt()));
							
						}
						for(int y=0;y<respuesta.size();y++){
							respuesta.get(y).mismoLocal(respuesta.get(y),k,y);
							
						}
						imprimirRespuesta();
						respuesta.clear();
					}
		}
	}
	
	
	

public void mismoLocal(problemaD local,int n,int k){
	for(int i=0;i<n;i++){
	        if(i!=k){
	            if(local.local==respuesta.get(i).visitante){
	                contador1++;
	               
	            }
	        }
	        
	    
	}
	
	
}
	
	public static void imprimirRespuesta(){
		System.out.println("Case #"+(contador2++)+":");	
		System.out.println(contador1);	
		contador1=0;
		
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package primerTaller;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 */
public class problemaE3 {
	private static int contador1=0;
	private static int contador2=0;
	private static int contador3=0;
	private static int contadorA=0;
	private static int contadorB=0;
	private static int contadorTotal=0;
	private static int [] arrayRespuesta;
	private static ArrayList<Integer>  arrayRespuesta2;
	public static void main(String[] args) throws Exception {
		Scanner scan = null;
		File f = new File("entrada.in");
		if (f.exists()) {
			scan = new Scanner(f);
						int n = scan.nextInt();
						arrayRespuesta= new int [n*3];
						for (int i = 0; i < n; i++) {
							int  k = scan.nextInt();
							
							ArrayList<Integer> datos = new ArrayList<Integer>();
							
							for (int j= 0; j < k; j++) {

								
							datos.add(scan.nextInt());	
							
							}
															
												}
						
						
		 
		} else{
			int k=0;
			int n=0;
			scan = new Scanner(System.in);
			
			n = scan.nextInt();
			for(int x=0;x<n;x++){
				 k = scan.nextInt();
				 arrayRespuesta=new int[k];
				for(int y=0;y<k;y++){
					
					arrayRespuesta[y]= scan.nextInt();
				}
				cero(arrayRespuesta,k);
				valido();
				imprimir( );
			}

				
			
			}

	}
	
	
	
public static void cero(int[]cero,int k){
	arrayRespuesta2=new ArrayList<Integer>(); 
	for (int y=0;y<k;y++) {
		if(cero[y]==0){
			arrayRespuesta2.add(y);
		}
	}
	
}

public static void valido(){
	contador1=0;
	for (int y=0;y<arrayRespuesta2.size();y++) {
		
		if(contador1==1){
			if(contador2+1==arrayRespuesta2.get(y)){
				
				contador2=arrayRespuesta2.get(y);
				
		}else{
			
			contador3++;
			contador2=arrayRespuesta2.get(y);
		}}
		if(contador1==0){
			
			contador2=arrayRespuesta2.get(y);
			
			contador1=1;
			contador3++;
			
		}
		
		
	
	
}}
public static void imprimir() throws IOException{
	
	
	
	System.out.println(contador3);
	contador3=0;
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package aentregar;


import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

// SeparateChaining Hash table class
//
// CONSTRUCTION: an approximate initial size or default of 101
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// void makeEmpty( )      --> Remove all items

/**
 * Separate chaining table implementation of hash tables.
 * Note that all "matching" is based on the equals method.
 * @param <AnyType>
 */
public class SeparateChainingHashTable<AnyType>
{
	
	public static int con2;
	public static int con4;
	public static int con5;
	public static int con6;
	public static int con7;
	public static int con8;
	public static int con9;
	public static int con99;
	public static int con25;
	public static int con24;
	public static int con26;
	public static int con27;
	public static int con28;
	public static int con29;
	public static  LinkedList< BinaryHeap<Integer>> g66 ;
	static SeparateChainingHashTable<Integer> H;
	public static  BinaryHeap<Integer> h66 ;
    /**
     * Construct the hash table.
     */
	 private static final int DEFAULT_TABLE_SIZE = 101;

     /** The array of Lists. */
public  List<AnyType> [ ] theLists; 
 private int currentSize;
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {//con2=0;
     con99=0;
     con25=0;
     con24=0;
     con26=0;
     con27=0;
     con28=0;
    		 con29=0;
        theLists = new LinkedList[ size ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }
    
    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( !whichList.contains( x ) )
        {
            whichList.add( x );

                // Rehash; see Section 5.5
            if( ++currentSize > theLists.length )
                rehash( );
        }else{
        	 whichList.add( x );

        }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        //con2++;
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
    }

    /**
     * A hash routine for String objects.
     * @param key the String to hash.
     * @param tableSize the size of the hash table.
     * @return the hash value.
     */
    public static int hash( String key, int tableSize )
    {
        int hashVal = 0;

        for( int i = 0; i < key.length( ); i++ )
            hashVal = 37 * hashVal + key.charAt( i );

        hashVal %= tableSize;
        if( hashVal < 0 )
            hashVal += tableSize;

        return hashVal;
    }

    private void rehash( )
    {
        List<AnyType> [ ]  oldLists = theLists;

            // Create new double-sized, empty table
        theLists = new List[ nextPrime( 2 * theLists.length ) ];
        for( int j = 0; j < theLists.length; j++ )
            theLists[ j ] = new LinkedList<>( );

            // Copy table over
        currentSize = 0;
        for( List<AnyType> list : oldLists )
            for( AnyType item : list )
                insert( item );
    }

    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );

        hashVal %= con4;
        if( hashVal < 0 )
            hashVal += con4;

        return hashVal;
    }
    
   

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }

public static void crear(int se,int[]vv){
	for( int bb =0;bb<se;bb++ ){
       	//System.out.println( "C+++" +vv[bb]);
           	H.insert(vv[bb]);
           	
           }
	
}
public void conteo( ) throws Exception
{int nn=0;
	int[] gg= new int [theLists.length];
	for(int i=0;i<theLists.length;i++){
	//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
		if(theLists[i].size()>1){
			nn+=(theLists[i].size()-1);
			BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
			for(int i2=0;i2<theLists[i].size();i2++){
				h55.insert((Integer) theLists[i].get(i2));
				
				//System.out.println( "txcxc  "+theLists[i].get(i2));
				
			}
			h66.insert(h55.findMin());
			g66.add(h55);
		}
		
		//System.out.println( "tamaño)  "+i+" f "+theLists[i].size());
	}
	con8=nn;
	
	
}
public void conteo2( ) throws Exception
{int nn=0;
	int[] gg= new int [theLists.length];
	for(int i=0;i<theLists.length;i++){
	//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
		if(theLists[i].size()>1){
			nn+=(theLists[i].size()-1);
			
			
		}
		
	}
	con8=nn;
	
	
}
public void imprimir( ) throws Exception{
	int inn=0;

	while(!h66.isEmpty()){
		inn=h66.deleteMin();
		for(int i4=0;i4<g66.size();i4++){
			if((g66.get(i4).isEmpty()==false)){
			if((inn==g66.get(i4).findMin())){
				
				while(!g66.get(i4).isEmpty()){
					System.out.print( g66.get(i4).deleteMin()+" ");
				}
				System.out.println( "");
			}
			
		}
			}
		
		//System.out.println( "txcxc  "+theLists[i].get(i2));
		
	}
	
}
        // Simple main isPrime( int n )
    public static void main( String [ ] args ) throws Exception
    {
      int ress=1;

        long startTime = System.currentTimeMillis();
        
        Scanner sc= new Scanner(System.in); 
        String linnn[] = sc.nextLine().split(" ");
        int c2=Integer.parseInt(linnn[0]);
        
        for(int ii=0;ii<c2;ii++){
        	System.out.println( "Case #"+ress+":" );
        	ress++;
      h66 = new BinaryHeap<>( );
      g66= new LinkedList< BinaryHeap<Integer>> () ;
        
               String lin[] = sc.nextLine().split(" ");
               
 	    int c5=Integer.parseInt(lin[0]);
 	  
 	    int c6=Integer.parseInt(lin[1]);
 	  // System.out.println( "b1111 " );
        int[]vv2=new int[c5];
        con5=0;

	String bb4[] = sc.nextLine().split(" ");
	for( int rr=0;rr<bb4.length;rr++ ){
		con6 =Integer.parseInt(bb4[rr]);
        vv2[rr]=con6;
        if(con6>con5){
        if(isPrime( con6 )){
 		  con5=con6; 
 	   }else{
 		   con5=nextPrime( con6);
 	   }
        	}
        	
        }

H = new SeparateChainingHashTable<>(100);
con4=con5;
crear(c5,vv2);
H.conteo2();
con9=con8;
H.makeEmpty();
//System.out.println( "C+++" + con5);
//System.out.println( "Csdf" + con8);
//System.out.println( "Csdssss" + con9);

//H.imprimir( ) ;

       
        int[]vv4=new int[c6];
       
    		String bb6[] = sc.nextLine().split(" ");
    		for( int rr=0;rr<bb6.length;rr++ ){
    			 vv4[rr]=Integer.parseInt(bb6[rr]);
    	    	  
    	   
    		}
       
      
       //System.out.println( "bdsdfsd "+con4 );
      // int gg=sc.nextInt();
       con25=2000;
       con24=0;
       for(int i =0;i<c6;i++){
    	   
    	  if(( vv4[i]!=1)){
    		 con4= vv4[i];
    		// System.out.println( "b "+con4 );
    		 
    		 crear(c5,vv2);
    		 H.conteo2();
    		 //System.out.println( "gg "+con8 );
    		 H.makeEmpty();
    		 if(con9>=con8){
    			 crear(c5,vv2);
    			 H.conteo();
    			 System.out.println( con4 );
    	    	   System.out.println( con8 );
    			 H.imprimir( ) ;
    			 con24++;
    			 i=c6;
    			 
    		 }else if(con8<con25){
    			 con25=con8;
    			con27=i;
    			 //con26=con8;
    		 }
    		// System.out.println( "hfg "+con25 );
    		 //else if(con26>con8){
    			// con27=i;
    			// con26=con8; 
    		 //}
    			 
    		 }
    	  
    	   
    	  
       } 
       if(con24==0){
    	   con4=vv4[con27];
    	   //System.out.println( con4 );
    	   H.makeEmpty();
  		 crear(c5,vv2);
    	   H.conteo();
    	   System.out.println( con4 );
    	   System.out.println( con8 );
    	   H.imprimir();
       }
        }
       }
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
    {
        /**
         * Construct the binary heap.
         */
        public BinaryHeap( )
        {
            this( DEFAULT_CAPACITY );
        }

        /**
         * Construct the binary heap.
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap( int capacity )
        {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
        
        /**
         * Construct the binary heap given an array of items.
         * @param items
         */
        public BinaryHeap( AnyType [ ] items )
        {
                currentSize = items.length;
                array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

                int i = 1;
                for( AnyType item : items )
                    array[ i++ ] = item;
                buildHeap( );
        }

        /**
         * Insert into the priority queue, maintaining heap order.
         * Duplicates are allowed.
         * @param x the item to insert.
         */
        public void insert( AnyType x )
        {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

                // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }


        private void enlargeArray( int newSize )
        {
                AnyType [] old = array;
                array = (AnyType []) new Comparable[ newSize ];
                for( int i = 0; i < old.length; i++ )
                    array[ i ] = old[ i ];        
        }
        
        /**
         * Find the smallest item in the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

        /**
         * Remove the smallest item from the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );

            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary
         * arrangement of items. Runs in linear time.
         */
        private void buildHeap( )
        {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

        /**
         * Test if the priority queue is logically empty.
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty( )
        {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty( )
        {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown( int hole )
        {
            int child;
            AnyType tmp = array[ hole ];

            for( ; hole * 2 <= currentSize; hole = child )
            {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else
                    break;
            }
            array[ hole ] = tmp;
        }
        

            // Test program
        public static void main( String [ ] args ) throws Exception
        {
            int numItems = 10000;
            BinaryHeap<Integer> h = new BinaryHeap<>( );
            int i = 37;

            for( i = 37; i != 0; i = ( i + 37 ) % numItems )
                h.insert( i );
            for( i = 1; i < numItems; i++ )
                if( h.deleteMin( ) != i )
                    System.out.println( "Oops! " + i );
        }
        
        
    }

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package aentregar;
import java.util.LinkedList;
import java.util.Scanner;




/**
 * 
 */

/**
 *
 */
public class problemaB<AnyType>
{
    /**
     * Construct the hash table.
     */
	public static  LinkedList<Integer> g66 ;
	static problemaB<Integer> H;
    public problemaB( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size the approximate initial size.
     */
    public problemaB( int size )
    {
        allocateArray( size );
        doClear( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, do nothing.
     * @param x the item to insert.
     * @return 
     */
    public boolean insert( AnyType x )
    {
            // Insert x as active
        int currentPos = findPos( x );
        if( isActive( currentPos ) )
            return false;

        array[ currentPos ] = new HashEntry<>( x, true );
        theSize++;
        
            // Rehash; see Section 5.5
        if( ++occupied > array.length / 2 )
            rehash( );
        
        return true;
    }

    /**
     * Expand the hash table.
     */
    private void rehash( )
    {
        HashEntry<AnyType> [ ] oldArray = array;

            // Create a new double-sized, empty table
        allocateArray( 2 * oldArray.length );
        occupied = 0;
        theSize = 0;

            // Copy table over
        for( HashEntry<AnyType> entry : oldArray )
            if( entry != null && entry.isActive )
                insert( entry.element );
    }

    /**
     * Method that performs quadratic probing resolution.
     * @param x the item to search for.
     * @return the position where the search terminates.
     */
    private int findPos( AnyType x )
    {
        int offset = 1;
        int currentPos = myhash( x );
        
        while( array[ currentPos ] != null &&
                !array[ currentPos ].element.equals( x ) )
        {
            currentPos += offset;  // Compute ith probe
            offset += 2;
            if( currentPos >= array.length )
                currentPos -= array.length;
        }
        
        return currentPos;
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     * @return true if item removed
     */
    public boolean remove( AnyType x )
    {
        int currentPos = findPos( x );
        if( isActive( currentPos ) )
        {
            array[ currentPos ].isActive = false;
            theSize--;
            return true;
        }
        else
            return false;
    }
    
    /**
     * Get current size.
     * @return the size.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Get length of internal table.
     * @return the size.
     */
    public int capacity( )
    {
        return array.length;
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return the matching item.
     */
    public boolean contains( AnyType x )
    {
        int currentPos = findPos( x );
        return isActive( currentPos );
    }

    /**
     * Return true if currentPos exists and is active.
     * @param currentPos the result of a call to findPos.
     * @return true if currentPos is active.
     */
    private boolean isActive( int currentPos )
    {
        return array[ currentPos ] != null && array[ currentPos ].isActive;
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        doClear( );
    }

    private void doClear( )
    {
        occupied = 0;
        for( int i = 0; i < array.length; i++ )
            array[ i ] = null;
    }
    
    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );

        hashVal %= array.length;
        if( hashVal < 0 )
            hashVal += array.length;

        return hashVal;
    }
    
    private static class HashEntry<AnyType>
    {
        public AnyType  element;   // the element
        public boolean isActive;  // false if marked deleted

        public HashEntry( AnyType e )
        {
            this( e, true );
        }

        public HashEntry( AnyType e, boolean i )
        {
            element  = e;
            isActive = i;
        }
    }

    private static final int DEFAULT_TABLE_SIZE = 101;

    private HashEntry<AnyType> [ ] array; // The array of elements
    private int occupied;                 // The number of occupied cells
    private int theSize;                  // Current size

    /**
     * Internal method to allocate array.
     * @param arraySize the size of the array.
     */
    private void allocateArray( int arraySize )
    {
        array = new HashEntry[ nextPrime( arraySize ) ];
    }

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }

    public static int crear(int n2,int n ){
    int bb=0;
    int b2=0;
    	H.insert(n);
    	if(H.contains(n2)){
    		H.remove(n2);
    		
    	}else{g66.add(n2);
    	b2=g66.size();
    			for(int i=0;i<g66.size();i++){
    			if(H.contains(g66.get(i))){
    				 H.remove(g66.get(i));
                   g66.remove(i);
                  
    	    		i=g66.size();
    	    	}else{
    	    		bb++;
    	    	}
    		}
    			if(bb==b2){
    				H.remove(n);
    				return 1;
    			}
    	
    	}
			return 0;
    			
    	
    }
    // Simple main
    public static void main( String [ ] args )
    {
         H = new problemaB<>( );
        g66= new LinkedList< Integer>() ;
       // System.out.println( "Checking... (no more output means success)" );
        Scanner sc = new Scanner( System.in ); 
        String lin[] = sc.nextLine().split(" ");
	    int cc=Integer.parseInt(lin[0]);
       // long startTime = System.currentTimeMillis( );
        int contador=1;
        for( int f = 0 ; f < cc ; f++){
        
        	
        String lines[] = sc.nextLine().split(" ");
	    int casos =Integer.parseInt(lines[0]);
  

       

        int cantidad=0;
	 	    for( int i = 0 ; i < casos ; ++i ){
	 	  	 String lines2[] = sc.nextLine().split(" ");
			 int s2 = Integer.parseInt(lines2[0]);
			 int s4 = Integer.parseInt(lines2[1]);
	 	        
			 cantidad+=crear(s2,s4 );
			 
	 	    }
	 	   System.out.println( "Case #"+contador+":");
	 	  System.out.println(cantidad);
	 	  contador++;
	 	  H.makeEmpty();
	 	  g66.clear();
	 	  }
        
        //long endTime = System.currentTimeMillis( );
        
        //System.out.println( "Elapsed time: " + (endTime - startTime) );
       
    }

	

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package dsadas;


import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

// SeparateChaining Hash table class
//
// CONSTRUCTION: an approximate initial size or default of 101
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// void makeEmpty( )      --> Remove all items

/**
 * Separate chaining table implementation of hash tables.
 * Note that all "matching" is based on the equals method.
 * @param <AnyType>
 */
public class SeparateChainingHashTable<AnyType>
{
	
	public static int con2;
	public static int con4;
	public static int con5;
	public static int con6;
	public static int con7;
	public static int con8;
	public static int con9;
	public static int con99;
	public static int con25;
	public static int con24;
	public static int con26;
	public static int con27;
	public static int con28;
	public static int con29;
	public static  LinkedList< BinaryHeap<Integer>> g66 ;
	static SeparateChainingHashTable<Integer> H;
	public static  BinaryHeap<Integer> h66 ;
    /**
     * Construct the hash table.
     */
	 private static final int DEFAULT_TABLE_SIZE = 101;

     /** The array of Lists. */
public  List<AnyType> [ ] theLists; 
 private int currentSize;
    public SeparateChainingHashTable( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public SeparateChainingHashTable( int size )
    {//con2=0;
     con99=0;
     con25=0;
     con24=0;
     con26=0;
     con27=0;
     con28=0;
    		 con29=0;
        theLists = new LinkedList[ size ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }
    
    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( !whichList.contains( x ) )
        {
            whichList.add( x );

                // Rehash; see Section 5.5
            if( ++currentSize > theLists.length )
                rehash( );
        }else{
        	 whichList.add( x );

        }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        //con2++;
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
    }

    /**
     * A hash routine for String objects.
     * @param key the String to hash.
     * @param tableSize the size of the hash table.
     * @return the hash value.
     */
    public static int hash( String key, int tableSize )
    {
        int hashVal = 0;

        for( int i = 0; i < key.length( ); i++ )
            hashVal = 37 * hashVal + key.charAt( i );

        hashVal %= tableSize;
        if( hashVal < 0 )
            hashVal += tableSize;

        return hashVal;
    }

    private void rehash( )
    {
        List<AnyType> [ ]  oldLists = theLists;

            // Create new double-sized, empty table
        theLists = new List[ nextPrime( 2 * theLists.length ) ];
        for( int j = 0; j < theLists.length; j++ )
            theLists[ j ] = new LinkedList<>( );

            // Copy table over
        currentSize = 0;
        for( List<AnyType> list : oldLists )
            for( AnyType item : list )
                insert( item );
    }

    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );

        hashVal %= con4;
        if( hashVal < 0 )
            hashVal += con4;

        return hashVal;
    }
    
   

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }

public static void crear(int se,int[]vv){
	for( int bb =0;bb<se;bb++ ){
       	//System.out.println( "C+++" +vv[bb]);
           	H.insert(vv[bb]);
           	
           }
	
}
public void conteo( ) throws Exception
{int nn=0;
	int[] gg= new int [theLists.length];
	for(int i=0;i<theLists.length;i++){
	//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
		if(theLists[i].size()>1){
			nn+=(theLists[i].size()-1);
			BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
			for(int i2=0;i2<theLists[i].size();i2++){
				h55.insert((Integer) theLists[i].get(i2));
				
				//System.out.println( "txcxc  "+theLists[i].get(i2));
				
			}
			h66.insert(h55.findMin());
			g66.add(h55);
		}
		
		//System.out.println( "tamaño)  "+i+" f "+theLists[i].size());
	}
	con8=nn;
	
	
}
public void conteo2( ) throws Exception
{int nn=0;
	int[] gg= new int [theLists.length];
	for(int i=0;i<theLists.length;i++){
	//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
		if(theLists[i].size()>1){
			nn+=(theLists[i].size()-1);
			
			
		}
		
	}
	con8=nn;
	
	
}
public void imprimir( ) throws Exception{
	int inn=0;

	while(!h66.isEmpty()){
		inn=h66.deleteMin();
		for(int i4=0;i4<g66.size();i4++){
			if((g66.get(i4).isEmpty()==false)){
			if((inn==g66.get(i4).findMin())){
				
				while(!g66.get(i4).isEmpty()){
					System.out.print( g66.get(i4).deleteMin()+" ");
				}
				System.out.println( "");
			}
			
		}
			}
		
		//System.out.println( "txcxc  "+theLists[i].get(i2));
		
	}
	
}
        // Simple main isPrime( int n )
    public static void main( String [ ] args ) throws Exception
    {
      int ress=1;

        long startTime = System.currentTimeMillis();
        
        Scanner sc= new Scanner(System.in); 
        String linnn[] = sc.nextLine().split(" ");
        int c2=Integer.parseInt(linnn[0]);
        
        for(int ii=0;ii<c2;ii++){
        	System.out.println( "Case #"+ress+":" );
        	ress++;
      h66 = new BinaryHeap<>( );
      g66= new LinkedList< BinaryHeap<Integer>> () ;
        
               String lin[] = sc.nextLine().split(" ");
               
 	    int c5=Integer.parseInt(lin[0]);
 	  
 	    int c6=Integer.parseInt(lin[1]);
 	  // System.out.println( "b1111 " );
        int[]vv2=new int[c5];
        con5=0;

	String bb4[] = sc.nextLine().split(" ");
	for( int rr=0;rr<bb4.length;rr++ ){
		con6 =Integer.parseInt(bb4[rr]);
        vv2[rr]=con6;
        if(con6>con5){
        if(isPrime( con6 )){
 		  con5=con6; 
 	   }else{
 		   con5=nextPrime( con6);
 	   }
        	}
        	
        }

H = new SeparateChainingHashTable<>(100);
con4=con5;
crear(c5,vv2);
H.conteo2();
con9=con8;
H.makeEmpty();
//System.out.println( "C+++" + con5);
//System.out.println( "Csdf" + con8);
//System.out.println( "Csdssss" + con9);

//H.imprimir( ) ;

       
        int[]vv4=new int[c6];
       
    		String bb6[] = sc.nextLine().split(" ");
    		for( int rr=0;rr<bb6.length;rr++ ){
    			 vv4[rr]=Integer.parseInt(bb6[rr]);
    	    	  
    	   
    		}
       
      
       //System.out.println( "bdsdfsd "+con4 );
      // int gg=sc.nextInt();
       con25=2000;
       con24=0;
       for(int i =0;i<c6;i++){
    	   
    	  if(( vv4[i]!=1)){
    		 con4= vv4[i];
    		// System.out.println( "b "+con4 );
    		 
    		 crear(c5,vv2);
    		 H.conteo2();
    		 //System.out.println( "gg "+con8 );
    		 H.makeEmpty();
    		 if(con9>=con8){
    			 crear(c5,vv2);
    			 H.conteo();
    			 System.out.println( con4 );
    	    	   System.out.println( con8 );
    			 H.imprimir( ) ;
    			 con24++;
    			 i=c6;
    			 
    		 }else if(con8<con25){
    			 con25=con8;
    			con27=i;
    			 //con26=con8;
    		 }
    		// System.out.println( "hfg "+con25 );
    		 //else if(con26>con8){
    			// con27=i;
    			// con26=con8; 
    		 //}
    			 
    		 }
    	  
    	   
    	  
       } 
       if(con24==0){
    	   con4=vv4[con27];
    	   //System.out.println( con4 );
    	   H.makeEmpty();
  		 crear(c5,vv2);
    	   H.conteo();
    	   System.out.println( con4 );
    	   System.out.println( con8 );
    	   H.imprimir();
       }
        }
       }
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
    {
        /**
         * Construct the binary heap.
         */
        public BinaryHeap( )
        {
            this( DEFAULT_CAPACITY );
        }

        /**
         * Construct the binary heap.
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap( int capacity )
        {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
        
        /**
         * Construct the binary heap given an array of items.
         * @param items
         */
        public BinaryHeap( AnyType [ ] items )
        {
                currentSize = items.length;
                array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

                int i = 1;
                for( AnyType item : items )
                    array[ i++ ] = item;
                buildHeap( );
        }

        /**
         * Insert into the priority queue, maintaining heap order.
         * Duplicates are allowed.
         * @param x the item to insert.
         */
        public void insert( AnyType x )
        {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

                // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }


        private void enlargeArray( int newSize )
        {
                AnyType [] old = array;
                array = (AnyType []) new Comparable[ newSize ];
                for( int i = 0; i < old.length; i++ )
                    array[ i ] = old[ i ];        
        }
        
        /**
         * Find the smallest item in the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

        /**
         * Remove the smallest item from the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );

            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary
         * arrangement of items. Runs in linear time.
         */
        private void buildHeap( )
        {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

        /**
         * Test if the priority queue is logically empty.
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty( )
        {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty( )
        {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown( int hole )
        {
            int child;
            AnyType tmp = array[ hole ];

            for( ; hole * 2 <= currentSize; hole = child )
            {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else
                    break;
            }
            array[ hole ] = tmp;
        }
        

            // Test program
        public static void main( String [ ] args ) throws Exception
        {
            int numItems = 10000;
            BinaryHeap<Integer> h = new BinaryHeap<>( );
            int i = 37;

            for( i = 37; i != 0; i = ( i + 37 ) % numItems )
                h.insert( i );
            for( i = 1; i < numItems; i++ )
                if( h.deleteMin( ) != i )
                    System.out.println( "Oops! " + i );
        }
        
        
    }

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package dsadas;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;


/**
 * 
 */

/**
 *
 */
public class problemaC2<AnyType>
{
	public static  LinkedList<Integer> a5 ;
	public static  LinkedList<Integer> v;
	public static  LinkedList<Integer> a6 ;
	public static  LinkedList<Integer> a7 ;
	public static int con2;
	public static int con4;
	public static int con5;
	public static int con6;
	public static int con7;
	public static int con8;
	public static int con9;
	public static int con99;
	public static int con25;
	public static int con24;
	public static int con26;
	public static int con27;
	public static int con28;
	public static int con29;
	public static int  na5;
	public static  LinkedList< BinaryHeap<Integer>> g66 ;
	public static  LinkedList<Integer> g77 ;
	static problemaC2<Integer> h5;
	static problemaC2<Integer> h6;
	static problemaC2<Integer> h7;

	public static  BinaryHeap<Integer> h55;
	public static  BinaryHeap<Integer> h66;
	public static  BinaryHeap<Integer> h77;
	public static  BinaryHeap<Integer> h88;
    /**
     * Construct the hash table.
     */
	 private static final int DEFAULT_TABLE_SIZE = 101;

     /** The array of Lists. */
public  List<AnyType> [ ] theLists; 
 private int currentSize;
    public problemaC2( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
    public problemaC2( int size )
    {//con2=0;
     con99=0;
     con25=0;
     con24=0;
     con26=0;
     con27=0;
     con28=0;
    		 con29=0;
        theLists = new LinkedList[ size ];
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ] = new LinkedList<>( );
    }
   
    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( !whichList.contains( x ) )
        {
            whichList.add( x );

                // Rehash; see Section 5.5
            if( ++currentSize > theLists.length )
                rehash( );
        }else{
        	 whichList.add( x );

        }
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) )
    {
        whichList.remove( x );
            currentSize--;
    }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        //con2++;
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
    }

    /**
     * A hash routine for String objects.
     * @param key the String to hash.
     * @param tableSize the size of the hash table.
     * @return the hash value.
     */
    public static int hash( String key, int tableSize )
    {
        int hashVal = 0;

        for( int i = 0; i < key.length( ); i++ )
            hashVal = 37 * hashVal + key.charAt( i );

        hashVal %= tableSize;
        if( hashVal < 0 )
            hashVal += tableSize;

        return hashVal;
    }

    private void rehash( )
    {
        List<AnyType> [ ]  oldLists = theLists;

            // Create new double-sized, empty table
        theLists = new List[ nextPrime( 2 * theLists.length ) ];
        for( int j = 0; j < theLists.length; j++ )
            theLists[ j ] = new LinkedList<>( );

            // Copy table over
        currentSize = 0;
        for( List<AnyType> list : oldLists )
            for( AnyType item : list )
                insert( item );
    }

    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );

        hashVal %= con4;
        if( hashVal < 0 )
            hashVal += con4;

        return hashVal;
    }
    
   

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }

public static void crear(){
	for( int bb =0;bb<v.size();bb++ ){
       	//System.out.println( "C+++" +vv[bb]);
           	h5.insert(v.get(bb));
           	
           }
	
}
public void conteo( ) throws Exception
{int nn=0;
	int[] gg= new int [h5.theLists.length];
	for(int i=0;i<h5.theLists.length;i++){
	//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
		if(h5.theLists[i].size()>1){
			nn=h5.theLists[i].size();
			//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
			
				//h55.insert((Integer) theLists[i].get(i2));
				g77.add((Integer) h5.theLists[i].get(nn-1));
				//System.out.println( "txcxc  "+theLists[i].get(i2));
				
			
			//h66.insert(h55.findMin());
			//g66.add(h55);
		}
		
		//System.out.println( "tamaño)  "+i+" f "+theLists[i].size());
	}
	con8=nn;
	
	
}

public void imprimir( ) throws Exception{
	
	 na5=0;
	int na6=0;
	//int na7=0;
		for(int i4=0;i4<g77.size();i4++){
			
			//System.out.println( "txcxc  "+g77.get(i4));
			h6.insert(g77.get(i4));
		}
	
	
}
public static void finaal(){
	int f55=a5.size();
	for(int i=0;i<a5.size();i++){
    	//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
    		if(h6.contains(a5.get(i))){
    		
    		}else{
    			h55.insert(a5.get(i));
    			// System.out.println( "Ch5 "+a5.get(i) );
    			 con27++;
    		}}
	
	f55=a6.size();
	for(int i=0;i<a6.size();i++){
    	//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
    		if(h6.contains(a6.get(i))){
    			
    		}else{
    			h66.insert(a6.get(i));
    			// System.out.println( "Ch6 "+a6.get(i) );
    			 con28++;
    		}}
f55=a7.size();
	for(int i=0;i<a7.size();i++){
    	//BinaryHeap<Integer> h55= new BinaryHeap<Integer>();
    		if(h6.contains(a7.get(i))){
    			
    		}else{
    			h77.insert(a7.get(i));
    			
    			//System.out.println( "Ch7 "+a7.get(i) );
    			 con29++;
    			 
    		}}
	
	

	h88.insert(con27);
	h88.insert(con28);
	h88.insert(con29);
	
}
public static void maria() throws Exception{
System.out.print( "Norma "+con27+" " );
	while(!h55.isEmpty()){
		System.out.print( h55.deleteMin()+" ");
	}
	System.out.println( "");
	
}
public static void mario() throws Exception{
	System.out.print( "Mario "+con28 +" ");
	while(!h66.isEmpty()){
		System.out.print( h66.deleteMin()+" ");
	}
	System.out.println( "");
}
public static void pipe() throws Exception{
	System.out.print( "Pipe  "+con29+" " );
	while(!h77.isEmpty()){
		System.out.print( h77.deleteMin()+" ");
	}
	System.out.println( "");
}
public static void imprime() throws Exception{
	int mandar=0;
	while(!h88.isEmpty()){
		mandar=h88.deleteMin();
	}
	
	if(mandar==con27){
		 maria();
}
	if(mandar==con28){
		mario() ;
}	
	if(mandar==con29){
		pipe();
}
}
        // Simple main isPrime( int n )
    public static void main( String [ ] args ) throws Exception
    {
      
    	   Scanner sc= new Scanner(System.in);
    	   String linn[] = sc.nextLine().split(" ");
    	   int contadorrr=1;
    	   int c2=Integer.parseInt(linn[0]);
    	   for(int fb=0;fb<c2;fb++){
      h55= new BinaryHeap<>( );
      h66 = new BinaryHeap<>( );
      h77 = new BinaryHeap<>( );
      h88 = new BinaryHeap<>( );
     g77=new LinkedList<Integer>() ;
     // g66= new LinkedList< BinaryHeap<Integer>> () ;
      
    
	System.out.println( "Case #"+contadorrr+":");
     
        
        contadorrr++;
        
        String lin[] = sc.nextLine().split(" ");
 	    int c5=Integer.parseInt(lin[0]);
 	   a5=new LinkedList<Integer> () ;
 	    int c6=Integer.parseInt(lin[1]);
 	   a6=new LinkedList<Integer> () ;
 	    int c7=Integer.parseInt(lin[2]);
 	   a7=new LinkedList<Integer> () ;
 	  v=new LinkedList<Integer>() ;
 	 int cc5=0;
 	int cc6=0;
 		int cc7=0;
         int contador=1;
         con5=0;
         //System.out.println( "Checking... )" );
         String bb4[] = sc.nextLine().split(" ");
 		for( int rr=0;rr<bb4.length;rr++ ){
 			 cc5=Integer.parseInt(bb4[rr]);
 	    	  
 			;
        	 v.add(cc5);
        	 a5.add(cc5);
        	 if(cc5>con5){
        	        if(isPrime( cc5 )){
        	 		  con5=cc5; 
        	 	   }else{
        	 		   con5=nextPrime( cc5);
        	 	   }
        	        	}
 		}
        	
         
         //System.out.println( "Checki" );
 		String bb6[] = sc.nextLine().split(" ");
 		for( int rr=0;rr<bb6.length;rr++ ){
 			 cc6=Integer.parseInt(bb6[rr]);
 	    	  
 			;
        	 v.add(cc6);
        	 a6.add(cc6);
        	 if(cc6>con5){
        	        if(isPrime( cc6 )){
        	 		  con5=cc6; 
        	 	   }else{
        	 		   con5=nextPrime( cc6);
        	 	   }
        	        	}
 		}
        // System.out.println( "Ch" );
 		String bb8[] = sc.nextLine().split(" ");
 		for( int rr=0;rr<bb8.length;rr++ ){
 			 cc7=Integer.parseInt(bb8[rr]);
 	    	  
 			;
        	 v.add(cc7);
        	 a7.add(cc7);
        	 if(cc7>con5){
        	        if(isPrime( cc7 )){
        	 		  con5=cc7; 
        	 	   }else{
        	 		   con5=nextPrime( cc7);
        	 	   }
        	        	}
 		}
        
        
        
        
        
h5 = new problemaC2<>(con5 );
h6 = new problemaC2<>();
con4=con5;
crear();
h5.conteo();

h5.makeEmpty();
//System.out.println( "C+++" + con5);
//System.out.println( "Csdf" + con8);
//System.out.println( "Csdssss" + con9);
h5.imprimir( ) ;
finaal();
imprime();
 }}
    public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
    {
        /**
         * Construct the binary heap.
         */
        public BinaryHeap( )
        {
            this( DEFAULT_CAPACITY );
        }

        /**
         * Construct the binary heap.
         * @param capacity the capacity of the binary heap.
         */
        public BinaryHeap( int capacity )
        {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
        
        /**
         * Construct the binary heap given an array of items.
         * @param items
         */
        public BinaryHeap( AnyType [ ] items )
        {
                currentSize = items.length;
                array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

                int i = 1;
                for( AnyType item : items )
                    array[ i++ ] = item;
                buildHeap( );
        }

        /**
         * Insert into the priority queue, maintaining heap order.
         * Duplicates are allowed.
         * @param x the item to insert.
         */
        public void insert( AnyType x )
        {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

                // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }


        private void enlargeArray( int newSize )
        {
                AnyType [] old = array;
                array = (AnyType []) new Comparable[ newSize ];
                for( int i = 0; i < old.length; i++ )
                    array[ i ] = old[ i ];        
        }
        
        /**
         * Find the smallest item in the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType findMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

        /**
         * Remove the smallest item from the priority queue.
         * @return the smallest item, or throw an UnderflowException if empty.
         * @throws java.lang.Exception
         */
        public AnyType deleteMin( ) throws Exception
        {
            if( isEmpty( ) )
                throw new Exception( );

            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );

            return minItem;
        }

        /**
         * Establish heap order property from an arbitrary
         * arrangement of items. Runs in linear time.
         */
        private void buildHeap( )
        {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

        /**
         * Test if the priority queue is logically empty.
         * @return true if empty, false otherwise.
         */
        public boolean isEmpty( )
        {
            return currentSize == 0;
        }

        /**
         * Make the priority queue logically empty.
         */
        public void makeEmpty( )
        {
            currentSize = 0;
        }

        private static final int DEFAULT_CAPACITY = 10;

        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

        /**
         * Internal method to percolate down in the heap.
         * @param hole the index at which the percolate begins.
         */
        private void percolateDown( int hole )
        {
            int child;
            AnyType tmp = array[ hole ];

            for( ; hole * 2 <= currentSize; hole = child )
            {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else
                    break;
            }
            array[ hole ] = tmp;
        }
        

            // Test program
        public static void main( String [ ] args ) throws Exception
        {
            int numItems = 10000;
            BinaryHeap<Integer> h = new BinaryHeap<>( );
            int i = 37;

            for( i = 37; i != 0; i = ( i + 37 ) % numItems )
                h.insert( i );
            for( i = 1; i < numItems; i++ )
                if( h.deleteMin( ) != i )
                    System.out.println( "Oops! " + i );
        }
        
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package dsadas;
import java.util.LinkedList;
import java.util.Scanner;




/**
 * 
 */

/**
 *
 */
public class problemaB<AnyType>
{
    /**
     * Construct the hash table.
     */
	public static  LinkedList<Integer> g66 ;
	static problemaB<Integer> H;
    public problemaB( )
    {
        this( DEFAULT_TABLE_SIZE );
    }

    /**
     * Construct the hash table.
     * @param size the approximate initial size.
     */
    public problemaB( int size )
    {
        allocateArray( size );
        doClear( );
    }

    /**
     * Insert into the hash table. If the item is
     * already present, do nothing.
     * @param x the item to insert.
     * @return 
     */
    public boolean insert( AnyType x )
    {
            // Insert x as active
        int currentPos = findPos( x );
        if( isActive( currentPos ) )
            return false;

        array[ currentPos ] = new HashEntry<>( x, true );
        theSize++;
        
            // Rehash; see Section 5.5
        if( ++occupied > array.length / 2 )
            rehash( );
        
        return true;
    }

    /**
     * Expand the hash table.
     */
    private void rehash( )
    {
        HashEntry<AnyType> [ ] oldArray = array;

            // Create a new double-sized, empty table
        allocateArray( 2 * oldArray.length );
        occupied = 0;
        theSize = 0;

            // Copy table over
        for( HashEntry<AnyType> entry : oldArray )
            if( entry != null && entry.isActive )
                insert( entry.element );
    }

    /**
     * Method that performs quadratic probing resolution.
     * @param x the item to search for.
     * @return the position where the search terminates.
     */
    private int findPos( AnyType x )
    {
        int offset = 1;
        int currentPos = myhash( x );
        
        while( array[ currentPos ] != null &&
                !array[ currentPos ].element.equals( x ) )
        {
            currentPos += offset;  // Compute ith probe
            offset += 2;
            if( currentPos >= array.length )
                currentPos -= array.length;
        }
        
        return currentPos;
    }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     * @return true if item removed
     */
    public boolean remove( AnyType x )
    {
        int currentPos = findPos( x );
        if( isActive( currentPos ) )
        {
            array[ currentPos ].isActive = false;
            theSize--;
            return true;
        }
        else
            return false;
    }
    
    /**
     * Get current size.
     * @return the size.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Get length of internal table.
     * @return the size.
     */
    public int capacity( )
    {
        return array.length;
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return the matching item.
     */
    public boolean contains( AnyType x )
    {
        int currentPos = findPos( x );
        return isActive( currentPos );
    }

    /**
     * Return true if currentPos exists and is active.
     * @param currentPos the result of a call to findPos.
     * @return true if currentPos is active.
     */
    private boolean isActive( int currentPos )
    {
        return array[ currentPos ] != null && array[ currentPos ].isActive;
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( )
    {
        doClear( );
    }

    private void doClear( )
    {
        occupied = 0;
        for( int i = 0; i < array.length; i++ )
            array[ i ] = null;
    }
    
    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );

        hashVal %= array.length;
        if( hashVal < 0 )
            hashVal += array.length;

        return hashVal;
    }
    
    private static class HashEntry<AnyType>
    {
        public AnyType  element;   // the element
        public boolean isActive;  // false if marked deleted

        public HashEntry( AnyType e )
        {
            this( e, true );
        }

        public HashEntry( AnyType e, boolean i )
        {
            element  = e;
            isActive = i;
        }
    }

    private static final int DEFAULT_TABLE_SIZE = 101;

    private HashEntry<AnyType> [ ] array; // The array of elements
    private int occupied;                 // The number of occupied cells
    private int theSize;                  // Current size

    /**
     * Internal method to allocate array.
     * @param arraySize the size of the array.
     */
    private void allocateArray( int arraySize )
    {
        array = new HashEntry[ nextPrime( arraySize ) ];
    }

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }

    public static int crear(int n2,int n ){
    int bb=0;
    int b2=0;
    	H.insert(n);
    	if(H.contains(n2)){
    		H.remove(n2);
    		
    	}else{g66.add(n2);
    	b2=g66.size();
    			for(int i=0;i<g66.size();i++){
    			if(H.contains(g66.get(i))){
    				 H.remove(g66.get(i));
                   g66.remove(i);
                  
    	    		i=g66.size();
    	    	}else{
    	    		bb++;
    	    	}
    		}
    			if(bb==b2){
    				H.remove(n);
    				return 1;
    			}
    	
    	}
			return 0;
    			
    	
    }
    // Simple main
    public static void main( String [ ] args )
    {
         H = new problemaB<>( );
        g66= new LinkedList< Integer>() ;
       // System.out.println( "Checking... (no more output means success)" );
        Scanner sc = new Scanner( System.in ); 
        String lin[] = sc.nextLine().split(" ");
	    int cc=Integer.parseInt(lin[0]);
       // long startTime = System.currentTimeMillis( );
        int contador=1;
        for( int f = 0 ; f < cc ; f++){
        
        	
        String lines[] = sc.nextLine().split(" ");
	    int casos =Integer.parseInt(lines[0]);
  

       

        int cantidad=0;
	 	    for( int i = 0 ; i < casos ; ++i ){
	 	  	 String lines2[] = sc.nextLine().split(" ");
			 int s2 = Integer.parseInt(lines2[0]);
			 int s4 = Integer.parseInt(lines2[1]);
	 	        
			 cantidad+=crear(s2,s4 );
			 
	 	    }
	 	   System.out.println( "Case #"+contador+":");
	 	  System.out.println(cantidad);
	 	  contador++;
	 	  H.makeEmpty();
	 	  g66.clear();
	 	  }
        
        //long endTime = System.currentTimeMillis( );
        
        //System.out.println( "Elapsed time: " + (endTime - startTime) );
       
    }

	

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package primero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 */
public class primero {
	  static long TInicio;
		static long TFin;
		static long tiempo; 
	 static Grafo2 Grafo2;//<--Se declara el grafo a usar
	    
	    public static void llenandoGrafo(int n){
	    	String hh="";
	        Grafo2 = new Grafo2();//<---Construimos al objeto Grafo2
	        for(int i=0;i<n;i++){
	        	hh=Integer.toString(i);
	        	 Grafo2.adjuntarNodo(new Nodo(hh)); 
	        }
	       
	
	       
	    }
	    public static void crearenlace(String  a,String b){

	        Grafo2.crearEnlaces(a,b);
	        Grafo2.crearEnlaces(b,a);
	 
	    }
	    
	    
	    public static void main(String []args) throws FileNotFoundException{        
	
	    
	    Scanner scan;
		File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			
		} else {
			scan = new Scanner( System.in );
		}
		
		int t = Integer.parseInt( scan.nextLine() );
		 
        TInicio = System.currentTimeMillis(); 
        
		for ( int test = 0; test < t; test++ ) {
			System.out.println( "Case #" + ( test + 1 ) + ":" );
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			int m = arr[1];
			
			llenandoGrafo(n);
			
			for ( int i = 0; i < m; i++ ) {
				String s[] = scan.nextLine().split( " " );

				crearenlace(s[0],s[1]);
			}
			  
			String s4[] = scan.nextLine().split( " " );
			
			 Recorrido recorrido = new Recorrido();
			  
		        recorrido.recorrerProfundidadIterativo(Grafo2,Grafo2.buscarNodo(s4[0]));
		      //  Recorrido 
		        
		      
		        System.out.println((recorrido.con2-1)); 
		        recorrido.con2=0;
		       
		        recorrido.con6=0;
		        
		}
		TFin = System.currentTimeMillis(); 
       
        tiempo = TFin - TInicio; //Calculamos los milisegundos de diferencia
        System.out.println("Tiempo de ejecución en milisegundos: " + tiempo); 
    
}
 
	public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
	public static class Grafo2{
	    private ArrayList<Nodo> listaNodo;

	    public Grafo2(){
	        listaNodo = new ArrayList<Nodo>();
	    }
	    public void adjuntarNodo(Nodo nodo){
	        listaNodo.add(nodo);
	    }
	    public void crearEnlaces(Object nombreNodoPadre,Object nombreNodoHijo){
	        Nodo padre = buscarNodo(nombreNodoPadre);    
	        Nodo hijo = buscarNodo(nombreNodoHijo);
	        if(padre != null && hijo != null){  
	        	padre.setNodo(hijo);
	        }
	    }
	    public Nodo buscarNodo(Object nombreNodo){
	       Nodo temp = null;
	        for(int i = 0;i < listaNodo.size(); i++){
	            if(((String)nombreNodo).equals((String)listaNodo.get(i).getDato())){
	                return listaNodo.get(i);}
	        }
	        return temp;
	    }
	   
	    
	}
	 public static class Nodo
	    {
	        private Object dato;// define a dato 
	        private ArrayList<Nodo> nodo;// lugares en la lista como nodos
	        public boolean visitado = false;// creamos n parametro tipo booleano para la marca visitado

	        public Nodo(){
	        	this(new Object());
	        }
	        public Nodo(Object dato){
	            this.dato = dato;
	            nodo = new ArrayList<Nodo>();
	        }
	        public void setDato(Object dato){
	        	this.dato = dato;
	        }
	        public Object getDato(){
	            return this.dato;
	        }
	        public void setNodo(Nodo nodo){
	            this.nodo.add(nodo);
	        }
	        public ArrayList<Nodo> getHijos(){
	        	return nodo;
	        }
	    }
	 public static class Pila2 extends ArrayList{
		 public Pila2() {
	            super();}
	        public void addNodo(Nodo nodo){
	            if(!this.contains(nodo) && nodo.visitado != true){
	            	add(nodo);
	               
	            }
	        }
	        public Nodo getNodo(){
	            Nodo nodoTemp = null;
	            if(!this.isEmpty() && this != null){//
	                nodoTemp = (Nodo)this.get(this.size() - 1);
	                this.remove(this.size() - 1);
	            }
	                  
	            return nodoTemp; 
	            }
	        public void mostrarContenido(){
	            System.out.print("[");
	            for(int i = 0;i < this.size();i++){
	                System.out.print(((Nodo)this.get(i)).getDato());
	            }
	            System.out.print("]");        
	        }
	        
	    }
	 public static class Recorrido{
		    private Pila2 Pila2;
		   
		public static int con2=0;
		public static int con4=0;
		public static int con6=0;
		public static int con8=0;
		    public Recorrido(){
		        Pila2 = new Pila2();
		        
		    }
		    private void llenarPila2NodosAdyacentes(Nodo nodo){
		    	for(int i = 0; i < nodo.getHijos().size();i++){

		            if(!nodo.getHijos().contains(nodo)){                
		                Pila2.addNodo(nodo.getHijos().get(i));
		            }
		        }
		    }
		    
		    
		    public void recorrerProfundidadIterativo(Grafo2 Grafo2,Nodo nodoInicio){
		        if(Grafo2 != null && nodoInicio != null){
		            Pila2.addNodo(nodoInicio);
		            while(Pila2.size() > 0){
		            	con2++;
		                Nodo nodoVisitado = Pila2.getNodo();
		                if(nodoVisitado.visitado == false){
		                	
		                    nodoVisitado.visitado = true;
		                                   
		                    llenarPila2NodosAdyacentes(nodoVisitado); }
		            }
		        }
		       
		      
		    }
		    
		   
		}

	}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package primero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 */
public class primero {
	  static long TInicio;
		static long TFin;
		static long tiempo; 
	 static Grafo2 Grafo2;//<--Se declara el grafo a usar
	    
	    public static void llenandoGrafo(int n){
	    	String hh="";
	        Grafo2 = new Grafo2();//<---Construimos al objeto Grafo2
	        for(int i=0;i<n;i++){
	        	hh=Integer.toString(i);
	        	 Grafo2.adjuntarNodo(new Nodo(hh)); 
	        }
	       
	
	       
	    }
	    public static void crearenlace(String  a,String b){

	        Grafo2.crearEnlaces(a,b);
	        Grafo2.crearEnlaces(b,a);
	 
	    }
	    
	    
	    public static void main(String []args) throws FileNotFoundException{        
	
	    
	    Scanner scan;
		File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			
		} else {
			scan = new Scanner( System.in );
		}
		
		int t = Integer.parseInt( scan.nextLine() );
		 
        TInicio = System.currentTimeMillis(); 
        
		for ( int test = 0; test < t; test++ ) {
			System.out.println( "Case #" + ( test + 1 ) + ":" );
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			int m = arr[1];
			
			llenandoGrafo(n);
			
			for ( int i = 0; i < m; i++ ) {
				String s[] = scan.nextLine().split( " " );

				crearenlace(s[0],s[1]);
			}
			  
			String s4[] = scan.nextLine().split( " " );
			
			 Recorrido recorrido = new Recorrido();
			  
		        recorrido.recorrerProfundidadIterativo(Grafo2,Grafo2.buscarNodo(s4[0]));
		      //  Recorrido 
		        
		      
		        System.out.println((recorrido.con2-1)); 
		        recorrido.con2=0;
		       
		        recorrido.con6=0;
		        
		}
		TFin = System.currentTimeMillis(); 
       
        tiempo = TFin - TInicio; //Calculamos los milisegundos de diferencia
        System.out.println("Tiempo de ejecucion en milisegundos: " + tiempo); 
    
}
 
	public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
	public static class Grafo2{
	    private ArrayList<Nodo> listaNodo;

	    public Grafo2(){
	        listaNodo = new ArrayList<Nodo>();
	    }
	    public void adjuntarNodo(Nodo nodo){
	        listaNodo.add(nodo);
	    }
	    public void crearEnlaces(Object nombreNodoPadre,Object nombreNodoHijo){
	        Nodo padre = buscarNodo(nombreNodoPadre);    
	        Nodo hijo = buscarNodo(nombreNodoHijo);
	        if(padre != null && hijo != null){  
	        	padre.setNodo(hijo);
	        }
	    }
	    public Nodo buscarNodo(Object nombreNodo){
	       Nodo temp = null;
	        for(int i = 0;i < listaNodo.size(); i++){
	            if(((String)nombreNodo).equals((String)listaNodo.get(i).getDato())){
	                return listaNodo.get(i);}
	        }
	        return temp;
	    }
	   
	    
	}
	 public static class Nodo
	    {
	        private Object dato;// define a dato 
	        private ArrayList<Nodo> nodo;// lugares en la lista como nodos
	        public boolean visitado = false;// creamos n parametro tipo booleano para la marca visitado

	        public Nodo(){
	        	this(new Object());
	        }
	        public Nodo(Object dato){
	            this.dato = dato;
	            nodo = new ArrayList<Nodo>();
	        }
	        public void setDato(Object dato){
	        	this.dato = dato;
	        }
	        public Object getDato(){
	            return this.dato;
	        }
	        public void setNodo(Nodo nodo){
	            this.nodo.add(nodo);
	        }
	        public ArrayList<Nodo> getHijos(){
	        	return nodo;
	        }
	    }
	 public static class Pila2 extends ArrayList{
		 public Pila2() {
	            super();}
	        public void addNodo(Nodo nodo){
	            if(!this.contains(nodo) && nodo.visitado != true){
	            	add(nodo);
	               
	            }
	        }
	        public Nodo getNodo(){
	            Nodo nodoTemp = null;
	            if(!this.isEmpty() && this != null){//
	                nodoTemp = (Nodo)this.get(this.size() - 1);
	                this.remove(this.size() - 1);
	            }
	                  
	            return nodoTemp; 
	            }
	        public void mostrarContenido(){
	            System.out.print("[");
	            for(int i = 0;i < this.size();i++){
	                System.out.print(((Nodo)this.get(i)).getDato());
	            }
	            System.out.print("]");        
	        }
	        
	    }
	 public static class Recorrido{
		    private Pila2 Pila2;
		   
		public static int con2=0;
		public static int con4=0;
		public static int con6=0;
		public static int con8=0;
		    public Recorrido(){
		        Pila2 = new Pila2();
		        
		    }
		    private void llenarPila2NodosAdyacentes(Nodo nodo){
		    	for(int i = 0; i < nodo.getHijos().size();i++){

		            if(!nodo.getHijos().contains(nodo)){                
		                Pila2.addNodo(nodo.getHijos().get(i));
		            }
		        }
		    }
		    
		    
		    public void recorrerProfundidadIterativo(Grafo2 Grafo2,Nodo nodoInicio){
		        if(Grafo2 != null && nodoInicio != null){
		            Pila2.addNodo(nodoInicio);
		            while(Pila2.size() > 0){
		            	con2++;
		                Nodo nodoVisitado = Pila2.getNodo();
		                if(nodoVisitado.visitado == false){
		                	
		                    nodoVisitado.visitado = true;
		                                   
		                    llenarPila2NodosAdyacentes(nodoVisitado); }
		            }
		        }
		       
		      
		    }
		    
		   
		}

	}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package segundo;

//A Java program by Diego fn
import java.io.*;
import java.util.*;

public class Segundo
{
	 static long TInicio;
		static long TFin;
		static long tiempo;
 private int V;  
 private LinkedList<Integer> adj[]; 
public static  LinkedList<Integer> add4;
public static Stack stacke;

 Segundo(int v)
 {
     V = v;
     adj = new LinkedList[v];
     for (int i=0; i<v; ++i)
         adj[i] = new LinkedList();
 }

 void add4Edge(int v,int w) { adj[v].add(w); }
 public boolean compare(int v,int w) {
	 
	 if( adj[v].contains(w)){
		
		 return true;
	 }
	
	return false;
	
	 }

 void topologicalSortUtil(int v, Boolean visited[],Stack stack)
 {
    
     visited[v] = true;
     Integer i;

     Iterator<Integer> it = adj[v].iterator();
     while (it.hasNext())
     {
         i = it.next();
         if (!visited[i])
             topologicalSortUtil(i, visited, stack);
     }

     stack.push(new Integer(v));
     stacke.push(new Integer(v));
 }

 void topologicalSort()
 {
     Stack stack = new Stack();

    
     Boolean visited[] = new Boolean[V];
     for (int i = 0; i < V; i++)
         visited[i] = false;

     
     for (int i = 0; i < V; i++)
         if (visited[i] == false)
             topologicalSortUtil(i, visited, stack);

     while (stack.empty()==false)
       
     add4.add((Integer) stack.pop());
 }

 public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
 public static void main(String args[]) throws FileNotFoundException
 {
     
     Scanner scan;  
     
     
		File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
		
		} else {
			scan = new Scanner( System.in );
		}
		
		String s[] = scan.nextLine().split( " " );
		TInicio = System.currentTimeMillis();
		int va = Integer.parseInt(s[0] );
		
		
		for(int x = 1; x<= va; x++){
			stacke = new Stack();
			System.out.println( "Case #" + ( x ) + ":" );
			add4=new LinkedList<Integer> ();
			 String s2[] = scan.nextLine().split( " " );
				int vv4 = Integer.parseInt(s2[0] );;
				int vv6 = Integer.parseInt(s2[1] );;
	    	 Segundo g = new Segundo(vv4);
		
	    	 
	    	
		for ( int test = 0; test < vv6; test++ ) {
			int arr[] = readInts( scan.nextLine() );
			
			g.add4Edge(arr[0], arr[1]);
		}
 
     g.topologicalSort();
   
	int von=0;
	for ( int vv = 0; vv < add4.size()-1; vv++ ) {
		
		 if(g.compare(add4.get(vv), add4.get(vv+1))==false){
			 vv =add4.size();
			 von++;
		 }else{
			 
		 }
		 
	}
	
	add4.clear();
	if(von==0){
		System.out.println("Deberia empezar a estudiar");
		von=0;
	}
    
		}
		 TFin = System.currentTimeMillis(); 
	        tiempo = TFin - TInicio; //Calculamos los milisegundos de diferencia
	        System.out.println("Tiempo de ejecucion en milisegundos: " + tiempo); 
		
 }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package tercero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.InputMismatchException;
import java.util.Scanner;
public class jhonson_ww 
{
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private int augmentedMatrix[][];
    private int potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private int[][] allPairShortestPath;
 
    public static final int MAX_VALUE = 999;
 
    public jhonson_ww(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new int[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new int[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new int[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        int reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            int[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private int[][] reweightGraph(int adjacencyMatrix[][])
    {
        int[][] result = new int[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		TInicio = System.currentTimeMillis(); 
      
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            jhonson_ww johnsonsAlgorithm = new jhonson_ww(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            
            
            System.out.println(numberOf4);
            numberOf4=0;
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
        TFin = System.currentTimeMillis(); 
        tiempo = TFin - TInicio; //Calculamos los milisegundos de diferencia
        System.out.println("Tiempo de ejecucion en milisegundos: " + tiempo); 
    }
}
 
class BellmanFord 
{
    private int distances[];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new int[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, int adjacencymatrix[][])
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + adjacencymatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + adjacencymatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + adjacencymatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private int distances[];
    private int adjacencymatrix[][];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, int adjacencymatrix[][])
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new int[numberofvertices + 1];
        this.adjacencymatrix = new int[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = adjacencymatrix[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        int min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        int edgeDistance = -1;
        int newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package primero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

/**
 *
 */
public class primero {
	  static long TInicio;
		static long TFin;
		static long tiempo; 
	 static Grafo2 Grafo2;//<--Se declara el grafo a usar
	    
	    public static void llenandoGrafo(int n){
	    	String hh="";
	        Grafo2 = new Grafo2();//<---Construimos al objeto Grafo2
	        for(int i=0;i<n;i++){
	        	hh=Integer.toString(i);
	        	 Grafo2.adjuntarNodo(new Nodo(hh)); 
	        }
	       
	
	       
	    }
	    public static void crearenlace(String  a,String b){

	        Grafo2.crearEnlaces(a,b);
	        Grafo2.crearEnlaces(b,a);
	 
	    }
	    
	    
	    public static void main(String []args) throws FileNotFoundException{        
	
	    
	    Scanner scan;
		File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			
		} else {
			scan = new Scanner( System.in );
		}
		
		int t = Integer.parseInt( scan.nextLine() );
		 
       // TInicio = System.currentTimeMillis(); 
        
		for ( int test = 0; test < t; test++ ) {
			System.out.println( "Case #" + ( test + 1 ) + ":" );
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			int m = arr[1];
			
			llenandoGrafo(n);
			
			for ( int i = 0; i < m; i++ ) {
				String s[] = scan.nextLine().split( " " );

				crearenlace(s[0],s[1]);
			}
			  
			String s4[] = scan.nextLine().split( " " );
			
			 Recorrido recorrido = new Recorrido();
			  
		        recorrido.recorrerProfundidadIterativo(Grafo2,Grafo2.buscarNodo(s4[0]));
		      //  Recorrido 
		        
		      
		        System.out.println((recorrido.con2-1)); 
		        recorrido.con2=0;
		       
		        recorrido.con6=0;
		        
		}
		//TFin = System.currentTimeMillis(); 
       
        //tiempo = TFin - TInicio; //Calculamos los milisegundos de diferencia
      //  System.out.println("Tiempo de ejecucion en milisegundos: " + tiempo); 
    
}
 
	public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
	public static class Grafo2{
	    private ArrayList<Nodo> listaNodo;

	    public Grafo2(){
	        listaNodo = new ArrayList<Nodo>();
	    }
	    public void adjuntarNodo(Nodo nodo){
	        listaNodo.add(nodo);
	    }
	    public void crearEnlaces(Object nombreNodoPadre,Object nombreNodoHijo){
	        Nodo padre = buscarNodo(nombreNodoPadre);    
	        Nodo hijo = buscarNodo(nombreNodoHijo);
	        if(padre != null && hijo != null){  
	        	padre.setNodo(hijo);
	        }
	    }
	    public Nodo buscarNodo(Object nombreNodo){
	       Nodo temp = null;
	        for(int i = 0;i < listaNodo.size(); i++){
	            if(((String)nombreNodo).equals((String)listaNodo.get(i).getDato())){
	                return listaNodo.get(i);}
	        }
	        return temp;
	    }
	   
	    
	}
	 public static class Nodo
	    {
	        private Object dato;// define a dato 
	        private ArrayList<Nodo> nodo;// lugares en la lista como nodos
	        public boolean visitado = false;// creamos n parametro tipo booleano para la marca visitado

	        public Nodo(){
	        	this(new Object());
	        }
	        public Nodo(Object dato){
	            this.dato = dato;
	            nodo = new ArrayList<Nodo>();
	        }
	        public void setDato(Object dato){
	        	this.dato = dato;
	        }
	        public Object getDato(){
	            return this.dato;
	        }
	        public void setNodo(Nodo nodo){
	            this.nodo.add(nodo);
	        }
	        public ArrayList<Nodo> getHijos(){
	        	return nodo;
	        }
	    }
	 public static class Pila2 extends ArrayList{
		 public Pila2() {
	            super();}
	        public void addNodo(Nodo nodo){
	            if(!this.contains(nodo) && nodo.visitado != true){
	            	add(nodo);
	               
	            }
	        }
	        public Nodo getNodo(){
	            Nodo nodoTemp = null;
	            if(!this.isEmpty() && this != null){//
	                nodoTemp = (Nodo)this.get(this.size() - 1);
	                this.remove(this.size() - 1);
	            }
	                  
	            return nodoTemp; 
	            }
	        public void mostrarContenido(){
	            System.out.print("[");
	            for(int i = 0;i < this.size();i++){
	                System.out.print(((Nodo)this.get(i)).getDato());
	            }
	            System.out.print("]");        
	        }
	        
	    }
	 public static class Recorrido{
		    private Pila2 Pila2;
		   
		public static int con2=0;
		public static int con4=0;
		public static int con6=0;
		public static int con8=0;
		    public Recorrido(){
		        Pila2 = new Pila2();
		        
		    }
		    private void llenarPila2NodosAdyacentes(Nodo nodo){
		    	for(int i = 0; i < nodo.getHijos().size();i++){

		            if(!nodo.getHijos().contains(nodo)){                
		                Pila2.addNodo(nodo.getHijos().get(i));
		            }
		        }
		    }
		    
		    
		    public void recorrerProfundidadIterativo(Grafo2 Grafo2,Nodo nodoInicio){
		        if(Grafo2 != null && nodoInicio != null){
		            Pila2.addNodo(nodoInicio);
		            while(Pila2.size() > 0){
		            	con2++;
		                Nodo nodoVisitado = Pila2.getNodo();
		                if(nodoVisitado.visitado == false){
		                	
		                    nodoVisitado.visitado = true;
		                                   
		                    llenarPila2NodosAdyacentes(nodoVisitado); }
		            }
		        }
		       
		      
		    }
		    
		   
		}

	}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package segundo;

//A Java program by Diego fn
import java.io.*;
import java.util.*;

public class Segundo
{
	 static long TInicio;
		static long TFin;
		static long tiempo;
 private int V;  
 private LinkedList<Integer> adj[]; 
public static  LinkedList<Integer> add4;
public static Stack stacke;

 Segundo(int v)
 {
     V = v;
     adj = new LinkedList[v];
     for (int i=0; i<v; ++i)
         adj[i] = new LinkedList();
 }

 void add4Edge(int v,int w) { adj[v].add(w); }
 public boolean compare(int v,int w) {
	 
	 if( adj[v].contains(w)){
		
		 return true;
	 }
	
	return false;
	
	 }

 void topologicalSortUtil(int v, Boolean visited[],Stack stack)
 {
    
     visited[v] = true;
     Integer i;

     Iterator<Integer> it = adj[v].iterator();
     while (it.hasNext())
     {
         i = it.next();
         if (!visited[i])
             topologicalSortUtil(i, visited, stack);
     }

     stack.push(new Integer(v));
     stacke.push(new Integer(v));
 }

 void topologicalSort()
 {
     Stack stack = new Stack();

    
     Boolean visited[] = new Boolean[V];
     for (int i = 0; i < V; i++)
         visited[i] = false;

     
     for (int i = 0; i < V; i++)
         if (visited[i] == false)
             topologicalSortUtil(i, visited, stack);

     while (stack.empty()==false)
       
     add4.add((Integer) stack.pop());
 }

 public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
 public static void main(String args[]) throws FileNotFoundException
 {
     
     Scanner scan;  
     
     
		File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
		
		} else {
			scan = new Scanner( System.in );
		}
		
		String s[] = scan.nextLine().split( " " );
		TInicio = System.currentTimeMillis();
		int va = Integer.parseInt(s[0] );
		
		
		for(int x = 1; x<= va; x++){
			stacke = new Stack();
			System.out.println( "Case #" + ( x ) + ":" );
			add4=new LinkedList<Integer> ();
			 String s2[] = scan.nextLine().split( " " );
				int vv4 = Integer.parseInt(s2[0] );;
				int vv6 = Integer.parseInt(s2[1] );;
	    	 Segundo g = new Segundo(vv4);
		
	    	 
	    	
		for ( int test = 0; test < vv6; test++ ) {
			int arr[] = readInts( scan.nextLine() );
			
			g.add4Edge(arr[0], arr[1]);
		}
 
     g.topologicalSort();
   
	int von=0;
	for ( int vv = 0; vv < add4.size()-1; vv++ ) {
		
		 if(g.compare(add4.get(vv), add4.get(vv+1))==false){
			 vv =add4.size();
			 von++;
		 }else{
			 
		 }
		 
	}
	
	add4.clear();
	if(von==0){
		System.out.println("Deberia empezar a estudiar");
		von=0;
	}
    
		}
		 TFin = System.currentTimeMillis(); 
	        tiempo = TFin - TInicio; //Calculamos los milisegundos de diferencia
	        System.out.println("Tiempo de ejecucion en milisegundos: " + tiempo); 
		
 }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package segundo;

//A Java program by Diego fn
import java.io.*;
import java.util.*;

public class Segundo
{
	 static long TInicio;
		static long TFin;
		static long tiempo;
 private int V;  
 private LinkedList<Integer> adj[]; 
public static  LinkedList<Integer> add4;
public static Stack stacke;

 Segundo(int v)
 {
     V = v;
     adj = new LinkedList[v];
     for (int i=0; i<v; ++i)
         adj[i] = new LinkedList();
 }

 void add4Edge(int v,int w) { adj[v].add(w); }
 public boolean compare(int v,int w) {
	 
	 if( adj[v].contains(w)){
		
		 return true;
	 }
	
	return false;
	
	 }

 void topologicalSortUtil(int v, Boolean visited[],Stack stack)
 {
    
     visited[v] = true;
     Integer i;

     Iterator<Integer> it = adj[v].iterator();
     while (it.hasNext())
     {
         i = it.next();
         if (!visited[i])
             topologicalSortUtil(i, visited, stack);
     }

     stack.push(new Integer(v));
     stacke.push(new Integer(v));
 }

 void topologicalSort()
 {
     Stack stack = new Stack();

    
     Boolean visited[] = new Boolean[V];
     for (int i = 0; i < V; i++)
         visited[i] = false;

     
     for (int i = 0; i < V; i++)
         if (visited[i] == false)
             topologicalSortUtil(i, visited, stack);

     while (stack.empty()==false)
       
     add4.add((Integer) stack.pop());
 }

 public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
 public static void main(String args[]) throws FileNotFoundException
 {
     
     Scanner scan;  
     
     
		File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
		
		} else {
			scan = new Scanner( System.in );
		}
		
		String s[] = scan.nextLine().split( " " );
		//TInicio = System.currentTimeMillis();
		int va = Integer.parseInt(s[0] );
		
		
		for(int x = 1; x<= va; x++){
			stacke = new Stack();
			System.out.println( "Case #" + ( x ) + ":" );
			add4=new LinkedList<Integer> ();
			 String s2[] = scan.nextLine().split( " " );
				int vv4 = Integer.parseInt(s2[0] );;
				int vv6 = Integer.parseInt(s2[1] );;
	    	 Segundo g = new Segundo(vv4);
		
	    	 
	    	
		for ( int test = 0; test < vv6; test++ ) {
			int arr[] = readInts( scan.nextLine() );
			
			g.add4Edge(arr[0], arr[1]);
		}
 
     g.topologicalSort();
   
	int von=0;
	for ( int vv = 0; vv < add4.size()-1; vv++ ) {
		
		 if(g.compare(add4.get(vv), add4.get(vv+1))==false){
			 vv =add4.size();
			 von++;
		 }else{
			 
		 }
		 
	}
	
	add4.clear();
	if(von==0){
		System.out.println("Deberia empezar a estudiar");
		von=0;
	}
    
		}
		// TFin = System.currentTimeMillis(); 
	       // tiempo = TFin - TInicio; //Calculamos los milisegundos de diferencia
	     //   System.out.println("Tiempo de ejecucion en milisegundos: " + tiempo); 
		
 }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package tercero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.InputMismatchException;
import java.util.Scanner;
public class jhonson_ww 
{
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private int augmentedMatrix[][];
    private int potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private int[][] allPairShortestPath;
 
    public static final int MAX_VALUE = 999;
 
    public jhonson_ww(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new int[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new int[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new int[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        int reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            int[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private int[][] reweightGraph(int adjacencyMatrix[][])
    {
        int[][] result = new int[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		//TInicio = System.currentTimeMillis(); 
      
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            jhonson_ww johnsonsAlgorithm = new jhonson_ww(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            
            
            System.out.println(numberOf4);
            numberOf4=0;
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
        //TFin = System.currentTimeMillis(); 
       // tiempo = TFin - TInicio; //Calculamos los milisegundos de diferencia
       // System.out.println("Tiempo de ejecucion en milisegundos: " + tiempo); 
    }
}
 
class BellmanFord 
{
    private int distances[];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new int[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, int adjacencymatrix[][])
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + adjacencymatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + adjacencymatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + adjacencymatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private int distances[];
    private int adjacencymatrix[][];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, int adjacencymatrix[][])
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new int[numberofvertices + 1];
        this.adjacencymatrix = new int[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = adjacencymatrix[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        int min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        int edgeDistance = -1;
        int newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package tercero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.InputMismatchException;
import java.util.Scanner;
public class jhonson_ww 
{
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private int augmentedMatrix[][];
    private int potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private int[][] allPairShortestPath;
 
    public static final int MAX_VALUE = 999;
 
    public jhonson_ww(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new int[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new int[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new int[numberOfNodes + 1][numberOfNodes + 1];
    }
 ////
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        int reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            int[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private int[][] reweightGraph(int adjacencyMatrix[][])
    {
        int[][] result = new int[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
	
      
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            jhonson_ww johnsonsAlgorithm = new jhonson_ww(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            
            
            System.out.println(numberOf4);
            numberOf4=0;
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
       
    
    }
}
 
class BellmanFord 
{
    private int distances[];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new int[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, int adjacencymatrix[][])
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + adjacencymatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + adjacencymatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + adjacencymatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private int distances[];
    private int adjacencymatrix[][];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, int adjacencymatrix[][])
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new int[numberofvertices + 1];
        this.adjacencymatrix = new int[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = adjacencymatrix[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        int min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        int edgeDistance = -1;
        int newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package Cuarto;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.Scanner;
public class jhonson_ww 
{
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private int augmentedMatrix[][];
    private int potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private int[][] allPairShortestPath;
 public static ArrayList<Integer> hola;
    public static final int MAX_VALUE = 999;
 
    public jhonson_ww(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new int[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new int[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new int[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        int reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            int[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	hola.add(source-1);
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private int[][] reweightGraph(int adjacencyMatrix[][])
    {
        int[][] result = new int[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
        	hola=new ArrayList<Integer> ();
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            jhonson_ww johnsonsAlgorithm = new jhonson_ww(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            Collections.sort(hola);
            for (int xd = 0; xd <hola.size(); xd++)
            {
            	 System.out.print(hola.get(xd)+" ");
            	 
            }
            System.out.println(" ");
            
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
      
    }
}
 
class BellmanFord 
{
    private int distances[];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new int[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, int adjacencymatrix[][])
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + adjacencymatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + adjacencymatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + adjacencymatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private int distances[];
    private int adjacencymatrix[][];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, int adjacencymatrix[][])
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new int[numberofvertices + 1];
        this.adjacencymatrix = new int[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = adjacencymatrix[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        int min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        int edgeDistance = -1;
        int newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
    ///
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package tercero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.InputMismatchException;
import java.util.Scanner;
public class jhonson_ww 
{
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private int augmentedMatrix[][];
    private int potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private int[][] allPairShortestPath;
 
    public static final int MAX_VALUE = 99999999;
 
    public jhonson_ww(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new int[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new int[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new int[numberOfNodes + 1][numberOfNodes + 1];
    }
 ////
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        int reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            int[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private int[][] reweightGraph(int adjacencyMatrix[][])
    {
        int[][] result = new int[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
	
      
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            jhonson_ww johnsonsAlgorithm = new jhonson_ww(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            
            
            System.out.println(numberOf4);
            numberOf4=0;
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
       
    
    }
}
 
class BellmanFord 
{
    private int distances[];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new int[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, int adjacencymatrix[][])
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + adjacencymatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + adjacencymatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + adjacencymatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private int distances[];
    private int adjacencymatrix[][];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, int adjacencymatrix[][])
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new int[numberofvertices + 1];
        this.adjacencymatrix = new int[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = adjacencymatrix[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        int min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        int edgeDistance = -1;
        int newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package Cuarto;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.Scanner;
public class Cuartomejorado
{//
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private long augmentedMatrix[][];
    private long potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private long[][] allPairShortestPath;
 public static ArrayList<Integer> hola;
    public static final int MAX_VALUE = 999999999;
 
    public Cuartomejorado(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new long[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new long[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new long[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        long reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            long[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	hola.add(source-1);
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private long[][] reweightGraph(int adjacencyMatrix[][])
    {
        long [][] result = new long[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
        	hola=new ArrayList<Integer> ();
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            Cuartomejorado johnsonsAlgorithm = new Cuartomejorado(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            Collections.sort(hola);
            for (int xd = 0; xd <hola.size(); xd++)
            {
            	 System.out.print(hola.get(xd)+" ");
            	 
            }
            System.out.println(" ");
            
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
      
    }
}
 
class BellmanFord 
{
    private long[] distances;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new long[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, long[][] augmentedMatrix)
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + augmentedMatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + augmentedMatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + augmentedMatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private long distances[];
    private long[][] adjacencymatrix;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, long[][] reweightedGraph)
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new long[numberofvertices + 1];
        this.adjacencymatrix = new long[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = reweightedGraph[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        long min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        long edgeDistance = -1;
        long newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
    ///
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package Cuarto;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.Scanner;
public class Cuartomejorado
{//
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private long augmentedMatrix[][];
    private long potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private long[][] allPairShortestPath;
 public static ArrayList<Integer> hola;
    public static final int MAX_VALUE = 999999999;
 
    public Cuartomejorado(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new long[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new long[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new long[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        long reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            long[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	hola.add(source-1);
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private long[][] reweightGraph(int adjacencyMatrix[][])
    {
        long [][] result = new long[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
        	hola=new ArrayList<Integer> ();
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            Cuartomejorado johnsonsAlgorithm = new Cuartomejorado(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            Collections.sort(hola);
            for (int xd = 0; xd <hola.size(); xd++)
            {
            	 System.out.print(hola.get(xd)+" ");
            	 
            }
            System.out.println(" ");
            
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
      
    }
}
 
class BellmanFord 
{
    private long[] distances;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new long[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, long[][] augmentedMatrix)
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + augmentedMatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + augmentedMatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + augmentedMatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private long distances[];
    private long[][] adjacencymatrix;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, long[][] reweightedGraph)
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new long[numberofvertices + 1];
        this.adjacencymatrix = new long[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = reweightedGraph[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        long min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        long edgeDistance = -1;
        long newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
    ///
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package tercero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Scanner;


public class terceromejorado
{

    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private long augmentedMatrix[][];
    private long potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private long[][] allPairShortestPath;
 public static ArrayList<Integer> hola;
    public static final int MAX_VALUE = 999999999;
 
    public terceromejorado(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new long[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new long[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new long[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        long reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            long[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
            	  if(destination==numberOf){
                      if(allPairShortestPath[source][destination]<=numberOf2){
                      	numberOf4++;
                      	
                      }
                  	
                  }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private long[][] reweightGraph(int adjacencyMatrix[][])
    {
        long [][] result = new long[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
        	hola=new ArrayList<Integer> ();
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            terceromejorado johnsonsAlgorithm = new terceromejorado(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            System.out.println(numberOf4);
            numberOf4=0;
            
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
      
    }
}
 
class BellmanFord 
{
    private long[] distances;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new long[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, long[][] augmentedMatrix)
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + augmentedMatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + augmentedMatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + augmentedMatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private long distances[];
    private long[][] adjacencymatrix;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, long[][] reweightedGraph)
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new long[numberofvertices + 1];
        this.adjacencymatrix = new long[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = reweightedGraph[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        long min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        long edgeDistance = -1;
        long newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
    ///
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package tercero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.InputMismatchException;
import java.util.Scanner;
public class jhonson_ww 
{
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private int augmentedMatrix[][];
    private int potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private int[][] allPairShortestPath;
 
    public static final int MAX_VALUE = 999;
 
    public jhonson_ww(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new int[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new int[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new int[numberOfNodes + 1][numberOfNodes + 1];
    }
 ////
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        int reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            int[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private int[][] reweightGraph(int adjacencyMatrix[][])
    {
        int[][] result = new int[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
	
      
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            jhonson_ww johnsonsAlgorithm = new jhonson_ww(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            
            
            System.out.println(numberOf4);
            numberOf4=0;
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
       
    
    }
}
 
class BellmanFord 
{
    private int distances[];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new int[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, int adjacencymatrix[][])
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + adjacencymatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + adjacencymatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (adjacencymatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + adjacencymatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private int distances[];
    private int adjacencymatrix[][];
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, int adjacencymatrix[][])
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new int[numberofvertices + 1];
        this.adjacencymatrix = new int[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = adjacencymatrix[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        int min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        int edgeDistance = -1;
        int newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public int[] getDistances()
    {
        return distances;
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package tercero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Scanner;


public class terceromejorado
{

    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private long augmentedMatrix[][];
    private long potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private long[][] allPairShortestPath;
 public static ArrayList<Integer> hola;
    public static final int MAX_VALUE = 999999999;
 
    public terceromejorado(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new long[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new long[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new long[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        long reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            long[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
            	  if(destination==numberOf){
                      if(allPairShortestPath[source][destination]<=numberOf2){
                      	numberOf4++;
                      	
                      }
                  	
                  }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private long[][] reweightGraph(int adjacencyMatrix[][])
    {
        long [][] result = new long[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
        	hola=new ArrayList<Integer> ();
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            terceromejorado johnsonsAlgorithm = new terceromejorado(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            System.out.println(numberOf4);
            numberOf4=0;
            
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
      
    }
}
 
class BellmanFord 
{
    private long[] distances;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 99999999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new long[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, long[][] augmentedMatrix)
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + augmentedMatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + augmentedMatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + augmentedMatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private long distances[];
    private long[][] adjacencymatrix;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999999999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, long[][] reweightedGraph)
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new long[numberofvertices + 1];
        this.adjacencymatrix = new long[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = reweightedGraph[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        long min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        long edgeDistance = -1;
        long newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
    ///
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package Cuarto;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.Scanner;
public class Cuartomejorado
{//
    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private long augmentedMatrix[][];
    private long potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private long[][] allPairShortestPath;
 public static ArrayList<Integer> hola;
    public static final int MAX_VALUE = 999999999;
 
    public Cuartomejorado(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new long[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new long[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new long[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        long reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            long[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
               
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	hola.add(source-1);
                    	
                    }
                	
                }
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private long[][] reweightGraph(int adjacencyMatrix[][])
    {
        long [][] result = new long[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
        	hola=new ArrayList<Integer> ();
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            Cuartomejorado johnsonsAlgorithm = new Cuartomejorado(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            Collections.sort(hola);
            for (int xd = 0; xd <hola.size(); xd++)
            {
            	 System.out.print(hola.get(xd)+" ");
            	 
            }
            System.out.println(" ");
            
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
      
    }
}
 
class BellmanFord 
{
    private long[] distances;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 99999999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new long[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, long[][] augmentedMatrix)
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + augmentedMatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + augmentedMatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + augmentedMatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private long distances[];
    private long[][] adjacencymatrix;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 99999999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, long[][] reweightedGraph)
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new long[numberofvertices + 1];
        this.adjacencymatrix = new long[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = reweightedGraph[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        long min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        long edgeDistance = -1;
        long newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
    ///
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/**
 * 
 */
package tercero;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.Scanner;


public class terceromejorado
{

    private int SOURCE_NODE;
    static long TInicio;
	static long TFin;
	static long tiempo; 
    private int numberOfNodes;
    public static int numberOf;
    public static int numberOf2;
    public static int numberOf4=0;
    private long augmentedMatrix[][];
    private long potential[];
    private BellmanFord bellmanFord;
    private DijkstraShortesPath dijsktraShortesPath;
    private long[][] allPairShortestPath;
 public static ArrayList<Integer> hola;
    public static final int MAX_VALUE = 999999999;
 
    public terceromejorado(int numberOfNodes)
    {
        this.numberOfNodes = numberOfNodes;
        augmentedMatrix = new long[numberOfNodes + 2][numberOfNodes + 2];
        SOURCE_NODE = numberOfNodes + 1;
        potential = new long[numberOfNodes + 2];
        bellmanFord = new BellmanFord(numberOfNodes + 1);
        dijsktraShortesPath = new DijkstraShortesPath(numberOfNodes);
        allPairShortestPath = new long[numberOfNodes + 1][numberOfNodes + 1];
    }
 
    public void johnsonsAlgorithms(int adjacencyMatrix[][])
    {
        computeAugmentedGraph(adjacencyMatrix);
 
        bellmanFord.BellmanFordEvaluation(SOURCE_NODE, augmentedMatrix);
        potential = bellmanFord.getDistances();
 
        long reweightedGraph[][] = reweightGraph(adjacencyMatrix);
        
 
        for (int source = 1; source <= numberOfNodes; source++)
        {
            dijsktraShortesPath.dijkstraShortestPath(source, reweightedGraph);
            long[] result = dijsktraShortesPath.getDistances();
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                allPairShortestPath[source][destination] = result[destination] 
                        + potential[destination] - potential[source];
            }
        }
 
       
        for (int i = 1; i<= numberOfNodes; i++)
        {
            
        }
       
        for (int source = 1; source <= numberOfNodes; source++)
        {
            
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                if(destination==numberOf){
                    if(allPairShortestPath[source][destination]<=numberOf2){
                    	numberOf4++;
                    	hola.add(source-1);
                    	
                    }
                }
                
            }
        
        }
    }
 
    private void computeAugmentedGraph(int adjacencyMatrix[][])
    {
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            { 
                augmentedMatrix[source][destination] = adjacencyMatrix[source][destination];
            }
        }
        for (int destination = 1; destination <= numberOfNodes; destination++)
        {
            augmentedMatrix[SOURCE_NODE][destination] = 0;
        }
    }
 
    private long[][] reweightGraph(int adjacencyMatrix[][])
    {
        long [][] result = new long[numberOfNodes + 1][numberOfNodes + 1];
        for (int source = 1; source <= numberOfNodes; source++)
        {
            for (int destination = 1; destination <= numberOfNodes; destination++)
            {
                result[source][destination] = adjacencyMatrix[source][destination]
                       + potential[source] - potential[destination];
            }
        }
        return result;
    }
    public static int[] readInts(String cad) {
		String line[] = cad.split( " " );
		int arr[] = new int[line.length];
		for ( int i = 0; i < arr.length; i++ ) {
			arr[i] = Integer.parseInt( line[i] );
		}
		return arr;
	}
    public static void main(String... arg) throws FileNotFoundException
    {
        int adjacency_matrix[][];
        int number_of_vertices;
        Scanner scan;
        File f = new File( "P1G3_1.txt" );
		if ( f.exists() ) {
			scan = new Scanner( f );
			// System.setOut( new PrintStream( "P1G3_1Out.txt" ) );
		} else {
			scan = new Scanner( System.in );
		}
		
		int num= Integer.parseInt( scan.nextLine() );
		
        for (int y = 1; y <= num; y++)
        {
        	System.out.println( "Case #" + ( y) + ":" );
        	hola=new ArrayList<Integer> ();
			int arr[] = readInts( scan.nextLine() );
			int n = arr[0];
			numberOf= (arr[1]+1);
			numberOf2= arr[2];
        try
        {
            
            number_of_vertices = n;
            adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];
 
            
            for (int i = 1; i <= number_of_vertices; i++)
            {
                for (int j = 1; j <= number_of_vertices; j++)
                {
                    if (i == j) 
                    {
                        adjacency_matrix[i][j] = 0;
                        
                    }else
                    {
                        adjacency_matrix[i][j] = MAX_VALUE;
                    }
                }
            }
           
            String s[] = scan.nextLine().split( " " );
			
			int va = Integer.parseInt(s[0] );
            for (int x = 1; x <= va; x++)
            {String sd[] = scan.nextLine().split( " " );
			
            	 int a = Integer.parseInt(sd[0] );
            	 int b = Integer.parseInt(sd[1] );
            	 int c = Integer.parseInt(sd[2] );
            	
            	adjacency_matrix[a+1][b+1]=c;
            }
 
            terceromejorado johnsonsAlgorithm = new terceromejorado(number_of_vertices);
            johnsonsAlgorithm.johnsonsAlgorithms(adjacency_matrix);
            Collections.sort(hola);
            for (int xd = 0; xd <hola.size(); xd++)
            {
            	 System.out.print(hola.get(xd)+" ");
            	 
            }
            System.out.println(" ");
            
        } catch (InputMismatchException inputMismatch)
        {
          
        }
        }
        scan.close();
      
    }
}
 
class BellmanFord 
{
    private long[] distances;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999;
 
    public BellmanFord(int numberofvertices)  
    {
        this.numberofvertices = numberofvertices;
        distances = new long[numberofvertices + 1];
    }
 
    public void BellmanFordEvaluation(int source, long[][] augmentedMatrix)
    {
        for (int node = 1; node <= numberofvertices; node++)
        {
            distances[node] = MAX_VALUE;
        }
 
        distances[source] = 0;
 
        for (int node = 1; node <= numberofvertices - 1; node++)
        {
            for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
            {
                for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
                {
                    if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                    {
                        if (distances[destinationnode] > distances[sourcenode] 
                               + augmentedMatrix[sourcenode][destinationnode])
                        {
                            distances[destinationnode] = distances[sourcenode]
                               + augmentedMatrix[sourcenode][destinationnode];
                        }
                    }
                }
            }
        }
 
        for (int sourcenode = 1; sourcenode <= numberofvertices; sourcenode++)
        {
            for (int destinationnode = 1; destinationnode <= numberofvertices; destinationnode++)
            {
                if (augmentedMatrix[sourcenode][destinationnode] != MAX_VALUE)
                {
                    if (distances[destinationnode] > distances[sourcenode]
                            + augmentedMatrix[sourcenode][destinationnode]);
                        
	        }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
}
 
class DijkstraShortesPath
{
    private boolean settled[];
    private boolean unsettled[];
    private long distances[];
    private long[][] adjacencymatrix;
    private int numberofvertices;
 
    public static final int MAX_VALUE = 999999999;
 
    public DijkstraShortesPath(int numberofvertices)
    {
        this.numberofvertices = numberofvertices;
    }
 
    public void dijkstraShortestPath(int source, long[][] reweightedGraph)
    {
        this.settled = new boolean[numberofvertices + 1];
        this.unsettled = new boolean[numberofvertices + 1];
        this.distances = new long[numberofvertices + 1];
        this.adjacencymatrix = new long[numberofvertices + 1][numberofvertices + 1];
 
        int evaluationnode;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            distances[vertex] = MAX_VALUE;
        }
 
        for (int sourcevertex = 1; sourcevertex <= numberofvertices; sourcevertex++)
        {
            for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
            {
                this.adjacencymatrix[sourcevertex][destinationvertex] 
                     = reweightedGraph[sourcevertex][destinationvertex];
            }
        }
 
        unsettled[source] = true;
        distances[source] = 0;
        while (getUnsettledCount(unsettled) != 0)
        {
            evaluationnode = getNodeWithMinimumDistanceFromUnsettled(unsettled);
            unsettled[evaluationnode] = false;
            settled[evaluationnode] = true;
            evaluateNeighbours(evaluationnode);
        }
    } 
 
    public int getUnsettledCount(boolean unsettled[])
    {
        int count = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true)
            {
                count++;
            }
        }
        return count;
    }
 
    public int getNodeWithMinimumDistanceFromUnsettled(boolean unsettled[])
    {
        long min = MAX_VALUE;
        int node = 0;
        for (int vertex = 1; vertex <= numberofvertices; vertex++)
        {
            if (unsettled[vertex] == true && distances[vertex] < min)
            {
                node = vertex;
                min = distances[vertex];
            }
        }
        return node;
    }
 
    public void evaluateNeighbours(int evaluationNode)
    {
        long edgeDistance = -1;
        long newDistance = -1;
 
        for (int destinationNode = 1; destinationNode <= numberofvertices; destinationNode++)
        {
            if (settled[destinationNode] == false)
            {
                if (adjacencymatrix[evaluationNode][destinationNode] != MAX_VALUE)
                {
                    edgeDistance = adjacencymatrix[evaluationNode][destinationNode];
                    newDistance = distances[evaluationNode] + edgeDistance;
                    if (newDistance < distances[destinationNode])
                    {
                        distances[destinationNode] = newDistance;
                    }
                    unsettled[destinationNode] = true;
                }
            }
        }
    }
 
    public long[] getDistances()
    {
        return distances;
    }
    ///
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
