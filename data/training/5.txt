import java.util.Scanner;

public class Operadores {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int casos, num;
		int mayor, menor, igual;
		
		int[] numeros;
		
		casos = in.nextInt();
		
		for (int i=1; i<=casos; i++){
			
			num = in.nextInt();
			numeros = new int[num];
			
			mayor = 0;
			menor = 0;
			igual = 0;
			
			for (int j=0; j<numeros.length; j++){
				numeros[j] = in.nextInt();
			}
			
			for (int j=0; j<numeros.length; j++){	
				for (int k=0; k<numeros.length; k++){
					if(j==k){
					} else if(numeros[j]>numeros[k]){
						mayor++;
						
					} else if(numeros[j]<numeros[k]){
						menor++;
						
					}else if(numeros[j]==numeros[k]){
						igual++;	
					}
				}
			}	
			
			System.out.println("Case #" + i + ":");
			System.out.println(mayor);
			System.out.println(menor);
			System.out.println(igual);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Torneo {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int casos, numeq, visit;
		
		int[][] colores;
		
		casos = in.nextInt();
		
		for (int i=1; i<=casos; i++){
			
			numeq = in.nextInt();
			colores = new int[numeq][2];
			
			visit = 0;
			
			for (int j=0; j<numeq; j++){
				for (int k=0; k<2; k++){
					colores[j][k] = in.nextInt();
				}
			}
			
			for (int j=0; j<colores.length; j++){
				for (int k=0; k<colores.length; k++){
					if(colores[j][0]==colores[k][1]){
						visit++;
					}
				}
			}
			
			System.out.println("Case #" + i + ":");
			System.out.println(visit);
			
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Torneo {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int casos, numeq, visit;
		
		int[][] colores;
		casos = in.nextInt();
		
		for (int i=1; i<=casos; i++){
			
			numeq = in.nextInt();
			colores = new int[numeq][2];
			
			visit = 0;
			
			for (int j=0; j<numeq; j++){
				for (int k=0; k<2; k++){
					colores[j][k] = in.nextInt();
				}
			}
			for (int j=0; j<numeq; j++){
				for (int k=0; k<numeq; k++){
					if(colores[j][0]==colores[k][1]){
						visit++;
					}
				}
			}
			System.out.println("Case #" + i + ":");
			System.out.println(visit);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Tablero {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int casos, tam, gana;
		int[] fila;
		int[] colu;
		int[][] tablero;
		
		for (int i=1; i<=100; i++){
			
			gana=0;
			tam = in.nextInt();
			
			tablero = new int[tam][tam];
			fila = new int[tam];
			colu = new int[tam];

			for (int j=0; j<tablero.length; j++){	
				for (int k=0; k<tam; k++){
					tablero[j][k] = in.nextInt();
				}
			}
			
			for (int j=0; j<tam; j++){
					
				fila[j]=0;
				colu[j]=0;
					
				for (int k=0; k<tam; k++){
					fila[j] += tablero[j][k];
					colu[j] += tablero[k][j];	
				}
				
			}
			
			for (int j=0; j<tam; j++){
				for (int k=0; k<tam; k++){
					if(fila[j]<colu[k]){
						gana++;
					}
				}
			}
			
			System.out.println("Case #" + i + ":");
			System.out.println(gana);	
		}		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Tablero {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int casos, tam, gana;
		int[] fila;
		int[] colu;
		int[][] tablero;
		
		for (int i=1; i<=100; i++){
			
			gana=0;
			tam = in.nextInt();
			
			tablero = new int[tam][tam];
			fila = new int[tam];
			colu = new int[tam];

			for (int j=0; j<tablero.length; j++){	
				for (int k=0; k<tam; k++){
					tablero[j][k] = in.nextInt();
				}
			}
			
			for (int j=0; j<tam; j++){
					
				fila[j]=0;
				colu[j]=0;
					
				for (int k=0; k<tam; k++){
					fila[j] += tablero[j][k];
					colu[j] += tablero[k][j];	
				}
				
			}
			
			for (int j=0; j<tam; j++){
				for (int k=0; k<tam; k++){
					if(fila[j]<colu[k]){
						gana++;
					}
				}
			}
			
			System.out.println("Case #" + i + ":");
			System.out.println(gana);	
		}		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Tablero {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int casos, tam, gana, i;
		int[] fila;
		int[] colu;
		int[][] tablero;
		
		//for (int i=1; i<=100; i++){
		while(in.hasNext()){
			
			i=1;
			gana=0;
			
			tam = in.nextInt();
			
		
				
			tablero = new int[tam][tam];
			fila = new int[tam];
			colu = new int[tam];

			for (int j=0; j<tablero.length; j++){	
				for (int k=0; k<tam; k++){
					tablero[j][k] = in.nextInt();
				}
			}
			
			for (int j=0; j<tam; j++){
					
				fila[j]=0;
				colu[j]=0;
					
				for (int k=0; k<tam; k++){
					fila[j] += tablero[j][k];
					colu[j] += tablero[k][j];	
				}
			}
			for (int j=0; j<tam; j++){
				for (int k=0; k<tam; k++){
					if(fila[j]<colu[k]){
						gana++;
					}
				}
			}
			
			System.out.println("Case #" + i + ":");
			System.out.println(gana);	
			
		}		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Tablero {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int casos, tam, gana, i=1;
		int[] fila;
		int[] colu;
		int[][] tablero;
		
		//for (int i=1; i<=100; i++){
		while(in.hasNext()){
			
			
			gana=0;
			
			tam = in.nextInt();
			
		
				
			tablero = new int[tam][tam];
			fila = new int[tam];
			colu = new int[tam];

			for (int j=0; j<tablero.length; j++){	
				for (int k=0; k<tam; k++){
					tablero[j][k] = in.nextInt();
				}
			}
			
			for (int j=0; j<tam; j++){
					
				fila[j]=0;
				colu[j]=0;
					
				for (int k=0; k<tam; k++){
					fila[j] += tablero[j][k];
					colu[j] += tablero[k][j];	
				}
			}
			for (int j=0; j<tam; j++){
				for (int k=0; k<tam; k++){
					if(fila[j]<colu[k]){
						gana++;
					}
				}
			}
			
			System.out.println("Case #" + i + ":");
			System.out.println(gana);
			
			i++;
		}		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Torneo {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int numeq, visit, casos;
		
		int[][] colores;
		casos = in.nextInt();
		
		for (int i=1; i<=casos; i++){
			
			numeq = in.nextInt();
			colores = new int[numeq][2];
			
			visit = 0;
			
			for (int j=0; j<numeq; j++){
				for (int k=0; k<2; k++){
					colores[j][k] = in.nextInt();
				}
			}
			for (int j=0; j<numeq; j++){
				for (int k=0; k<numeq; k++){
					if(colores[j][0]==colores[k][1]){
						visit++;
					}
				}
			}
			System.out.println("Case #" + i + ":");
			System.out.println(visit);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Torneo {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int numeq, visit, casos;
		
		int[][] colores;
		casos = in.nextInt();
		
		for (int i=1; i<=casos; i++){
			
			numeq = in.nextInt();
			colores = new int[numeq][2];
			
			visit = 0;
			
			for (int j=0; j<numeq; j++){
				for (int k=0; k<2; k++){
					colores[j][k] = in.nextInt();
				}
			}
			for (int m=0; m<numeq; m++){
				for (int n=0; n<numeq; n++){
					if(m==n){
					}else if(colores[m][0]==colores[n][1]){
						visit++;
					}
				}
			}
			System.out.println("Case #" + i + ":");
			System.out.println(visit);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


public class Piedras {

	/*static void swap(char x, char y)
	{
	    char temp;
	    temp = x;
	    x = y;
	    y = temp;
	    
	    
	}*/
	
	static char[] swap(char[]a, int i, int j)
	{
	    char temp;
	    temp = a[i];
	    a[i] = a[j];
	    a[j] = temp;
		return a;
	    
	    
	}
	/*static void permute(char[] a,int x, int z)
	{
		
	    int p;
	    
	    if (x == z){
	    	System.out.println(a);
	    }
	        
	        for (p = x; p <= z; p++)
	        {
	            swap(a[x], a[p]);
	            
	            permute(a, x + 1, z);
	            
	            swap(a[x], a[p]); //backtrack
	        }
	        
	}*/
	
	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		Scanner ch = new Scanner(System.in);
		
		int casos, num, fac=1;
		String cadena, cadesp;
		
		char[] piedras, aux, arr = null;
		Object[] combin;
		
		casos = in.nextInt();
		
		
		
		for (int n=1; n<=casos; n++){
			
			fac=1;
			num = in.nextInt();
			
			while (num!=0) {
				 fac*=num;
				 num--;
			}
			
			piedras = new char[num];
			aux = new char[num];
			/*combin = new char[num][fac];*/
			combin = new Object[fac];
			cadesp = ch.nextLine();
			cadena = cadesp.replace(" ","");
			
			piedras = cadena.toCharArray();
			
			
			
			combin[0]="abc";
			combin[1]=1;
			
			

				for(int j=0;j<num;j++){
					
					for(int k=0;k<num;k++){
						
						arr = swap(piedras, j, k);
						combin[j+k] = arr;
					}
				}
			
			
			
			
			/*for (int i=0; i<num; i++){
				aux[i+1]=piedras[i];
				aux[i]=piedras[i-1];
				aux[i-1]=piedras[i+1];
				for (int j=0; j<num; j++){
					combin[i][j] = aux[j];
				}
			}*/
			
			
			
			
			
			System.out.println("Case " + n + ":");
			
			for(int i=0;i<fac;i++){
				System.out.println(combin[i]);
			}
			
			
			for (int i1=0; i1<num; i1++){
				for (int j1=0; j1<num; j1++){
					//System.out.println(combin[i1][j1]);
					
					
				}
			}
			
			
			
		}
		
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Juego {

	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		int casos, num;
		int uno, cont;
		
		int[] numeros;
		
		casos = in.nextInt();
		
		for (int i=1; i<=casos; i++){
			
			num = in.nextInt();
			numeros = new int[num];
			
			uno=0;
			cont=0;
			
			for (int j=0; j<numeros.length; j++){
				numeros[j] = in.nextInt();
			}
			
			
			while (cont<2){
			for (int j=0; j<numeros.length; j++){		
				if (numeros[j]==0){
						numeros[j] = 1;
						cont++;
				}else{}
				
			}
			}
			
			
			for (int j=0; j<numeros.length; j++){
				
				if (numeros[j]==1){
					uno++;
				
				}
			}
			
			/*for (int j=0; j<numeros.length; j++){
			System.out.println(numeros[j]);
			}*/
			
			System.out.println(uno);
			
		}
	}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Problema_C;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class Norma {
	
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File("C:/Users/jaime_000/Desktop/C_1.txt");
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine()); // numero de casos de prueba
		for (int test = 0; test < t; test++) {
			System.out.print("Case #" + ++test + ":\n");
			test--;

			Set<Integer> progN = new HashSet<Integer>();
			Set<Integer> progM = new HashSet<Integer>();
			Set<Integer> progP = new HashSet<Integer>();
			Set<Integer> uniqueProgN = new TreeSet<Integer>();
			Set<Integer> uniqueProgM = new TreeSet<Integer>();
			Set<Integer> uniqueProgP = new TreeSet<Integer>();
			Set<Integer> allProg = new HashSet<Integer>();

			int uniqN = 0;
			int uniqM = 0;
			int uniqP = 0;

			String lines[] = scan.nextLine().split(" "); // leer linea
			int N = Integer.parseInt(lines[0]); // cantidad de problemas por
												// Norma
			int M = Integer.parseInt(lines[1]); // cantidad de problemas por
												// Mario
			int P = Integer.parseInt(lines[2]); // cantidad de problemas por
												// Pipe

			String problemasN[] = scan.nextLine().split(" "); // leer linea
																// Norma
			String problemasM[] = scan.nextLine().split(" "); // leer linea
																// Mario
			String problemasP[] = scan.nextLine().split(" "); // leer linea Pipe

			for (int i = 0; i < N; i++) {
				int pN = Integer.parseInt(problemasN[i]);
				progN.add(pN);
			}
			for (int i = 0; i < M; i++) {
				int pM = Integer.parseInt(problemasM[i]);
				progM.add(pM);
			}
			for (int i = 0; i < P; i++) {
				int pP = Integer.parseInt(problemasP[i]);
				progP.add(pP);
			}

			for (int i = 0; i < N; i++) {
				int pN = Integer.parseInt(problemasN[i]);
				allProg.add(pN);
			}
			for (int i = 0; i < M; i++) {
				int pM = Integer.parseInt(problemasM[i]);
				allProg.add(pM);
			}
			for (int i = 0; i < P; i++) {
				int pP = Integer.parseInt(problemasP[i]);
				allProg.add(pP);
			}
			for (int element : allProg) {
				if (progN.contains(element) && !progM.contains(element) && !progP.contains(element)) {
					uniqueProgN.add(element);
					uniqN++;
				} else if (progM.contains(element) && !progP.contains(element) && !progN.contains(element)) {
					uniqueProgM.add(element);
					uniqM++;
				} else if (progP.contains(element) && !progN.contains(element) && !progM.contains(element)) {
					uniqueProgP.add(element);
					uniqP++;
				}
			}

			Person p1 = new Person("Norma", uniqN, uniqueProgN);
			Person p2 = new Person("Mario", uniqM, uniqueProgM);
			Person p3 = new Person("Pipe", uniqP, uniqueProgP);

			if (uniqN > uniqM && uniqN > uniqP) {

				System.out.print(p1 + " ");
				for (Integer element : uniqueProgN) {
					System.out.print(element + " ");
				}
				System.out.println();

			} else if (uniqM > uniqN && uniqM > uniqP) {
				System.out.print(p2 + " ");

				for (Integer element : uniqueProgM) {
					System.out.print(element + " ");
				}
				System.out.println();

			} else if (uniqP > uniqN && uniqP > uniqM) {

				System.out.print(p3 + " ");

				for (Integer element : uniqueProgP) {
					System.out.print(element + " ");
				}
				System.out.println();

			} else if (uniqN == uniqM && uniqN == uniqP && uniqM == uniqP) {
				System.out.print(p1 + " ");
				for (Integer element : uniqueProgN) {
					System.out.print(element + " ");
				}
				System.out.println();
				System.out.print(p2 + " ");
				for (Integer element : uniqueProgM) {
					System.out.print(element + " ");
				}
				System.out.println();
				System.out.print(p3 + " ");
				for (Integer element : uniqueProgP) {
					System.out.print(element + " ");
				}
				System.out.println();
				
			} else if (uniqN == uniqM) {
				System.out.print(p1 + " ");
				for (Integer element : uniqueProgN) {
					System.out.print(element + " ");
				}
				System.out.println();
				System.out.print(p2 + " ");
				for (Integer element : uniqueProgM) {
					System.out.print(element + " ");
				}
				System.out.println();

			} else if (uniqN == uniqP) {
				System.out.print(p1 + " ");
				for (Integer element : uniqueProgN) {
					System.out.print(element + " ");
				}
				System.out.println();

				System.out.print(p3 + " ");
				for (Integer element : uniqueProgP) {
					System.out.print(element + " ");
				}
				System.out.println();
			} else if (uniqM == uniqP) {
				System.out.print(p2 + " ");
				for (Integer element : uniqueProgM) {
					System.out.print(element + " ");
				}
				System.out.println();
				
				System.out.print(p3 + " ");
				for (Integer element : uniqueProgP) {
					System.out.print(element + " ");
				}
				System.out.println();
			}
		}
	}
}

class Person {

	private int num;
	private Set<Integer> programs = new HashSet<Integer>();
	private String name;

	public Person(String name, int num, Set<Integer> programs) {
		this.num = num;
		this.programs = programs;
		this.name = name;
	}

	public String toString() {
		return name + " " + num;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + num;
		result = prime * result + ((programs == null) ? 0 : programs.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (num != other.num)
			return false;
		if (programs == null) {
			if (other.programs != null)
				return false;
		} else if (!programs.equals(other.programs))
			return false;
		return true;
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Problema_D;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class Votaciones {

	public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map) {
		List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>(map.entrySet());
		Collections.sort(list, new Comparator<Map.Entry<K, V>>() {
			public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {
				return (o1.getValue()).compareTo(o2.getValue());
			}
		});
		Map<K, V> result = new LinkedHashMap<K, V>();
		for (Map.Entry<K, V> entry : list) {
			result.put(entry.getKey(), entry.getValue());
		}
		return result;
	}
	
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File("C:/Users/jaime_000/Desktop/D_2.txt");
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine()); // numero de casos de prueba
		for (int test = 0; test < t; test++) {
			System.out.print("Case #" + ++test + ":\n");
			test--;

			Map<String, String> map = new HashMap<String, String>(); // candidato -> partido
			Map<String, Integer> votacion = new HashMap<String, Integer>(); // partido -> votos totales
			Set<String> winners = new TreeSet<String>();

			int N = Integer.parseInt(scan.nextLine()); // numero de candidatos
			for (int c = 0; c < N; c++) {
				String lines[] = scan.nextLine().split(" "); // nombre y partido
				String candidato = lines[0];
				String partido = lines[1];
				int voto = 0;
				map.put(candidato, partido);
				votacion.put(partido, voto);
			}

			int cont = 0;
			int Q = Integer.parseInt(scan.nextLine()); // numero de votos
			for (int v = 0; v < Q; v++) {
				String lineC = scan.nextLine(); // candidato apoyado
				if (map.containsKey(lineC)) {
					cont = votacion.get(map.get(lineC));
					cont++;
					votacion.put(map.get(lineC), cont);
				} else {
				}
			}

			votacion = sortByValue(votacion);
			int x = 0;
			String winStr = null;
			for (Map.Entry<String, Integer> entry : votacion.entrySet()) {
				if (x == votacion.size() - 1) {
					winStr = entry.getKey();
				}
				x++;
			}

			for (Map.Entry<String, Integer> entry : votacion.entrySet()) {
				if (votacion.get(winStr) == entry.getValue()) {
					winners.add(entry.getKey());
				}
			}
			for (String element : winners) {
				System.out.println(element);
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Problema_D;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class Votaciones {

	public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map) {
		List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>(map.entrySet());
		Collections.sort(list, new Comparator<Map.Entry<K, V>>() {
			public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {
				return (o1.getValue()).compareTo(o2.getValue());
			}
		});
		Map<K, V> result = new LinkedHashMap<K, V>();
		for (Map.Entry<K, V> entry : list) {
			result.put(entry.getKey(), entry.getValue());
		}
		return result;
	}
	
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File("C:/Users/jaime_000/Desktop/D_2.txt");
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine()); // numero de casos de prueba
		for (int test = 0; test < t; test++) {
			System.out.print("Case #" + ++test + ":\n");
			test--;

			Map<String, String> map = new HashMap<String, String>(); // candidato -> partido
			Map<String, Integer> votacion = new HashMap<String, Integer>(); // partido -> votos totales
			Set<String> winners = new TreeSet<String>();

			int N = Integer.parseInt(scan.nextLine()); // numero de candidatos
			for (int c = 0; c < N; c++) {
				String lines[] = scan.nextLine().split(" "); // nombre y partido
				String candidato = lines[0];
				String partido = lines[1];
				int voto = 0;
				map.put(candidato, partido);
				votacion.put(partido, voto);
			}

			int cont = 0;
			int Q = Integer.parseInt(scan.nextLine()); // numero de votos
			for (int v = 0; v < Q; v++) {
				String lineC = scan.nextLine(); // candidato apoyado
				if (map.containsKey(lineC)) {
					cont = votacion.get(map.get(lineC));
					cont++;
					votacion.put(map.get(lineC), cont);
				} else {
				}
			}

			votacion = sortByValue(votacion);
			int x = 0;
			String winStr = null;
			for (Map.Entry<String, Integer> entry : votacion.entrySet()) {
				if (x == votacion.size() - 1) {
					winStr = entry.getKey();
				}
				x++;
			}

			for (Map.Entry<String, Integer> entry : votacion.entrySet()) {
				if (votacion.get(winStr) == entry.getValue()) {
					winners.add(entry.getKey());
				}
			}
			for (String element : winners) {
				System.out.println(element);
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Problema_D;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

public class Votaciones {

	public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map) {
		List<Map.Entry<K, V>> list = new LinkedList<Map.Entry<K, V>>(map.entrySet());
		Collections.sort(list, new Comparator<Map.Entry<K, V>>() {
			public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {
				return (o1.getValue()).compareTo(o2.getValue());
			}
		});
		Map<K, V> result = new LinkedHashMap<K, V>();
		for (Map.Entry<K, V> entry : list) {
			result.put(entry.getKey(), entry.getValue());
		}
		return result;
	}
	
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File("C:/Users/jaime_000/Desktop/D_2.txt");
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine()); // numero de casos de prueba
		for (int test = 0; test < t; test++) {
			System.out.print("Case #" + ++test + ":\n");
			test--;

			Map<String, String> map = new HashMap<String, String>(); // candidato -> partido
			Map<String, Integer> votacion = new TreeMap<String, Integer>(); // partido -> votos totales
			Set<String> winners = new TreeSet<String>();

			int N = Integer.parseInt(scan.nextLine()); // numero de candidatos
			for (int c = 0; c < N; c++) {
				String lines[] = scan.nextLine().split(" "); // nombre y partido
				String candidato = lines[0];
				String partido = lines[1];
				int voto = 0;
				map.put(candidato, partido);
				votacion.put(partido, voto);
			}

			int cont = 0;
			int Q = Integer.parseInt(scan.nextLine()); // numero de votos
			for (int v = 0; v < Q; v++) {
				String lineC = scan.nextLine(); // candidato apoyado
				if (map.containsKey(lineC)) {
					cont = votacion.get(map.get(lineC));
					cont++;
					votacion.put(map.get(lineC), cont);
				} else {
				}
			}

			votacion = sortByValue(votacion);
			int x = 0;
			String winStr = null;
			for (Map.Entry<String, Integer> entry : votacion.entrySet()) {
				if (x == votacion.size() - 1) {
					winStr = entry.getKey();
				}
				x++;
			}
			
			//System.out.println(winStr);

			for (Map.Entry<String, Integer> entry : votacion.entrySet()) {
				if (votacion.get(winStr).equals(entry.getValue())) {
					winners.add(entry.getKey());
				}
			}
			for (String element : winners) {
				System.out.println(element);
			}
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Problema_B;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

public class Pokemon {

	//////////////////////////////////////////////////////////////////////

	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File("C:/Users/jaime_000/Desktop/B_2.txt");
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine()); // numero de casos de
													// prueba
		for (int test = 0; test < t; test++) {
			System.out.print("Case #" + ++test + ":\n");
			test--;

			HashMap<Integer, Integer> comida = new HashMap<>();
			// Set<Integer> comidAux = new HashSet<Integer>();

			int N = Integer.parseInt(scan.nextLine()); // cantidad de
														// estanques
			int cont = 0;
			for (int estanque = 0; estanque < N; estanque++) {
				String lines[] = scan.nextLine().split(" "); // leer linea
				int A = Integer.parseInt(lines[0]); // comida del estanque i
				int B = Integer.parseInt(lines[1]); // pokemon del estanque
													// i
				if (A == B) {

				} else {
					Integer comidAux = comida.get(A);
					Integer poquemon = comida.get(B);
					
					if (comidAux == null) {
						comida.put(A, 1);
					} else {
						comida.put(A, comidAux + 1);
					}
					
					if (poquemon == null || poquemon <= 0) {
						cont++;
					} else {
						comida.put(B, poquemon-1);
					}
				}
			}
			
			System.out.println(cont);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Problema_E;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class PokemonCon {

	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File f = new File("C:/Users/jaime_000/Desktop/E_in.txt");
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine()); // numero de casos de
													// prueba
		for (int test = 0; test < t; test++) {
			System.out.print("Case #" + ++test + ":\n");
			test--;

			HashMap<Integer, Integer> comida = new HashMap<>();
			HashMap<Integer, Integer> comidaCas = new HashMap<>();
			
			int cont = 0;
			
			int N = Integer.parseInt(scan.nextLine()); // cantidad de
														// estanques
			for (int estanque = 0; estanque < N; estanque++) {
				String lines[] = scan.nextLine().split(" "); // leer linea
				int A = Integer.parseInt(lines[0]); // comida del estanque i
				int B = Integer.parseInt(lines[1]); // pokemon del estanque
													// i
				if (A == B) {

				} else {
					Integer comidAux = comida.get(A);
					Integer poquemon = comida.get(B);
					
					if (comidAux == null) {
						comida.put(A, 1);
					} else {
						comida.put(A, comidAux + 1);
					}
					
					if (poquemon == null || poquemon <= 0) {
						cont++;
						comidaCas.put(B, cont);
						
					} else {
						comida.put(B, poquemon-1);
						
					}
				}
			}
			System.out.println(cont);
			for( Map.Entry<Integer,Integer> entry : comidaCas.entrySet() ) {
				int key = entry.getKey();
				int value = entry.getValue();
				
				System.out.println(key + " " + value);	
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PA;

import java.io.File;
import java.io.FileNotFoundException;
import java.math.BigInteger;
import java.util.LinkedList;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/A_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int tam;
		BigInteger mult, higher;
		BigInteger[] numeros;

		LinkedList<BigInteger> multiplies = new LinkedList<BigInteger>();

		tam = scan.nextInt();
		numeros = new BigInteger[tam];

		for (int j = 0; j < numeros.length; j++) {
			numeros[j] = scan.nextBigInteger();
		}

		for (int j = 0; j < numeros.length; j++) {
			for (int k = 0; k < numeros.length; k++) {
				if (j == k) {
				} else {
					mult = numeros[j].multiply(numeros[k]);
					multiplies.add(mult);
				}
			}
		}
		higher = elementoMayor(multiplies);

		System.out.println(higher);
	}

	private static BigInteger elementoMayor(LinkedList<BigInteger> list) {
		BigInteger aux = BigInteger.ZERO;
		for (BigInteger value : list) {
			if (value.compareTo(aux) > 0) {
				aux = value;
			} else {
				continue;
			}
		}
		return aux;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/B_2.in");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int tam, gana;
		int i = 1;
		int[] fila;
		int[] colu;
		int[][] tablero;

		try {
			while (scan.hasNext()) {

				gana = 0;
				tam = scan.nextInt();

				tablero = new int[tam][tam];
				fila = new int[tam];
				colu = new int[tam];

				for (int j = 0; j < tablero.length; j++) {
					for (int k = 0; k < tam; k++) {
						tablero[j][k] = scan.nextInt();
					}
				}

				for (int j = 0; j < tam; j++) {

					fila[j] = 0;
					colu[j] = 0;

					for (int k = 0; k < tam; k++) {
						fila[j] += tablero[j][k];
						colu[j] += tablero[k][j];
					}
				}

				for (int j = 0; j < tam; j++) {
					for (int k = 0; k < tam; k++) {
						if (fila[j] < colu[k]) {
							gana++;
						}
					}
				}

				System.out.println("Case #" + i + ":");
				System.out.println(gana);

				i++;
			}
		} finally {
			scan.close();
			System.exit(0);
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PC;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/C_2.in");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int numEq, visit, casos;

		int[][] colores;
		casos = Integer.parseInt(scan.nextLine());

		for (int i = 1; i <= casos; i++) {

			numEq = scan.nextInt();
			colores = new int[numEq][2];

			visit = 0;

			for (int j = 0; j < numEq; j++) {
				for (int k = 0; k < 2; k++) {
					colores[j][k] = scan.nextInt();
				}
			}
			for (int m = 0; m < numEq; m++) {
				for (int n = 0; n < numEq; n++) {
					if (m == n) {
					} else if (colores[m][0] == colores[n][1]) {
						visit++;
					}
				}
			}
			System.out.println("Case #" + i + ":");
			System.out.println(visit);
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PD;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/D_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int N, casos;
		int cherryAmount, firstHalf, secondHalf;
		boolean band;
		char[][] choco;
		casos = Integer.parseInt(scan.nextLine());

		for (int i = 1; i <= casos; i++) {

			cherryAmount = 0;
			band = false;
			N = Integer.parseInt(scan.nextLine());

			choco = new char[N][N];

			for (int j = 0; j < N; j++) {
				String cad = scan.nextLine();
				for (int k = 0; k < N; k++) {
					choco[j][k] = new Character(cad.charAt(k));
					if (choco[j][k] == '#') {
						cherryAmount++;
					}
				}
			}

			if (cherryAmount % 2 != 0) {
				System.out.println("NO");
			} else {
				// System.out.println("?");

				for (int direct = 0; direct < 2; direct++) {

					for (int x = 1; x < choco.length; x++) {

						firstHalf = 0;
						secondHalf = 0;

						for (int row = 0; row < x; row++) {
							for (int col = 0; col < choco.length; col++) {

								if (direct == 0) {
									if (choco[row][col] == '#') {
										firstHalf++;
									}
								} else {
									if (choco[col][row] == '#') {
										firstHalf++;
									}
								}

							}
						}
						for (int row = x; row < choco.length; row++) {
							for (int col = 0; col < choco.length; col++) {
								if (direct == 0) {
									if (choco[row][col] == '#') {
										secondHalf++;
									}
								} else {
									if (choco[col][row] == '#') {
										secondHalf++;
									}
								}
							}
						}

						if (firstHalf == secondHalf) {
							band = true;
							break;
						} else {
							continue;
						}
					}

					if (band) {
						break;
					} else {
						continue;
					}
				}

				if (band) {
					System.out.println("YES");
				} else {
					System.out.println("NO");
				}

			}
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PD;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/D_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int N, casos;
		//int cherryAmount;
		int firstHalf, secondHalf;
		boolean band;
		char[][] choco;
		casos = Integer.parseInt(scan.nextLine());

		for (int i = 1; i <= casos; i++) {

			//cherryAmount = 0;
			band = false;
			N = Integer.parseInt(scan.nextLine());

			choco = new char[N][N];

			/*
			for (int j = 0; j < N; j++) {
				String cad = scan.nextLine();
				for (int k = 0; k < N; k++) {
					choco[j][k] = new Character(cad.charAt(k));
					if (choco[j][k] == '#') {
						cherryAmount++;
					}
				}
			}

			if (cherryAmount % 2 != 0) {
				System.out.println("NO");
			} else {
				
				
				for (int direct = 0; direct < 2; direct++) {

					for (int x = 1; x < choco.length; x++) {

						firstHalf = 0;
						secondHalf = 0;

						for (int row = 0; row < x; row++) {
							for (int col = 0; col < choco.length; col++) {

								if (direct == 0) {
									if (choco[row][col] == '#') {
										firstHalf++;
									}
								} else {
									if (choco[col][row] == '#') {
										firstHalf++;
									}
								}

							}
						}
						for (int row = x; row < choco.length; row++) {
							for (int col = 0; col < choco.length; col++) {
								if (direct == 0) {
									if (choco[row][col] == '#') {
										secondHalf++;
									}
								} else {
									if (choco[col][row] == '#') {
										secondHalf++;
									}
								}
							}
						}

						if (firstHalf == secondHalf) {
							band = true;
							break;
						} else {
							continue;
						}
					}

					if (band) {
						break;
					} else {
						continue;
					}
				}

				if (band) {
					System.out.println("YES");
				} else {
					System.out.println("NO");
				}

			}
			*/
			
			//////////////////////////////
			
			for (int j = 0; j < N; j++) {
				String cad = scan.nextLine();
				for (int k = 0; k < N; k++) {
					choco[j][k] = new Character(cad.charAt(k));
					
				}
			}
			
			
			for (int direct = 0; direct < 2; direct++) {

				for (int x = 1; x < choco.length; x++) {

					firstHalf = 0;
					secondHalf = 0;

					for (int row = 0; row < x; row++) {
						for (int col = 0; col < choco.length; col++) {

							if (direct == 0) {
								if (choco[row][col] == '#') {
									firstHalf++;
								}
							} else {
								if (choco[col][row] == '#') {
									firstHalf++;
								}
							}

						}
					}
					for (int row = x; row < choco.length; row++) {
						for (int col = 0; col < choco.length; col++) {
							if (direct == 0) {
								if (choco[row][col] == '#') {
									secondHalf++;
								}
							} else {
								if (choco[col][row] == '#') {
									secondHalf++;
								}
							}
						}
					}

					if (firstHalf == secondHalf) {
						band = true;
						break;
					} else {
						continue;
					}
				}

				if (band) {
					break;
				} else {
					continue;
				}
			}

			if (band) {
				System.out.println("YES");
			} else {
				System.out.println("NO");
			}
			
			
			
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PF;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/F.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int te;
		int[] answer = new int[5];
		int correct = 0;

		te = Integer.parseInt(scan.nextLine());

		for (int j = 0; j < answer.length; j++) {
			answer[j] = scan.nextInt();
		}

		for (int j = 0; j < answer.length; j++) {
			if (answer[j] == te) {
				correct++;
			}
		}
		
		System.out.println(correct);

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PE;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/E.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int casos;

		casos = Integer.parseInt(scan.nextLine());
		for (int i = 1; i <= casos; i++) {

			String line[] = scan.nextLine().split(" ");
			int D = Integer.parseInt(line[0]);
			int X = Integer.parseInt(line[1]);
			int Y = Integer.parseInt(line[2]);

			Double S = Math.pow(X, 2) + Math.pow(Y, 2);
			
			if (S==0) {
				System.out.println(0);
			} else if (D==1) {
				long L = Math.round(Math.sqrt(S));
				System.out.println(L);
			} else {
				Double div = S/D;
				long L = Math.round(Math.sqrt(div));
				System.out.println(L);
			}
		}
		
		

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PD2;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/D_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int N, casos;
		int cherryAmount, contRow, contCol;
		int sumRowFirst, sumColFirst, sumRowSecond, sumColSecond;
		char[][] choco;
		casos = Integer.parseInt(scan.nextLine());
		int[] sumRow, sumCol;
		int[] firstHalfRow, secondHalfRow, firstHalfCol, secondHalfCol;
		String str;
		boolean band;

		for (int i = 1; i <= casos; i++) {

			cherryAmount = 0;
			sumRowFirst = 0;
			sumRowSecond = 0;
			sumColFirst = 0;
			sumColSecond = 0;
			str = "NO";
			band = false;

			N = Integer.parseInt(scan.nextLine());

			choco = new char[N][N];
			sumRow = new int[N];
			sumCol = new int[N];
			firstHalfRow = new int[N - 1];
			secondHalfRow = new int[N - 1];
			firstHalfCol = new int[N - 1];
			secondHalfCol = new int[N - 1];

			for (int j = 0; j < N; j++) {
				String cad = scan.nextLine();
				for (int k = 0; k < N; k++) {
					choco[j][k] = new Character(cad.charAt(k));
					if (choco[j][k] == '#') {
						cherryAmount++;
					}
				}
			}

			for (int j = 0; j < N; j++) {
				contRow = 0;
				contCol = 0;
				for (int k = 0; k < N; k++) {
					if (choco[j][k] == '#') {
						cherryAmount++;
						contRow++;
						sumRow[j] = contRow;
					}
					if (choco[k][j] == '#') {
						contCol++;
						sumCol[j] = contCol;
					}
				}

			}

			if (cherryAmount % 2 != 0) {
				band = false;
			} else {

				for (int j = 0; j < N - 1; j++) {
					sumRowFirst += sumRow[j];
					sumColFirst +=sumCol[j];
					firstHalfRow[j] = sumRowFirst;
					firstHalfCol[j] = sumColFirst;
				}
				for (int j = N - 1; j > 0; j--) {
					sumRowSecond += sumRow[j];
					sumColSecond += sumCol[j];
					secondHalfRow[j - 1] = sumRowSecond;
					secondHalfCol[j - 1] = sumColSecond;
				}
				for (int k = 0; k < N - 1; k++) {
					if (firstHalfRow[k] == secondHalfRow[k] || firstHalfCol[k] == secondHalfCol[k]) {
						band = true;
						k = N - 1;
					}
				}
			}

			if(band){
				System.out.println("YES");
			}else{
				System.out.println("NO");
			}
			
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PD2;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/D_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int N, casos;
		int cherryAmount, contRow, contCol;
		int sumRowFirst, sumColFirst, sumRowSecond, sumColSecond;
		char[][] choco;
		int[] sumRow, sumCol;
		int[] firstHalfRow, secondHalfRow, firstHalfCol, secondHalfCol;
		boolean band;

		casos = Integer.parseInt(scan.nextLine());
		for (int i = 1; i <= casos; i++) {

			cherryAmount = 0;
			sumRowFirst = 0;
			sumRowSecond = 0;
			sumColFirst = 0;
			sumColSecond = 0;
			band = false;

			N = Integer.parseInt(scan.nextLine());

			choco = new char[N][N];
			sumRow = new int[N];
			sumCol = new int[N];
			firstHalfRow = new int[N - 1];
			secondHalfRow = new int[N - 1];
			firstHalfCol = new int[N - 1];
			secondHalfCol = new int[N - 1];

			for (int j = 0; j < N; j++) {
				String cad = scan.nextLine();
				for (int k = 0; k < N; k++) {
					choco[j][k] = new Character(cad.charAt(k));
					if (choco[j][k] == '#') {
						cherryAmount++;
					}
				}
			}

			for (int j = 0; j < N; j++) {
				contRow = 0;
				contCol = 0;
				for (int k = 0; k < N; k++) {
					if (choco[j][k] == '#') {
						cherryAmount++;
						contRow++;
						sumRow[j] = contRow;
					}
					if (choco[k][j] == '#') {
						contCol++;
						sumCol[j] = contCol;
					}
				}
			}

			if (cherryAmount % 2 != 0) {
				band = false;
			} else {

				for (int j = 0; j < N - 1; j++) {
					sumRowFirst += sumRow[j];
					sumColFirst += sumCol[j];
					firstHalfRow[j] = sumRowFirst;
					firstHalfCol[j] = sumColFirst;
				}
				for (int j = N - 1; j > 0; j--) {
					sumRowSecond += sumRow[j];
					sumColSecond += sumCol[j];
					secondHalfRow[j - 1] = sumRowSecond;
					secondHalfCol[j - 1] = sumColSecond;
				}
				for (int k = 0; k < N - 1; k++) {
					if (firstHalfRow[k] == secondHalfRow[k] || firstHalfCol[k] == secondHalfCol[k]) {
						band = true;
						break;
					} else
						continue;
				}
			}

			if (band) {
				System.out.println("YES");
			} else {
				System.out.println("NO");
			}
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

	//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
	
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * LinkedList class implements a doubly-linked list.
		 */
		
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    /**
	     *  Returns the index of the first occurrence of the given value in the list,
		 *  or -1 if the value is not found in the list.
	     */
	    public int indexOf(AnyType x) {
	    	int index = 0;
	        if (x == null) {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (p.data == null)
	                    return index;
	                index++;
	            }
	        } else {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (x.equals(p.data))
	                	return index;
	                index++;
	            }
	        }
	        return -1;
		}
	    
	    /**
	     * Returns {true} if this list contains the specified element.
	     */
	    public boolean contains(AnyType x) {
	        return indexOf(x) != -1;
	    }
		
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	//----------------------------------------------------------------------------------//
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/B_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < t; test++) {
			
			System.out.print("Caso #" + ++test + ":\n");
			test--;

			MyLinkedList<Integer> deck = new MyLinkedList<Integer>();
			MyLinkedList<Integer> players = new MyLinkedList<Integer>();
			MyLinkedList<Integer> winners = new MyLinkedList<Integer>();

			int N = 0, K = 0;
			int greater = 0;
			int move = 0;

			String s[] = scan.nextLine().split(" ");

			N = Integer.parseInt(s[0]);
			K = Integer.parseInt(s[1]);

			String cards = scan.nextLine();
			deck = readInts(cards);

			for (int i = 0; i < K; i++) {
				if (deck.isEmpty()) {
					break;
				}

				if (deck.get(0) > deck.get(deck.size()-1)) {
					if (players.size() <= i) {
						players.add(i, deck.remove(0));
					} else {
						players.set(i, players.get(i) + deck.remove(0));
					}
				} else {
					if (players.size() <= i) {
						players.add(i, deck.remove(deck.size()-1));
					} else {
						players.set(i, players.get(i) + deck.remove(deck.size()-1));
					}
				}
				if (i == K - 1) {
					i = -1;
				}

			}

			greater = elementoMayor(players);

			for (Integer player : players) {
				if (player.equals(greater)) {
					winners.add(players.indexOf(player) + move);
					move++;
				}
			}
			
			for (Integer win : winners) {
				System.out.print(win + " ");
			}
			System.out.println();
			
		}

	}

	public static MyLinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		MyLinkedList<Integer> lista = new MyLinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

	private static Integer elementoMayor(MyLinkedList<Integer> list) {
		Integer aux = 0;
		for (Integer value : list) {
			if (value.compareTo(aux) > 0) {
				aux = value;
			} else {
				continue;
			}
		}
		return aux;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

	//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
	
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * LinkedList class implements a doubly-linked list.
		 */
		
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    /**
	     *  Returns the index of the first occurrence of the given value in the list,
		 *  or -1 if the value is not found in the list.
	     */
	    public int indexOf(AnyType x) {
	    	int index = 0;
	        if (x == null) {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (p.data == null)
	                    return index;
	                index++;
	            }
	        } else {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (x.equals(p.data))
	                	return index;
	                index++;
	            }
	        }
	        return -1;
		}
	    
	    /**
	     * Returns {true} if this list contains the specified element.
	     */
	    public boolean contains(AnyType x) {
	        return indexOf(x) != -1;
	    }
		
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	//----------------------------------------------------------------------------------//
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/B_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < t; test++) {
			
			System.out.print("Caso #" + ++test + ":\n");
			test--;

			MyLinkedList<Integer> deck = new MyLinkedList<Integer>();
			MyLinkedList<Integer> players = new MyLinkedList<Integer>();
			MyLinkedList<Integer> winners = new MyLinkedList<Integer>();

			int N = 0, K = 0;
			int greater = 0;
			int move = 0;

			String s[] = scan.nextLine().split(" ");

			N = Integer.parseInt(s[0]);
			K = Integer.parseInt(s[1]);

			String cards = scan.nextLine();
			deck = readInts(cards);

			for (int i = 0; i < K; i++) {
				if (deck.isEmpty()) {
					break;
				}

				if (deck.get(0) > deck.get(deck.size()-1)) {
					if (players.size() <= i) {
						players.add(i, deck.remove(0));
					} else {
						players.set(i, players.get(i) + deck.remove(0));
					}
				} else {
					if (players.size() <= i) {
						players.add(i, deck.remove(deck.size()-1));
					} else {
						players.set(i, players.get(i) + deck.remove(deck.size()-1));
					}
				}
				if (i == K - 1) {
					i = -1;
				}

			}

			greater = elementoMayor(players);

			for (Integer player : players) {
				if (player.equals(greater)) {
					winners.add(players.indexOf(player) + move);
					move++;
				}
			}
			
			for (Integer win : winners) {
				System.out.print(win + " ");
			}
			System.out.println();
			
		}

	}

	public static MyLinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		MyLinkedList<Integer> lista = new MyLinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

	private static Integer elementoMayor(MyLinkedList<Integer> list) {
		Integer aux = 0;
		for (Integer value : list) {
			if (value.compareTo(aux) > 0) {
				aux = value;
			} else {
				continue;
			}
		}
		return aux;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

	//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
	
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * LinkedList class implements a doubly-linked list.
		 */
		
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    /**
	     *  Returns the index of the first occurrence of the given value in the list,
		 *  or -1 if the value is not found in the list.
	     */
	    public int indexOf(AnyType x) {
	    	int index = 0;
	        if (x == null) {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (p.data == null)
	                    return index;
	                index++;
	            }
	        } else {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (x.equals(p.data))
	                	return index;
	                index++;
	            }
	        }
	        return -1;
		}
	    
	    /**
	     * Returns {true} if this list contains the specified element.
	     */
	    public boolean contains(AnyType x) {
	        return indexOf(x) != -1;
	    }
		
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	//----------------------------------------------------------------------------------//
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/B_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < t; test++) {
			
			System.out.print("Caso #" + ++test + ":\n");
			test--;

			MyLinkedList<Integer> deck = new MyLinkedList<Integer>();
			MyLinkedList<Integer> players = new MyLinkedList<Integer>();
			MyLinkedList<Integer> winners = new MyLinkedList<Integer>();

			int N = 0, K = 0;
			int greater = 0;
			int move = 0;

			String s[] = scan.nextLine().split(" ");

			N = Integer.parseInt(s[0]);
			K = Integer.parseInt(s[1]);

			String cards = scan.nextLine();
			deck = readInts(cards);

			for (int i = 0; i < K; i++) {
				if (deck.isEmpty()) {
					break;
				}

				if (deck.get(0) > deck.get(deck.size()-1)) {
					if (players.size() <= i) {
						players.add(i, deck.remove(0));
					} else {
						players.set(i, players.get(i) + deck.remove(0));
					}
				} else {
					if (players.size() <= i) {
						players.add(i, deck.remove(deck.size()-1));
					} else {
						players.set(i, players.get(i) + deck.remove(deck.size()-1));
					}
				}
				if (i == K - 1) {
					i = -1;
				}

			}

			greater = elementoMayor(players);

			for (Integer player : players) {
				if (player.equals(greater)) {
					winners.add(players.indexOf(player) + move);
					move++;
				}
			}
			
			for (Integer win : winners) {
				System.out.print(win + " ");
			}
			System.out.println();
			
		}

	}

	public static MyLinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		MyLinkedList<Integer> lista = new MyLinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

	private static Integer elementoMayor(MyLinkedList<Integer> list) {
		Integer aux = 0;
		for (Integer value : list) {
			if (value.compareTo(aux) > 0) {
				aux = value;
			} else {
				continue;
			}
		}
		return aux;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

	//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
	
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * LinkedList class implements a doubly-linked list.
		 */
		
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    /**
	     *  Returns the index of the first occurrence of the given value in the list,
		 *  or -1 if the value is not found in the list.
	     */
	    public int indexOf(AnyType x) {
	    	int index = 0;
	        if (x == null) {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (p.data == null)
	                    return index;
	                index++;
	            }
	        } else {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (x.equals(p.data))
	                	return index;
	                index++;
	            }
	        }
	        return -1;
		}
	    
	    /**
	     * Returns {true} if this list contains the specified element.
	     */
	    public boolean contains(AnyType x) {
	        return indexOf(x) != -1;
	    }
		
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	//----------------------------------------------------------------------------------//
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/B_.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < t; test++) {
			
			System.out.print("Caso #" + ++test + ":\n");
			test--;

			MyLinkedList<Integer> deck = new MyLinkedList<Integer>();
			MyLinkedList<Integer> players = new MyLinkedList<Integer>();
			MyLinkedList<Integer> winners = new MyLinkedList<Integer>();

			int N = 0, K = 0;
			int greater = 0;
			int move = 0;

			String s[] = scan.nextLine().split(" ");

			N = Integer.parseInt(s[0]);
			K = Integer.parseInt(s[1]);

			String cards = scan.nextLine();
			deck = readInts(cards);

			for (int i = 0; i < K; i++) {
				if (deck.isEmpty()) {
					break;
				}

				if (deck.get(0) > deck.get(deck.size()-1)) {
					if (players.size() <= i) {
						players.add(i, deck.remove(0));
					} else {
						players.set(i, players.get(i) + deck.remove(0));
					}
				} else {
					if (players.size() <= i) {
						players.add(i, deck.remove(deck.size()-1));
					} else {
						players.set(i, players.get(i) + deck.remove(deck.size()-1));
					}
				}
				if (i == K - 1) {
					i = -1;
				}

			}

			greater = elementoMayor(players);

			for (Integer player : players) {
				if (player.equals(greater)) {
					winners.add(players.indexOf(player) + move);
					move++;
				}
			}
			for (int element = 0; element < winners.size() ;element++){
				if(element == winners.size()-1){
					System.out.print(winners.get(element));
				}else{
					System.out.print(winners.get(element) + " ");
				}
				
			}
//			for (Integer win : winners) {
//				System.out.print(win + " ");
//			}
			System.out.println();
			
		}

	}

	public static MyLinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		MyLinkedList<Integer> lista = new MyLinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

	private static Integer elementoMayor(MyLinkedList<Integer> list) {
		Integer aux = 0;
		for (Integer value : list) {
			if (value.compareTo(aux) > 0) {
				aux = value;
			} else {
				continue;
			}
		}
		return aux;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PA;

	//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
	
	// Static
	public static class MyArrayList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList() {
			doClear();
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * 
		 * @return true if this collection is empty.
		 */
		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			return theItems[idx];
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			AnyType old = theItems[idx];
			theItems[idx] = newVal;

			return old;
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity(int newCapacity) {
			if (newCapacity < theSize)
				return;

			AnyType[] old = theItems;
			theItems = (AnyType[]) new Object[newCapacity];
			for (int i = 0; i < size(); i++)
				theItems[i] = old[i];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {
			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public void add(int idx, AnyType x) {
			if (theItems.length == size())
				ensureCapacity(size() * 2 + 1);

			for (int i = theSize; i > idx; i--)
				theItems[i] = theItems[i - 1];

			theItems[idx] = x;
			theSize++;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			AnyType removedItem = theItems[idx];

			for (int i = idx; i < size() - 1; i++)
				theItems[i] = theItems[i + 1];
			theSize--;

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear() {
			doClear();
		}

		private void doClear() {
			theSize = 0;
			ensureCapacity(DEFAULT_CAPACITY);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new ArrayListIterator();
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * This is the implementation of the ArrayListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType> {
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current < size();
			}

			public AnyType next() {
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				okToRemove = true;
				return theItems[current++];
			}

			public void remove() {
				if (!okToRemove)
					throw new IllegalStateException();

				MyArrayList.this.remove(--current);
				okToRemove = false;
			}
		}

		private static final int DEFAULT_CAPACITY = 10;

		private AnyType[] theItems;
		private int theSize;
	}

	//------------------------------------------------------------------------
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/A_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < t; test++) {
			
			System.out.print("Caso #" + ++test + ":\n");
			test--;

			int costA = 0;
			int costL = 0;
			
			String command = null;
			int value = 0, position = 0, x = 0;
			//LinkedList<Integer> linkedL = new LinkedList<Integer>();
			MyArrayList<Integer> arrayL = new MyArrayList<Integer>();

//			MyArrayList<Integer> myArrayL = new MyArrayList<Integer>();
//			MyLinkedList<Integer> myLinkedL = new MyLinkedList<Integer>();

			int numCom = Integer.parseInt(scan.nextLine());
			for (int i = 0; i < numCom; i++) {
				
				String s[] = scan.nextLine().split(" ");

				if (s.length == 1) {
					command = s[0];
				} else if (s.length == 2) {
					command = s[0];
					x = Integer.parseInt(s[1]);
				} else if (s.length == 3) {
					command = s[0];
					value = Integer.parseInt(s[1]);
					position = Integer.parseInt(s[2]);
				}

				switch (command) {
				// insertar value posicion
				case ("insertar"): {
					if (position < 0 || position > arrayL.size()){
						System.out.println("insertar: posicion invalida");
					} else {
						System.out.println("insertar: posicion valida");
						costA = costA + (arrayL.size()-position);
						costL = costL + position;
						//linkedL.add(position, value);
						arrayL.add(position, value);
					}
					break;
				}

				// consultar posicion (x)
				case ("consultar"): {
					if (position < 0 || x >= arrayL.size()){
						System.out.println("consulta: no encontrado");
					} else {
						System.out.println("consulta: " + arrayL.get(x));
						costL += x;
					}

					//linkedL.get(x);
					//arrayL.get(x);

					break;
				}

				// eliminar posicion (x)
				case ("eliminar"): {

					if (position < 0 || x >= arrayL.size()){
						System.out.println("eliminar: posicion invalida");
					} else {
						costA = costA + (arrayL.size() - x - 1);
						costL += x;
						arrayL.remove(x);
						System.out.println("eliminar: posicion valida");
					}
					//linkedL.remove(x);
					//arrayL.remove(x);

					break;
				}

				// buscar value (x)
				case ("buscar"): {

					//val = lector.nextInt();
					int currentVal = -1;
					for (int k = 0; k < arrayL.size(); k++) {

						if (arrayL.get(k) == x) {
							
							currentVal = k;
							break;
						}
					}
					if (currentVal != -1) {
						System.out.println("buscar: " + currentVal);
						costA = costA + (currentVal+1);
						costL = costL + (currentVal+1);
					} else {
						costA = costA + arrayL.size();
						costL = costL + arrayL.size();
						System.out.println("no existe numero");
					}
					break;
				}

				case ("costo"): {

					System.out.println("costo: " + costA + " " + costL);
					break;
				}

				}

			}
		}

	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PC;

	//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.Scanner;

public class Main {

	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * LinkedList class implements a doubly-linked list.
		 */
		
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    /**
	     *  Returns the index of the first occurrence of the given value in the list,
		 *  or -1 if the value is not found in the list.
	     */
	    public int indexOf(AnyType x) {
	    	int index = 0;
	        if (x == null) {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (p.data == null)
	                    return index;
	                index++;
	            }
	        } else {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (x.equals(p.data))
	                	return index;
	                index++;
	            }
	        }
	        return -1;
		}
	    
	    /**
	     * Returns {true} if this list contains the specified element.
	     */
	    public boolean contains(AnyType x) {
	        return indexOf(x) != -1;
	    }
	    
	    /**
	     * Add a list to another list (concatenate).
	     * 
	     */
//	    void addAll(MyLinkedList<AnyType> list){
//	    	addAll(size( ), list);
//	    }
//	    void addAll(int idx, MyLinkedList<AnyType> list)
//	    {
//	      for(AnyType x : list)
//	      {
//	        add(idx, x);
//	        idx++;
//	      }
//	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	//----------------------------------------------------------------------------------//
	

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/C_.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		MyLinkedList<Integer> qCarlos = new MyLinkedList<Integer>();
		
		
		int count = 0;

		int quanQualC = Integer.parseInt(scan.nextLine());
		String cadQuCarlos = scan.nextLine();
		qCarlos = readInts(cadQuCarlos);
		

		int quanNinas = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < quanNinas; i++) {
			
			MyLinkedList<Integer> qNina = new MyLinkedList<Integer>();

			MyLinkedList<Integer> qCarlosAux = new MyLinkedList<Integer>();
			//qCarlosAux = readInts(cadQuCarlos);
			
			//qCarlosAux.addAll(qCarlos);
			
			for (Integer cual1 : qCarlos) {
				qCarlosAux.add(cual1);
			}
			
			//________________________
			

//			System.out.println("Lista cualidades Carlos.");
//			for (Integer cual : qCarlos) {
//				System.out.println(cual);
//			}
			
//			System.out.println("Lista cualidades Carlos (Auxiliar 1).");
//			for (Integer cual1 : qCarlosAux) {
//				System.out.println(cual1);
//			}

			String cadQuNina = scan.nextLine();
			qNina = readInts(cadQuNina);

//			System.out.println("Lista cualidades de la ninia.");
//			for (Integer cual2 : qNina) {
//				System.out.println(cual2);
//			}

			for (Integer cual3 : qNina) {
				if (qCarlosAux.contains(cual3)) {
					qCarlosAux.remove(qCarlosAux.indexOf(cual3)-1);
				} else
					break;
			}

//			System.out.println("Lista cualidades Carlos (Auxiliar 2).");
//			for (Integer cual1 : qCarlosAux) {
//				System.out.println(cual1);
//			}

			if (qCarlosAux.isEmpty()) {
				count++;
			}

			// ninas.add((LinkedList) qNina);
			// System.out.println("Lista de listas.");
			// for (LinkedList cual : ninas) {
			// System.out.println(cual);
			// }
		}
		
		System.out.println(count);
	}

	public static MyLinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		MyLinkedList<Integer> lista = new MyLinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

	//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
	
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * LinkedList class implements a doubly-linked list.
		 */
		
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    /**
	     *  Returns the index of the first occurrence of the given value in the list,
		 *  or -1 if the value is not found in the list.
	     */
	    public int indexOf(AnyType x) {
	    	int index = 0;
	        if (x == null) {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (p.data == null)
	                    return index;
	                index++;
	            }
	        } else {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (x.equals(p.data))
	                	return index;
	                index++;
	            }
	        }
	        return -1;
		}
	    
	    /**
	     * Returns {true} if this list contains the specified element.
	     */
	    public boolean contains(AnyType x) {
	        return indexOf(x) != -1;
	    }
		
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	//----------------------------------------------------------------------------------//
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/B_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < t; test++) {
			
			System.out.print("Caso #" + ++test + ":\n");
			test--;

			MyLinkedList<Integer> deck = new MyLinkedList<Integer>();
			MyLinkedList<Integer> players = new MyLinkedList<Integer>();
			MyLinkedList<Integer> winners = new MyLinkedList<Integer>();

			int N = 0, K = 0;
			int greater = 0;
			int move = 0;

			String s[] = scan.nextLine().split(" ");

			N = Integer.parseInt(s[0]);
			K = Integer.parseInt(s[1]);

			String cards = scan.nextLine();
			deck = readInts(cards);
			
//			System.out.println("Cartas: ");
//			for (Integer card: deck){
//				System.out.print(card);
//			}
//			System.out.println();
			
			for (int i = 0; i < K; i++){
				players.add(i, 0);
			}

			for (int i = 0; i < K; i++) {
				if (deck.isEmpty()) {
					break;
				}

				if (deck.get(0) > deck.get(deck.size()-1)) {
					if (players.size() <= i) {
						players.add(i, deck.remove(0));
					} else {
						players.set(i, players.get(i) + deck.remove(0));
					}
				} else {
					if (players.size() <= i) {
						players.add(i, deck.remove(deck.size()-1));
					} else {
						players.set(i, players.get(i) + deck.remove(deck.size()-1));
					}
				}
				if (i == K - 1) {
					i = -1;
				}

			}

			greater = elementoMayor(players);

			for (Integer player : players) {
				if (player.equals(greater)) {
					winners.add(players.indexOf(player) + move);
					move++;
					
				}
			}
			for (int element = 0; element < winners.size() ;element++){
				if(element == winners.size()-1){
					System.out.print(winners.get(element));
				}else{
					System.out.print(winners.get(element) + " ");
				}
				
			}
//			for (Integer win : winners) {
//				System.out.print(win + " ");
//			}
			System.out.println();
			
		}

	}

	public static MyLinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		MyLinkedList<Integer> lista = new MyLinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

	private static Integer elementoMayor(MyLinkedList<Integer> list) {
		Integer aux = 0;
		for (Integer value : list) {
			if (value.compareTo(aux) > 0) {
				aux = value;
			} else {
				continue;
			}
		}
		return aux;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

	//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
	
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
		/**
		 * LinkedList class implements a doubly-linked list.
		 */
		
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    /**
	     *  Returns the index of the first occurrence of the given value in the list,
		 *  or -1 if the value is not found in the list.
	     */
	    public int indexOf(AnyType x) {
	    	int index = 0;
	        if (x == null) {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (p.data == null)
	                    return index;
	                index++;
	            }
	        } else {
	            for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
	                if (x.equals(p.data))
	                	return index;
	                index++;
	            }
	        }
	        return -1;
		}
	    
	    /**
	     * Returns {true} if this list contains the specified element.
	     */
	    public boolean contains(AnyType x) {
	        return indexOf(x) != -1;
	    }
		
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	//----------------------------------------------------------------------------------//
	
	// FOR EACH -> SOLO PARA IMPRIMIR!!
	
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/B_.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < t; test++) {
			
			System.out.print("Caso #" + ++test + ":\n");
			test--;

			MyLinkedList<Integer> deck = new MyLinkedList<Integer>();
			MyLinkedList<Integer> players = new MyLinkedList<Integer>();
			MyLinkedList<Integer> winners = new MyLinkedList<Integer>();

			int N = 0, K = 0;
			int greater = 0;
			int move = 0;

			String s[] = scan.nextLine().split(" ");

			N = Integer.parseInt(s[0]);
			K = Integer.parseInt(s[1]);

			String cards = scan.nextLine();
			deck = readInts(cards);
			
//			System.out.println("Cartas: ");
//			for (Integer card: deck){
//				System.out.print(card);
//			}
//			System.out.println();
			
			for (int i = 0; i < K; i++){
				players.add(i, 0);
			}

			for (int i = 0; i < K; i++) {
				if (deck.isEmpty()) {
					break;
				}

				if (deck.get(0) > deck.get(deck.size()-1)) {
//					if (players.size() <= i) {
//						players.add(i, deck.remove(0));
//					} else {
						players.set(i, players.get(i) + deck.remove(0));
//					}
				} else {
//					if (players.size() <= i) {
//						players.add(i, deck.remove(deck.size()-1));
//					} else {
						players.set(i, players.get(i) + deck.remove(deck.size()-1));
					//}
				}
				if (i == K - 1) {
					i = -1;
				}

			}

			greater = elementoMayor(players);

			for (int i = 0; i < players.size(); i++){
				if (players.get(i) == greater) {
					winners.add(i+1);
				}
			}
//			for (Integer player : players) {
//				if (player.equals(greater)) {
//					winners.add(players.indexOf(player) + move);
//					move++;
//					
//				}
//			}
			for (int element = 0; element < winners.size(); element++){
				if(element == winners.size()-1){
					System.out.print(winners.get(element));
				}else{
					System.out.print(winners.get(element) + " ");
				}
			}
//			for (Integer win : winners) {
//				System.out.print(win + " ");
//			}
			System.out.println();
			
		}

	}

	public static MyLinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		MyLinkedList<Integer> lista = new MyLinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

	private static Integer elementoMayor(MyLinkedList<Integer> list) {
		Integer aux = 0;
		for (Integer value : list) {
			if (value.compareTo(aux) > 0) {
				aux = value;
			} else {
				continue;
			}
		}
		return aux;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PC;

//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.Scanner;

public class Main {

	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * LinkedList class implements a doubly-linked list.
		 */

		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;
			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		/**
		 * Returns the index of the first occurrence of the given value in the
		 * list, or -1 if the value is not found in the list.
		 */
		public int indexOf(AnyType x) {
			int index = 0;
			if (x == null) {
				for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
					if (p.data == null)
						return index;
					index++;
				}
			} else {
				for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
					if (x.equals(p.data))
						return index;
					index++;
				}
			}
			return -1;
		}

		/**
		 * Returns {true} if this list contains the specified element.
		 */
		public boolean contains(AnyType x) {
			return indexOf(x) != -1;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	// ----------------------------------------------------------------------------------//

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/C_2.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		MyLinkedList<Integer> qCarlos = new MyLinkedList<Integer>();

		int count = 0;

		int quanQualC = Integer.parseInt(scan.nextLine());
		String cadQuCarlos = scan.nextLine();
		qCarlos = readInts(cadQuCarlos);

		int quanNinas = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < quanNinas; i++) {

			MyLinkedList<Integer> qNina = new MyLinkedList<Integer>();
			MyLinkedList<Integer> qCarlosAux = new MyLinkedList<Integer>();

			String cadQuNina = scan.nextLine();
			qNina = readInts(cadQuNina);

			int qualityCheck = 0;

			for (Integer cual1 : qCarlos) {
				qCarlosAux.add(cual1);
			}
			
			for (int k = 0; k < qCarlosAux.size(); k++) {
				for (int m = 0; m < qNina.size(); m++) {
					if (qCarlosAux.get(k) == qNina.get(m)) {
						qualityCheck++;
					}
				}
			}

			if (qCarlosAux.size() == qualityCheck) {
				count++;
			}
		}

		System.out.println(count);
	}

	public static MyLinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		MyLinkedList<Integer> lista = new MyLinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PD;

//	Proyecto 02

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.Scanner;

public class Main {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("C:/Users/jaime_000/Desktop/D_.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < t; test++) {

			System.out.print("Caso #" + ++test + ":\n");
			test--;

			String command = null;
			String name = null, surname = null;
			int id = 0;

			LinkedList<Integer> list = new LinkedList<Integer>();
			LinkedList<Cubicle> cubiculo = new LinkedList<Cubicle>();

			// Cantidad de cubiculos
			int N = Integer.parseInt(scan.nextLine());

			// Cantidad de casilleros por cubiculo
			String cad = scan.nextLine();
			list = readInts(cad);

			for (int j = 0; j < N; j++) {
				cubiculo.add(new Cubicle(j, list.get(j)));
			}

			int numCom = Integer.parseInt(scan.nextLine());
			for (int i = 0; i < numCom; i++) {

				String s[] = scan.nextLine().split(" ");

				if (s.length == 2) {
					command = s[0];
					id = Integer.parseInt(s[1]);
				} else if (s.length == 4) {
					command = s[0];
					name = s[1];
					surname = s[2];
					id = Integer.parseInt(s[3]);
				}

				switch (command) {

				case ("ingresar"): {
					Person x = new Person(name, surname, id);
					cubiculo = sortByLoad(cubiculo);
					cubiculo.get(cubiculo.size() - 1).addPerson(x);
					
					
					//System.out.println(cubiculo);

					break;
				}

				case ("salir"): {

					boolean band = false;
					int indexCub = 0, indexPer = 0;

					for (Cubicle cub : cubiculo) {
						for (Person per : cub.listPerson) {
							if (per.id == id) {
								System.out.println(name);
								break;
							}
							indexPer++;
						}
						if (band)
							break;
						indexCub++;
					}
					cubiculo.get(indexCub).removePerson(indexPer);
					break;
				}

				}
			}
		}
	}

	public static LinkedList<Integer> readInts(String cad) {
		String lines[] = cad.split(" ");
		LinkedList<Integer> lista = new LinkedList<>();
		for (int i = 0; i < lines.length; i++) {
			lista.add(Integer.parseInt(lines[i]));
		}
		return lista;
	}

	public static LinkedList<Cubicle> sortByLoad(LinkedList<Cubicle> cub) {
		for (int i = 1; i < cub.size(); i++) {
			if (cub.get(i - 1).compareTo(cub.get(i))) {
				cub.add(i - 1, cub.remove(i - 1));
				cub.add(i - 1, cub.remove(i));
			}
		}
		return cub;
	}
}

// public static class
class Person {

	public String name;
	public String surname;
	public int id;

	public Person(String name, String surname, int id) {
		this.name = name;
		this.surname = surname;
		this.id = id;
	}

}

// public static class
class Cubicle {
	public LinkedList<Person> listPerson;
	public int id;
	public int occupied;
	public int maxCapacity;

	public Cubicle(int id, int maxCapacity) {
		this.id = id;
		this.maxCapacity = maxCapacity;
		listPerson = new LinkedList<Person>();
	}

	@Override
	public String toString() {
		return "Cubicle [listPerson=" + listPerson + ", id=" + id + ", occupied=" + occupied + ", maxCapacity="
				+ maxCapacity + "]";
	}

	public void addPerson(Person persona) {
		if (occupied >= maxCapacity) {
			System.out.println("limite alcanzado");
		} else {
			listPerson.add(persona);
			occupied = listPerson.size();
			System.out.println((id + 1) + " " + occupied);
		}
	}

	public void removePerson(int index) {
		listPerson.remove(index);
		occupied = listPerson.size();
	}

	public double getLoad() {
		return (double) occupied / (double) maxCapacity;
	}

	public boolean compareTo(Cubicle cub) {
		if ((id < cub.id) && (getLoad() <= cub.getLoad())) {
			return true;
		} else if (getLoad() < cub.getLoad()) {
			return true;
		}
		return false;
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PA;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	// BinarySearchTree class
	//
	// CONSTRUCTION: with no initializer
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x ) --> Insert x
	// void remove( x ) --> Remove x
	// boolean contains( x ) --> Return true if x is present
	// Comparable findMin( ) --> Return smallest item
	// Comparable findMax( ) --> Return largest item
	// boolean isEmpty( ) --> Return true if empty; else false
	// void makeEmpty( ) --> Remove all items
	// void printTree( ) --> Print tree in sorted order
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements an unbalanced binary search tree. Note that all "matching" is
	 * based on the compareTo method.
	 * 
	 */
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the tree.
		 */
		public BinarySearchTree() {
			root = null;
		}

		/**
		 * Insert into the tree; duplicates are ignored.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			root = insert(x, root);
		}

		/**
		 * Remove from the tree. Nothing is done if x is not found.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			root = remove(x, root);
		}

		/**
		 * Find the smallest item in the tree.
		 * 
		 * @return smallest item or null if empty.
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMin(root).element;
		}

		/**
		 * Find the largest item in the tree.
		 * 
		 * @return the largest item of null if empty.
		 */
		public AnyType findMax() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMax(root).element;
		}

		/**
		 * Find an item in the tree.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if not found.
		 */
		public boolean contains(AnyType x) {
			return contains(x, root);
		}

		/**
		 * Make the tree logically empty.
		 */
		public void makeEmpty() {
			root = null;
		}

		/**
		 * Test if the tree is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return root == null;
		}

		/**
		 * Print the tree contents in sorted order.
		 */
		public void printTree() {
			if (isEmpty())
				System.out.println("Empty tree");
			else
				printTree(root);
		}

		/**
		 * Internal method to insert into a subtree.
		 * 
		 * @param x
		 *            the item to insert.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> insert(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return new BinaryNode<>(x, null, null);

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = insert(x, t.left);
			else if (compareResult > 0)
				t.right = insert(x, t.right);
			else
				; // Duplicate; do nothing
			return t;
		}

		/**
		 * Internal method to remove from a subtree.
		 * 
		 * @param x
		 *            the item to remove.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> remove(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return t; // Item not found; do nothing

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = remove(x, t.left);
			else if (compareResult > 0)
				t.right = remove(x, t.right);
			else if (t.left != null && t.right != null) // Two children
			{
				t.element = findMin(t.right).element;
				t.right = remove(t.element, t.right);
			} else
				t = (t.left != null) ? t.left : t.right;
			return t;
		}

		/**
		 * Internal method to find the smallest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the smallest item.
		 */
		private BinaryNode<AnyType> findMin(BinaryNode<AnyType> t) {
			if (t == null)
				return null;
			else if (t.left == null)
				return t;
			return findMin(t.left);
		}

		/**
		 * Internal method to find the largest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the largest item.
		 */
		private BinaryNode<AnyType> findMax(BinaryNode<AnyType> t) {
			if (t != null)
				while (t.right != null)
					t = t.right;

			return t;
		}

		/**
		 * Internal method to find an item in a subtree.
		 * 
		 * @param x
		 *            is item to search for.
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the matched item.
		 */
		private boolean contains(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return false;

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				return contains(x, t.left);
			else if (compareResult > 0)
				return contains(x, t.right);
			else
				return true; // Match
		}

		/**
		 * Internal method to print a subtree in sorted order.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private void printTree(BinaryNode<AnyType> t) {
			if (t != null) {
				printTree(t.left);
				System.out.println(t.element);
				printTree(t.right);
			}
		}

		/**
		 * Internal method to compute height of a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private int height(BinaryNode<AnyType> t) {
			if (t == null)
				return -1;
			else
				return 1 + Math.max(height(t.left), height(t.right));
		}

		// Basic node stored in unbalanced binary search trees
		private static class BinaryNode<AnyType> {
			// Constructors
			BinaryNode(AnyType theElement) {
				this(theElement, null, null);
			}

			BinaryNode(AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt) {
				element = theElement;
				left = lt;
				right = rt;
			}

			AnyType element; // The data in the node
			BinaryNode<AnyType> left; // Left child
			BinaryNode<AnyType> right; // Right child
		}

		/** The tree root. */
		private BinaryNode<AnyType> root;
		
		///////////////////////////////////////////////////////
		
		// Ancestro comun entre dos nodos.
	    public AnyType ancestor( AnyType u, AnyType v )
	    {
	    	if ( contains(u) && contains(v) ) {
	    		return ancestor( u, v, root ).element;
	    	} else
	    		return null;   
	    }
	    
	    private BinaryNode<AnyType> ancestor(AnyType u, AnyType v, BinaryNode<AnyType> t){
	
	    	boolean band = false;
	    	
	    	while(band == false){
	    		
	    		int compareNodeU = u.compareTo(t.element);
	    		int comparteNodeV = v.compareTo(t.element);
	    		
	    		if ( (compareNodeU == 0 && comparteNodeV > 0) || (compareNodeU == 0 && comparteNodeV < 0) ) {
	    			band=true;
	    			return t;	    			
	    		}
	    		
	    		if ( (comparteNodeV == 0 && compareNodeU > 0) || (comparteNodeV==0 && compareNodeU < 0) ) {
	    			band=true;
	    			return t;	    			
	    		}
	    		
	    		if (compareNodeU == 0 && comparteNodeV == 0){
	    			band=true;
	    			return t;	
	    		}
	    		
	    		if ( (compareNodeU > 0  &&  comparteNodeV < 0) || (compareNodeU < 0  &&  comparteNodeV > 0) ) {	    			
	    			band=true;
	    			return t;
	    		}
	    		
	    		if (compareNodeU > 0) {
	    			t = t.right;
	    		}
	    		
	    		if (compareNodeU < 0) {
	    			t = t.left;
	    		}
	    	}
	       return t;
	    }
	    
	    
	    // Distancia entre dos nodos.
	    public int distance( AnyType u, AnyType v )
	    {
	    	if ( contains(u) && contains(v) ) {
	    		return  distance (u,v, ancestor(u, v, root) );
	    	}else
	    		return -1;   
	    }	    
	    
	    private int distance(AnyType u, AnyType v, BinaryNode<AnyType> t) {
	    	
	    	int dist = 0;
	    	boolean band = false;
	    	int compareNodeU = 0;
	    	int compareNodeV = 0;
	    	
	    	BinaryNode<AnyType> aux = t;
	    	
	    	if (u==v){
	    		return 0;
	    	}
	    	
	    	while(band==false){
	    		
	    		compareNodeU = u.compareTo(t.element);
	    		
	    		if(compareNodeU == 0){
	    			//signal=true;
	    			break;
	    		}
	
	    		if(compareNodeU > 0){
	    			dist++;
	    			t = t.right;
	    		}
	    		
	    		if(compareNodeU < 0){
	    			dist++;
	    			t = t.left;
	    		}
	    	}
	    	
	    	while(band==false){
	    		
	    		compareNodeV = v.compareTo(aux.element);
	    		
	    		if(compareNodeV == 0){
	    			//signal=true;
	    			break;
	    		}
	
	    		if(compareNodeV > 0){
	    			dist++;
	    			aux = aux.right;
	    		}
	    		
	    		if(compareNodeV < 0){
	    			dist++;
	    			aux = aux.left;
	    		}
	    	}
	    	return dist;
	    }
		
		///////////////////////////////////////////////////////

	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////

	public static void main(String[] args) throws IOException {

		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/A_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}
		
		BinarySearchTree<Integer> binaryST;

		StringBuilder str = new StringBuilder();
		String line = null;

		int casos = Integer.parseInt( reader.readLine() );

		for (int c = 1; c <= casos; c++) {

			binaryST = new BinarySearchTree<>();

			int commands = Integer.parseInt(reader.readLine());
			str.append("Caso #" + c + ":" + System.lineSeparator());

			for (int com = 1; com <= commands; com++) {

				line = reader.readLine();
				String split[] = line.split(" ");
				
				switch (split[0]) {
					case "agregar":
						binaryST.insert(Integer.parseInt(split[1]));
						break;
						
					case "ancestro":
						Integer answer = binaryST.ancestor(Integer.parseInt(split[1]), Integer.parseInt(split[2]));
						if (answer == null) {
							str.append("ancestro: -1" + System.lineSeparator());
						} else {
							str.append("ancestro: " + answer + System.lineSeparator());
						}
						break;
						
					case "distancia":
						str.append( "distancia: " + binaryST.distance( Integer.parseInt(split[1]),
								Integer.parseInt(split[2]) ) + System.lineSeparator() );
						break;
				}
			}
		}

		System.out.println(str);
	}
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PA;

//// Lab 04 (Arboles) - Problema A

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	// BinarySearchTree class
	//
	// CONSTRUCTION: with no initializer
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x ) --> Insert x
	// void remove( x ) --> Remove x
	// boolean contains( x ) --> Return true if x is present
	// Comparable findMin( ) --> Return smallest item
	// Comparable findMax( ) --> Return largest item
	// boolean isEmpty( ) --> Return true if empty; else false
	// void makeEmpty( ) --> Remove all items
	// void printTree( ) --> Print tree in sorted order
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements an unbalanced binary search tree. Note that all "matching" is
	 * based on the compareTo method.
	 * 
	 */
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the tree.
		 */
		public BinarySearchTree() {
			root = null;
		}

		/**
		 * Insert into the tree; duplicates are ignored.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			root = insert(x, root);
		}

		/**
		 * Remove from the tree. Nothing is done if x is not found.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			root = remove(x, root);
		}

		/**
		 * Find the smallest item in the tree.
		 * 
		 * @return smallest item or null if empty.
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMin(root).element;
		}

		/**
		 * Find the largest item in the tree.
		 * 
		 * @return the largest item of null if empty.
		 */
		public AnyType findMax() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMax(root).element;
		}

		/**
		 * Find an item in the tree.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if not found.
		 */
		public boolean contains(AnyType x) {
			return contains(x, root);
		}

		/**
		 * Make the tree logically empty.
		 */
		public void makeEmpty() {
			root = null;
		}

		/**
		 * Test if the tree is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return root == null;
		}

		/**
		 * Print the tree contents in sorted order.
		 */
		public void printTree() {
			if (isEmpty())
				System.out.println("Empty tree");
			else
				printTree(root);
		}

		/**
		 * Internal method to insert into a subtree.
		 * 
		 * @param x
		 *            the item to insert.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> insert(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return new BinaryNode<>(x, null, null);

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = insert(x, t.left);
			else if (compareResult > 0)
				t.right = insert(x, t.right);
			else
				; // Duplicate; do nothing
			return t;
		}

		/**
		 * Internal method to remove from a subtree.
		 * 
		 * @param x
		 *            the item to remove.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> remove(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return t; // Item not found; do nothing

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = remove(x, t.left);
			else if (compareResult > 0)
				t.right = remove(x, t.right);
			else if (t.left != null && t.right != null) // Two children
			{
				t.element = findMin(t.right).element;
				t.right = remove(t.element, t.right);
			} else
				t = (t.left != null) ? t.left : t.right;
			return t;
		}

		/**
		 * Internal method to find the smallest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the smallest item.
		 */
		private BinaryNode<AnyType> findMin(BinaryNode<AnyType> t) {
			if (t == null)
				return null;
			else if (t.left == null)
				return t;
			return findMin(t.left);
		}

		/**
		 * Internal method to find the largest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the largest item.
		 */
		private BinaryNode<AnyType> findMax(BinaryNode<AnyType> t) {
			if (t != null)
				while (t.right != null)
					t = t.right;

			return t;
		}

		/**
		 * Internal method to find an item in a subtree.
		 * 
		 * @param x
		 *            is item to search for.
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the matched item.
		 */
		private boolean contains(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return false;

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				return contains(x, t.left);
			else if (compareResult > 0)
				return contains(x, t.right);
			else
				return true; // Match
		}

		/**
		 * Internal method to print a subtree in sorted order.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private void printTree(BinaryNode<AnyType> t) {
			if (t != null) {
				printTree(t.left);
				System.out.println(t.element);
				printTree(t.right);
			}
		}

		/**
		 * Internal method to compute height of a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private int height(BinaryNode<AnyType> t) {
			if (t == null)
				return -1;
			else
				return 1 + Math.max(height(t.left), height(t.right));
		}

		// Basic node stored in unbalanced binary search trees
		private static class BinaryNode<AnyType> {
			// Constructors
			BinaryNode(AnyType theElement) {
				this(theElement, null, null);
			}

			BinaryNode(AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt) {
				element = theElement;
				left = lt;
				right = rt;
			}

			AnyType element; // The data in the node
			BinaryNode<AnyType> left; // Left child
			BinaryNode<AnyType> right; // Right child
		}

		/** The tree root. */
		private BinaryNode<AnyType> root;
		
		///////////////////////////////////////////////////////
		
		// Ancestro comun entre dos nodos.
	    public AnyType ancestor( AnyType u, AnyType v )
	    {
	    	if ( contains(u) && contains(v) ) {
	    		return ancestor( u, v, root ).element;
	    	} else
	    		return null;   
	    }
	    
	    private BinaryNode<AnyType> ancestor(AnyType u, AnyType v, BinaryNode<AnyType> t){
	
	    	boolean band = false;
	    	
	    	while(band == false){
	    		
	    		int compareNodeU = u.compareTo(t.element);
	    		int comparteNodeV = v.compareTo(t.element);
	    		
	    		if ( (compareNodeU == 0 && comparteNodeV > 0) || (compareNodeU == 0 && comparteNodeV < 0) ) {
	    			band=true;
	    			return t;	    			
	    		}
	    		if ( (comparteNodeV == 0 && compareNodeU > 0) || (comparteNodeV==0 && compareNodeU < 0) ) {
	    			band=true;
	    			return t;	    			
	    		}
	    		if (compareNodeU == 0 && comparteNodeV == 0){
	    			band=true;
	    			return t;	
	    		}
	    		if ( (compareNodeU > 0  &&  comparteNodeV < 0) || (compareNodeU < 0  &&  comparteNodeV > 0) ) {	    			
	    			band=true;
	    			return t;
	    		}
	    		if (compareNodeU > 0) {
	    			t = t.right;
	    		}
	    		if (compareNodeU < 0) {
	    			t = t.left;
	    		}
	    	}
	       return t;
	    }
	    
	    ///////////////////////////////////////////////////////
	    
	    // Distancia entre dos nodos.
	    public int distance( AnyType u, AnyType v )
	    {
	    	if ( contains(u) && contains(v) ) {
	    		return  distance (u,v, ancestor(u, v, root) );
	    	}else
	    		return -1;   
	    }	    
	    
	    private int distance(AnyType u, AnyType v, BinaryNode<AnyType> t) {
	    	
	    	int dist = 0;
	    	boolean band = false;
	    	int compareNodeU = 0;
	    	int compareNodeV = 0;
	    	
	    	BinaryNode<AnyType> aux = t;
	    	
	    	if (u==v){
	    		return 0;
	    	}
	    	
	    	while(band==false){
	    		
	    		compareNodeU = u.compareTo(t.element);
	    		
	    		if(compareNodeU == 0){
	    			//signal=true;
	    			break;
	    		}
	    		if(compareNodeU > 0){
	    			dist++;
	    			t = t.right;
	    		}
	    		if(compareNodeU < 0){
	    			dist++;
	    			t = t.left;
	    		}
	    	}
	    	
	    	while(band==false){
	    		
	    		compareNodeV = v.compareTo(aux.element);
	    		
	    		if(compareNodeV == 0){
	    			//signal=true;
	    			break;
	    		}
	    		if(compareNodeV > 0){
	    			dist++;
	    			aux = aux.right;
	    		}
	    		if(compareNodeV < 0){
	    			dist++;
	    			aux = aux.left;
	    		}
	    	}
	    	return dist;
	    }
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////

	public static void main(String[] args) throws IOException {

		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/A_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}
		
		BinarySearchTree<Integer> binaryST;

		StringBuilder str = new StringBuilder();
		String line = null;

		int casos = Integer.parseInt( reader.readLine() );
		for (int c = 1; c <= casos; c++) {

			binaryST = new BinarySearchTree<Integer>();

			int command = Integer.parseInt(reader.readLine());
			str.append( "Caso #" + c + ":\n" );

			for (int x = 1; x <= command; x++) {

				line = reader.readLine();
				String strArray[] = line.split(" ");
				
				switch (strArray[0]) {
					case "agregar":
						binaryST.insert(Integer.parseInt(strArray[1]));
						break;
						
					case "ancestro":
						Integer answer = binaryST.ancestor(Integer.parseInt(strArray[1]), Integer.parseInt(strArray[2]));
						if (answer == null) {
							str.append("ancestro: -1" + "\n" );
						} else {
							str.append("ancestro: " + answer + "\n" );
						}
						break;
						
					case "distancia":
						str.append( "distancia: " + binaryST.distance( Integer.parseInt(strArray[1]),
								Integer.parseInt(strArray[2]) ) + "\n" );
						break;
				}
			}
		}

		System.out.println(str);
	}
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PA;

////	Lab 05 (SegmentTree & BinaryHeap) - Problema A

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;

public class Main {

	// ---------------------------------------------------------------------------------------//

	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	// or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x ) --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( ) --> Return smallest item
	// boolean isEmpty( ) --> Return true if empty; else false
	// void makeEmpty( ) --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

		/**
		 * Return BinaryHeap size.
		 */
		public int size() {
			return currentSize;
		}
	}

	// ---------------------------------------------------------------------------------------//

	public static void main(String[] args) throws Exception {
		
		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/A_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}
		
		BinaryHeap<Long> binaryHeap = new BinaryHeap<Long>();
		
		StringBuilder str = new StringBuilder();
		int size = Integer.parseInt(reader.readLine());
		
		String line = reader.readLine();
		String[] strArray = line.split(" ");

		long value1 = 0, value2 = 0, value3 = 0;
		
		for (int i = 0; i < size; i++) {
			
			binaryHeap.insert( -1 * Long.parseLong(strArray[i]) );
			
			if (i == 0 || i == 1){
				str.append( "-1" + "\n" );
			} else {
				value1 = binaryHeap.deleteMin();
				value2 = binaryHeap.deleteMin();
				value3 = binaryHeap.deleteMin();
				
//				System.out.println("value 1 " + value1);
//				System.out.println("value 2 " + value2);
//				System.out.println("value 3 " + value3);
//				System.out.println(" /////////////// ");
				
				str.append( -1 * value1 * value2 * value3 + "\n" );
				
				binaryHeap.insert(value1);
				binaryHeap.insert(value2);
				binaryHeap.insert(value3);
			}
		}
		
		System.out.println(str);
		
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

////	Lab 05 (SegmentTree & BinaryHeap) - Problema B

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;

public class Main {

	//---------------------------------------------------------------------------------------//

	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) > 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMax() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMax() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType maxItem = findMax();
			array[1] = array[currentSize--];
			percolateDown(1);

			return maxItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) > 0)
					child++;
				if (array[child].compareTo(tmp) > 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

		/////////////////////////////////////////////////////////////////

		/**
		 * Return size of the BinaryHeap.
		 */
		public int size() {
			return currentSize;
		}

		public AnyType valueArray(int idx) {
			return array[idx];
		}
	}

	//---------------------------------------------------------------------------------------//

	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * LinkedList class implements a doubly-linked list.
		 */

		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;
			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		/**
		 * Returns the index of the first occurrence of the given value in the
		 * list, or -1 if the value is not found in the list.
		 */
		public int indexOf(AnyType x) {
			int index = 0;
			if (x == null) {
				for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
					if (p.data == null)
						return index;
					index++;
				}
			} else {
				for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
					if (x.equals(p.data))
						return index;
					index++;
				}
			}
			return -1;
		}

		/**
		 * Returns {true} if this list contains the specified element.
		 */
		public boolean contains(AnyType x) {
			return indexOf(x) != -1;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	//---------------------------------------------------------------------------------------//

	public static class Printer implements Comparable < Printer > {

		public int value;
		public int index;
		public boolean last;
		public boolean mine;
		
		Printer(int value, int index, boolean mine) {
			this.value = value;
			this.index = index;
			this.last = false;
			this.mine = mine;
		}

		public int compareTo(Printer t) {

			if (value < t.value) {
				return -1;
			} else if (value > t.value) {
				return 1;
			} else {
				return 0;
			}
		}
		
	}
	
	//---------------------------------------------------------------------------------------//

	public static void main(String[] args) throws Exception {
		
		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/B_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}
		
		Printer myPrinter;
		BinaryHeap<Printer> binaryHeap;
		MyLinkedList<Printer> linkedList;
		
		StringBuilder str = new StringBuilder();
		String line;

		int casos = Integer.parseInt(reader.readLine());
		for (int x = 0; x < casos; x++) {

			binaryHeap = new BinaryHeap<>();
			linkedList = new MyLinkedList<>();

			int idx = 0;
			int time = 0;

			line = reader.readLine();
			String[] strArray = line.split(" ");

			//int numberJobs = Integer.parseInt(strArray[0]);
			int idxMyJob = Integer.parseInt(strArray[1]);

			line = reader.readLine();
			strArray = line.split(" ");

			int myJob = Integer.parseInt( strArray[idxMyJob] );
			int idxLargest = -1;
			int valueMax = 0;
			boolean band = false;

			for (int i = 0; i < strArray.length; i++) {

				myPrinter = new Printer(Integer.parseInt(strArray[i]), idx, false);

				if (Integer.parseInt(strArray[i]) >= myJob) {
					if (i == idxMyJob) {
						myPrinter.mine = true;
					}
					binaryHeap.insert(myPrinter);
					linkedList.add(myPrinter);
					idx++;
				}
			}
			
			while (true) {
				if (myJob != binaryHeap.findMax().value) {
					valueMax = binaryHeap.deleteMax().value;
					time++;
				} else {
					break;
				}
			}

			for (int n = 0; n < linkedList.size(); n++) {
				if (linkedList.get(n).value == valueMax) {
					idxLargest = linkedList.get(n).index;
					break;
				}
			}

			if (idxLargest >= linkedList.size() - 1) {
				idxLargest = -1;
			}

			for (int j = idxLargest + 1; j <= linkedList.size() + 1; j++) {

				if (j == linkedList.size()) {
					j = 0;
				}
				if (band == true) {
					break;
				}
				if (linkedList.get(j).mine) {
					time++;
					break;
				}
				
			}

			str.append(time + "\n");
		}

		System.out.println(str);
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PA;

////	Lab 04 (Arboles) - Problema A

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	// BinarySearchTree class
	//
	// CONSTRUCTION: with no initializer
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x ) --> Insert x
	// void remove( x ) --> Remove x
	// boolean contains( x ) --> Return true if x is present
	// Comparable findMin( ) --> Return smallest item
	// Comparable findMax( ) --> Return largest item
	// boolean isEmpty( ) --> Return true if empty; else false
	// void makeEmpty( ) --> Remove all items
	// void printTree( ) --> Print tree in sorted order
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements an unbalanced binary search tree. Note that all "matching" is
	 * based on the compareTo method.
	 * 
	 */
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the tree.
		 */
		public BinarySearchTree() {
			root = null;
		}

		/**
		 * Insert into the tree; duplicates are ignored.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			root = insert(x, root);
		}

		/**
		 * Remove from the tree. Nothing is done if x is not found.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			root = remove(x, root);
		}

		/**
		 * Find the smallest item in the tree.
		 * 
		 * @return smallest item or null if empty.
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMin(root).element;
		}

		/**
		 * Find the largest item in the tree.
		 * 
		 * @return the largest item of null if empty.
		 */
		public AnyType findMax() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMax(root).element;
		}

		/**
		 * Find an item in the tree.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if not found.
		 */
		public boolean contains(AnyType x) {
			return contains(x, root);
		}

		/**
		 * Make the tree logically empty.
		 */
		public void makeEmpty() {
			root = null;
		}

		/**
		 * Test if the tree is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return root == null;
		}

		/**
		 * Print the tree contents in sorted order.
		 */
		public void printTree() {
			if (isEmpty())
				System.out.println("Empty tree");
			else
				printTree(root);
		}

		/**
		 * Internal method to insert into a subtree.
		 * 
		 * @param x
		 *            the item to insert.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> insert(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return new BinaryNode<>(x, null, null);

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = insert(x, t.left);
			else if (compareResult > 0)
				t.right = insert(x, t.right);
			else
				; // Duplicate; do nothing
			return t;
		}

		/**
		 * Internal method to remove from a subtree.
		 * 
		 * @param x
		 *            the item to remove.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> remove(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return t; // Item not found; do nothing

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = remove(x, t.left);
			else if (compareResult > 0)
				t.right = remove(x, t.right);
			else if (t.left != null && t.right != null) // Two children
			{
				t.element = findMin(t.right).element;
				t.right = remove(t.element, t.right);
			} else
				t = (t.left != null) ? t.left : t.right;
			return t;
		}

		/**
		 * Internal method to find the smallest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the smallest item.
		 */
		private BinaryNode<AnyType> findMin(BinaryNode<AnyType> t) {
			if (t == null)
				return null;
			else if (t.left == null)
				return t;
			return findMin(t.left);
		}

		/**
		 * Internal method to find the largest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the largest item.
		 */
		private BinaryNode<AnyType> findMax(BinaryNode<AnyType> t) {
			if (t != null)
				while (t.right != null)
					t = t.right;

			return t;
		}

		/**
		 * Internal method to find an item in a subtree.
		 * 
		 * @param x
		 *            is item to search for.
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the matched item.
		 */
		private boolean contains(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return false;

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				return contains(x, t.left);
			else if (compareResult > 0)
				return contains(x, t.right);
			else
				return true; // Match
		}

		/**
		 * Internal method to print a subtree in sorted order.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private void printTree(BinaryNode<AnyType> t) {
			if (t != null) {
				printTree(t.left);
				System.out.println(t.element);
				printTree(t.right);
			}
		}

		/**
		 * Internal method to compute height of a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private int height(BinaryNode<AnyType> t) {
			if (t == null)
				return -1;
			else
				return 1 + Math.max(height(t.left), height(t.right));
		}

		// Basic node stored in unbalanced binary search trees
		private static class BinaryNode<AnyType> {
			// Constructors
			BinaryNode(AnyType theElement) {
				this(theElement, null, null);
			}

			BinaryNode(AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt) {
				element = theElement;
				left = lt;
				right = rt;
			}

			AnyType element; // The data in the node
			BinaryNode<AnyType> left; // Left child
			BinaryNode<AnyType> right; // Right child
		}

		/** The tree root. */
		private BinaryNode<AnyType> root;
		
		///////////////////////////////////////////////////////
		
		// Ancestro comun entre dos nodos.
	    public AnyType ancestor( AnyType u, AnyType v )
	    {
	    	if ( contains(u) && contains(v) ) {
	    		return ancestor( u, v, root ).element;
	    	} else
	    		return null;   
	    }
	    
	    private BinaryNode<AnyType> ancestor(AnyType u, AnyType v, BinaryNode<AnyType> t){
	
	    	boolean band = false;
	    	
	    	while(band == false){
	    		
	    		int compareNodeU = u.compareTo(t.element);
	    		int comparteNodeV = v.compareTo(t.element);
	    		
	    		if ( (compareNodeU == 0 && comparteNodeV > 0) || (compareNodeU == 0 && comparteNodeV < 0) ) {
	    			band=true;
	    			return t;	    			
	    		}
	    		if ( (comparteNodeV == 0 && compareNodeU > 0) || (comparteNodeV==0 && compareNodeU < 0) ) {
	    			band=true;
	    			return t;	    			
	    		}
	    		if (compareNodeU == 0 && comparteNodeV == 0){
	    			band=true;
	    			return t;	
	    		}
	    		if ( (compareNodeU > 0  &&  comparteNodeV < 0) || (compareNodeU < 0  &&  comparteNodeV > 0) ) {	    			
	    			band=true;
	    			return t;
	    		}
	    		if (compareNodeU > 0) {
	    			t = t.right;
	    		}
	    		if (compareNodeU < 0) {
	    			t = t.left;
	    		}
	    	}
	       return t;
	    }
	    
	    ///////////////////////////////////////////////////////
	    
	    // Distancia entre dos nodos.
	    public int distance( AnyType u, AnyType v )
	    {
	    	if ( contains(u) && contains(v) ) {
	    		return  distance (u,v, ancestor(u, v, root) );
	    	}else
	    		return -1;   
	    }	    
	    
	    private int distance(AnyType u, AnyType v, BinaryNode<AnyType> t) {
	    	
	    	int dist = 0;
	    	boolean band = false;
	    	int compareNodeU = 0;
	    	int compareNodeV = 0;
	    	
	    	BinaryNode<AnyType> aux = t;
	    	
	    	if (u==v){
	    		return 0;
	    	}
	    	
	    	while(band==false){
	    		
	    		compareNodeU = u.compareTo(t.element);
	    		
	    		if(compareNodeU == 0){
	    			//signal=true;
	    			break;
	    		}
	    		if(compareNodeU > 0){
	    			dist++;
	    			t = t.right;
	    		}
	    		if(compareNodeU < 0){
	    			dist++;
	    			t = t.left;
	    		}
	    	}
	    	
	    	while(band==false){
	    		
	    		compareNodeV = v.compareTo(aux.element);
	    		
	    		if(compareNodeV == 0){
	    			//signal=true;
	    			break;
	    		}
	    		if(compareNodeV > 0){
	    			dist++;
	    			aux = aux.right;
	    		}
	    		if(compareNodeV < 0){
	    			dist++;
	    			aux = aux.left;
	    		}
	    	}
	    	return dist;
	    }
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////

	public static void main(String[] args) throws IOException {

		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/A_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}
		
		BinarySearchTree<Integer> binaryST;

		StringBuilder str = new StringBuilder();
		String line = null;

		int casos = Integer.parseInt( reader.readLine() );
		for (int c = 1; c <= casos; c++) {

			binaryST = new BinarySearchTree<Integer>();

			int command = Integer.parseInt(reader.readLine());
			str.append( "Caso #" + c + ":\n" );

			for (int x = 1; x <= command; x++) {

				line = reader.readLine();
				String strArray[] = line.split(" ");
				
				switch (strArray[0]) {
					case "agregar":
						binaryST.insert(Integer.parseInt(strArray[1]));
						break;
						
					case "ancestro":
						Integer answer = binaryST.ancestor( Integer.parseInt(strArray[1]), Integer.parseInt(strArray[2]) );
						if (answer == null) {
							str.append("ancestro: -1" + "\n" );
						} else {
							str.append("ancestro: " + answer + "\n" );
						}
						break;
						
					case "distancia":
						str.append( "distancia: " + binaryST.distance( Integer.parseInt(strArray[1]),
								Integer.parseInt(strArray[2]) ) + "\n" );
						break;
				}
			}
		}

		System.out.println(str);
	}
	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PB;

////	Lab 05 (SegmentTree & BinaryHeap) - Problema B

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;

public class Main {

	//---------------------------------------------------------------------------------------//

	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) > 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMax() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMax() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType maxItem = findMax();
			array[1] = array[currentSize--];
			percolateDown(1);

			return maxItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) > 0)
					child++;
				if (array[child].compareTo(tmp) > 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

		/////////////////////////////////////////////////////////////////

		/**
		 * Return size of the BinaryHeap.
		 */
		public int size() {
			return currentSize;
		}

		public AnyType valueArray(int idx) {
			return array[idx];
		}
	}

	//---------------------------------------------------------------------------------------//

	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * LinkedList class implements a doubly-linked list.
		 */

		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;
			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		/**
		 * Returns the index of the first occurrence of the given value in the
		 * list, or -1 if the value is not found in the list.
		 */
		public int indexOf(AnyType x) {
			int index = 0;
			if (x == null) {
				for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
					if (p.data == null)
						return index;
					index++;
				}
			} else {
				for (Node<AnyType> p = beginMarker; p != null; p = p.next) {
					if (x.equals(p.data))
						return index;
					index++;
				}
			}
			return -1;
		}

		/**
		 * Returns {true} if this list contains the specified element.
		 */
		public boolean contains(AnyType x) {
			return indexOf(x) != -1;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	//---------------------------------------------------------------------------------------//

	public static class Printer implements Comparable < Printer > {

		public int value;
		public int index;
		public boolean last;
		public boolean mine;
		
		Printer(int value, int index, boolean mine) {
			this.value = value;
			this.index = index;
			this.last = false;
			this.mine = mine;
		}

		public int compareTo(Printer t) {
			if (value < t.value) {
				return -1;
			} else if (value > t.value) {
				return 1;
			} else {
				return 0;
			}
		}
		
	}
	
	//---------------------------------------------------------------------------------------//

	public static void main(String[] args) throws Exception {
		
		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/B_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}
		
		Printer myPrinter;
		BinaryHeap<Printer> binaryHeap;
		MyLinkedList<Printer> linkedList;
		
		StringBuilder str = new StringBuilder();
		String line;

		int casos = Integer.parseInt(reader.readLine());
		for (int x = 0; x < casos; x++) {

			binaryHeap = new BinaryHeap<>();
			linkedList = new MyLinkedList<>();

			int idx = 0;
			int time = 0;

			line = reader.readLine();
			String[] strArray = line.split(" ");

			//int numberJobs = Integer.parseInt(strArray[0]);
			int idxMyJob = Integer.parseInt(strArray[1]);

			line = reader.readLine();
			strArray = line.split(" ");

			int myJob = Integer.parseInt( strArray[idxMyJob] );
			int idxLargest = -1;
			int valueMax = 0;
			boolean band = false;

			for (int i = 0; i < strArray.length; i++) {

				myPrinter = new Printer(Integer.parseInt(strArray[i]), idx, false);

				if (Integer.parseInt(strArray[i]) >= myJob) {
					if (i == idxMyJob) {
						myPrinter.mine = true;
					}
					binaryHeap.insert(myPrinter);
					linkedList.add(myPrinter);
					idx++;
				}
			}
			
			while (true) {
				if (myJob != binaryHeap.findMax().value) {
					valueMax = binaryHeap.deleteMax().value;
					time++;
				} else {
					break;
				}
			}

			for (int n = 0; n < linkedList.size(); n++) {
				if (linkedList.get(n).value == valueMax) {
					idxLargest = linkedList.get(n).index;
					break;
				}
			}

			if (idxLargest >= linkedList.size() - 1) {
				idxLargest = -1;
			}

			for (int j = idxLargest + 1; j <= linkedList.size() + 1; j++) {

				if (j == linkedList.size()) {
					j = 0;
				}
				if (band == true) {
					break;
				}
				if (linkedList.get(j).mine) {
					time++;
					break;
				}
				if (linkedList.get(j).value == myJob) {
					time++;
				}
				
			}

			str.append(time + "\n");
		}

		System.out.println(str);
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PC2;

////	Lab 06 (Hash & UnionFind) - Problema C

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.TreeMap;

public class Main {
	
	//---------------------------------------------------------------------------------------//
	
	public static class UnionFind {
		private int padre[];
		private int rango[];
		private int count;

		public UnionFind(int n) {
			padre = new int[n];
			rango = new int[n];
			count = n;
			for (int i = 0; i < n; i++) {
				padre[i] = i;
				rango[i] = 1;
			}
		}

		public int find(int x) {
			if (padre[x] != x)
				return padre[x] = find(padre[x]);
			return x;
		}
		
		public int getCount() {
			return count;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if (rango[a] < rango[b]) {
				padre[a] = b;
				rango[b] += rango[a];
			} else {
				padre[b] = a;
				rango[a] += rango[b];
			}
			count--;
		}
	}

	//---------------------------------------------------------------------------------------//
	
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/C_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}

		StringBuilder str = new StringBuilder();

		int casos = Integer.parseInt(reader.readLine());
		for (int i = 1; i <= casos; i++) {
			
			str.append("Caso #" + i + ":" + "\n");
			
			TreeMap<Integer, String> keyFriend = new TreeMap<>();
			TreeMap<String, Integer> friendKey = new TreeMap<>();
			
			int n = Integer.parseInt(reader.readLine());
			UnionFind uniony = new UnionFind(2 * n);
			
			//UnionFind uniony = new UnionFind();
			//uniony.makeSet(2*n);
			
			int count = 0;
			int idx1;
			int idx2;

			for (int k = 0; k < n; k++) {
				
				String strFriends = reader.readLine();
				String[] friendsArray = strFriends.split(" ");
				
				if (k == 0) {
					
					keyFriend.put(count, friendsArray[0]);
					friendKey.put(friendsArray[0], count);
					keyFriend.put(count + 1, friendsArray[1]);
					friendKey.put(friendsArray[1], count + 1);
					
					uniony.union(count, count + 1);
					str.append( uniony.rango[uniony.find(count)] + "\n" );
					
					count += 2;
					
				} else {
					
					if ( keyFriend.containsValue(friendsArray[0]) && friendKey.containsKey(friendsArray[0]) ) {
						idx1 = friendKey.get( friendsArray[0] );
					} else {
						idx1 = count;
						keyFriend.put( count, friendsArray[0] );
						friendKey.put( friendsArray[0], count );
						count++;
					}
					
					if ( keyFriend.containsValue(friendsArray[1]) && friendKey.containsKey(friendsArray[1]) ) {
						idx2 = friendKey.get( friendsArray[1] );
					} else {
						idx2 = count;
						keyFriend.put( count, friendsArray[1] );
						friendKey.put( friendsArray[1], count );
						count++;
					}
					
					uniony.union( idx1, idx2 );
					str.append( uniony.rango[uniony.find(idx1)] + "\n" );
				}
			}
		}
		
		System.out.print(str);
	}
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PD;

////	Lab 06 (Hash & UnionFind) - Problema D

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	// ---------------------------------------------------------------------------------------//

	public static class UnionFind {
		private int padre[];
		private int rango[];
		private int count;

		public UnionFind(int n) {
			padre = new int[n];
			rango = new int[n];
			count = n;
			for (int i = 0; i < n; i++) {
				padre[i] = i;
				rango[i] = 1;
			}
		}

		public int find(int x) {
			if (padre[x] != x)
				return padre[x] = find(padre[x]);
			return x;
		}

		public int getCount() {
			return count;
		}

		public void union(int x, int y) {
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if (rango[a] < rango[b]) {
				padre[a] = b;
				rango[b] += rango[a];
			} else {
				padre[b] = a;
				rango[a] += rango[b];
			}
			count--;
		}
	}

	// ---------------------------------------------------------------------------------------//

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/D_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}

		StringBuilder str = new StringBuilder();

		int casos = Integer.parseInt(reader.readLine());
		for (int i = 1; i <= casos; i++) {
			str.append("Caso #" + i + ":" + "\n");

			String line = reader.readLine();
			String[] strArray = line.split(" ");

			int n = Integer.parseInt(strArray[0]);

			UnionFind uniony = new UnionFind(2 * n);
			int command = Integer.parseInt(strArray[1]);
			
			for (int k = 1; k <= command; k = k + 1) {
				
				String op = reader.readLine();
				String[] strOperation = op.split(" ");
				
				int operacion = Integer.parseInt(strOperation[0]);
				int preso1 = Integer.parseInt(strOperation[1]);
				int preso2 = Integer.parseInt(strOperation[2]);
				
				switch (operacion) {
				case 1:
					if ( (uniony.find(2 * preso1 + 1) == uniony.find(2 * preso2)) ) {
						str.append("-1" + "\n");
					} else {
						uniony.union(2 * preso1, 2 * preso2);
						uniony.union(2 * preso1 + 1, 2 * preso2 + 1);
					}
					break;
				case 2:
					if ( uniony.find(2 * preso1) == uniony.find(2 * preso2) ) {
						str.append("-1" + "\n");
					} else {
						uniony.union(2 * preso1, 2 * preso2 + 1);
						uniony.union(2 * preso1 + 1, 2 * preso2);
					}
					break;
				case 3:
					if ( (uniony.find(2 * preso1) == uniony.find(2 * preso2)) ) {
						str.append("1" + "\n");
					} else {
						str.append("0" + "\n");
					}
					break;
				case 4:
					if ((uniony.find(2 * preso1 + 1) == uniony.find(2 * preso2))) {
						str.append("1" + "\n");
					} else {
						str.append("0" + "\n");
					}
					break;
				}
			}
		}
		System.out.print(str);
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package PE;

////	Lab 04 (Arboles) - Problema E

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;

public class Main {

	// BinarySearchTree class
	//
	// CONSTRUCTION: with no initializer
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x ) --> Insert x
	// void remove( x ) --> Remove x
	// boolean contains( x ) --> Return true if x is present
	// Comparable findMin( ) --> Return smallest item
	// Comparable findMax( ) --> Return largest item
	// boolean isEmpty( ) --> Return true if empty; else false
	// void makeEmpty( ) --> Remove all items
	// void printTree( ) --> Print tree in sorted order
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements an unbalanced binary search tree. Note that all "matching" is
	 * based on the compareTo method.
	 * 
	 */
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the tree.
		 */
		public BinarySearchTree() {
			root = null;
		}

		/**
		 * Insert into the tree; duplicates are ignored.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			root = insert(x, root);
		}

		/**
		 * Remove from the tree. Nothing is done if x is not found.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			root = remove(x, root);
		}

		/**
		 * Find the smallest item in the tree.
		 * 
		 * @return smallest item or null if empty.
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMin(root).element;
		}

		/**
		 * Find the largest item in the tree.
		 * 
		 * @return the largest item of null if empty.
		 */
		public AnyType findMax() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMax(root).element;
		}

		/**
		 * Find an item in the tree.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if not found.
		 */
		public boolean contains(AnyType x) {
			return contains(x, root);
		}

		/**
		 * Make the tree logically empty.
		 */
		public void makeEmpty() {
			root = null;
		}

		/**
		 * Test if the tree is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return root == null;
		}

		/**
		 * Print the tree contents in sorted order.
		 */
		public void printTree() {
			if (isEmpty())
				System.out.println("Empty tree");
			else
				printTree(root);
		}

		/**
		 * Internal method to insert into a subtree.
		 * 
		 * @param x
		 *            the item to insert.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> insert(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return new BinaryNode<>(x, null, null);

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = insert(x, t.left);
			else if (compareResult > 0)
				t.right = insert(x, t.right);
			else
				; // Duplicate; do nothing
			return t;
		}

		/**
		 * Internal method to remove from a subtree.
		 * 
		 * @param x
		 *            the item to remove.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> remove(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return t; // Item not found; do nothing

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = remove(x, t.left);
			else if (compareResult > 0)
				t.right = remove(x, t.right);
			else if (t.left != null && t.right != null) // Two children
			{
				t.element = findMin(t.right).element;
				t.right = remove(t.element, t.right);
			} else
				t = (t.left != null) ? t.left : t.right;
			return t;
		}

		/**
		 * Internal method to find the smallest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the smallest item.
		 */
		private BinaryNode<AnyType> findMin(BinaryNode<AnyType> t) {
			if (t == null)
				return null;
			else if (t.left == null)
				return t;
			return findMin(t.left);
		}

		/**
		 * Internal method to find the largest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the largest item.
		 */
		private BinaryNode<AnyType> findMax(BinaryNode<AnyType> t) {
			if (t != null)
				while (t.right != null)
					t = t.right;

			return t;
		}

		/**
		 * Internal method to find an item in a subtree.
		 * 
		 * @param x
		 *            is item to search for.
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the matched item.
		 */
		private boolean contains(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return false;

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				return contains(x, t.left);
			else if (compareResult > 0)
				return contains(x, t.right);
			else
				return true; // Match
		}

		/**
		 * Internal method to print a subtree in sorted order.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private void printTree(BinaryNode<AnyType> t) {
			if (t != null) {
				printTree(t.left);
				System.out.println(t.element);
				printTree(t.right);
			}
		}

		/**
		 * Internal method to compute height of a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private int height(BinaryNode<AnyType> t) {
			if (t == null)
				return -1;
			else
				return 1 + Math.max(height(t.left), height(t.right));
		}

		// Basic node stored in unbalanced binary search trees
		private static class BinaryNode<AnyType> {
			// Constructors
			BinaryNode(AnyType theElement) {
				this(theElement, null, null);
			}

			BinaryNode(AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt) {
				element = theElement;
				left = lt;
				right = rt;
			}

			AnyType element; // The data in the node
			BinaryNode<AnyType> left; // Left child
			BinaryNode<AnyType> right; // Right child
		}

		/** The tree root. */
		private BinaryNode<AnyType> root;

		///////////////////////////////////////////////////////

		// Ancestro comun entre dos nodos.
		public AnyType ancestor(AnyType u, AnyType v) {
			if (contains(u) && contains(v)) {
				return ancestor(u, v, root).element;
			} else
				return null;
		}

		private BinaryNode<AnyType> ancestor(AnyType u, AnyType v, BinaryNode<AnyType> t) {

			boolean band = false;

			while (band == false) {

				int compareNodeU = u.compareTo(t.element);
				int comparteNodeV = v.compareTo(t.element);

				if ((compareNodeU == 0 && comparteNodeV > 0) || (compareNodeU == 0 && comparteNodeV < 0)) {
					band = true;
					return t;
				}
				if ((comparteNodeV == 0 && compareNodeU > 0) || (comparteNodeV == 0 && compareNodeU < 0)) {
					band = true;
					return t;
				}
				if (compareNodeU == 0 && comparteNodeV == 0) {
					band = true;
					return t;
				}
				if ((compareNodeU > 0 && comparteNodeV < 0) || (compareNodeU < 0 && comparteNodeV > 0)) {
					band = true;
					return t;
				}
				if (compareNodeU > 0) {
					t = t.right;
				}
				if (compareNodeU < 0) {
					t = t.left;
				}
			}
			return t;
		}

		///////////////////////////////////////////////////////

		// Distancia entre dos nodos.
		public int distance(AnyType u, AnyType v) {
			if (contains(u) && contains(v)) {
				return distance(u, v, ancestor(u, v, root));
			} else
				return -1;
		}

		private int distance(AnyType u, AnyType v, BinaryNode<AnyType> t) {

			int dist = 0;
			boolean band = false;
			int compareNodeU = 0;
			int compareNodeV = 0;

			BinaryNode<AnyType> aux = t;

			if (u == v) {
				return 0;
			}

			while (band == false) {

				compareNodeU = u.compareTo(t.element);

				if (compareNodeU == 0) {
					// signal=true;
					break;
				}
				if (compareNodeU > 0) {
					dist++;
					t = t.right;
				}
				if (compareNodeU < 0) {
					dist++;
					t = t.left;
				}
			}

			while (band == false) {

				compareNodeV = v.compareTo(aux.element);

				if (compareNodeV == 0) {
					// signal=true;
					break;
				}
				if (compareNodeV > 0) {
					dist++;
					aux = aux.right;
				}
				if (compareNodeV < 0) {
					dist++;
					aux = aux.left;
				}
			}
			return dist;
		}

		///////////////////////////////////////////////////////

		public int contar(AnyType u) {
			if (contains(u)) {
				return contar(u, root);
			} else
				return -1;
		}

		private int contar(AnyType u, BinaryNode<AnyType> e) {

			boolean band1 = false;
			int account = 0;

			BinaryNode<AnyType> data = null;

			while (band1 == false) {
				int compareResult_u = u.compareTo(e.element);

				if (compareResult_u == 0) {
					data = e;
					break;
				}
				if (compareResult_u > 0) {
					e = e.right;
				}
				if (compareResult_u < 0) {
					e = e.left;
				}
			}
			account = printTree(data, account);

			return account - 1;
		}

		private int printTree(BinaryNode<AnyType> e, int count) {
			if (e != null) {
				count = printTree(e.left, count);
				count++;
				count = printTree(e.right, count);
			}
			return count;
		}

	}

	public static void main(String[] args) throws Exception {

		BufferedReader reader;
		File file = new File("C:/Users/jaime_000/Desktop/E_2.txt");
		if (file.exists()) {
			reader = new BufferedReader(new FileReader(file));
		} else {
			reader = new BufferedReader(new InputStreamReader(System.in));
		}

		BinarySearchTree<Integer> binaryST;

		StringBuilder str = new StringBuilder();
		String line;

		int casos = Integer.parseInt(reader.readLine());
		for (int c = 1; c <= casos; c++) {

			binaryST = new BinarySearchTree<>();

			int command = Integer.parseInt(reader.readLine());
			str.append("Caso #" + c + ":\n");

			for (int x = 1; x <= command; x++) {

				line = reader.readLine();
				String strArray[] = line.split(" ");

				switch (strArray[0]) {

				case "agregar":
					binaryST.insert(Integer.parseInt(strArray[1]));
					break;
					
				case "ancestro":
					Integer answer = binaryST.ancestor( Integer.parseInt(strArray[1]), Integer.parseInt(strArray[2]) );
					if (answer == null) {
						str.append("ancestro: -1" + "\n");
					} else {
						str.append("ancestro: " + answer + "\n");
					}
					break;
					
				case "distancia":
					str.append("distancia: "
							+ binaryST.distance(Integer.parseInt(strArray[1]), Integer.parseInt(strArray[2])) + "\n");
					break;

				case "contar":
					str.append("contar: " + binaryST.contar(Integer.parseInt(strArray[1])) + "\n");
					break;

				}
			}
		}

		System.out.println(str);
	}
	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
