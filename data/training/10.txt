import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		int nCasos = 0;
		int nNum = 0;
		Scanner in = new Scanner(System.in);
		try{
			nCasos = in.nextInt();
		}catch(Exception  e){
			
		}
		for(int i = 0; i<nCasos; i++){
			try{
				nNum = in.nextInt();
			}catch(Exception e){
				
			}
			ArrayList<Integer> numeros = new ArrayList();
			for(int j = 0; j < nNum;j++){
				
				try{
					numeros.add(in.nextInt());
				}catch(Exception e){
					
				}
			}
			int menores  = 0, iguales= 0, mayores = 0;
			for(int k = 0; k < numeros.size(); k ++){
				for(int l = 0; l < numeros.size(); l ++){
					if(numeros.get(k)<numeros.get(l)) menores++;
					if(k!=l && numeros.get(k)==numeros.get(l) ) iguales++;

					if(numeros.get(k)>numeros.get(l)) mayores++;
				}
			}
			System.out.println("Case #"+(i+1)+":");
			System.out.println(mayores);
			System.out.println(menores);
			System.out.println(iguales);
		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		int numCase = 0;
		while(true){
			numCase ++;
			int N = 0;
			
			Scanner in = new Scanner(System.in);
			
			try{
				do{
				N = in.nextInt();
				}while(N<1 && N  >100);
			}catch(Exception  e){
				
			}
			
			ArrayList< ArrayList<Integer> > numeros = new ArrayList();
			
			for(int i = 0; i < N ; i ++){
				 ArrayList<Integer> aux = new ArrayList();
				for (int j = 0;j < N ; j++){
					try{
						aux.add(in.nextInt());
					}catch(Exception  e){
						
					}
				}
				numeros.add(aux);
			}
			
			int casillasGanadoras = 0;
			for(int i=0; i<N ; i++){
				for(int j=0; j<N; j++){
					int filas = 0, columnas = 0;
					for(int k=0; k<N; k++){
						filas += numeros.get(i).get(k);
						columnas += numeros.get(k).get(j);
					}
					if(filas < columnas){
						casillasGanadoras++;
					}
				}
			}
			System.out.println("Case #"+numCase+":");
			System.out.println(casillasGanadoras);
		}

		}

	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		int numCase = 0;
		while(true){
			numCase ++;
			int N = 0;
			
			Scanner in = new Scanner(System.in);
			
			try{
				do{
				N = in.nextInt();
				}while(N<1 && N  >100);
			}catch(Exception  e){
				
			}
			
			ArrayList< ArrayList<Integer> > numeros = new ArrayList();
			
			for(int i = 0; i < N ; i ++){
				 ArrayList<Integer> aux = new ArrayList();
				for (int j = 0;j < N ; j++){
					try{
						aux.add(in.nextInt());
					}catch(Exception  e){
						
					}
				}
				numeros.add(aux);
			}
			
			int casillasGanadoras = 0;
			for(int i=0; i<N ; i++){
				for(int j=0; j<N; j++){
					int filas = 0, columnas = 0;
					for(int k=0; k<N; k++){
						filas += numeros.get(i).get(k);
						columnas += numeros.get(k).get(j);
					}
					if(filas < columnas){
						casillasGanadoras++;
					}
				}
			}
			System.out.println("Case #"+numCase+":");
			System.out.println(casillasGanadoras);
		}

		}

	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		int numCase = 0;
		while(true){
			numCase ++;
			int N = 0;
			
			Scanner in = new Scanner(System.in);
			
			try{
				do{
				N = in.nextInt();
				}while(N<1 && N  >100);
			}catch(Exception  e){
				
			}
			
			ArrayList< ArrayList<Integer> > numeros = new ArrayList();
			
			for(int i = 0; i < N ; i ++){
				 ArrayList<Integer> aux = new ArrayList();
				for (int j = 0;j < N ; j++){
					try{
						aux.add(in.nextInt());
					}catch(Exception  e){
						
					}
				}
				numeros.add(aux);
			}
			
			int casillasGanadoras = 0;
			for(int i=0; i<N ; i++){
				for(int j=0; j<N; j++){
					int filas = 0, columnas = 0;
					for(int k=0; k<N; k++){
						filas += numeros.get(i).get(k);
						columnas += numeros.get(k).get(j);
					}
					if(filas < columnas){
						casillasGanadoras++;
					}
				}
			}
			System.out.println("Case #"+numCase+":");
			System.out.println(casillasGanadoras);
		}

		}

	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		int numCase = 0;
		Scanner in = new Scanner(System.in);
		while(in.hasNextLine()){
			numCase ++;
			int N = 0;
			
			
			
			try{
				do{
				N = in.nextInt();
				}while(N<1 && N  >100);
			}catch(Exception  e){
				
			}
			
			ArrayList< ArrayList<Integer> > numeros = new ArrayList();
			
			for(int i = 0; i < N ; i ++){
				 ArrayList<Integer> aux = new ArrayList();
				for (int j = 0;j < N ; j++){
					try{
						aux.add(in.nextInt());
					}catch(Exception  e){
						
					}
				}
				numeros.add(aux);
			}
			
			int casillasGanadoras = 0;
			for(int i=0; i<N ; i++){
				for(int j=0; j<N; j++){
					int filas = 0, columnas = 0;
					for(int k=0; k<N; k++){
						filas += numeros.get(i).get(k);
						columnas += numeros.get(k).get(j);
					}
					if(filas < columnas){
						casillasGanadoras++;
					}
				}
			}
			System.out.println("Case #"+numCase+":");
			System.out.println(casillasGanadoras);
		}

		}

	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sia;



import java.util.ArrayList;
import java.util.Scanner;

    public class Sia {

	public static void main(String[] args) {
		int numCase = 0;
		Scanner in = new Scanner(System.in);
		while(in.hasNextLine()){
			numCase ++;
			int N = 0;
			
			
			
			try{
				do{
				N = in.nextInt();
				}while(N<1 && N  >100);
			}catch(Exception  e){
				
			}
			
			ArrayList< ArrayList<Integer> > numeros = new ArrayList();
			
			for(int i = 0; i < N ; i ++){
				 ArrayList<Integer> aux = new ArrayList();
				for (int j = 0;j < N ; j++){
					try{
						aux.add(in.nextInt());
					}catch(Exception  e){
						
					}
				}
				numeros.add(aux);
			}
			
			int casillasGanadoras = 0;
			for(int i=0; i<N ; i++){
				for(int j=0; j<N; j++){
					int filas = 0, columnas = 0;
					for(int k=0; k<N; k++){
						filas += numeros.get(i).get(k);
						columnas += numeros.get(k).get(j);
					}
					if(filas < columnas){
						casillasGanadoras++;
					}
				}
			}
			System.out.println("Case #"+numCase+":");
			System.out.println(casillasGanadoras);
		}

		}

	}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sia;



import java.util.ArrayList;
import java.util.Scanner;

    public class Sia {

	public static void main(String[] args) {
		int numCase = 0;
		Scanner in = new Scanner(System.in);
		while(in.hasNextInt()){
			numCase ++;
			int N = 0;
			
			
			
			try{
				do{
				N = in.nextInt();
				}while(N<1 && N  >100 && in.hasNextInt() );
			}catch(Exception  e){
				
			}
			
			ArrayList< ArrayList<Integer> > numeros = new ArrayList();
			
			for(int i = 0; i < N ; i ++){
				 ArrayList<Integer> aux = new ArrayList();
				for (int j = 0;j < N ; j++){
					try{
						aux.add(in.nextInt());
					}catch(Exception  e){
						
					}
				}
				numeros.add(aux);
			}
			
			int casillasGanadoras = 0;
			for(int i=0; i<N ; i++){
				for(int j=0; j<N; j++){
					int filas = 0, columnas = 0;
					for(int k=0; k<N; k++){
						filas += numeros.get(i).get(k);
						columnas += numeros.get(k).get(j);
					}
					if(filas < columnas){
						casillasGanadoras++;
					}
				}
			}
			System.out.println("Case #"+numCase+":");
			System.out.println(casillasGanadoras);
		}

		}

	}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sia;



import java.util.ArrayList;
import java.util.Scanner;

    public class Sia {

	public static void main(String[] args) {
		int numCase = 0;
                boolean preguntando = true;
		Scanner in = new Scanner(System.in);
		while(preguntando){
			numCase ++;
			int N = 0;
			
			
			
			try{
                                if(in.hasNextInt()){
				do{
				N = in.nextInt();
				}while(N<1 && N  >100 );
                                }else preguntando = false;
			}catch(Exception  e){
				
			}
			
			ArrayList< ArrayList<Integer> > numeros = new ArrayList();
			
                        if(preguntando){
			for(int i = 0; i < N ; i ++){
				 ArrayList<Integer> aux = new ArrayList();
				for (int j = 0;j < N ; j++){
					try{
						aux.add(in.nextInt());
					}catch(Exception  e){
						
					}
				}
				numeros.add(aux);
			}
                        }
			
			int casillasGanadoras = 0;
			for(int i=0; i<N ; i++){
				for(int j=0; j<N; j++){
					int filas = 0, columnas = 0;
					for(int k=0; k<N; k++){
						filas += numeros.get(i).get(k);
						columnas += numeros.get(k).get(j);
					}
					if(filas < columnas){
						casillasGanadoras++;
					}
				}
			}
                        if(preguntando){
			System.out.println("Case #"+numCase+":");
			System.out.println(casillasGanadoras);
                        }
		}

		}

	}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sia;



import java.util.ArrayList;
import java.util.Scanner;

    public class Sia {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
                int numCase = 0;
                int T =0;
                        try{
                            T = in.nextInt();
                        }catch(Exception  e){
				
			}
                //Casos de prueba        
                for (int i = 0; i < T; i++){
                    numCase++;
                    
                    ArrayList<Integer> equipos = new ArrayList();
                    equipos.clear();
                    int numVestRep = 0;
                    //NUMERO DE EQUIPOS QUE JUEGAN EL TORNEO 
                    int N = 0;
                        try{
                            N = in.nextInt();
                        }catch(Exception  e){
				
			}
                    for (int j = 0; j < N; j++){
                        try{
                            equipos.add(in.nextInt());
                        }catch(Exception  e){
				
			}
                        try{
                             equipos.add(in.nextInt());
                        }catch(Exception  e){
				
			}
                    }
                    
                    for(int k = 1; k <= N-2; k++){
                        if(equipos.get(0) == equipos.get(k+3)) numVestRep++;
                    }
                    
                    System.out.println("Case #"+numCase+":");
                    System.out.println(numVestRep);   
                    
                    
                }  
        }
    }

	


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

/**
 *
 */
public class Sia {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
         
        
         Scanner ent1= new Scanner (System.in);
       
         int casos = (ent1.nextInt());
         
         int t =0;
             if(casos <=100)
                  
           for (int i = 0; i < casos; i++) {
            t=t+1;
             
        
         int piedras = (ent1.nextInt());
            
         String con [] = new String [piedras]; 
         
         for(int f=0;f<con.length;f++){
             
                con [f]= ent1.next();
             
                                    
                     
             }
         
         
         
         
         if(piedras >=1){
         if(piedras<=6){
           
           
             if (piedras==1){
             
              for(int f=0;f<1;f++){
             
                 con [f]= ent1.next();
             
                    
                    
              
              
              System.out.println("Case #" + t +":");  
               System.out.println(con[f]);
                 
             }
             }
             
             
              if(piedras==2){
           
                 for (int j = 0; j < 1; j++) {
                     String con1 = con[j];
                     String con2 = con[1];
                 //for (int k = 1; k < 2; k++) {
                        // String con2 = con[k];
                         
                  if(con[0].equals(con[1])==true){
                         
                  
           System.out.println("Case #" + t +":");  
               System.out.println(con[0]+con[1]);
                     
                 
                  }else if (con[0].equals(con[1])==false){
                 
                  
           System.out.println("Case #" + t +":");  
               System.out.println(con[0]+con[1]);
                System.out.println(con[1]+con[0]);
                  }    
                 }   
                 
                 }}
 
                 
               if(piedras==3){
                 
              System.out.println("Case #" + t +":");  
                 for (int j = 0; j < con.length; j++) {
                     String con1 = con[j];
                     
                     for (int k = 0; k < con.length; k++) {
                         String con2 = con[k];
                         
                         if(j!=k)
                     
                         for (int l = 0; l < con.length; l++) {
                             String con3 = con[l];
                             
                         if(j!=l && k!=l)
                             
                           
               System.out.println(con[j]+con[k]+con[l]);
                
                                       
                             
                             
                         
                         }
                                       
                     }
                   }
                    
             }
                 
                    
                    
                 if (piedras==4){
              
              System.out.println("Case #" + t +":");  
                 for (int j = 0; j < con.length; j++) {
                     String con1 = con[j];
                     
                     for (int k = 0; k < con.length; k++) {
                         String con2 = con[k];
                         
                         if(j!=k)
                     
                         for (int l = 0; l < con.length; l++) {
                             String con3 = con[l];
                             
                         if(j!=l && k!=l)
                             for (int m = 0; m < con.length; m++) {
                                 String con4 = con[m];
                                 
                             if (j!=m && k!=m && l!=m )
                           
               System.out.println(con[j]+con[k]+con[l]+con[m]);
                
                        }               
                             
                             
                         
                         }
                                        
                     }
                   
                 }
             
         
                 }
         

                  if (piedras==5){
               
              System.out.println("Case #" + t +":");  
                 for (int j = 0; j < con.length; j++) {
                     String con1 = con[j];
                     
                     for (int k = 0; k < con.length; k++) {
                         String con2 = con[k];
                         
                         if(j!=k)
                     
                         for (int l = 0; l < con.length; l++) {
                             String con3 = con[l];
                             
                         if(j!=l && k!=l)
                             for (int m = 0; m < con.length; m++) {
                                 String con4 = con[m];
                                 
                             if (j!=m && k!=m && l!=m )
                           
                                 for (int n = 0; n < con.length; n++) {
                                     String con5 = con[n];
                                     
                                 if (j!=n && k!=n && l!=n && m!=n )
                                 
                                 
                        System.out.println(con[j]+con[k]+con[l]+con[m]+con[n]);
                }
                        }               
                             
                             
                         
                         }
                                        
                     }
                   
                 }
               
         
                 }
         

                  if (piedras==6){
               
              System.out.println("Case #" + t +":");  
                 for (int j = 0; j < con.length; j++) {
                     String con1 = con[j];
                     
                     for (int k = 0; k < con.length; k++) {
                         String con2 = con[k];
                         
                         if(j!=k)
                     
                         for (int l = 0; l < con.length; l++) {
                             String con3 = con[l];
                             
                         if(j!=l && k!=l)
                             for (int m = 0; m < con.length; m++) {
                                 String con4 = con[m];
                                 
                             if (j!=m && k!=m && l!=m )
                           
                                 for (int n = 0; n < con.length; n++) {
                                     String con5 = con[n];
                                     
                                 if (j!=n && k!=n && l!=n && m!=n )
                                 
                                 
                                         for (int o = 0; o < con.length; o++) {
                                             String con6 = con[o];
                                             
                                         
                                          if (j!=o && k!=o && l!=o && m!=o )
                                     
                        System.out.println(con[j]+con[k]+con[l]+con[m]+con[n]+con[0]);
                        }
                }
                        }               
                             
                             
                         
                         }
                                        
                     }
                   
                 }
               
         
                 }

        





      //fin opera
         }
           
                 
             
                 }}
    
}


//}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class Sia {


    public static void main(String[] args) {
         
        
         Scanner ent1= new Scanner (System.in);
       
         int casos = (ent1.nextInt());
         
         int t =0;
             if(casos <=100)
                  
           for (int i = 0; i < casos; i++) {
            t=t+1;
             
        
         int piedras = (ent1.nextInt());
            
         String con [] = new String [piedras]; 
         
         for(int f=0;f<con.length;f++){
             
                con [f]= ent1.next();
             
                                    
                     
             }
         
         
         
         
         if(piedras >=1){
         if(piedras<=6){
           
           
             if (piedras==1){
             
              for(int f=0;f<1;f++){
             
                 con [f]= ent1.next();
             
                    
                    
              
              
              System.out.println("Case #" + t +":");  
               System.out.println(con[f]);
                 
             }
             }
             
             
              if(piedras==2){
           
                 for (int j = 0; j < 1; j++) {
                     String con1 = con[j];
                     String con2 = con[1];
                 //for (int k = 1; k < 2; k++) {
                        // String con2 = con[k];
                         
                  if(con[0].equals(con[1])==true){
                         
                  
           System.out.println("Case #" + t +":");  
               System.out.println(con[0]+con[1]);
                     
                 
                  }else if (con[0].equals(con[1])==false){
                 
                  
           System.out.println("Case #" + t +":");  
               System.out.println(con[0]+con[1]);
                System.out.println(con[1]+con[0]);
                  }    
                 }   
                 
                 }}
 
                 
               if(piedras==3){
                 
              System.out.println("Case #" + t +":");  
                 for (int j = 0; j < con.length; j++) {
                     String con1 = con[j];
                     
                     for (int k = 0; k < con.length; k++) {
                         String con2 = con[k];
                         
                         if(j!=k)
                     
                         for (int l = 0; l < con.length; l++) {
                             String con3 = con[l];
                             
                         if(j!=l && k!=l)
                             
                           
               System.out.println(con[j]+con[k]+con[l]);
                
                                       
                             
                             
                         
                         }
                                       
                     }
                   }
                    
             }
                 
                    
                    
                 if (piedras==4){
              
              System.out.println("Case #" + t +":");  
                 for (int j = 0; j < con.length; j++) {
                     String con1 = con[j];
                     
                     for (int k = 0; k < con.length; k++) {
                         String con2 = con[k];
                         
                         if(j!=k)
                     
                         for (int l = 0; l < con.length; l++) {
                             String con3 = con[l];
                             
                         if(j!=l && k!=l)
                             for (int m = 0; m < con.length; m++) {
                                 String con4 = con[m];
                                 
                             if (j!=m && k!=m && l!=m )
                           
               System.out.println(con[j]+con[k]+con[l]+con[m]);
                
                        }               
                             
                             
                         
                         }
                                        
                     }
                   
                 }
             
         
                 }
         

                  if (piedras==5){
               
              System.out.println("Case #" + t +":");  
                 for (int j = 0; j < con.length; j++) {
                     String con1 = con[j];
                     
                     for (int k = 0; k < con.length; k++) {
                         String con2 = con[k];
                         
                         if(j!=k)
                     
                         for (int l = 0; l < con.length; l++) {
                             String con3 = con[l];
                             
                         if(j!=l && k!=l)
                             for (int m = 0; m < con.length; m++) {
                                 String con4 = con[m];
                                 
                             if (j!=m && k!=m && l!=m )
                           
                                 for (int n = 0; n < con.length; n++) {
                                     String con5 = con[n];
                                     
                                 if (j!=n && k!=n && l!=n && m!=n )
                                 
                                 
                        System.out.println(con[j]+con[k]+con[l]+con[m]+con[n]);
                }
                        }               
                             
                             
                         
                         }
                                        
                     }
                   
                 }
               
         
                 }
         

                  if (piedras==6){
               
              System.out.println("Case #" + t +":");  
                 for (int j = 0; j < con.length; j++) {
                     String con1 = con[j];
                     
                     for (int k = 0; k < con.length; k++) {
                         String con2 = con[k];
                         
                         if(j!=k)
                     
                         for (int l = 0; l < con.length; l++) {
                             String con3 = con[l];
                             
                         if(j!=l && k!=l)
                             for (int m = 0; m < con.length; m++) {
                                 String con4 = con[m];
                                 
                             if (j!=m && k!=m && l!=m )
                           
                                 for (int n = 0; n < con.length; n++) {
                                     String con5 = con[n];
                                     
                                 if (j!=n && k!=n && l!=n && m!=n )
                                 
                                 
                                         for (int o = 0; o < con.length; o++) {
                                             String con6 = con[o];
                                             
                                         
                                          if (j!=o && k!=o && l!=o && m!=o )
                                     
                        System.out.println(con[j]+con[k]+con[l]+con[m]+con[n]+con[0]);
                        }
                }
                        }               
                             
                             
                         
                         }
                                        
                     }
                   
                 }
               
         
                 }

        





      //fin opera
         }
           
                 
             
                 }}
    
}


//}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;


public class ProblemaC {

	 public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }
}

    public static void main(String[] args) throws FileNotFoundException, Exception {
         Scanner scan;
        File f = new File( "C_2.txt" );
        
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        Map<Integer, Integer> miMapa;
        for ( int test = 1; test <= t; test++ ) {
            miMapa = new HashMap<>();
            int[] nombres = readInts(scan.nextLine());
            int[] N = readInts(scan.nextLine());
            int[] M = readInts(scan.nextLine());
            int[] P = readInts(scan.nextLine());          
            for (int i = 0; i < N.length; i++) {
                if(miMapa.containsKey(N[i]))
                    miMapa.put(N[i], 4);
                else
                    miMapa.put(N[i], 1);
            }
            for (int i = 0; i < M.length; i++) {
                if(miMapa.containsKey(M[i]))
                    miMapa.put(M[i], 4);
                else
                    miMapa.put(M[i], 2);
            }
            for (int i = 0; i < P.length; i++) {
                if(miMapa.containsKey(P[i]))
                    miMapa.put(P[i], 4);
                else
                    miMapa.put(P[i], 3);
            }
            Object[] s= miMapa.keySet().toArray();
            TreeSet tsN = new TreeSet();
            TreeSet tsM = new TreeSet();
            TreeSet tsP = new TreeSet();
            for (int i = 0; i < s.length; i++) {
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 1)
                    tsN.add(s[i]);
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 2)
                    tsM.add(s[i]);
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 3)
                    tsP.add(s[i]);            
            }
            System.out.println("Case #" + test + ":"); 
            if(tsN.size() > tsM.size() && tsN.size() > tsP.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
            }
            if(tsM.size() > tsN.size() && tsM.size() > tsP.size()){
                String aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
            }
            if(tsP.size() > tsM.size() && tsP.size() > tsN.size()){
                String aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux);
            }
            if(tsP.size() == tsM.size() && tsP.size() == tsN.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux); 
            }
            if(tsN.size() == tsM.size() && tsN.size() > tsP.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
            }
            if(tsN.size() == tsP.size() && tsN.size() > tsM.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux); 
            }   
            if(tsM.size() == tsP.size() && tsM.size() > tsN.size()){
                String aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux);  
            }
        }
    }

    

    public static int[] readInts(String cad){
        String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }

    public static String stringFinal(String aux){
    	aux = aux.replace(",", "");
        aux = aux.replace("[", "");
        aux= aux.replace("]", "");
        return aux;
    }
    
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
   
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 *
 */
public class P52 {

public static void main(String[] args) throws FileNotFoundException {
		Scanner scan = new Scanner(System.in);
		File f = new File("D_2.txt");
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int t = Integer.parseInt(scan.nextLine());
                int numCaso = 0;
		//casos
                
                TreeSet p = new TreeSet();
                
		for (int i = 0; i < t; i++) {
			
			numCaso++;
                        System.out.println("Case #"+ numCaso +":");
			//n= numero de candidatos
                        int n = Integer.parseInt(scan.nextLine());
                        //candidatos y partido
                        
                        TreeMap<String,String> tm = new TreeMap();
                        TreeMap<String,Integer> vot = new TreeMap();
                        for (int i2 = 0; i2 < n; i2++) {
                            
                            String nombreYpartido[] = scan.nextLine().split(" ");
                            if(nombreYpartido.length > 1){
                            tm.put(nombreYpartido[0],nombreYpartido[1]);
                            }else{
                                tm.put(nombreYpartido[0],"Independiente");
                            }
                            vot.put(nombreYpartido[0],0);
                        }
                        
                        // numero de votos
                        int q = Integer.parseInt(scan.nextLine());
                        
                        
                        for (int i2 = 0; i2 < q; i2++) {
                           String voto = scan.nextLine();
                           if(tm.containsKey(voto)){
                              int numVoto = vot.get(voto);
                               vot.put(voto, numVoto+1);
                           }
                           
                            
                        }
                        
                      /*************
                              for( Iterator it = tm.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = tm.get(clave).toString();
                            System.out.println(clave + " : " + valor);
            
                        }
                       
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            System.out.println(clave + ": " + valor + " votos");
                        }
                        * 
                        * 
                        * 
                        * *I{*u*****/
                        int v = 0;
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            if (v < Integer.parseInt(valor)){
                                v=Integer.parseInt(valor);
                            }
                        }
                        
                        
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            if (Integer.parseInt(valor)==v){
                                System.out.println(tm.get(clave));
                            }
                        }
                        
                        //System.out.println(v);
                        tm.clear();
                        
                        
			

                        

                       
                        
		}
		
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 *
 */
public class P52 {

public static void main(String[] args) throws FileNotFoundException {
        Scanner scan = new Scanner(System.in);
        File f = new File("D_2.txt");
        if (f.exists()) {
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }

        int t = Integer.parseInt(scan.nextLine());
                int numCaso = 0;
        //casos
                
                TreeSet p = new TreeSet();
                
        for (int i = 0; i < t; i++) {
            
            numCaso++;
                        System.out.println("Case #"+ numCaso +":");
            //n= numero de candidatos
                        int n = Integer.parseInt(scan.nextLine());
                        //candidatos y partido
                        
                        TreeMap<String,String> tm = new TreeMap();
                        TreeMap<String,Integer> vot = new TreeMap();
                        for (int i2 = 0; i2 < n; i2++) {
                            
                            String nombreYpartido[] = scan.nextLine().split(" ");
                            if(nombreYpartido.length > 1){
                            tm.put(nombreYpartido[0],nombreYpartido[1]);
                            }else{
                                tm.put(nombreYpartido[0],"Independiente");
                            }
                            vot.put(nombreYpartido[0],0);
                        }
                        
                        // numero de votos
                        int q = Integer.parseInt(scan.nextLine());
                        
                        
                        for (int i2 = 0; i2 < q; i2++) {
                           String voto = scan.nextLine();
                           if(tm.containsKey(voto)){
                              int numVoto = vot.get(voto);
                               vot.put(voto, numVoto+1);
                           }
                           
                            
                        }
                        
                      /*************
                              for( Iterator it = tm.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = tm.get(clave).toString();
                            System.out.println(clave + " : " + valor);
            
                        }
                       
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            System.out.println(clave + ": " + valor + " votos");
                        }
                        * 
                        * 
                        * 
                        * *I{*u*****/
                        int v = 0;
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            if (v < Integer.parseInt(valor)){
                                v=Integer.parseInt(valor);
                            }
                        }
                        
                        LinkedList respuesta = new LinkedList();
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            if (Integer.parseInt(valor)==v){
                                respuesta.add(tm.get(clave));
                                //System.out.println(tm.get(clave));
                            }
                        }
                        
                        respuesta.sort(null);
                        for(int i3 = 0; i3 < respuesta.size(); i3++){
                            System.out.println(respuesta.get(i3));
                        }
                        
                        //System.out.println(v);
                        tm.clear();
                        
                        
            

                        

                       
                        
        }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 *
 */
public class P52 {

public static void main(String[] args) throws FileNotFoundException {
        Scanner scan = new Scanner(System.in);
        File f = new File("D_2.txt");
        if (f.exists()) {
            scan = new Scanner(f);
        } else {
            scan = new Scanner(System.in);
        }

        int t = Integer.parseInt(scan.nextLine());
                int numCaso = 0;
        //casos
                
                TreeSet p = new TreeSet();
                
        for (int i = 0; i < t; i++) {
            
            numCaso++;
                        System.out.println("Case #"+ numCaso +":");
            //n= numero de candidatos
                        int n = Integer.parseInt(scan.nextLine());
                        //candidatos y partido
                        
                        TreeMap<String,String> tm = new TreeMap();
                        TreeMap<String,Integer> vot = new TreeMap();
                        for (int i2 = 0; i2 < n; i2++) {
                            
                            String nombreYpartido[] = scan.nextLine().split(" ");
                            if(nombreYpartido.length > 1){
                            tm.put(nombreYpartido[0],nombreYpartido[1]);
                            }else{
                                tm.put(nombreYpartido[0],"Independiente");
                            }
                            vot.put(nombreYpartido[0],0);
                        }
                        
                        // numero de votos
                        int q = Integer.parseInt(scan.nextLine());
                        
                        
                        for (int i2 = 0; i2 < q; i2++) {
                           String voto = scan.nextLine();
                           if(tm.containsKey(voto)){
                              int numVoto = vot.get(voto);
                               vot.put(voto, numVoto+1);
                           }
                           
                            
                        }
                        
                      /*************
                              for( Iterator it = tm.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = tm.get(clave).toString();
                            System.out.println(clave + " : " + valor);
            
                        }
                       
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            System.out.println(clave + ": " + valor + " votos");
                        }
                        * 
                        * 
                        * 
                        * *I{*u*****/
                        int v = 0;
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            if (v < Integer.parseInt(valor)){
                                v=Integer.parseInt(valor);
                            }
                        }
                        
                        LinkedList respuesta = new LinkedList();
                        for( Iterator it = vot.keySet().iterator();it.hasNext();){
                            String clave = ((String)it.next());
                            String valor = vot.get(clave).toString();
                            if (Integer.parseInt(valor)==v){
                                respuesta.add(tm.get(clave));
                                //System.out.println(tm.get(clave));
                            }
                        }
                        
                        Collections.sort(respuesta);
                        for(int i3 = 0; i3 < respuesta.size(); i3++){
                            System.out.println(respuesta.get(i3));
                        }
                        
                        //System.out.println(v);
                        tm.clear();
                        
                        
            

                        

                       
                        
        }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

// SeparateChaining Hash table class
//
// CONSTRUCTION: an approximate initial size or default of 101
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// void makeEmpty( )      --> Remove all items

/**
 * Separate chaining table implementation of hash tables. Note that all
 * "matching" is based on the equals method.
 * 
 * @param <AnyType>
 */
class SeparateChainingHashTable<AnyType> {
	/**
	 * Construct the hash table.
	 */
	public SeparateChainingHashTable() {
		this(DEFAULT_TABLE_SIZE);
	}

	/**
	 * Construct the hash table.
	 * 
	 * @param size
	 *            approximate table size.
	 */
	public SeparateChainingHashTable(int size) {
		theLists = new LinkedList[nextPrime(size)];
		for (int i = 0; i < theLists.length; i++)
			theLists[i] = new LinkedList<>();
	}

	/**
	 * Insert into the hash table. If the item is already present, then do
	 * nothing.
	 * 
	 * @param x
	 *            the item to insert.
	 */
	public void insert(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		//if (!whichList.contains(x)) {
			whichList.add(x);

			// Rehash; see Section 5.5
			if (++currentSize > theLists.length)
				rehash();
		}
	//}

	/**
	 * Remove from the hash table.
	 * 
	 * @param x
	 *            the item to remove.
	 */
	public void remove(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		if (whichList.contains(x)) {
			whichList.remove(x);
			currentSize--;
		}
	}

	/**
	 * Find an item in the hash table.
	 * 
	 * @param x
	 *            the item to search for.
	 * @return true if x is found.
	 */
	public boolean contains(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		return whichList.contains(x);
	}

	/**
	 * Make the hash table logically empty.
	 */
	public void makeEmpty() {
		for (int i = 0; i < theLists.length; i++)
			theLists[i].clear();
		currentSize = 0;
	}

	/**
	 * A hash routine for String objects.
	 * 
	 * @param key
	 *            the String to hash.
	 * @param tableSize
	 *            the size of the hash table.
	 * @return the hash value.
	 */
	public static int hash(String key, int tableSize) {
		int hashVal = 0;

		for (int i = 0; i < key.length(); i++)
			hashVal = 37 * hashVal + key.charAt(i);

		hashVal %= tableSize;
		if (hashVal < 0)
			hashVal += tableSize;

		return hashVal;
	}

	private void rehash() {
		List<AnyType>[] oldLists = theLists;

		// Create new double-sized, empty table
		theLists = new List[nextPrime(2 * theLists.length)];
		for (int j = 0; j < theLists.length; j++)
			theLists[j] = new LinkedList<>();

		// Copy table over
		currentSize = 0;
		for (List<AnyType> list : oldLists)
			for (AnyType item : list)
				insert(item);
	}

	private int myhash(AnyType x) {
		int hashVal = x.hashCode();

		hashVal %= theLists.length;
		if (hashVal < 0)
			hashVal += theLists.length;

		return hashVal;
	}

	private static final int DEFAULT_TABLE_SIZE = 101;

	/** The array of Lists. */
	private List<AnyType>[] theLists;
	private int currentSize;

	/**
	 * Internal method to find a prime number at least as large as n.
	 * 
	 * @param n
	 *            the starting number (must be positive).
	 * @return a prime number larger than or equal to n.
	 */
	@SuppressWarnings("empty-statement")
	private static int nextPrime(int n) {
		if (n % 2 == 0)
			n++;

		for (; !isPrime(n); n += 2)
			;

		return n;
	}

	/**
	 * Internal method to test if a number is prime. Not an efficient algorithm.
	 * 
	 * @param n
	 *            the number to test.
	 * @return the result of the test.
	 */
	private static boolean isPrime(int n) {
		if (n == 2 || n == 3)
			return true;

		if (n == 1 || n % 2 == 0)
			return false;

		for (int i = 3; i * i <= n; i += 2)
			if (n % i == 0)
				return false;

		return true;
	}

	// Simple main

}

public class EjercicioB {
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("B_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < cases; test++) {
			System.out.println("Case #"+(test+1)+":");
			int estanques= scan.nextInt();
			int llevar=0;
			SeparateChainingHashTable<Integer> pok= new SeparateChainingHashTable<Integer>();
			for(int i=0; i<estanques; i++ ){
				int food=scan.nextInt();
				int poke=scan.nextInt();
				
				pok.insert(food);
				
				if(!pok.contains(poke)){
					llevar++;
				}else{
					pok.remove(poke);
				}
			}
			
			System.out.println(llevar);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;


public class ProblemaC {

	 public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }
}

    public static void main(String[] args) throws FileNotFoundException, Exception {
         Scanner scan;
        File f = new File( "C_2.txt" );
        
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        Map<Integer, Integer> miMapa;
        for ( int test = 1; test <= t; test++ ) {
            miMapa = new HashMap<>();
            int[] nombres = readInts(scan.nextLine());
            int[] N = readInts(scan.nextLine());
            int[] M = readInts(scan.nextLine());
            int[] P = readInts(scan.nextLine());          
            for (int i = 0; i < N.length; i++) {
                if(miMapa.containsKey(N[i]))
                    miMapa.put(N[i], 4);
                else
                    miMapa.put(N[i], 1);
            }
            for (int i = 0; i < M.length; i++) {
                if(miMapa.containsKey(M[i]))
                    miMapa.put(M[i], 4);
                else
                    miMapa.put(M[i], 2);
            }
            for (int i = 0; i < P.length; i++) {
                if(miMapa.containsKey(P[i]))
                    miMapa.put(P[i], 4);
                else
                    miMapa.put(P[i], 3);
            }
            Object[] s= miMapa.keySet().toArray();
            TreeSet tsN = new TreeSet();
            TreeSet tsM = new TreeSet();
            TreeSet tsP = new TreeSet();
            for (int i = 0; i < s.length; i++) {
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 1)
                    tsN.add(s[i]);
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 2)
                    tsM.add(s[i]);
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 3)
                    tsP.add(s[i]);            
            }
            System.out.println("Case #" + test + ":"); 
            if(tsN.size() > tsM.size() && tsN.size() > tsP.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
            }
            if(tsM.size() > tsN.size() && tsM.size() > tsP.size()){
                String aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
            }
            if(tsP.size() > tsM.size() && tsP.size() > tsN.size()){
                String aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux);
            }
            if(tsP.size() == tsM.size() && tsP.size() == tsN.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux); 
            }
            if(tsN.size() == tsM.size() && tsN.size() > tsP.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
            }
            if(tsN.size() == tsP.size() && tsN.size() > tsM.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux); 
            }   
            if(tsM.size() == tsP.size() && tsM.size() > tsN.size()){
                String aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux);  
            }
        }
    }

    

    public static int[] readInts(String cad){
        String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }

    public static String stringFinal(String aux){
    	aux = aux.replace(",", "");
        aux = aux.replace("[", "");
        aux= aux.replace("]", "");
        return aux;
    }
    
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
   
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;


public class ProblemaC {

	 public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>{
    /**
     * Construct the binary heap.
     */
    public BinaryHeap( )
    {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity )
    {
        currentSize = 0;
        array = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
    public BinaryHeap( AnyType [ ] items )
    {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
    }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        if( currentSize == array.length - 1 )
            enlargeArray( array.length * 2 + 1 );

            // Percolate up
        int hole = ++currentSize;
        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
            array[ hole ] = array[ hole / 2 ];
        array[ hole ] = x;
    }


    private void enlargeArray( int newSize )
    {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];        
    }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return array[ 1 ];
    }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
    public AnyType deleteMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );

        AnyType minItem = findMin( );
        array[ 1 ] = array[ currentSize-- ];
        percolateDown( 1 );

        return minItem;
    }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
    private void buildHeap( )
    {
        for( int i = currentSize / 2; i > 0; i-- )
            percolateDown( i );
    }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return currentSize == 0;
    }

    /**
     * Make the priority queue logically empty.
     */
    public void makeEmpty( )
    {
        currentSize = 0;
    }

    private static final int DEFAULT_CAPACITY = 10;

    private int currentSize;      // Number of elements in heap
    private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
    private void percolateDown( int hole )
    {
        int child;
        AnyType tmp = array[ hole ];

        for( ; hole * 2 <= currentSize; hole = child )
        {
            child = hole * 2;
            if( child != currentSize && array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                child++;
            if( array[ child ].compareTo( tmp ) < 0 )
                array[ hole ] = array[ child ];
            else
                break;
        }
        array[ hole ] = tmp;
    }
}

    public static void main(String[] args) throws FileNotFoundException, Exception {
         Scanner scan;
        File f = new File( "C_2.txt" );
        
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        int t = Integer.parseInt( scan.nextLine() );
        Map<Integer, Integer> miMapa;
        for ( int test = 1; test <= t; test++ ) {
            miMapa = new HashMap<>();
            int[] nombres = readInts(scan.nextLine());
            int[] N = readInts(scan.nextLine());
            int[] M = readInts(scan.nextLine());
            int[] P = readInts(scan.nextLine());          
            for (int i = 0; i < N.length; i++) {
                if(miMapa.containsKey(N[i]))
                    miMapa.put(N[i], 4);
                else
                    miMapa.put(N[i], 1);
            }
            for (int i = 0; i < M.length; i++) {
                if(miMapa.containsKey(M[i]))
                    miMapa.put(M[i], 4);
                else
                    miMapa.put(M[i], 2);
            }
            for (int i = 0; i < P.length; i++) {
                if(miMapa.containsKey(P[i]))
                    miMapa.put(P[i], 4);
                else
                    miMapa.put(P[i], 3);
            }
            Object[] s= miMapa.keySet().toArray();
            TreeSet tsN = new TreeSet();
            TreeSet tsM = new TreeSet();
            TreeSet tsP = new TreeSet();
            for (int i = 0; i < s.length; i++) {
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 1)
                    tsN.add(s[i]);
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 2)
                    tsM.add(s[i]);
                if(Integer.parseInt(miMapa.get(s[i]).toString()) == 3)
                    tsP.add(s[i]);            
            }
            System.out.println("Case #" + test + ":"); 
            if(tsN.size() > tsM.size() && tsN.size() > tsP.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
            }
            if(tsM.size() > tsN.size() && tsM.size() > tsP.size()){
                String aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
            }
            if(tsP.size() > tsM.size() && tsP.size() > tsN.size()){
                String aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux);
            }
            if(tsP.size() == tsM.size() && tsP.size() == tsN.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux); 
            }
            if(tsN.size() == tsM.size() && tsN.size() > tsP.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
            }
            if(tsN.size() == tsP.size() && tsN.size() > tsM.size()){
                String aux = tsN.toString();
                aux = stringFinal(aux);
                System.out.println("Norma " + tsN.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux); 
            }   
            if(tsM.size() == tsP.size() && tsM.size() > tsN.size()){
                String aux = tsM.toString();
                aux = stringFinal(aux);
                System.out.println("Mario " + tsM.size() +" " + aux);
                aux = tsP.toString();
                aux = stringFinal(aux);
                System.out.println("Pipe " + tsP.size() +" " + aux);  
            }
        }
    }

    

    public static int[] readInts(String cad){
        String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }

    public static String stringFinal(String aux){
    	aux = aux.replace(",", "");
        aux = aux.replace("[", "");
        aux= aux.replace("]", "");
        return aux;
    }
    
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
   
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package p2;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

// SeparateChaining Hash table class
//
// CONSTRUCTION: an approximate initial size or default of 101
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// void makeEmpty( )      --> Remove all items

/**
 * Separate chaining table implementation of hash tables. Note that all
 * "matching" is based on the equals method.
 * 
 * @param <AnyType>
 */
class SeparateChainingHashTable<AnyType> {
	/**
	 * Construct the hash table.
	 */
	public SeparateChainingHashTable() {
		this(DEFAULT_TABLE_SIZE);
	}

	/**
	 * Construct the hash table.
	 * 
	 * @param size
	 *            approximate table size.
	 */
	public SeparateChainingHashTable(int size) {
		theLists = new LinkedList[nextPrime(size)];
		for (int i = 0; i < theLists.length; i++)
			theLists[i] = new LinkedList<>();
	}

	/**
	 * Insert into the hash table. If the item is already present, then do
	 * nothing.
	 * 
	 * @param x
	 *            the item to insert.
	 */
	public void insert(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		//if (!whichList.contains(x)) {
			whichList.add(x);

			// Rehash; see Section 5.5
			if (++currentSize > theLists.length)
				rehash();
		}
	//}

	/**
	 * Remove from the hash table.
	 * 
	 * @param x
	 *            the item to remove.
	 */
	public void remove(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		if (whichList.contains(x)) {
			whichList.remove(x);
			currentSize--;
		}
	}

	/**
	 * Find an item in the hash table.
	 * 
	 * @param x
	 *            the item to search for.
	 * @return true if x is found.
	 */
	public boolean contains(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		return whichList.contains(x);
	}

	/**
	 * Make the hash table logically empty.
	 */
	public void makeEmpty() {
		for (int i = 0; i < theLists.length; i++)
			theLists[i].clear();
		currentSize = 0;
	}

	/**
	 * A hash routine for String objects.
	 * 
	 * @param key
	 *            the String to hash.
	 * @param tableSize
	 *            the size of the hash table.
	 * @return the hash value.
	 */
	public static int hash(String key, int tableSize) {
		int hashVal = 0;

		for (int i = 0; i < key.length(); i++)
			hashVal = 37 * hashVal + key.charAt(i);

		hashVal %= tableSize;
		if (hashVal < 0)
			hashVal += tableSize;

		return hashVal;
	}

	private void rehash() {
		List<AnyType>[] oldLists = theLists;

		// Create new double-sized, empty table
		theLists = new List[nextPrime(2 * theLists.length)];
		for (int j = 0; j < theLists.length; j++)
			theLists[j] = new LinkedList<>();

		// Copy table over
		currentSize = 0;
		for (List<AnyType> list : oldLists)
			for (AnyType item : list)
				insert(item);
	}

	private int myhash(AnyType x) {
		int hashVal = x.hashCode();

		hashVal %= theLists.length;
		if (hashVal < 0)
			hashVal += theLists.length;

		return hashVal;
	}

	private static final int DEFAULT_TABLE_SIZE = 101;

	/** The array of Lists. */
	private List<AnyType>[] theLists;
	private int currentSize;

	/**
	 * Internal method to find a prime number at least as large as n.
	 * 
	 * @param n
	 *            the starting number (must be positive).
	 * @return a prime number larger than or equal to n.
	 */
	@SuppressWarnings("empty-statement")
	private static int nextPrime(int n) {
		if (n % 2 == 0)
			n++;

		for (; !isPrime(n); n += 2)
			;

		return n;
	}

	/**
	 * Internal method to test if a number is prime. Not an efficient algorithm.
	 * 
	 * @param n
	 *            the number to test.
	 * @return the result of the test.
	 */
	private static boolean isPrime(int n) {
		if (n == 2 || n == 3)
			return true;

		if (n == 1 || n % 2 == 0)
			return false;

		for (int i = 3; i * i <= n; i += 2)
			if (n % i == 0)
				return false;

		return true;
	}

	// Simple main

}

public class EjercicioB {
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("B_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < cases; test++) {
			System.out.println("Case #"+(test+1)+":");
			int estanques= scan.nextInt();
			int llevar=0;
			SeparateChainingHashTable<Integer> pokemon= new SeparateChainingHashTable<Integer>();
			for(int i=0; i<estanques; i++ ){
				int food=scan.nextInt();
				int poke=scan.nextInt();
				
				pokemon.insert(food);
				
				if(!pokemon.contains(poke)){
					llevar++;
				}else{
					pokemon.remove(poke);
				}
			}
			
			System.out.println(llevar);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package p2;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

// SeparateChaining Hash table class
//
// CONSTRUCTION: an approximate initial size or default of 101
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// void makeEmpty( )      --> Remove all items


class SeparateChainingHashTable<AnyType> {
	/**
	 * Construct the hash table.
	 */
	public SeparateChainingHashTable() {
		this(DEFAULT_TABLE_SIZE);
	}

	/**
	 * Construct the hash table.
	 * 
	 * @param size
	 *            approximate table size.
	 */
	public SeparateChainingHashTable(int size) {
		theLists = new LinkedList[nextPrime(size)];
		for (int i = 0; i < theLists.length; i++)
			theLists[i] = new LinkedList<>();
	}

	/**
	 * Insert into the hash table. If the item is already present, then do
	 * nothing.
	 * 
	 * @param x
	 *            the item to insert.
	 */
	public void insert(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		//if (!whichList.contains(x)) {
			whichList.add(x);

			// Rehash; see Section 5.5
			if (++currentSize > theLists.length)
				rehash();
		}
	//}

	/**
	 * Remove from the hash table.
	 * 
	 * @param x
	 *            the item to remove.
	 */
	public void remove(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		if (whichList.contains(x)) {
			whichList.remove(x);
			currentSize--;
		}
	}

	/**
	 * Find an item in the hash table.
	 * 
	 * @param x
	 *            the item to search for.
	 * @return true if x is found.
	 */
	public boolean contains(AnyType x) {
		List<AnyType> whichList = theLists[myhash(x)];
		return whichList.contains(x);
	}

	/**
	 * Make the hash table logically empty.
	 */
	public void makeEmpty() {
		for (int i = 0; i < theLists.length; i++)
			theLists[i].clear();
		currentSize = 0;
	}

	/**
	 * A hash routine for String objects.
	 * 
	 * @param key
	 *            the String to hash.
	 * @param tableSize
	 *            the size of the hash table.
	 * @return the hash value.
	 */
	public static int hash(String key, int tableSize) {
		int hashVal = 0;

		for (int i = 0; i < key.length(); i++)
			hashVal = 37 * hashVal + key.charAt(i);

		hashVal %= tableSize;
		if (hashVal < 0)
			hashVal += tableSize;

		return hashVal;
	}

	private void rehash() {
		List<AnyType>[] oldLists = theLists;

		// Create new double-sized, empty table
		theLists = new List[nextPrime(2 * theLists.length)];
		for (int j = 0; j < theLists.length; j++)
			theLists[j] = new LinkedList<>();

		// Copy table over
		currentSize = 0;
		for (List<AnyType> list : oldLists)
			for (AnyType item : list)
				insert(item);
	}

	private int myhash(AnyType x) {
		int hashVal = x.hashCode();

		hashVal %= theLists.length;
		if (hashVal < 0)
			hashVal += theLists.length;

		return hashVal;
	}

	private static final int DEFAULT_TABLE_SIZE = 101;

	/** The array of Lists. */
	private List<AnyType>[] theLists;
	private int currentSize;

	/**
	 * Internal method to find a prime number at least as large as n.
	 * 
	 * @param n
	 *            the starting number (must be positive).
	 * @return a prime number larger than or equal to n.
	 */
	@SuppressWarnings("empty-statement")
	private static int nextPrime(int n) {
		if (n % 2 == 0)
			n++;

		for (; !isPrime(n); n += 2)
			;

		return n;
	}

	/**
	 * Internal method to test if a number is prime. Not an efficient algorithm.
	 * 
	 * @param n
	 *            the number to test.
	 * @return the result of the test.
	 */
	private static boolean isPrime(int n) {
		if (n == 2 || n == 3)
			return true;

		if (n == 1 || n % 2 == 0)
			return false;

		for (int i = 3; i * i <= n; i += 2)
			if (n % i == 0)
				return false;

		return true;
	}

	// Simple main

}

public class EjercicioB {
	public static void main(String[] args) throws FileNotFoundException {

		Scanner scan;
		File file = new File("B_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < cases; test++) {
			System.out.println("Case #"+(test+1)+":");
			int estanques= scan.nextInt();
			int llevar=0;
			SeparateChainingHashTable<Integer> pokemon= new SeparateChainingHashTable<Integer>();
			for(int i=0; i<estanques; i++ ){
				int food=scan.nextInt();
				int poke=scan.nextInt();
				
				pokemon.insert(food);
				
				if(!pokemon.contains(poke)){
					llevar++;
				}else{
					pokemon.remove(poke);
				}
			}
			
			System.out.println(llevar);
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

package a7;






import java.io.FileNotFoundException;
import java.util.Scanner;
import java.io.File;
import java.util.HashSet;



public class A7 {

    public static void main(String[] args) throws FileNotFoundException {
        
        Scanner scan;
       
        File f = new File( "A_1.txt" );
        if ( f.exists() ) {
            scan = new Scanner( f );
        } else {
            scan = new Scanner( System.in );
        }
        
        
        int t = Integer.parseInt( scan.nextLine() );
        MyArrayList l1,l2;
        int caso=0;
        for ( int test = 0; test < t; test++ ) {
            caso++;
            System.out.println("Case #" + caso + ":");
            cuenta = new HashSet();
            int[] NyM = leer(scan.nextLine());
            miGrafo = new MyArrayList<>();
            for (int i = 0; i < NyM[0]; i++) {
                miGrafo.add(i, new MyArrayList<>());                
            }
            for (int i = 0; i < NyM[1]; i++) {
                int[] emes = leer(scan.nextLine());
                l1 = new MyArrayList();
                l1 = miGrafo.get(emes[0]);
                l1.add(emes[1]);
                miGrafo.set(emes[0], l1);
                l1 = new MyArrayList();
                l1 = miGrafo.get(emes[1]);
                l1.add(emes[0]);
                miGrafo.set(emes[1], l1);
            }
              
            l = Integer.parseInt( scan.nextLine() );
            contar(l);
            System.out.println(cuenta.size());
        }
    }
    
    
    
    
    public static void contar(int n){
        for (int i = 0; i < miGrafo.get(n).size(); i++) {
            if(l != (int) miGrafo.get(n).get(i) && !cuenta.contains((int) miGrafo.get(n).get(i))){
                cuenta.add((int) miGrafo.get(n).get(i));
                contar((int) miGrafo.get(n).get(i));
            }
        }
    }
    
    
    
    
    public static int[] leer(String cad){
	String line[] = cad.split( " " );
	int arr[] = new int[line.length];
	for( int i = 0 ; i < arr.length ; i++ ){
		arr[i] = Integer.parseInt( line[i] );
	}
	return arr;
    }
    
    
    
    public static MyArrayList<MyArrayList> miGrafo;
    
    public static HashSet cuenta = new HashSet();
    
    public static int l;
    
    
    public static class MyArrayList<AnyType> implements Iterable<AnyType>{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @return 
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param idx
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    @Override
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    @Override
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "" );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        @Override
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        @Override
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        @Override
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
    public static class MyLinkedList<AnyType> implements Iterable<AnyType>{
        /**
         * Construct an empty LinkedList.
         */
        public MyLinkedList( )
        {
            doClear( );
        }

        private void clear( )
        {
            doClear( );
        }

        /**
         * Change the size of this collection to zero.
         */
        public void doClear( )
        {
            beginMarker = new Node<>( null, null, null );
            endMarker = new Node<>( null, beginMarker, null );
            beginMarker.next = endMarker;

            theSize = 0;
            modCount++;
        }

        /**
         * Returns the number of items in this collection.
         * @return the number of items in this collection.
         */
        public int size( )
        {
            return theSize;
        }

        public boolean isEmpty( )
        {
            return size( ) == 0;
        }

        /**
         * Adds an item to this collection, at the end.
         * @param x any object.
         * @return true.
         */
        public boolean add( AnyType x )
        {

            add( size( ), x );   
            return true;         
        }

        /**
         * Adds an item to this collection, at specified position.
         * Items at or after that position are slid one position higher.
         * @param x any object.
         * @param idx position to add at.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
         */
        public void add( int idx, AnyType x )
        {
            addBefore( getNode( idx, 0, size( ) ), x );
        }

        /**
         * Adds an item to this collection, at specified position p.
         * Items at or after that position are slid one position higher.
         * @param p Node to add before.
         * @param x any object.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
         */    
        private void addBefore( Node<AnyType> p, AnyType x )
        {
            Node<AnyType> newNode = new Node<>( x, p.prev, p );
            newNode.prev.next = newNode;
            p.prev = newNode;         
            theSize++;
            modCount++;
        }   


        /**
         * Returns the item at position idx.
         * @param idx the index to search in.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType get( int idx )
        {
            return getNode( idx ).data;
        }

        /**
         * Changes the item at position idx.
         * @param idx the index to change.
         * @param newVal the new value.
         * @return the old value.
         * @throws IndexOutOfBoundsException if index is out of range.
         */
        public AnyType set( int idx, AnyType newVal )
        {
            Node<AnyType> p = getNode( idx );
            AnyType oldVal = p.data;

            p.data = newVal;   
            return oldVal;
        }

        /**
         * Gets the Node at position idx, which must range from 0 to size( ) - 1.
         * @param idx index to search at.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
         */
        private Node<AnyType> getNode( int idx )
        {
            return getNode( idx, 0, size( ) - 1 );
        }

        /**
         * Gets the Node at position idx, which must range from lower to upper.
         * @param idx index to search at.
         * @param lower lowest valid index.
         * @param upper highest valid index.
         * @return internal node corresponding to idx.
         * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
         */    
        private Node<AnyType> getNode( int idx, int lower, int upper )
        {
            Node<AnyType> p;  
            if( idx < lower || idx > upper )
                throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
            if( idx < size( ) / 2 ){
                p = beginMarker.next;
                for( int i = 0; i < idx; i++ )
                    p = p.next;            
            }
            else{
                p = endMarker;
                for( int i = size( ); i > idx; i-- )
                    p = p.prev;
            }         
            return p;
        }

        /**
         * Removes an item from this collection.
         * @param idx the index of the object.
         * @return the item was removed from the collection.
         */
        public AnyType remove( int idx )
        {
            return remove( getNode( idx ) );
        }

        /**
         * Removes the object contained in Node p.
         * @param p the Node containing the object.
         * @return the item was removed from the collection.
         */
        private AnyType remove( Node<AnyType> p )
        {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            theSize--;
            modCount++;

            return p.data;
        }

        /**
         * Returns a String representation of this collection.
         */
        public String toString( )
        {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
        }

        /**
         * Obtains an Iterator object used to traverse the collection.
         * @return an iterator positioned prior to the first element.
         */
        public java.util.Iterator<AnyType> iterator( )
        {
            return new LinkedListIterator( );
        }

        /**
         * This is the implementation of the LinkedListIterator.
         * It maintains a notion of a current position and of
         * course the implicit reference to the MyLinkedList.
         */
        private class LinkedListIterator implements java.util.Iterator<AnyType>
        {
            private Node<AnyType> current = beginMarker.next;
            private int expectedModCount = modCount;
            private boolean okToRemove = false;

            public boolean hasNext( )
            {
                return current != endMarker;
            }

            public AnyType next( )
            {
                if( modCount != expectedModCount )
                    throw new java.util.ConcurrentModificationException( );
                if( !hasNext( ) )
                    throw new java.util.NoSuchElementException( ); 

                AnyType nextItem = current.data;
                current = current.next;
                okToRemove = true;
                return nextItem;
            }

            public void remove( )
            {
                if( modCount != expectedModCount )
                    throw new java.util.ConcurrentModificationException( );
                if( !okToRemove )
                    throw new IllegalStateException( );

                MyLinkedList.this.remove( current.prev );
                expectedModCount++;
                okToRemove = false;       
            }
        }

        /**
         * This is the doubly-linked list node.
         */
        private static class Node<AnyType>
        {
            public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
            {
                data = d; prev = p; next = n;
            }

            public AnyType data;
            public Node<AnyType>   prev;
            public Node<AnyType>   next;
        }

        private int theSize;
        private int modCount = 0;
        private Node<AnyType> beginMarker;
        private Node<AnyType> endMarker;
    }



}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

package b7;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;

public class B7 {

        public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File file = new File("b_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < cases; test++) {
			System.out.println("Case #" + (test + 1) + ":");
			
			String lines[] = scan.nextLine().split(" ");
			int N = Integer.parseInt(lines[0]);
			int M = Integer.parseInt(lines[1]);
                        Grafo materia = new Grafo();
			for (int i = 0; i < N; i++) {
				ArrayList<Integer> tema = new ArrayList<Integer>();
				materia.migrafo.add(tema);
			}

			for (int i = 0; i < M; i++) {
				String pre[] = scan.nextLine().split(" ");
				int v = Integer.parseInt(pre[0]);
				int w = Integer.parseInt(pre[1]);
				materia.add(v, w);
			}

			materia.topSort();
			
			System.out.println();
		}
	}
    
    
	static class Grafo {

		class Nodo {
			Integer inDegree;
			Integer topNum=0;


			public Nodo( Integer w) {
				this.inDegree=w;
			}

		}

		ArrayList<ArrayList<Integer>> migrafo;

		public Grafo() {
			migrafo = new ArrayList<ArrayList<Integer>>();

		}

		public void add(int v, int w) {
			migrafo.get(v).add(w);
		}

		public int BFS(int source) {
			Queue<Integer> q = new LinkedList<Integer>();
			int number = 0;
			q.add(source);
			int dist[] = new int[migrafo.size()];
			boolean vis[] = new boolean[migrafo.size()];
			dist[source] = 0;
			vis[source] = true;
			while (!q.isEmpty()) {
				int current = q.poll();
				for (int i = 0; i < migrafo.get(current).size(); i++) {
					int neigh = migrafo.get(current).get(i);
					if (vis[neigh] == false) {
						number++;
						q.add(neigh);
						dist[neigh] = dist[current] + 1;
						vis[neigh] = true;
					}
				}
			}

			return number;
		}

		public boolean conectar(int v, int w) {

			for (int i = 0; i < migrafo.get(v).size(); i++) {
				if (migrafo.get(v).get(i) == w)
					return true;
			}
			return false;
		}

		public int outDegree(int v) {
			return migrafo.get(v).size();
		}

		public int inDegree(int v) {
			int a = 0;
			for (int i = 0; i < migrafo.size(); i++) {
				if (migrafo.get(i).contains(v)) {
					a++;
				}
			}

			return a;
		}

		public void topSort() {
			PriorityQueue<Integer> orden = new PriorityQueue<Integer>();
			Nodo[] topics=new Nodo[migrafo.size()];
			int counter = 0;
			
			for(int i=0; i<migrafo.size();i++){
				topics[i]= new Nodo(inDegree(i));
			}

			for (int i = 0; i < migrafo.size(); i++) {
				if (topics[i].inDegree == 0) {
					orden.add(i);
					counter++; 
				}
			}

			while (!orden.isEmpty()) {
				int formas = 0;
                                Integer v = orden.remove();
				 topics[v].topNum=++counter;

				

				for (int i = 0; i < migrafo.get(v).size(); i++) {
					if (--topics[migrafo.get(v).get(i)].inDegree == 0) {
						orden.add(migrafo.get(v).get(i));
						formas++; 
					}
				}

				if (formas > 1) {
																	
					return;
				}
			}
			System.out.print("Deberia empezar a estudiar"); 

	}

	}
	
	
	

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package problemad;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;

public class ProblemaD {
    
    public static void main(String[] args) throws FileNotFoundException {
		Scanner scan;
		File file = new File("D_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases = Integer.parseInt(scan.nextLine());
		for (int test = 0; test < cases; test++) {
			System.out.println("Case #" + (test + 1) + ":");
			Grafo materia = new Grafo();
			String lines[] = scan.nextLine().split(" ");
			int N = Integer.parseInt(lines[0]);
			int M = Integer.parseInt(lines[1]);

			for (int i = 0; i < N; i++) {
				ArrayList<Integer> tema = new ArrayList<Integer>();
				materia.miGrafo.add(tema);
			}

			for (int i = 0; i < M; i++) {
				String pre[] = scan.nextLine().split(" ");
				int v = Integer.parseInt(pre[0]);
				int w = Integer.parseInt(pre[1]);
				materia.add(v, w);
			}

			materia.topSort();
			
			System.out.println();
		}
	}

	static class Grafo {

		class Nodo{
			Integer inDegree;
			Integer topNum=0;

	
			public Nodo( Integer w) {
				this.inDegree=w;
			}



		}

		ArrayList<ArrayList<Integer>> miGrafo;

		public Grafo() {
			miGrafo = new ArrayList<ArrayList<Integer>>();

		}

		public void add(int v, int w) {
			miGrafo.get(v).add(w);
		}

		public int BFS(int source) {
			Queue<Integer> q = new LinkedList<Integer>();
			int number = 0;
			q.add(source);
			int dist[] = new int[miGrafo.size()];
			boolean vis[] = new boolean[miGrafo.size()];
			dist[source] = 0;
			vis[source] = true;
			while (!q.isEmpty()) {
				int current = q.poll();
				for (int i = 0; i < miGrafo.get(current).size(); i++) {
					int neigh = miGrafo.get(current).get(i);
					if (vis[neigh] == false) {
						number++;
						q.add(neigh);
						dist[neigh] = dist[current] + 1;
						vis[neigh] = true;
					}
				}
			}

			return number;
		}

		public boolean conectar(int v, int w) {

			for (int i = 0; i < miGrafo.get(v).size(); i++) {
				if (miGrafo.get(v).get(i) == w)
					return true;
			}
			return false;
		}

		public int outDegree(int v) {
			return miGrafo.get(v).size();
		}

		public int inDegree(int v) {
			int a = 0;
			for (int i = 0; i < miGrafo.size(); i++) {
				if (miGrafo.get(i).contains(v)) {
					a++;
				}
			}

			return a;
		}

		public void topSort() {
			PriorityQueue<Integer> orden = new PriorityQueue<Integer>();
			Nodo[] topics=new Nodo[miGrafo.size()];
			int counter = 0;
			
			for(int i=0; i<miGrafo.size();i++){
				topics[i]= new Nodo(inDegree(i));
			}

			for (int i = 0; i < miGrafo.size(); i++) {
				if (topics[i].inDegree == 0) {
					orden.add(i);
					counter++;
				}
			}
			while (!orden.isEmpty()) {
				Integer v = orden.remove();
				System.out.print(v+" ");
				 topics[v].topNum=++counter;

				int ctr = 0;

				for (int i = 0; i < miGrafo.get(v).size(); i++) {
					if (--topics[miGrafo.get(v).get(i)].inDegree == 0) {
						orden.add(miGrafo.get(v).get(i));
						ctr++; 
					}
				}

			}

		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


package p7c;


import java.io.File;
import java.util.ArrayList;
import java.util.Scanner;

public class P7C {

	private static Vertex[] grafo;

	public static void main(String[] args) throws Exception {

                
                Scanner scan;
		File file = new File("C_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases =  Integer.parseInt(scan.nextLine());

		for (int t = 0; t < cases; t++) {
			System.out.println("Case #" + (t + 1) + ":");

                String[] line = scan.nextLine().split(" ");
                int n = Integer.parseInt(line[0]);
                int e = Integer.parseInt(line[1]);
                int time = Integer.parseInt(line[2]);
                int m = Integer.parseInt(scan.nextLine());

                grafo = new Vertex[n];
                for (int j = 0; j < m; j++) {
                    line = scan.nextLine().split(" ");
                    int u = Integer.parseInt(line[0]);
                    int v = Integer.parseInt(line[1]);
                    int w = Integer.parseInt(line[2]);

                    if (grafo[u] == null) {
                        grafo[u] = new Vertex(u);
                    }
                    grafo[u].adjacents.add(v);
                    grafo[u].weights.add(w);

                    if (grafo[v] == null) {
                        grafo[v] = new Vertex(v);
                    }
                }
 
                int c = 1;
                for (Vertex ver : grafo) {
                    if (ver != null) 
                        dijkstra(ver);
                    
                    if (grafo[e] != null) {
                        if (grafo[e].dist <= time) {
                            if (ver != null && ver.id != e) {
                                c++;
                            }
                        }
                    }
                }
                System.out.println(c+1);
            }
		
    }

    private static void dijkstra(Vertex s) throws Exception {
        for (Vertex v : grafo) {
            if (v != null) {
                v.dist = Integer.MAX_VALUE;
                v.known = false;
            }
        }
        s.dist = 0;
        BinaryHeap<Vertex> heap = new BinaryHeap<>();
        heap.insert(s);

        while (!heap.isEmpty()) {
            Vertex v = heap.deleteMin();
            if (!v.known) {
                v.known = true;

                for (int i = 0; i < v.adjacents.size(); i++) {
                    Vertex w = grafo[v.adjacents.get(i)];

                    if (!w.known) {
                        int aux = v.weights.get(i);
                        if (v.dist + aux < w.dist) {
                            w.dist = v.dist + aux;
                            w.path = v.id;
                        }
                        heap.insert(w);
                    }
                }
            }
        }
    }

	private static class Vertex implements Comparable<Vertex> {
		private int id;
		private int dist;
		private boolean known;
		private int path;
		private ArrayList<Integer> adjacents;
		private ArrayList<Integer> weights;

		public Vertex(int id) {
			this.id = id;
			path = -1;
			dist = 0;
			known = true;
			adjacents = new ArrayList<>();
			weights = new ArrayList<>();
		}

		@Override
		public String toString() {
			return "Vertex [id=" + id + ", dist=" + dist + ", known=" + known + ", path=" + path + ", adjacents="
					+ adjacents + ", weights=" + weights + "]";
		}

		@Override
		public int compareTo(Vertex o) {

			if (dist < o.dist)
				return -1;
			else if (dist > o.dist)
				return 1;
			return 0;
		}
	}

	private static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;
		private AnyType[] array;

		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		public boolean isEmpty() {
			return currentSize == 0;
		}

		public void makeEmpty() {
			currentSize = 0;
		}

		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


package p7c;


import java.io.File;
import java.util.ArrayList;
import java.util.Scanner;

public class P7C {

	private static Vertex[] grafo;

	public static void main(String[] args) throws Exception {

                
                Scanner scan;
		File file = new File("C_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases =  Integer.parseInt(scan.nextLine());

		for (int t = 0; t < cases; t++) {
			System.out.println("Case #" + (t + 1) + ":");

                String[] line = scan.nextLine().split(" ");
                int n = Integer.parseInt(line[0]);
                int e = Integer.parseInt(line[1]);
                int time = Integer.parseInt(line[2]);
                int m = Integer.parseInt(scan.nextLine());

                grafo = new Vertex[n];
                for (int j = 0; j < m; j++) {
                    line = scan.nextLine().split(" ");
                    int u = Integer.parseInt(line[0]);
                    int v = Integer.parseInt(line[1]);
                    int w = Integer.parseInt(line[2]);

                    if (grafo[u] == null) {
                        grafo[u] = new Vertex(u);
                    }
                    grafo[u].adjacents.add(v);
                    grafo[u].weights.add(w);

                    if (grafo[v] == null) {
                        grafo[v] = new Vertex(v);
                    }
                }
 
                int c = 5;
                for (Vertex ver : grafo) {
                    if (ver != null) 
                        dijkstra(ver);
                    
                    if (grafo[e] != null) {
                        if (grafo[e].dist <= time) {
                            if (ver != null && ver.id != e) {
                                c++;
                            }
                        }
                    }
                }
                System.out.println(c);
            }
		
    }

    private static void dijkstra(Vertex s) throws Exception {
        for (Vertex v : grafo) {
            if (v != null) {
                v.dist = Integer.MAX_VALUE;
                v.known = false;
            }
        }
        s.dist = 0;
        BinaryHeap<Vertex> heap = new BinaryHeap<>();
        heap.insert(s);

        while (!heap.isEmpty()) {
            Vertex v = heap.deleteMin();
            if (!v.known) {
                v.known = true;

                for (int i = 0; i < v.adjacents.size(); i++) {
                    Vertex w = grafo[v.adjacents.get(i)];

                    if (!w.known) {
                        int aux = v.weights.get(i);
                        if (v.dist + aux < w.dist) {
                            w.dist = v.dist + aux;
                            w.path = v.id;
                        }
                        heap.insert(w);
                    }
                }
            }
        }
    }

	private static class Vertex implements Comparable<Vertex> {
		private int id;
		private int dist;
		private boolean known;
		private int path;
		private ArrayList<Integer> adjacents;
		private ArrayList<Integer> weights;

		public Vertex(int id) {
			this.id = id;
			path = -1;
			dist = 0;
			known = true;
			adjacents = new ArrayList<>();
			weights = new ArrayList<>();
		}

		@Override
		public String toString() {
			return "Vertex [id=" + id + ", dist=" + dist + ", known=" + known + ", path=" + path + ", adjacents="
					+ adjacents + ", weights=" + weights + "]";
		}

		@Override
		public int compareTo(Vertex o) {

			if (dist < o.dist)
				return -1;
			else if (dist > o.dist)
				return 1;
			return 0;
		}
	}

	private static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;
		private AnyType[] array;

		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		public boolean isEmpty() {
			return currentSize == 0;
		}

		public void makeEmpty() {
			currentSize = 0;
		}

		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


package p7c;


import java.io.File;
import java.util.ArrayList;
import java.util.Scanner;

public class P7C {

	private static Vertex[] grafo;

	public static void main(String[] args) throws Exception {

                
                Scanner scan;
		File file = new File("C_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases =  Integer.parseInt(scan.nextLine());

		for (int t = 0; t < cases; t++) {
			System.out.println("Case #" + (t + 1) + ":");

                String[] line = scan.nextLine().split(" ");
                int n = Integer.parseInt(line[0]);
                int e = Integer.parseInt(line[1]);
                int time = Integer.parseInt(line[2]);
                int m = Integer.parseInt(scan.nextLine());

                grafo = new Vertex[n];
                for (int j = 0; j < m; j++) {
                    line = scan.nextLine().split(" ");
                    int u = Integer.parseInt(line[0]);
                    int v = Integer.parseInt(line[1]);
                    int w = Integer.parseInt(line[2]);

                    if (grafo[u] == null) {
                        grafo[u] = new Vertex(u);
                    }
                    grafo[u].adjacents.add(v);
                    grafo[u].weights.add(w);

                    if (grafo[v] == null) {
                        grafo[v] = new Vertex(v);
                    }
                }
 
                int c = 5;
                for (Vertex ver : grafo) {
                    if (ver != null) 
                        dijkstra(ver);
                    
                    if (grafo[e] != null) {
                        if (grafo[e].dist <= time) {
                            if (ver != null && ver.id != e) {
                                c++;
                            }
                        }
                    }
                }
                System.out.println(c);
            }
		
    }

    private static void dijkstra(Vertex s) throws Exception {
        for (Vertex v : grafo) {
            if (v != null) {
                v.dist = Integer.MAX_VALUE;
                v.known = false;
            }
        }
        s.dist = 0;
        BinaryHeap<Vertex> heap = new BinaryHeap<>();
        heap.insert(s);

        while (!heap.isEmpty()) {
            Vertex v = heap.deleteMin();
            if (!v.known) {
                v.known = true;

                for (int i = 0; i < v.adjacents.size(); i++) {
                    Vertex w = grafo[v.adjacents.get(i)];

                    if (!w.known) {
                        int aux = v.weights.get(i);
                        if (v.dist + aux < w.dist) {
                            w.dist = v.dist + aux;
                            w.path = v.id;
                        }
                        heap.insert(w);
                    }
                }
            }
        }
    }

	private static class Vertex implements Comparable<Vertex> {
		private int id;
		private int dist;
		private boolean known;
		private int path;
		private ArrayList<Integer> adjacents;
		private ArrayList<Integer> weights;

		public Vertex(int id) {
			this.id = id;
			path = -1;
			dist = 0;
			known = true;
			adjacents = new ArrayList<>();
			weights = new ArrayList<>();
		}

		@Override
		public String toString() {
			return "Vertex [id=" + id + ", dist=" + dist + ", known=" + known + ", path=" + path + ", adjacents="
					+ adjacents + ", weights=" + weights + "]";
		}

		@Override
		public int compareTo(Vertex o) {

			if (dist < o.dist)
				return -1;
			else if (dist > o.dist)
				return 1;
			return 0;
		}
	}

	private static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;
		private AnyType[] array;

		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		public boolean isEmpty() {
			return currentSize == 0;
		}

		public void makeEmpty() {
			currentSize = 0;
		}

		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


package p7c;


import java.io.File;
import java.util.ArrayList;
import java.util.Scanner;

public class P7C {
	public static void main(String[] args) throws Exception {

                
                Scanner scan;
		File file = new File("C_1.txt");
		if (file.exists()) {
			scan = new Scanner(file);
		} else {
			scan = new Scanner(System.in);
		}
		int cases =  Integer.parseInt(scan.nextLine());

		for (int t = 0; t < cases; t++) {
			System.out.println("Case #" + (t + 1) + ":");

                String[] line = scan.nextLine().split(" ");
                int n = Integer.parseInt(line[0]);
                int e = Integer.parseInt(line[1]);
                int time = Integer.parseInt(line[2]);
                int m = Integer.parseInt(scan.nextLine());

                grafo = new Vertex[n];
                for (int j = 0; j < m; j++) {
                    line = scan.nextLine().split(" ");
                    int u = Integer.parseInt(line[0]);
                    int v = Integer.parseInt(line[1]);
                    int w = Integer.parseInt(line[2]);

                    if (grafo[u] == null) {
                        grafo[u] = new Vertex(u);
                    }
                    grafo[u].adjacents.add(v);
                    grafo[u].weights.add(w);

                    if (grafo[v] == null) {
                        grafo[v] = new Vertex(v);
                    }
                }
 
                int c = 1;
                for (Vertex ver : grafo) {
                    if (ver != null) 
                        dijkstra(ver);
                    
                    if (grafo[e] != null) {
                        if (grafo[e].dist <= time) {
                            if (ver != null && ver.id != e) {
                                c++;
                            }
                        }
                    }
                }
                System.out.println(c);
            }
		
    }

    private static Vertex[] grafo;
    
    private static void dijkstra(Vertex s) throws Exception {
        for (Vertex v : grafo) {
            if (v != null) {
                v.dist = Integer.MAX_VALUE;
                v.known = false;
            }
        }
        s.dist = 0;
        BinaryHeap<Vertex> heap = new BinaryHeap<>();
        heap.insert(s);

        while (!heap.isEmpty()) {
            Vertex v = heap.deleteMin();
            if (!v.known) {
                v.known = true;

                for (int i = 0; i < v.adjacents.size(); i++) {
                    Vertex w = grafo[v.adjacents.get(i)];

                    if (!w.known) {
                        int aux = v.weights.get(i);
                        if (v.dist + aux < w.dist) {
                            w.dist = v.dist + aux;
                            w.path = v.id;
                        }
                        heap.insert(w);
                    }
                }
            }
        }
    }

	private static class Vertex implements Comparable<Vertex> {
		private int id;
		private int dist;
		private boolean known;
		private int path;
		private ArrayList<Integer> adjacents;
		private ArrayList<Integer> weights;

		public Vertex(int id) {
			this.id = id;
			path = -1;
			dist = 0;
			known = true;
			adjacents = new ArrayList<>();
			weights = new ArrayList<>();
		}

		@Override
		public String toString() {
			return "Vertex [id=" + id + ", dist=" + dist + ", known=" + known + ", path=" + path + ", adjacents="
					+ adjacents + ", weights=" + weights + "]";
		}

		@Override
		public int compareTo(Vertex o) {

			if (dist < o.dist)
				return -1;
			else if (dist > o.dist)
				return 1;
			return 0;
		}
	}

	private static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize;
		private AnyType[] array;

		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		public boolean isEmpty() {
			return currentSize == 0;
		}

		public void makeEmpty() {
			currentSize = 0;
		}

		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
