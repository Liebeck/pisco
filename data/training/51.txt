package proyecto_uno_arreglos;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {

	public static void main(String[] args) throws FileNotFoundException {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int cantidad;
		long A, B, C = 0;
		cantidad = scan.nextInt();
		int[] arreglo;
		arreglo = new int[cantidad];
		for (int i = 0; i < cantidad; i++) {
			arreglo[i] = scan.nextInt();
		}

		for (int d = cantidad - 1; d > 0; d--) {
			for (int k = 0; k < cantidad; k++) {
				A = arreglo[d];
				B = arreglo[k];
				if (d != k) {
					if (A * B > C) {
						C = A * B;
					}
				}
			}
		}
		System.out.println(C);
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_uno_arreglos;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_b {

 public static void main(String[] args) throws FileNotFoundException {

  File f = new File("B1.txt");
  Scanner scan;
  if (f.exists()) {
   scan = new Scanner(f);
  } else {
   scan = new Scanner(System.in);
  }

  int casos;
  casos = Integer.parseInt(scan.nextLine());

  for (int i = 0; i < casos; i++) {

   int size;
   size = Integer.parseInt(scan.nextLine());
   int[][] matriz;
   matriz = new int[size][size];
   for (int q = 0; q < size; q++) {
    String lines[] = scan.nextLine().split(" ");// leer linea
    for (int w = 0; w < size; w++) {
     matriz[q][w] = Integer.parseInt(lines[w]);// numero de
                // comandos
    }
   }

   int[] sumf;
   int[] sumc;
   sumf = new int[size];
   sumc = new int[size];
   int con = 0;
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumf[c] = sumf[c] + matriz[c][r];
    }
   }
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumc[c] = sumc[c] + matriz[r][c];
    }
   }

   for (int y = 0; y < size; y++) {
    for (int w = 0; w < size; w++) {
     if (sumf[y] < sumc[w]) {
      con++;
     }
    }
   }
   System.out.println("Case #" + (i + 1) + ":\n" + con);
  }
 }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_uno_arreglos;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_c {

	public static void main(String[] args) throws FileNotFoundException {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		int contador = 0;
		casos = scan.nextInt();

		for (int i = 0; i < casos; i++) {
			int[] local;
			int[] visitante;
			int cant_equipos;
			cant_equipos = scan.nextInt();
			local = new int[cant_equipos];
			visitante = new int[cant_equipos];

			for (int x = 0; x < cant_equipos; x++) {
				local[x] = scan.nextInt();
				visitante[x] = scan.nextInt();
			}

			for (int y = 0; y < cant_equipos; y++) {
				for (int w = 0; w < cant_equipos; w++) {
					if (y != w) {
						if (local[y] == visitante[w]) {
							contador++;
						}
					}
				}
			}
			System.out.println("Case #" + (i + 1) + ":" + "\n" + contador);
			contador = 0;
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_01;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_d {

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int casos;
		casos = Integer.parseInt(scan.nextLine());

		for (int i = 0; i < casos; i++) {

			int conch = 0;
			int size;
			size = Integer.parseInt(scan.nextLine());
			char[][] matriz;
			matriz = new char[size][size];
			for (int q = 0; q < size; q++) {
				String lines[] = scan.nextLine().split(" ");
				for (int w = 0; w < size; w++) {
					char[] charArray = lines[w].toCharArray();
					matriz[q][w] = charArray[0];
					if (matriz[q][w] == '#') {
						conch++;
					}
				}
			}

			if (conch % 2 == 0) {
				int[] sumf;
				int[] sumc;
				sumf = new int[size];
				sumc = new int[size];
				int con = 0;
				int conf = 0;
				for (int c = 0; c < size; c++) {
					for (int r = 0; r < size; r++) {
						if (matriz[c][r] == '#') {
							con++;
						}
					}
					sumf[c] = con;
					con = 0;
				}
				for (int c = 0; c < size; c++) {
					for (int r = 0; r < size; r++) {
						if (matriz[r][c] == '#') {
							conf++;
						}
					}
					sumc[c] = conf;
					conf = 0;
				}
				int acum = 0;
				int acum2 = 0;
				for (int y = 0; y < size; y++) {
					if (acum < (conch / 2) || acum2 < (conch / 2)) {
						if ((acum == (conch / 2)) || (acum2 == (conch / 2))) {
							System.out.println("YES");
							break;
						}
						acum = sumf[y] + acum;
						acum2 = sumc[y] + acum2;
					} else if (acum > (conch / 2) && acum2 > (conch / 2)) {
						System.out.println("NO");
						break;
					}
				}
			} else {
				System.out.println("NO");

			}
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_uno_arreglos;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_b {

 public static void main(String[] args) throws FileNotFoundException {

  File f = new File("B1.txt");
  Scanner scan;
  if (f.exists()) {
   scan = new Scanner(f);
  } else {
   scan = new Scanner(System.in);
  }

  int casos;
  casos = Integer.parseInt(scan.nextLine());

  for (int i = 0; i < casos; i++) {

   int size;
   size = Integer.parseInt(scan.nextLine());
   int[][] matriz;
   matriz = new int[size][size];
   for (int q = 0; q < size; q++) {
    String lines[] = scan.nextLine().split(" ");// leer linea
    for (int w = 0; w < size; w++) {
     matriz[q][w] = Integer.parseInt(lines[w]);// numero de
                // comandos
    }
   }

   int[] sumf;
   int[] sumc;
   sumf = new int[size];
   sumc = new int[size];
   int con = 0;
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumf[c] = sumf[c] + matriz[c][r];
    }
   }
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumc[c] = sumc[c] + matriz[r][c];
    }
   }

   for (int y = 0; y < size; y++) {
    for (int w = 0; w < size; w++) {
     if (sumf[y] < sumc[w]) {
      con++;
     }
    }
   }
   System.out.println("Case #" + (i + 1) + ":\n" + con);
  }
 }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_b {

 public static void main(String[] args) throws FileNotFoundException {

  File f = new File("B1.txt");
  Scanner scan;
  if (f.exists()) {
   scan = new Scanner(f);
  } else {
   scan = new Scanner(System.in);
  }

  int casos;
  casos = Integer.parseInt(scan.nextLine());

  for (int i = 0; i < casos; i++) {

   int size;
   size = Integer.parseInt(scan.nextLine());
   int[][] matriz;
   matriz = new int[size][size];
   for (int q = 0; q < size; q++) {
    String lines[] = scan.nextLine().split(" ");// leer linea
    for (int w = 0; w < size; w++) {
     matriz[q][w] = Integer.parseInt(lines[w]);// numero de
                // comandos
    }
   }

   int[] sumf;
   int[] sumc;
   sumf = new int[size];
   sumc = new int[size];
   int con = 0;
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumf[c] = sumf[c] + matriz[c][r];
    }
   }
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumc[c] = sumc[c] + matriz[r][c];
    }
   }

   for (int y = 0; y < size; y++) {
    for (int w = 0; w < size; w++) {
     if (sumf[y] < sumc[w]) {
      con++;
     }
    }
   }
   System.out.println("Case #" + (i + 1) + ":\n" + con);
  }
 }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_b {

 public static void main(String[] args) throws FileNotFoundException {

  File f = new File("B1.txt");
  Scanner scan;
  if (f.exists()) {
   scan = new Scanner(f);
  } else {
   scan = new Scanner(System.in);
  }

  int casos;
  casos = Integer.parseInt(scan.nextLine());

  for (int i = 0; i < casos; i++) {

   int size;
   size = Integer.parseInt(scan.nextLine());
   int[][] matriz;
   matriz = new int[size][size];
   for (int q = 0; q < size; q++) {
    String lines[] = scan.nextLine().split(" ");// leer linea
    for (int w = 0; w < size; w++) {
     matriz[q][w] = Integer.parseInt(lines[w]);// numero de
                // comandos
    }
   }

   int[] sumf;
   int[] sumc;
   sumf = new int[size];
   sumc = new int[size];
   int con = 0;
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumf[c] = sumf[c] + matriz[c][r];
    }
   }
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumc[c] = sumc[c] + matriz[r][c];
    }
   }

   for (int y = 0; y < size; y++) {
    for (int w = 0; w < size; w++) {
     if (sumf[y] < sumc[w]) {
      con++;
     }
    }
   }
   System.out.println("Case #" + (i + 1) + ":\n" + con);
  }
 }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_b {

 public static void main(String[] args) throws FileNotFoundException {

  File f = new File("B1.txt");
  Scanner scan;
  if (f.exists()) {
   scan = new Scanner(f);
  } else {
   scan = new Scanner(System.in);
  }

  int casos;
  casos = Integer.parseInt(scan.nextLine());

  for (int i = 0; i < casos; i++) {

   int size;
   size = Integer.parseInt(scan.nextLine());
   int[][] matriz;
   matriz = new int[size][size];
   for (int q = 0; q < size; q++) {
    String lines[] = scan.nextLine().split(" ");// leer linea
    for (int w = 0; w < size; w++) {
     matriz[q][w] = Integer.parseInt(lines[w]);// numero de
                // comandos
    }
   }

   int[] sumf;
   int[] sumc;
   sumf = new int[size];
   sumc = new int[size];
   int con = 0;
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumf[c] = sumf[c] + matriz[c][r];
    }
   }
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumc[c] = sumc[c] + matriz[r][c];
    }
   }

   for (int y = 0; y < size; y++) {
    for (int w = 0; w < size; w++) {
     if (sumf[y] < sumc[w]) {
      con++;
     }
    }
   }
   System.out.println("Case #" + (i + 1) + ":\n" + con);
  }
 }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_b {

 public static void main(String[] args) throws FileNotFoundException {

  File f = new File("B1.txt");
  Scanner scan;
  if (f.exists()) {
   scan = new Scanner(f);
  } else {
   scan = new Scanner(System.in);
  }

  int casos;
  casos = Integer.parseInt(scan.nextLine());

  for (int i = 0; i < casos; i++) {

   int size;
   size = Integer.parseInt(scan.nextLine());
   int[][] matriz;
   matriz = new int[size][size];
   for (int q = 0; q < size; q++) {
    String lines[] = scan.nextLine().split(" ");// leer linea
    for (int w = 0; w < size; w++) {
     matriz[q][w] = Integer.parseInt(lines[w]);// numero de
                // comandos
    }
   }

   int[] sumf;
   int[] sumc;
   sumf = new int[size];
   sumc = new int[size];
   int con = 0;
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumf[c] = sumf[c] + matriz[c][r];
    }
   }
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumc[c] = sumc[c] + matriz[r][c];
    }
   }

   for (int y = 0; y < size; y++) {
    for (int w = 0; w < size; w++) {
     if (sumf[y] < sumc[w]) {
      con++;
     }
    }
   }
   System.out.println("Case #" + (i + 1) + ":\n" + con);
  }
 }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_b {

 public static void main(String[] args) throws FileNotFoundException {

  File f = new File("B_1.in");
  Scanner scan;
  if (f.exists()) {
   scan = new Scanner(f);
  } else {
   scan = new Scanner(System.in);
  }
  
  int i = 0;
 while(scan.hasNext()) {
    i++;
   int size;
   size = Integer.parseInt(scan.nextLine());
   int[][] matriz;
   matriz = new int[size][size];
   for (int q = 0; q < size; q++) {
    String lines[] = scan.nextLine().split(" ");
    for (int w = 0; w < size; w++) {
     matriz[q][w] = Integer.parseInt(lines[w]);
    }
   }
   

   int[] sumf;
   int[] sumc;
   sumf = new int[size];
   sumc = new int[size];
   int con = 0;
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumf[c] = sumf[c] + matriz[c][r];
    }
   }
   for (int c = 0; c < size; c++) {
    for (int r = 0; r < size; r++) {
     sumc[c] = sumc[c] + matriz[r][c];
    }
   }

   for (int y = 0; y < size; y++) {
    for (int w = 0; w < size; w++) {
     if (sumf[y] < sumc[w]) {
      con++;
     }
    }
   }
 
   System.out.println("Case #" + (i) + ":\n" + con);
  }
   
 }
 
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
/**
 *
 */
public class problema_f {

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
           
        int res;
        res = Integer.parseInt(scan.nextLine());
        String [] matriz;
        matriz = new String[5];
       
        for (int w = 0; w < matriz.length; w++) {
        matriz = scan.nextLine().split(" ");
        int con = 0;
        for(int i =0; i < 5; i++){
             if(res == Integer.parseInt(matriz[i])){
                 con++;
             }
         }
       System.out.println(con);

    }
  
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
/**
 *
 */
public class problema_f {

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
           
        int res;
        res = Integer.parseInt(scan.nextLine());
        String [] matriz;
        matriz = new String[5];  
        matriz = scan.nextLine().split(" ");
        int con = 0;
        for(int i =0; i < 5; i++){
             if(res == Integer.parseInt(matriz[i])){
                 con++;
             }
         }
       System.out.println(con);

    }
  
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_uno_arreglos;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_d {

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int casos;
		casos = Integer.parseInt(scan.nextLine());

		for (int i = 0; i < casos; i++) {

			int conch = 0;
			int size;
			size = Integer.parseInt(scan.nextLine());
			char[][] matriz;
			matriz = new char[size][size];
			for (int q = 0; q < size; q++) {
				String lines[] = scan.nextLine().split(" ");
				for (int w = 0; w < size; w++) {
					char[] charArray = lines[0].toCharArray();
					matriz[q][w] = charArray[0];
					if (matriz[q][w] == '#') {
						conch++;
					}
				}
			}

			if (conch % 2 == 0) {
				int[] sumf;
				int[] sumc;
				sumf = new int[size];
				sumc = new int[size];
				int con = 0;
				int conf = 0;
				for (int c = 0; c < size; c++) {
					for (int r = 0; r < size; r++) {
						if (matriz[c][r] == '#') {
							con++;
						}
					}
					sumf[c] = con;
					con = 0;
				}
				for (int c = 0; c < size; c++) {
					for (int r = 0; r < size; r++) {
						if (matriz[r][c] == '#') {
							conf++;
						}
					}
					sumc[c] = conf;
					conf = 0;
				}
				int acum = 0;
				int acum2 = 0;
				for (int y = 0; y < size; y++) {
					if (acum < (conch / 2) || acum2 < (conch / 2)) {
						if ((acum == (conch / 2)) || (acum2 == (conch / 2))) {
							System.out.println("YES");
							break;
						}
						acum = sumf[y] + acum;
						acum2 = sumc[y] + acum2;
					} else if (acum > (conch / 2) && acum2 > (conch / 2)) {
						System.out.println("NO");
						break;
					}
				}
			} else {
				System.out.println("NO");

			}
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package rueba;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_d {

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int casos;
		casos = Integer.parseInt(scan.nextLine());

		for (int i = 0; i < casos; i++) {

			int conch = 0;
			int size;
			size = Integer.parseInt(scan.nextLine());
			char[][] matriz;
			matriz = new char[size][size];
			for (int q = 0; q < size; q++) {
				String lines = scan.nextLine();
				for (int w = 0; w < size; w++) {
					matriz[q][w] = lines.charAt(w);
					if (matriz[q][w] == '#') {
						conch++;
					}
				}
			}

			if (conch % 2 == 0) {
				int[] sumf;
				int[] sumc;
				sumf = new int[size];
				sumc = new int[size];
				int con = 0;
				int conf = 0;
				for (int c = 0; c < size; c++) {
					for (int r = 0; r < size; r++) {
						if (matriz[c][r] == '#') {
							con++;
						}
					}
					sumf[c] = con;
					con = 0;
				}
				for (int c = 0; c < size; c++) {
					for (int r = 0; r < size; r++) {
						if (matriz[r][c] == '#') {
							conf++;
						}
					}
					sumc[c] = conf;
					conf = 0;
				}
				int acum = 0;
				int acum2 = 0;
				for (int y = 0; y < size; y++) {
					if (acum < (conch / 2) || acum2 < (conch / 2)) {
						if ((acum == (conch / 2)) || (acum2 == (conch / 2))) {
							System.out.println("YES");
							break;
						}
						acum = sumf[y] + acum;
						acum2 = sumc[y] + acum2;
					} else if (acum > (conch / 2) && acum2 > (conch / 2)) {
						System.out.println("NO");
						break;
					}
				}
			} else {
				System.out.println("NO");

			}
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package rueba;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_d {

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int casos;
		casos = Integer.parseInt(scan.nextLine());

		for (int i = 0; i < casos; i++) {

			int conch = 0;
			int size;
			size = Integer.parseInt(scan.nextLine());
			char[][] matriz;
			matriz = new char[size][size];
			
			for (int q = 0; q < size; q++) {
				String lines = scan.nextLine();
				for (int w = 0; w < size; w++) {
					matriz[q][w] = lines.charAt(w);
					if (matriz[q][w] == '#') {
						conch++;
					}
				}
			}
			int a=0;

			if (conch % 2 == 0) {
				a=0;
				int[] sumf;
				int[] sumc;
				sumf = new int[size];
				sumc = new int[size];
				int con = 0;
				int conf = 0;
				for (int c = 0; c < size; c++) {
					for (int r = 0; r < size; r++) {
						if (matriz[c][r] == '#') {
							con++;
						}
					}
					sumf[c] = con;
					con = 0;
				}
				for (int c = 0; c < size; c++) {
					for (int r = 0; r < size; r++) {
						if (matriz[r][c] == '#') {
							conf++;
						}
					}
					sumc[c] = conf;
					conf = 0;
				}
				int acum = 0;
				int acum2 = 0;
				
				for (int y = 0; y < size; y++) {
					if (acum < (conch / 2) || acum2 < (conch / 2)) {
						
						if ((acum == (conch / 2)) || (acum2 == (conch / 2))) {
							System.out.println("YES");
							a=1;
							break;
						}
						acum = sumf[y] + acum;
						acum2 = sumc[y] + acum2;
						if ((acum == (conch / 2)) || (acum2 == (conch / 2))) {
							System.out.println("YES");
							a=1;
							break;
						}
					} else if (acum > (conch / 2) && acum2 > (conch / 2)) {
						System.out.println("NO");
						break;
					}
		
				}
			} else {
				System.out.println("NO");

			}
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	
	
	    public static void main( String [ ] args ) throws FileNotFoundException
	    {
	        
	        	       
	        File f = new File("B1.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	    	        			if(Integer.parseInt(recibe_comando[2])!=0)
	    	        				costo_lista = costo_lista + (lista.size() - (Integer.parseInt(recibe_comando[2])));
	    	        			
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        				costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		    	        					System.out.println("consultar: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}
	        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
	        				lista.remove(Integer.parseInt(recibe_comando[1]));
	        				costo_arreglo = costo_arreglo + (arreglo.size() - Integer.parseInt(recibe_comando[1]));
	        				costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == (Integer.parseInt(recibe_comando[1]))){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        					}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + (arreglo.size());
	        					costo_lista = costo_lista + (lista.size());
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException
	    {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	    	        			if(Integer.parseInt(recibe_comando[2])!=0)
	    	        				costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	    	        			
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        				if(Integer.parseInt(recibe_comando[1])<arreglo.size()){
		    	        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		    	        				}
		    	        					System.out.println("consultar: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				if(arreglo.size()!=Integer.parseInt(recibe_comando[1])){
		        				costo_arreglo = costo_arreglo + (arreglo.size() - Integer.parseInt(recibe_comando[1]));
		        				}else if(0 != Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == (Integer.parseInt(recibe_comando[1]))){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        					}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + (arreglo.size());
	        					costo_lista = costo_lista + (lista.size());
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException
	    {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	    	        			if(Integer.parseInt(recibe_comando[2])!=0)
	    	        				costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	    	        			
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        				if(Integer.parseInt(recibe_comando[1])<arreglo.size()){
		    	        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		    	        				}
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				if(arreglo.size()!=Integer.parseInt(recibe_comando[1])){
		        				costo_arreglo = costo_arreglo + (arreglo.size() - Integer.parseInt(recibe_comando[1]));
		        				}else if(0 != Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == (Integer.parseInt(recibe_comando[1]))){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        					}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + (arreglo.size());
	        					costo_lista = costo_lista + (lista.size());
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException
	    {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	    	        			if(Integer.parseInt(recibe_comando[2])!=0)
	    	        				costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	    	        			
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        				if(Integer.parseInt(recibe_comando[1])<arreglo.size()){
		    	        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		    	        				}
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				if(arreglo.size()!=Integer.parseInt(recibe_comando[1])){
		        				costo_arreglo = costo_arreglo + (arreglo.size() - Integer.parseInt(recibe_comando[1]));
		        				}else if(0 != Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == (Integer.parseInt(recibe_comando[1]))){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        					}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + (arreglo.size());
	        					costo_lista = costo_lista + (lista.size());
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Scanner;

public class problema_b {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;
			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static class MyArrayList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList() {
			doClear();
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * 
		 * @return true if this collection is empty.
		 */
		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			return theItems[idx];
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			AnyType old = theItems[idx];
			theItems[idx] = newVal;

			return old;
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity(int newCapacity) {
			if (newCapacity < theSize)
				return;

			AnyType[] old = theItems;
			theItems = (AnyType[]) new Object[newCapacity];
			for (int i = 0; i < size(); i++)
				theItems[i] = old[i];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {
			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public void add(int idx, AnyType x) {
			if (theItems.length == size())
				ensureCapacity(size() * 2 + 1);

			for (int i = theSize; i > idx; i--)
				theItems[i] = theItems[i - 1];

			theItems[idx] = x;
			theSize++;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			AnyType removedItem = theItems[idx];

			for (int i = idx; i < size() - 1; i++)
				theItems[i] = theItems[i + 1];
			theSize--;

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear() {
			doClear();
		}

		private void doClear() {
			theSize = 0;
			ensureCapacity(DEFAULT_CAPACITY);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new ArrayListIterator();
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * This is the implementation of the ArrayListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType> {
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current < size();
			}

			public AnyType next() {
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				okToRemove = true;
				return theItems[current++];
			}

			public void remove() {
				if (!okToRemove)
					throw new IllegalStateException();

				MyArrayList.this.remove(--current);
				okToRemove = false;
			}
		
		}
		private static final int DEFAULT_CAPACITY = 10;

		private AnyType[] theItems;
		private int theSize;
		
		public int getMax(MyArrayList list){
		    int max = (int) list.get(0);
		    for(int i=0; i<list.size(); i++){
		        if((int) list.get(i) > max){
		            max = (int) list.get(i);
		            
		        }
		    }
		    return max;		
		}
		
	}

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		casos = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < casos; i++) {
			MyLinkedList<Integer> mazo = new MyLinkedList<>();
			MyArrayList<Integer> acumulador = new MyArrayList<>();
    		String recibir[] = scan.nextLine().split(" ");
			int tam_mazo = Integer.parseInt(recibir[0]);
			int cant_jugadores = Integer.parseInt(recibir[1]);
			for(int y =0; y < cant_jugadores;y++){
				acumulador.add(0);
			}
			int her = tam_mazo-1;
			 recibir = scan.nextLine().split(" ");
			for (int x = 0; x < tam_mazo; x++) {
				mazo.add(Integer.parseInt(recibir[x]));
			}
			for (int w = 0; w < tam_mazo; w++) {
				if(mazo.get(0)>mazo.get(her)){
					acumulador.set(w%cant_jugadores, (mazo.get(0)+acumulador.get(w%cant_jugadores)));
					mazo.remove(0);
					her--;
				}else if(mazo.get(her)>mazo.get(0) || mazo.get(her)==mazo.get(0)){
					acumulador.set(w%cant_jugadores, (mazo.get(her)+acumulador.get(w%cant_jugadores)));
					mazo.remove(her);
					her--;
				}
			}
			int mrt = acumulador.getMax(acumulador);
			System.out.println("Caso #" + (i + 1) + ":");
			for(int e = 0; e < acumulador.size(); e++){
			if(mrt == acumulador.get(e)){
				System.out.println((e+1) + " ");
			}
		}
		}
		}
	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Scanner;

public class problema_b {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;
			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static class MyArrayList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList() {
			doClear();
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * 
		 * @return true if this collection is empty.
		 */
		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			return theItems[idx];
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			AnyType old = theItems[idx];
			theItems[idx] = newVal;

			return old;
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity(int newCapacity) {
			if (newCapacity < theSize)
				return;

			AnyType[] old = theItems;
			theItems = (AnyType[]) new Object[newCapacity];
			for (int i = 0; i < size(); i++)
				theItems[i] = old[i];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {
			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public void add(int idx, AnyType x) {
			if (theItems.length == size())
				ensureCapacity(size() * 2 + 1);

			for (int i = theSize; i > idx; i--)
				theItems[i] = theItems[i - 1];

			theItems[idx] = x;
			theSize++;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			AnyType removedItem = theItems[idx];

			for (int i = idx; i < size() - 1; i++)
				theItems[i] = theItems[i + 1];
			theSize--;

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear() {
			doClear();
		}

		private void doClear() {
			theSize = 0;
			ensureCapacity(DEFAULT_CAPACITY);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new ArrayListIterator();
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * This is the implementation of the ArrayListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType> {
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current < size();
			}

			public AnyType next() {
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				okToRemove = true;
				return theItems[current++];
			}

			public void remove() {
				if (!okToRemove)
					throw new IllegalStateException();

				MyArrayList.this.remove(--current);
				okToRemove = false;
			}
		
		}
		private static final int DEFAULT_CAPACITY = 10;

		private AnyType[] theItems;
		private int theSize;
		
		public int getMax(MyArrayList list){
		    int max = (int) list.get(0);
		    for(int i=0; i<list.size(); i++){
		        if((int) list.get(i) > max){
		            max = (int) list.get(i);
		            
		        }
		    }
		    return max;		
		}
		
	}

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		casos = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < casos; i++) {
			MyLinkedList<Integer> mazo = new MyLinkedList<>();
			MyArrayList<Integer> acumulador = new MyArrayList<>();
    		String recibir[] = scan.nextLine().split(" ");
			int tam_mazo = Integer.parseInt(recibir[0]);
			int cant_jugadores = Integer.parseInt(recibir[1]);
			for(int y =0; y < cant_jugadores;y++){
				acumulador.add(0);
			}
			int her = tam_mazo-1;
			 recibir = scan.nextLine().split(" ");
			for (int x = 0; x < tam_mazo; x++) {
				mazo.add(Integer.parseInt(recibir[x]));
			}
			for (int w = 0; w < tam_mazo; w++) {
				if(mazo.get(0)>mazo.get(her)){
					acumulador.set(w%cant_jugadores, (mazo.get(0)+acumulador.get(w%cant_jugadores)));
					mazo.remove(0);
					her--;
				}else if(mazo.get(her)>mazo.get(0) || mazo.get(her)==mazo.get(0)){
					acumulador.set(w%cant_jugadores, (mazo.get(her)+acumulador.get(w%cant_jugadores)));
					mazo.remove(her);
					her--;
				}
			}
			int mrt = acumulador.getMax(acumulador);
			System.out.println("Caso #" + (i + 1) + ":");
			for(int e = 0; e < acumulador.size(); e++){
			if(mrt == acumulador.get(e)){
				System.out.println((e+1) + " ");
			}
		}
		}
		}
	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException
	    {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					if(Integer.parseInt(recibe_comando[2])==0){
	        						costo_arreglo = costo_arreglo + arreglo.size();
	        					}else{
	        						costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        						costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	        					}
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				
		        				if(arreglo.size()==Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}else if(0 == Integer.parseInt(recibe_comando[1])){
		        					costo_arreglo = costo_arreglo + arreglo.size();
		        				}else{
		        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) + 1));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        				}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + arreglo.size();
	        					costo_lista = costo_lista + lista.size();
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Scanner;

public class problema_b {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;
			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static class MyArrayList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList() {
			doClear();
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * 
		 * @return true if this collection is empty.
		 */
		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			return theItems[idx];
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			AnyType old = theItems[idx];
			theItems[idx] = newVal;

			return old;
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity(int newCapacity) {
			if (newCapacity < theSize)
				return;

			AnyType[] old = theItems;
			theItems = (AnyType[]) new Object[newCapacity];
			for (int i = 0; i < size(); i++)
				theItems[i] = old[i];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {
			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public void add(int idx, AnyType x) {
			if (theItems.length == size())
				ensureCapacity(size() * 2 + 1);

			for (int i = theSize; i > idx; i--)
				theItems[i] = theItems[i - 1];

			theItems[idx] = x;
			theSize++;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			AnyType removedItem = theItems[idx];

			for (int i = idx; i < size() - 1; i++)
				theItems[i] = theItems[i + 1];
			theSize--;

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear() {
			doClear();
		}

		private void doClear() {
			theSize = 0;
			ensureCapacity(DEFAULT_CAPACITY);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new ArrayListIterator();
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * This is the implementation of the ArrayListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType> {
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current < size();
			}

			public AnyType next() {
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				okToRemove = true;
				return theItems[current++];
			}

			public void remove() {
				if (!okToRemove)
					throw new IllegalStateException();

				MyArrayList.this.remove(--current);
				okToRemove = false;
			}
		
		}
		private static final int DEFAULT_CAPACITY = 10;

		private AnyType[] theItems;
		private int theSize;
		
		public int getMax(MyArrayList list){
		    int max = (int) list.get(0);
		    for(int i=0; i<list.size(); i++){
		        if((int) list.get(i) > max){
		            max = (int) list.get(i);
		            
		        }
		    }
		    return max;		
		}
		
	}

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		casos = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < casos; i++) {
			MyLinkedList<Integer> mazo = new MyLinkedList<>();
			MyArrayList<Integer> acumulador = new MyArrayList<>();
    		String recibir[] = scan.nextLine().split(" ");
			int tam_mazo = Integer.parseInt(recibir[0]);
			int cant_jugadores = Integer.parseInt(recibir[1]);
			for(int y =0; y < cant_jugadores;y++){
				acumulador.add(0);
			}
			int her = tam_mazo-1;
			 recibir = scan.nextLine().split(" ");
			for (int x = 0; x < tam_mazo; x++) {
				mazo.add(Integer.parseInt(recibir[x]));
			}
			for (int w = 0; w < tam_mazo; w++) {
				if(mazo.get(0)>mazo.get(her)){
					acumulador.set(w%cant_jugadores, (mazo.get(0)+acumulador.get(w%cant_jugadores)));
					mazo.remove(0);
					her--;
				}else if(mazo.get(her)>mazo.get(0) || mazo.get(her)==mazo.get(0)){
					acumulador.set(w%cant_jugadores, (mazo.get(her)+acumulador.get(w%cant_jugadores)));
					mazo.remove(her);
					her--;
				}
			}
			int mrt = acumulador.getMax(acumulador);
			System.out.println("Caso #" + (i + 1) + ":");
			for(int e = 0; e < acumulador.size(); e++){
			if(mrt == acumulador.get(e)){
				System.out.print((e+1) + " ");
			}
			
		}
			System.out.println();
		}
		}
	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_c {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx
						+ "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;
			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
			public String nombre;
			public String apellido;
			public int cedula;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static class MyArrayList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList() {
			doClear();
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * 
		 * @return true if this collection is empty.
		 */
		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx
						+ "; size " + size());
			return theItems[idx];
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx
						+ "; size " + size());
			AnyType old = theItems[idx];
			theItems[idx] = newVal;

			return old;
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity(int newCapacity) {
			if (newCapacity < theSize)
				return;

			AnyType[] old = theItems;
			theItems = (AnyType[]) new Object[newCapacity];
			for (int i = 0; i < size(); i++)
				theItems[i] = old[i];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {
			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public void add(int idx, AnyType x) {
			if (theItems.length == size())
				ensureCapacity(size() * 2 + 1);

			for (int i = theSize; i > idx; i--)
				theItems[i] = theItems[i - 1];

			theItems[idx] = x;
			theSize++;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			AnyType removedItem = theItems[idx];

			for (int i = idx; i < size() - 1; i++)
				theItems[i] = theItems[i + 1];
			theSize--;

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear() {
			doClear();
		}

		private void doClear() {
			theSize = 0;
			ensureCapacity(DEFAULT_CAPACITY);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new ArrayListIterator();
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * This is the implementation of the ArrayListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType> {
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current < size();
			}

			public AnyType next() {
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				okToRemove = true;
				return theItems[current++];
			}

			public void remove() {
				if (!okToRemove)
					throw new IllegalStateException();

				MyArrayList.this.remove(--current);
				okToRemove = false;
			}
		}

		private static final int DEFAULT_CAPACITY = 10;

		private AnyType[] theItems;
		private int theSize;
	}

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("C_.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		int cant_cualidades = Integer.parseInt(scan.nextLine());
		int[] cualidades_requeridas = new int[cant_cualidades];
		String recibe_cualidades[] = scan.nextLine().split(" ");
		for (int k = 0; k < cant_cualidades; k++) {
			cualidades_requeridas[k] = Integer.parseInt(recibe_cualidades[k]);
		}

		int cant_ninas = Integer.parseInt(scan.nextLine());
		MyArrayList<Integer> ninas = new MyArrayList<>();
		int con = 0;
		int definitivo = 0;
		for (int m = 0; m < cant_ninas; m++) {
			ninas.clear();
			recibe_cualidades = scan.nextLine().split(" ");
			for (int u = 0; u < recibe_cualidades.length; u++) {
				ninas.add(Integer.parseInt(recibe_cualidades[u]));
			}
			con=0;
			for (int y = 0; y < cualidades_requeridas.length; y++) {
				for (int l = 0; l < ninas.size(); l++) {
					if (ninas.size() < cualidades_requeridas.length) {
						break;
					} else if (cualidades_requeridas[y] == ninas.get(l)) {
						con++;
						break;
					}
				}
				
				if (cant_cualidades == con) {
					definitivo++;
					break;
				}
			
			}
			
		}
		System.out.println(definitivo);
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					if(Integer.parseInt(recibe_comando[2])==0){
	        						costo_arreglo = costo_arreglo + arreglo.size();
	        					}else{
	        						costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        						costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	        					}
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				
		        				if(arreglo.size()==Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}else if(0 == Integer.parseInt(recibe_comando[1])){
		        					costo_arreglo = costo_arreglo + arreglo.size();
		        				}else{
		        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) + 1));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        				}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + arreglo.size();
	        					costo_lista = costo_lista + lista.size();
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					System.out.println("insertar: posicion valida");
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()-1<Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion invalida");
		        			}else{
		        				System.out.println("eliminar: posicion valida");
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) - 1));
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        				}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + arreglo.size();
	        					costo_lista = costo_lista + lista.size();
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					System.out.println("insertar: posicion valida");
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()-1<Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion invalida");
		        			}else{
		        				System.out.println("eliminar: posicion valida");
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) - 1));
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				if(arreglo.size()==0){
	        					System.out.println("no existe numero");
	        				}else{
	        					for(int t = 0; t < arreglo.size(); t++){
		        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
		        						System.out.println("buscar: " + t);
		        						costo_arreglo = costo_arreglo + (t+1);
		        						costo_lista = costo_lista + (t+1);
		        						skyfall = 1;
		        						break;
		        					}
		        					if(arreglo.size()-1==t){
		        						System.out.println("no existe numero");
		        						costo_arreglo = costo_arreglo + (t+1);
		        						costo_lista = costo_lista + (t+1);
		        					}
		        				}
	        				}
	        				
	        				
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					if(Integer.parseInt(recibe_comando[2])==0){
	        						costo_arreglo = costo_arreglo + arreglo.size();
	        					}else{
	        						costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        						costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	        					}
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				
		        				if(arreglo.size()==Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}else if(0 == Integer.parseInt(recibe_comando[1])){
		        					costo_arreglo = costo_arreglo + arreglo.size();
		        				}else{
		        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) + 1));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        				}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + arreglo.size();
	        					costo_lista = costo_lista + lista.size();
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					if(Integer.parseInt(recibe_comando[2])==0){
	        						costo_arreglo = costo_arreglo + arreglo.size();
	        					}else{
	        						costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        						costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	        					}
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				
		        				if(arreglo.size()==Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}else if(0 == Integer.parseInt(recibe_comando[1])){
		        					costo_arreglo = costo_arreglo + arreglo.size();
		        				}else{
		        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) + 1));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        				}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + arreglo.size();
	        					costo_lista = costo_lista + lista.size();
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					if(Integer.parseInt(recibe_comando[2])==0){
	        						costo_arreglo = costo_arreglo + arreglo.size();
	        					}else{
	        						costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        						costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	        					}
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				
		        				if(arreglo.size()==Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}else if(0 == Integer.parseInt(recibe_comando[1])){
		        					costo_arreglo = costo_arreglo + arreglo.size();
		        				}else{
		        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) + 1));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        				}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + arreglo.size();
	        					costo_lista = costo_lista + lista.size();
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					if(Integer.parseInt(recibe_comando[2])==0){
	        						costo_arreglo = costo_arreglo + arreglo.size();
	        					}else{
	        						costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        						costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	        					}
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				
		        				if(arreglo.size()==Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}else if(0 == Integer.parseInt(recibe_comando[1])){
		        					costo_arreglo = costo_arreglo + arreglo.size();
		        				}else{
		        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) + 1));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        				}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + arreglo.size();
	        					costo_lista = costo_lista + lista.size();
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_a {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyLinkedList( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyLinkedList.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}

public static class MyArrayList<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

	    public static void main( String [ ] args ) throws FileNotFoundException {
       
	        File f = new File("A_2.txt");
	        Scanner scan;
	        if (f.exists()) {
	         scan = new Scanner(f);
	        } else {
	         scan = new Scanner(System.in);
	        }
	        int casos;
	        casos = Integer.parseInt(scan.nextLine());
	        int comandos;
	        
	        for (int i = 0; i < casos; i++) {
	        	MyLinkedList<Integer> lista = new MyLinkedList<>( );
		        MyArrayList<Integer> arreglo = new MyArrayList<>( );
	        	System.out.println("Caso #" + (i+1) + ":");
		        comandos = Integer.parseInt(scan.nextLine());
		        int costo_arreglo = 0;
		        int costo_lista = 0;
	        	for (int x = 0; x < comandos; x++){
	        		String recibe_comando[] = scan.nextLine().split(" ");
	        		switch (recibe_comando.length){
	        		case 3:
	        			if((arreglo.size()>= Integer.parseInt(recibe_comando[2]))){
	        				if(Integer.parseInt(recibe_comando[2])==arreglo.size()){
	        					arreglo.add(Integer.parseInt(recibe_comando[1]));
	        					lista.add(Integer.parseInt(recibe_comando[1]));
	        					costo_lista = costo_lista + (Integer.parseInt(recibe_comando[2]));
	        					System.out.println("insertar: posicion valida");
	        				}else{
	        					if(Integer.parseInt(recibe_comando[2])==0){
	        						costo_arreglo = costo_arreglo + arreglo.size();
	        					}else{
	        						costo_arreglo = costo_arreglo + ((arreglo.size()-(Integer.parseInt(recibe_comando[2]))));
	        						costo_lista = costo_lista + ( (Integer.parseInt(recibe_comando[2])));
	        					}
	        					arreglo.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	    	        			lista.add( Integer.parseInt(recibe_comando[2]),  Integer.parseInt(recibe_comando[1]));
	        					System.out.println("insertar: posicion valida");
	        				}
	        			}else{
	        				System.out.println("insertar: posicion invalida");
	        			}
	        		break;
	        		case 2:
	        			if(recibe_comando[0].equals("consultar")){
	        				
	        				if((Integer.parseInt(recibe_comando[1]))<arreglo.size()){
	        					System.out.println("consulta: " + (arreglo.get(Integer.parseInt(recibe_comando[1]))));
	        				costo_lista = (costo_lista + Integer.parseInt(recibe_comando[1]));
	        				}else{
		    	        					System.out.println("consulta: no encontrado");
	        				}	    
	        				
	        			}else if(recibe_comando[0].equals("eliminar")){
		        			if((arreglo.size()>Integer.parseInt(recibe_comando[1]))){
		        				System.out.println("eliminar: posicion valida");
		        				
		        				arreglo.remove(Integer.parseInt(recibe_comando[1]));
		        				lista.remove(Integer.parseInt(recibe_comando[1]));
		        				
		        				if(arreglo.size()==Integer.parseInt(recibe_comando[1])){
		        					costo_lista = costo_lista + ((Integer.parseInt(recibe_comando[1])));
		        				}else if(0 == Integer.parseInt(recibe_comando[1])){
		        					costo_arreglo = costo_arreglo + arreglo.size();
		        				}else{
		        					costo_lista = costo_lista + Integer.parseInt(recibe_comando[1]);
		        					costo_arreglo = costo_arreglo + (arreglo.size() - ( Integer.parseInt(recibe_comando[1]) + 1));
		        				}
		        			}else{
		        				System.out.println("eliminar: posicion invalida");
		        			}      				
	        			}else if(recibe_comando[0].equals("buscar")){
	        				int skyfall = 0;
	        				for(int t = 0; t < arreglo.size(); t++){
	        					if(arreglo.get(t) == Integer.parseInt(recibe_comando[1])){
	        						System.out.println("buscar: " + t);
	        						costo_arreglo = costo_arreglo + (t+1);
	        						costo_lista = costo_lista + (t+1);
	        						skyfall = 1;
	        						break;
	        					}
	        				}
	        				if(skyfall == 0){
	        					System.out.println("no existe numero");
	        					costo_arreglo = costo_arreglo + arreglo.size();
	        					costo_lista = costo_lista + lista.size();
	        				}
	        			}
	        		break;
	        		case 1:
	        			System.out.println("costo: " + costo_arreglo + " " + costo_lista);
	        		break;
	        		}
	        	}
	        }
	        
	        }
	    }
	
	
	
	




<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;



public class problema_a<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty LinkedList.
     */
    public problema_a( )
    {
        doClear( );
    }
    
    private void clear( )
    {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( )
    {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;         
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "" );

        for( AnyType x : this )
            sb.append( x + "" );
        sb.append( "" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            problema_a.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType>
    {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
    
    
    
    
    
    

	public static class MyArrayList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty ArrayList.
		 */
		public MyArrayList() {
			doClear();
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		/**
		 * Returns true if this collection is empty.
		 * 
		 * @return true if this collection is empty.
		 */
		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			return theItems[idx];
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws ArrayIndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			if (idx < 0 || idx >= size())
				throw new ArrayIndexOutOfBoundsException("Index " + idx + "; size " + size());
			AnyType old = theItems[idx];
			theItems[idx] = newVal;

			return old;
		}

		@SuppressWarnings("unchecked")
		public void ensureCapacity(int newCapacity) {
			if (newCapacity < theSize)
				return;

			AnyType[] old = theItems;
			theItems = (AnyType[]) new Object[newCapacity];
			for (int i = 0; i < size(); i++)
				theItems[i] = old[i];
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {
			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at the specified index.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public void add(int idx, AnyType x) {
			if (theItems.length == size())
				ensureCapacity(size() * 2 + 1);

			for (int i = theSize; i > idx; i--)
				theItems[i] = theItems[i - 1];

			theItems[idx] = x;
			theSize++;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			AnyType removedItem = theItems[idx];

			for (int i = idx; i < size() - 1; i++)
				theItems[i] = theItems[i + 1];
			theSize--;

			return removedItem;
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void clear() {
			doClear();
		}

		private void doClear() {
			theSize = 0;
			ensureCapacity(DEFAULT_CAPACITY);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new ArrayListIterator();
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * This is the implementation of the ArrayListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyArrayList.
		 */
		private class ArrayListIterator implements java.util.Iterator<AnyType> {
			private int current = 0;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current < size();
			}

			public AnyType next() {
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				okToRemove = true;
				return theItems[current++];
			}

			public void remove() {
				if (!okToRemove)
					throw new IllegalStateException();

				MyArrayList.this.remove(--current);
				okToRemove = false;
			}
		
		}
		private static final int DEFAULT_CAPACITY = 10;

		private AnyType[] theItems;
		private int theSize;
		
		public int getMax(MyArrayList list){
		    int max = (int) list.get(0);
		    for(int i=0; i<list.size(); i++){
		        if((int) list.get(i) > max){
		            max = (int) list.get(i);
		            
		        }
		    }
		    return max;		
		}
		
	}


    
    
    
    
    
    
    
    
    public static void main( String [ ] args )
    {
    	// TODO Auto-generated method stub
    			Scanner input=new Scanner(System.in);
    			int numero_de_casos=Integer.parseInt(input.nextLine());
    			int cant_comandos;
    			String[] recibe_comandos;
    			int x;
    			int pos;
    			int costo_arreglo;
    			int costo_lista;
    			for(int c=1; c<=numero_de_casos; c++){
    				System.out.println("Caso #"+c+":");
    				costo_arreglo=0;
    				costo_lista=0;
    				problema_a<Integer> lst = new problema_a<>( );
    				cant_comandos=Integer.parseInt(input.nextLine()); 
    				for(int co=0; co<cant_comandos; co++){
    					recibe_comandos=input.nextLine().split(" ");
    					if(recibe_comandos[0].equals("insertar")){
    						x=Integer.parseInt(recibe_comandos[1]);
    						pos=Integer.parseInt(recibe_comandos[2]);
    						if(pos>lst.size()){
    							System.out.println("insertar: posicion invalida");
    						}else{
    							System.out.println("insertar: posicion valida");
    							costo_arreglo=costo_arreglo+(lst.size()-Integer.parseInt(recibe_comandos[2]));
    							costo_lista=costo_lista+Integer.parseInt(recibe_comandos[2]);
    							lst.add(Integer.parseInt(recibe_comandos[2]), x); 
    						}
    						
    					}
    					if(recibe_comandos[0].equals("consultar")){
    						pos=Integer.parseInt(recibe_comandos[1]);
    						if(pos>lst.size()-1){
    							System.out.println("consulta: no encontrado");
    						}else{
    							System.out.println("consulta: "+lst.get(pos));
    							costo_lista=costo_lista+pos;
    						}
    						
    					}
    					if(recibe_comandos[0].equals("eliminar")){
    						pos=Integer.parseInt(recibe_comandos[1]);
    						if(pos>lst.size()-1){
    							System.out.println("eliminar: posicion invalida");
    						}else{
    							System.out.println("eliminar: posicion valida");
    							costo_lista=costo_lista+pos;
    							costo_arreglo=costo_arreglo+(lst.size()-pos-1);
    							lst.remove(pos);
    						}
    					}
    					if(recibe_comandos[0].equals("buscar")){
    						x=Integer.parseInt(recibe_comandos[1]);
    						if(lst.size()==0){
    							System.out.println("no existe numero");
    						}else{
    						for (int j=0; j<lst.size(); j++){
    							if(lst.get(j)==x){
    								System.out.println("buscar: "+j);
    								costo_lista=costo_lista+j+1;
    								costo_arreglo=costo_arreglo+j+1;
    								break;
    							}
    							
    							if(j==lst.size()-1){
    								System.out.println("no existe numero");
    								costo_lista=costo_lista+j+1;
    								costo_arreglo=costo_arreglo+j+1;
    								
    							}
    						}
    						}
    					}
    					if(recibe_comandos[0].equals("costo")){
    						System.out.println("costo: "+costo_arreglo+" "+costo_lista);
    					}			
    				}			
    			}
    	}
}



	
	
	

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Scanner;



public class problema_d {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null,null,null);
			endMarker = new Node<>(null, beginMarker, null,null,null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x,String name,String last_name) {

			add(size(), x,name,last_name);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x,String name, String last_name) {
			addBefore(getNode(idx, 0, size()), x,name,last_name);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x,String name, String last_name) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p,name,last_name);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx
						+ "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n,String name, String last_name) {
				data = d;
				prev = p;
				next = n;
				nombre=name;
				apellido=last_name;
			}

			public AnyType data;//ceula
			public Node<AnyType> prev;
			public Node<AnyType> next;
			public String nombre;
			public String apellido;
			public int cedula;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}
	
	
	
	
	
	

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		casos = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < casos; i++) {
			int cant_cubiculos = Integer.parseInt(scan.nextLine());
			MyLinkedList<Integer>[] cubiculos = new MyLinkedList[cant_cubiculos];
    		String recibir[] = scan.nextLine().split(" ");
			MyLinkedList<Integer> casilleros = new MyLinkedList<>();

    		for(int a = 0; a < cant_cubiculos; a++){
    			cubiculos[a] =casilleros;
    			casilleros = new MyLinkedList<>();
			}
			int comandos = Integer.parseInt(scan.nextLine());
			for (int x = 0; x < comandos; x++) {
        		String recibe_comando[] = scan.nextLine().split(" ");
				switch(recibe_comando.length){
				case 4:
					int min=cubiculos[0].size()/Integer.parseInt(recibir[0]) ;
					int idx = 0;
					for(int r = 1; r < cubiculos.length ; r++){
						if(cubiculos[r].size()/Integer.parseInt(recibir[r]) < min ){
							idx = r;
							min = cubiculos[r].size()/Integer.parseInt(recibir[r]);
						}
					}
					cubiculos[idx].add(Integer.parseInt(recibe_comando[3]), recibe_comando[1], recibe_comando[2]);
					System.out.println(idx + cubiculos[idx].size());
					break;
				case 2:
					for(int uu = 0; uu < cubiculos.length; uu++){
						for(int su = 0; su < cubiculos[uu].size(); su++){
							if(cubiculos[uu].get(su) == Integer.parseInt(recibe_comando[1])){
								System.out.println(cubiculos[uu].getNode(su).nombre);
								cubiculos[uu].remove(su);
							}
						}
					}
				}
				
			}
			
		}
		}
		}
	






<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Scanner;



public class problema_d {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null,null,null);
			endMarker = new Node<>(null, beginMarker, null,null,null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x,String name,String last_name) {

			add(size(), x,name,last_name);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x,String name, String last_name) {
			addBefore(getNode(idx, 0, size()), x,name,last_name);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x,String name, String last_name) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p,name,last_name);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx
						+ "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n,String name, String last_name) {
				data = d;
				prev = p;
				next = n;
				nombre=name;
				apellido=last_name;
			}

			public AnyType data;//ceula
			public Node<AnyType> prev;
			public Node<AnyType> next;
			public String nombre;
			public String apellido;
			public int cedula;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}
	
	
	
	
	
	

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		casos = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < casos; i++) {
        	System.out.println("Caso #" + (i+1) + ":");
			int cant_cubiculos = Integer.parseInt(scan.nextLine());
			MyLinkedList<Integer>[] cubiculos = new MyLinkedList[cant_cubiculos];
    		String recibir[] = scan.nextLine().split(" ");
			MyLinkedList<Integer> casilleros = new MyLinkedList<>();

    		for(int a = 0; a < cant_cubiculos; a++){
    			cubiculos[a] =casilleros;
    			casilleros = new MyLinkedList<>();
			}
			int comandos = Integer.parseInt(scan.nextLine());
			for (int x = 0; x < comandos; x++) {
        		String recibe_comando[] = scan.nextLine().split(" ");
				switch(recibe_comando.length){
				case 4:
					int min=cubiculos[0].size()/Integer.parseInt(recibir[0]) ;
					int idx = 0;
					for(int r = 1; r < cubiculos.length ; r++){
						if(cubiculos[r].size()/Integer.parseInt(recibir[r]) < min ){
							idx = r;
							min = cubiculos[r].size()/Integer.parseInt(recibir[r]);
						}
					}
					if(min==1){
						System.out.println("limite alcanzado");
					}
					
					cubiculos[idx].add(Integer.parseInt(recibe_comando[3]), recibe_comando[1], recibe_comando[2]);
					System.out.println(idx + cubiculos[idx].size());
					break;
				case 2:
					for(int uu = 0; uu < cubiculos.length; uu++){
						for(int su = 0; su < cubiculos[uu].size(); su++){
							if(cubiculos[uu].get(su) == Integer.parseInt(recibe_comando[1])){
								System.out.println(cubiculos[uu].getNode(su).nombre);
								cubiculos[uu].remove(su);
							}
						}
					}
				}
				
			}
			
		}
		}
		}
	






<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Scanner;



public class problema_d {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null,null,null);
			endMarker = new Node<>(null, beginMarker, null,null,null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x,String name,String last_name) {

			add(size(), x,name,last_name);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x,String name, String last_name) {
			addBefore(getNode(idx, 0, size()), x,name,last_name);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x,String name, String last_name) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p,name,last_name);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx
						+ "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n,String name, String last_name) {
				data = d;
				prev = p;
				next = n;
				nombre=name;
				apellido=last_name;
			}

			public AnyType data;//ceula
			public Node<AnyType> prev;
			public Node<AnyType> next;
			public String nombre;
			public String apellido;
			public int cedula;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}
	
	
	
	
	
	

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		casos = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < casos; i++) {
        	System.out.println("Caso #" + (i+1) + ":");
			int cant_cubiculos = Integer.parseInt(scan.nextLine());
			MyLinkedList<Integer>[] cubiculos = new MyLinkedList[cant_cubiculos];
    		String recibir[] = scan.nextLine().split(" ");
			MyLinkedList<Integer> casilleros = new MyLinkedList<>();

    		for(int a = 0; a < cant_cubiculos; a++){
    			cubiculos[a] =casilleros;
    			casilleros = new MyLinkedList<>();
			}
			int comandos = Integer.parseInt(scan.nextLine());
			for (int x = 0; x < comandos; x++) {
        		String recibe_comando[] = scan.nextLine().split(" ");
				switch(recibe_comando.length){
				case 4:
					int min=cubiculos[0].size()/Integer.parseInt(recibir[0]) ;
					int idx = 0;
					for(int r = 1; r < cubiculos.length ; r++){
						if(cubiculos[r].size()/Integer.parseInt(recibir[r]) < min ){
							idx = r;
							min = cubiculos[r].size()/Integer.parseInt(recibir[r]);
						}
					}
					if(min==1){
						System.out.println("limite alcanzado");
					}
					
					cubiculos[idx].add(Integer.parseInt(recibe_comando[3]), recibe_comando[1], recibe_comando[2]);
					System.out.println(idx +" " + cubiculos[idx].size());
					break;
				case 2:
					for(int uu = 0; uu < cubiculos.length; uu++){
						for(int su = 0; su < cubiculos[uu].size(); su++){
							if(cubiculos[uu].get(su) == Integer.parseInt(recibe_comando[1])){
								System.out.println(cubiculos[uu].getNode(su).nombre);
								cubiculos[uu].remove(su);
							}
						}
					}
				}
				
			}
			
		}
		}
		}
	






<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Scanner;



public class problema_d {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null,null,null);
			endMarker = new Node<>(null, beginMarker, null,null,null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x,String name,String last_name) {

			add(size(), x,name,last_name);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x,String name, String last_name) {
			addBefore(getNode(idx, 0, size()), x,name,last_name);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x,String name, String last_name) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p,name,last_name);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx
						+ "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n,String name, String last_name) {
				data = d;
				prev = p;
				next = n;
				nombre=name;
				apellido=last_name;
			}

			public AnyType data;//ceula
			public Node<AnyType> prev;
			public Node<AnyType> next;
			public String nombre;
			public String apellido;
			public int cedula;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}
	
	
	
	
	
	

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		casos = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < casos; i++) {
        	System.out.println("Caso #" + (i+1) + ":");
			int cant_cubiculos = Integer.parseInt(scan.nextLine());
			MyLinkedList<Integer>[] cubiculos = new MyLinkedList[cant_cubiculos];
    		String recibir[] = scan.nextLine().split(" ");
			MyLinkedList<Integer> casilleros = new MyLinkedList<>();

    		for(int a = 0; a < cant_cubiculos; a++){
    			cubiculos[a] =casilleros;
    			casilleros = new MyLinkedList<>();
			}
			int comandos = Integer.parseInt(scan.nextLine());
			for (int x = 0; x < comandos; x++) {
        		String recibe_comando[] = scan.nextLine().split(" ");
				switch(recibe_comando.length){
				case 4:
					int min=cubiculos[0].size()/Integer.parseInt(recibir[0]) ;
					int idx = 0;
					for(int r = 1; r < cubiculos.length ; r++){
						if(cubiculos[r].size()/Integer.parseInt(recibir[r]) < min ){
							idx = r;
							min = cubiculos[r].size()/Integer.parseInt(recibir[r]);
						}
					}
					if(min==1){
						System.out.println("limite alcanzado");
					}
					
					cubiculos[idx].add(Integer.parseInt(recibe_comando[3]), recibe_comando[1], recibe_comando[2]);
					System.out.println((idx+1) +" " + cubiculos[idx].size());
					break;
				case 2:
					for(int uu = 0; uu < cubiculos.length; uu++){
						for(int su = 0; su < cubiculos[uu].size(); su++){
							if(cubiculos[uu].get(su) == Integer.parseInt(recibe_comando[1])){
								System.out.println(cubiculos[uu].getNode(su).nombre);
								cubiculos[uu].remove(su);
							}
						}
					}
				}
				
			}
			
		}
		}
		}
	






<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package Proyecto_listas;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Scanner;



public class problema_d {
	/**
	 * LinkedList class implements a doubly-linked list.
	 */
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null,null,null);
			endMarker = new Node<>(null, beginMarker, null,null,null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x,String name,String last_name) {

			add(size(), x,name,last_name);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x,String name, String last_name) {
			addBefore(getNode(idx, 0, size()), x,name,last_name);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x,String name, String last_name) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p,name,last_name);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx
						+ "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n,String name, String last_name) {
				data = d;
				prev = p;
				next = n;
				nombre=name;
				apellido=last_name;
			}

			public AnyType data;//ceula
			public Node<AnyType> prev;
			public Node<AnyType> next;
			public String nombre;
			public String apellido;
			public int cedula;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}
	
	
	
	
	
	

	public static void main(String[] args) throws FileNotFoundException {

		File f = new File("B.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}
		int casos;
		casos = Integer.parseInt(scan.nextLine());
		for (int i = 0; i < casos; i++) {
        	System.out.println("Caso #" + (i+1) + ":");
			int cant_cubiculos = Integer.parseInt(scan.nextLine());
			MyLinkedList<Integer>[] cubiculos = new MyLinkedList[cant_cubiculos];
    		String recibir[] = scan.nextLine().split(" ");
			MyLinkedList<Integer> casilleros = new MyLinkedList<>();

    		for(int a = 0; a < cant_cubiculos; a++){
    			cubiculos[a] =casilleros;
    			casilleros = new MyLinkedList<>();
			}
			int comandos = Integer.parseInt(scan.nextLine());
			for (int x = 0; x < comandos; x++) {
        		String recibe_comando[] = scan.nextLine().split(" ");
				switch(recibe_comando.length){
				case 4:
					double min=cubiculos[0].size()/Integer.parseInt(recibir[0]) ;
					int idx = 0;
					for(int r = 1; r < cubiculos.length ; r++){
						if(cubiculos[r].size()/Integer.parseInt(recibir[r]) < min ){
							idx = r;
							min = cubiculos[r].size()/Integer.parseInt(recibir[r]);
						}
					}
					if(min==1){
						System.out.println("limite alcanzado");
					}
					
					cubiculos[idx].add(Integer.parseInt(recibe_comando[3]), recibe_comando[1], recibe_comando[2]);
					System.out.println((idx+1) +" " + cubiculos[idx].size());
					break;
				case 2:
					for(int uu = 0; uu < cubiculos.length; uu++){
						for(int su = 0; su < cubiculos[uu].size(); su++){
							if(cubiculos[uu].get(su) == Integer.parseInt(recibe_comando[1])){
								System.out.println(cubiculos[uu].getNode(su).nombre);
								cubiculos[uu].remove(su);
							}
						}
					}
				}
				
			}
			
		}
		}
		}
	






<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_arboles;

import java.io.File;
import java.util.Scanner;

public class problema_a {

	/**
	 * Implements an unbalanced binary search tree. Note that all "matching" is
	 * based on the compareTo method.
	 * 
	 */
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the tree.
		 */
		public BinarySearchTree() {
			root = null;
		}

		/**
		 * Insert into the tree; duplicates are ignored.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			root = insert(x, root);
		}

		/**
		 * Remove from the tree. Nothing is done if x is not found.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			root = remove(x, root);
		}

		/**
		 * Find the smallest item in the tree.
		 * 
		 * @return smallest item or null if empty.
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMin(root).element;
		}

		/**
		 * Find the largest item in the tree.
		 * 
		 * @return the largest item of null if empty.
		 */
		public AnyType findMax() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMax(root).element;
		}

		/**
		 * Find an item in the tree.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if not found.
		 */
		public boolean contains(AnyType x) {
			return contains(x, root);
		}

		/**
		 * Make the tree logically empty.
		 */
		public void makeEmpty() {
			root = null;
		}

		/**
		 * Test if the tree is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return root == null;
		}

		/**
		 * Print the tree contents in sorted order.
		 */
		public void printTree() {
			if (isEmpty())
				System.out.println("Empty tree");
			else
				printTree(root);
		}

		/**
		 * Internal method to insert into a subtree.
		 * 
		 * @param x
		 *            the item to insert.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> insert(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return new BinaryNode<>(x, null, null);

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = insert(x, t.left);
			else if (compareResult > 0)
				t.right = insert(x, t.right);
			else
				; // Duplicate; do nothing
			return t;
		}

		/**
		 * Internal method to remove from a subtree.
		 * 
		 * @param x
		 *            the item to remove.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> remove(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return t; // Item not found; do nothing

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = remove(x, t.left);
			else if (compareResult > 0)
				t.right = remove(x, t.right);
			else if (t.left != null && t.right != null) // Two children
			{
				t.element = findMin(t.right).element;
				t.right = remove(t.element, t.right);
			} else
				t = (t.left != null) ? t.left : t.right;
			return t;
		}

		/**
		 * Internal method to find the smallest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the smallest item.
		 */
		private BinaryNode<AnyType> findMin(BinaryNode<AnyType> t) {
			if (t == null)
				return null;
			else if (t.left == null)
				return t;
			return findMin(t.left);
		}

		/**
		 * Internal method to find the largest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the largest item.
		 */
		private BinaryNode<AnyType> findMax(BinaryNode<AnyType> t) {
			if (t != null)
				while (t.right != null)
					t = t.right;

			return t;
		}

		/**
		 * Internal method to find an item in a subtree.
		 * 
		 * @param x
		 *            is item to search for.
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the matched item.
		 */
		private boolean contains(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return false;

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				return contains(x, t.left);
			else if (compareResult > 0)
				return contains(x, t.right);
			else
				return true; // Match
		}

		/**
		 * Internal method to print a subtree in sorted order.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private void printTree(BinaryNode<AnyType> t) {
			if (t != null) {
				printTree(t.left);
				System.out.println(t.element);
				printTree(t.right);
			}
		}

		/**
		 * Internal method to compute height of a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private int height(BinaryNode<AnyType> t) {
			if (t == null)
				return -1;
			else
				return 1 + Math.max(height(t.left), height(t.right));
		}

		public synchronized void recorridoInorden() {
			ayudanteInorden(root);
		}

		// metodo recursivo para recorrido inorden
		private void ayudanteInorden(BinaryNode nodo) {
			if (nodo == null)
				return;

			ayudanteInorden(nodo.left);
			System.out.print(nodo.element + " ");
			ayudanteInorden(nodo.right);
		}

		public static int way(BinaryNode nodo1, int k) {
			if (nodo1 != null) {
				int u = 0;
				if ((Integer) nodo1.element == k) {
					return u + 1;
				} else if ((u = way(nodo1.left, k)) > 0) {
					return u + 1;
				} else if ((u = way(nodo1.right, k)) > 0) {
					return u + 1;
				}
				return 0;
			}
			return 0;
		}

		public static BinaryNode ancestro(BinaryNode nodo1, int n1, int n2) {
			int contador = 0;
			if (nodo1 != null) {
				if ((Integer) nodo1.element == n1) {
					return nodo1;
				} else if ((Integer) nodo1.element == n2) {
					return nodo1;
				}
				BinaryNode izq = ancestro(nodo1.left, n1, n2);
				contador = (Integer) nodo1.element;
				BinaryNode der = ancestro(nodo1.right, n1, n2);
				if (izq != null) {
					if (der != null) {
						contador--;
						return nodo1;
					}
				}
				if (izq != null) {
					contador += (Integer) nodo1.element;
					return izq;
				}
				if (der != null) {
					contador += (Integer) der.element;
					return der;
				}
				contador++;
			}
			contador = 0;
			return null;
		}

		// Basic node stored in unbalanced binary search trees
		public static class BinaryNode<AnyType> {
			// Constructors
			BinaryNode(AnyType theElement) {
				this(theElement, null, null);
			}

			BinaryNode(AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt) {
				element = theElement;
				left = lt;
				right = rt;
			}

			AnyType element; // The data in the node
			BinaryNode<AnyType> left; // Left child
			BinaryNode<AnyType> right; // Right child
		}

		/** The tree root. */
		private BinaryNode<AnyType> root;

		// Test program
		public static void main(String[] args) throws Exception {

			File f = new File("A1.txt");
			Scanner scan;
			if (f.exists()) {
				scan = new Scanner(f);
			} else {
				scan = new Scanner(System.in);
			}

			BinarySearchTree<Integer> tree = new BinarySearchTree<>();
			BinaryNode nodo = null;

			int casos = 0;
			casos = scan.nextInt();
			for (int y = 0; y < casos; y++) {
				int tamao = 0;
				tamao = scan.nextInt();
				for (int j = 0; j < tamao; j++) {
					String lines[] = scan.nextLine().split(" ");					
					if (lines[0].equals("agregar")) {
						tree.insert(Integer.parseInt(lines[1]));
					} else if (lines[0].equals("distancia")) {
						int p = 0, n = 0;
						int padre, perro;
						p = way(tree.root, Integer.parseInt(lines[1]));
						p--;
						n = way(tree.root, Integer.parseInt(lines[2]));
						n--;
						nodo = ancestro(tree.root, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
						if (nodo == null) {
							System.out.println("distancia: " + "-1");
						} else {
							padre = (Integer) nodo.element;
							perro = way(tree.root, padre);
							perro--;
							if (perro != -1 && p != -1 && n != -1) {
								System.out.println("distancia: " + ((p + n) - (2 * (perro))));
							} else {
								System.out.println("distancia: " + "-1");
							}
						}

					} else if (lines[0].equals("ancestro")) {

						if (Integer.parseInt(lines[1]) == Integer.parseInt(lines[2])) {
							System.out.println("ancestro: " + lines[2]);
						} else {
							nodo = ancestro(tree.root, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
							if (nodo == null) {
								System.out.println("ancestro: -1");
							} else {
								System.out.println("ancestro: " + nodo.element);
							}
						}

					}
				}

			}
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_hash_union;

import java.math.BigInteger;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.HashMap;

public class problema_a {

	public static class B<AnyType> {
		/**
		 * Construct the hash table.
		 */
		public B() {
			this(DEFAULT_TABLE_SIZE);
		}

		/**
		 * Construct the hash table.
		 * 
		 * @param size
		 *            approximate table size.
		 */
		public B(int size) {
			theLists = new LinkedList[nextPrime(size)];
			for (int i = 0; i < theLists.length; i++)
				theLists[i] = new LinkedList<>();
		}

		/**
		 * Insert into the hash table. If the item is already present, then do
		 * nothing.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x, Node_hash<Integer> o) {
			List<Node_hash> whichList = theLists[myhash(x)];
			if (!esta(x, o)) {
				whichList.add(o);

				// Rehash; see Section 5.5
				if (++currentSize > theLists.length)
					rehash();
			} else {
				whichList.add(o);
			}
		}

		/**
		 * Remove from the hash table.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			List<Node_hash> whichList = theLists[myhash(x)];
			if (whichList.contains(x)) {
				whichList.remove(x);
				currentSize--;
			}
		}

		/**
		 * Find an item in the hash table.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if x is found.
		 */
		public boolean contains(AnyType x) {
			List<Node_hash> whichList = theLists[myhash(x)];
			return whichList.contains(x);
		}

		public boolean esta(AnyType x, Node_hash<Integer> o) {
			List<Node_hash> whichList = theLists[myhash(x)];
			for (int u = 0; u < whichList.size(); u++) {
				if (whichList.get(u).data == o.data)
					return true;
			}
			return false;
		}

		public Node_hash get(AnyType x) {

			List<Node_hash> whichList = theLists[myhash(x)];
			// int in = whichList.indexOf(x);
			return whichList.get(0);
		}

		/**
		 * Make the hash table logically empty.
		 */
		public void makeEmpty() {
			for (int i = 0; i < theLists.length; i++)
				theLists[i].clear();
			currentSize = 0;
		}

		/**
		 * A hash routine for String objects.
		 * 
		 * @param key
		 *            the String to hash.
		 * @param tableSize
		 *            the size of the hash table.
		 * @return the hash value.
		 */
		public int hash(String key, int tableSize) {
			int hashVal = 0;

			for (int i = 0; i < key.length(); i++)
				hashVal = 37 * hashVal + key.charAt(i);

			hashVal %= tableSize;
			if (hashVal < 0)
				hashVal += tableSize;

			return hashVal;
		}

		private void rehash() {
			List<Node_hash>[] oldLists = theLists;

			// Create new double-sized, empty table
			theLists = new List[nextPrime(2 * theLists.length)];
			for (int j = 0; j < theLists.length; j++)
				theLists[j] = new LinkedList<>();

			// Copy table over
			currentSize = 0;
			for (List<Node_hash> list : oldLists)
				for (Node_hash item : list)
					insert((AnyType) item.data, item);
		}

		private int myhash(AnyType x) {
			int hashVal = x.hashCode();

			hashVal %= theLists.length;
			if (hashVal < 0)
				hashVal += theLists.length;

			return hashVal;
		}

		private static final int DEFAULT_TABLE_SIZE = 101;

		/** The array of Lists. */
		private List<Node_hash>[] theLists;
		private int currentSize;

		/**
		 * Internal method to find a prime number at least as large as n.
		 * 
		 * @param n
		 *            the starting number (must be positive).
		 * @return a prime number larger than or equal to n.
		 */
		@SuppressWarnings("empty-statement")
		private int nextPrime(int n) {
			if (n % 2 == 0)
				n++;

			for (; !isPrime(n); n += 2)
				;

			return n;
		}

		/**
		 * Internal method to test if a number is prime. Not an efficient
		 * algorithm.
		 * 
		 * @param n
		 *            the number to test.
		 * @return the result of the test.
		 */
		private boolean isPrime(int n) {
			if (n == 2 || n == 3)
				return true;

			if (n == 1 || n % 2 == 0)
				return false;

			for (int i = 3; i * i <= n; i += 2)
				if (n % i == 0)
					return false;

			return true;
		}

		/**
		 * This is the doubly-linked list node.
		 */
	}

	public static class Node_hash<AnyType> {
		public Node_hash(AnyType d) {
			data = d;
			lista = new MyLinkedList<>();
		}

		public AnyType data;
		public MyLinkedList<Node_l> lista;
	}

	/////////////////////////////////////
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;

			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static class Node_l {
		public Node_l(int c, int pr, int pu) {
			confirm = c;
			problem = pr;
			puntuation = pu;
		}

		public int confirm;
		public int problem;
		public int puntuation;
	}
	////////////////////////////////////////////////////////////////////

	public static class BynaryHeap<AnyType extends Comparable<? super AnyType>>

	{

		/**
		 * Construct the binary heap.
		 */
		public BynaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BynaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BynaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}
	}

	public static class Node_b implements Comparable<Node_b> {
		public Node_b(int d, int p, int q) {
			id = d;
			tiempo = q;
			puntuacion = p;
		}

		public int id;
		public int tiempo;
		public int puntuacion;

		public int compareTo(Node_b o) {
			if (puntuacion > o.puntuacion)
				return -1;
			if (puntuacion < o.puntuacion)
				return 1;
			else {
				if (tiempo < o.tiempo)
					return -1;
				if (tiempo > o.tiempo)
					return 1;
				else {
					if (id < o.id)
						return -1;
					if (id > o.id)
						return 1;
				}
			}

			return 0;
		}
	}

	////////////////////////////////////////////////////////////////////////////////

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub
		File f = new File("A_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		String lines[] = scan.nextLine().split(" ");
		int casos = Integer.parseInt(lines[0]);
		for (int y = 0; y < casos; y++) {

			HashMap<Integer, Node_hash> tabla = new HashMap<Integer, Node_hash>();
			lines = scan.nextLine().split(" ");
			int equipos, envios;
			equipos = Integer.parseInt(lines[0]);
			envios = Integer.parseInt(lines[1]);
			for (int ii = 0; ii < envios; ii++) {
				lines = scan.nextLine().split(" ");

				if (tabla.containsKey(Integer.parseInt(lines[0]))) {

					Node_hash<Integer> tmp = tabla.get(Integer.parseInt(lines[0]));

					if (!tmp.lista.isEmpty()) {
						int kk = 99;
						MyLinkedList<Node_l> b = tmp.lista;
						for (int g = 0; g < tmp.lista.size(); g++) {
							Node_l alex = b.get(g);
							if (alex.problem == Integer.parseInt(lines[1])) {
								if (lines[3].equals("C")) {
									alex.confirm = 1;
									alex.puntuation = alex.puntuation + Integer.parseInt(lines[2]);
								} else if (lines[3].equals("T") || lines[3].equals("R") || lines[3].equals("I")) {
									if (alex.confirm == 0) {
										alex.confirm = 0;
										alex.puntuation = alex.puntuation + 20;
									}
								}
								kk = 100;
								break;
							}
						}
						if (kk == 99) {
							Node_l nod;
							if (lines[3].equals("C")) {
								nod = new Node_l(1, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
								b.add(nod);
							} else {
								nod = new Node_l(0, Integer.parseInt(lines[1]), 20);
								b.add(nod);
							}
						}

					}
				} else {

					Node_hash<Integer> tmp = new Node_hash(Integer.parseInt(lines[0]));
					Node_l nod;
					if (lines[3].equals("C")) {
						nod = new Node_l(1, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
						tmp.lista.add(nod);
					} else {
						nod = new Node_l(0, Integer.parseInt(lines[1]), 20);
						tmp.lista.add(nod);
					}
					tabla.put(Integer.parseInt(lines[0]), tmp);
				}
			}

			//

			BynaryHeap<Node_b> monticulo = new BynaryHeap<>();
			int t;
			for (int w = 1; w <= equipos; w++) {
				Node_b diego;
				int k = 0, d = 0;
				if (tabla.containsKey(w)) {

					Node_hash<Integer> tmp = tabla.get(w);
					MyLinkedList<Node_l> b = tmp.lista;
					if (b.isEmpty()) {
						diego = new Node_b(w, 0, 0);
					} else {
						for (int m = 0; m < b.size(); m++) {
							Node_l alex = b.get(m);
							if (alex.confirm == 1) {
								k++;
								d += alex.puntuation;
							}
						}
						diego = new Node_b(w, k, d);
					}
					monticulo.insert(diego);
				} else {

				}
			}
			System.out.println("Caso #" + (y + 1) + ":");

			for (int v = 0; v < equipos; v++) {
				if (!monticulo.isEmpty()) {
					Node_b pame = monticulo.deleteMin();
					System.out.println(pame.id + " " + pame.puntuacion + " " + pame.tiempo);
				}
			}

		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_hash_union;

import java.math.BigInteger;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.HashMap;

public class problema_e {

	public static class B<AnyType> {
		/**
		 * Construct the hash table.
		 */
		public B() {
			this(DEFAULT_TABLE_SIZE);
		}

		/**
		 * Construct the hash table.
		 * 
		 * @param size
		 *            approximate table size.
		 */
		public B(int size) {
			theLists = new LinkedList[nextPrime(size)];
			for (int i = 0; i < theLists.length; i++)
				theLists[i] = new LinkedList<>();
		}

		/**
		 * Insert into the hash table. If the item is already present, then do
		 * nothing.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x, Node_hash<Integer> o) {
			List<Node_hash> whichList = theLists[myhash(x)];
			if (!esta(x, o)) {
				whichList.add(o);

				// Rehash; see Section 5.5
				if (++currentSize > theLists.length)
					rehash();
			} else {
				whichList.add(o);
			}
		}

		/**
		 * Remove from the hash table.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			List<Node_hash> whichList = theLists[myhash(x)];
			if (whichList.contains(x)) {
				whichList.remove(x);
				currentSize--;
			}
		}

		/**
		 * Find an item in the hash table.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if x is found.
		 */
		public boolean contains(AnyType x) {
			List<Node_hash> whichList = theLists[myhash(x)];
			return whichList.contains(x);
		}

		public boolean esta(AnyType x, Node_hash<Integer> o) {
			List<Node_hash> whichList = theLists[myhash(x)];
			for (int u = 0; u < whichList.size(); u++) {
				if (whichList.get(u).data == o.data)
					return true;
			}
			return false;
		}

		public Node_hash get(AnyType x) {

			List<Node_hash> whichList = theLists[myhash(x)];
			// int in = whichList.indexOf(x);
			return whichList.get(0);
		}

		/**
		 * Make the hash table logically empty.
		 */
		public void makeEmpty() {
			for (int i = 0; i < theLists.length; i++)
				theLists[i].clear();
			currentSize = 0;
		}

		/**
		 * A hash routine for String objects.
		 * 
		 * @param key
		 *            the String to hash.
		 * @param tableSize
		 *            the size of the hash table.
		 * @return the hash value.
		 */
		public int hash(String key, int tableSize) {
			int hashVal = 0;

			for (int i = 0; i < key.length(); i++)
				hashVal = 37 * hashVal + key.charAt(i);

			hashVal %= tableSize;
			if (hashVal < 0)
				hashVal += tableSize;

			return hashVal;
		}

		private void rehash() {
			List<Node_hash>[] oldLists = theLists;

			// Create new double-sized, empty table
			theLists = new List[nextPrime(2 * theLists.length)];
			for (int j = 0; j < theLists.length; j++)
				theLists[j] = new LinkedList<>();

			// Copy table over
			currentSize = 0;
			for (List<Node_hash> list : oldLists)
				for (Node_hash item : list)
					insert((AnyType) item.data, item);
		}

		private int myhash(AnyType x) {
			int hashVal = x.hashCode();

			hashVal %= theLists.length;
			if (hashVal < 0)
				hashVal += theLists.length;

			return hashVal;
		}

		private static final int DEFAULT_TABLE_SIZE = 101;

		/** The array of Lists. */
		private List<Node_hash>[] theLists;
		private int currentSize;

		/**
		 * Internal method to find a prime number at least as large as n.
		 * 
		 * @param n
		 *            the starting number (must be positive).
		 * @return a prime number larger than or equal to n.
		 */
		@SuppressWarnings("empty-statement")
		private int nextPrime(int n) {
			if (n % 2 == 0)
				n++;

			for (; !isPrime(n); n += 2)
				;

			return n;
		}

		/**
		 * Internal method to test if a number is prime. Not an efficient
		 * algorithm.
		 * 
		 * @param n
		 *            the number to test.
		 * @return the result of the test.
		 */
		private boolean isPrime(int n) {
			if (n == 2 || n == 3)
				return true;

			if (n == 1 || n % 2 == 0)
				return false;

			for (int i = 3; i * i <= n; i += 2)
				if (n % i == 0)
					return false;

			return true;
		}

		/**
		 * This is the doubly-linked list node.
		 */
	}

	public static class Node_hash<AnyType> {
		public Node_hash(AnyType d) {
			data = d;
			lista = new MyLinkedList<>();
		}

		public AnyType data;
		public MyLinkedList<Node_l> lista;
	}

	/////////////////////////////////////
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;

			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static class Node_l {
		public Node_l(int c, int pr, int pu) {
			confirm = c;
			problem = pr;
			puntuation = pu;
		}

		public int confirm;
		public int problem;
		public int puntuation;
	}
	////////////////////////////////////////////////////////////////////

	public static class BynaryHeap<AnyType extends Comparable<? super AnyType>>

	{

		/**
		 * Construct the binary heap.
		 */
		public BynaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BynaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BynaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}
	}

	public static class Node_b implements Comparable<Node_b> {
		public Node_b(int d, int p, int q) {
			id = d;
			tiempo = q;
			puntuacion = p;
		}

		public int id;
		public int tiempo;
		public int puntuacion;

		public int compareTo(Node_b o) {
			if (puntuacion > o.puntuacion)
				return -1;
			if (puntuacion < o.puntuacion)
				return 1;
			else {
				if (tiempo < o.tiempo)
					return -1;
				if (tiempo > o.tiempo)
					return 1;
				else {
					if (id < o.id)
						return -1;
					if (id > o.id)
						return 1;
				}
			}

			return 0;
		}
	}

	////////////////////////////////////////////////////////////////////////////////

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub
		File f = new File("A_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		String lines[] = scan.nextLine().split(" ");
		int casos = Integer.parseInt(lines[0]);
		for (int y = 0; y < casos; y++) {

			HashMap<Integer, Node_hash> tabla = new HashMap<Integer, Node_hash>();
			lines = scan.nextLine().split(" ");
			int equipos, envios;
			int correctos = 0, incorrectos = 0, runerror = 0, timelimit = 0;
			equipos = Integer.parseInt(lines[0]);
			envios = Integer.parseInt(lines[1]);
			for (int ii = 0; ii < envios; ii++) {
				
				lines = scan.nextLine().split(" ");
				
				if(lines[3].equals("I")){
					incorrectos++;
				}else if(lines[3].equals("C")){
					correctos++;
				}else if(lines[3].equals("T")){
					timelimit++;
				}else if(lines[3].equals("R")){
					runerror++;
				}
				
				if (tabla.containsKey(Integer.parseInt(lines[0]))) {

					Node_hash<Integer> tmp = tabla.get(Integer.parseInt(lines[0]));
					if (!tmp.lista.isEmpty()) {
						int kk = 99;
						MyLinkedList<Node_l> b = tmp.lista;
						for (int g = 0; g < tmp.lista.size(); g++) {
							Node_l alex = b.get(g);
							if (alex.problem == Integer.parseInt(lines[1])) {
								if (lines[3].equals("C")) {
									alex.confirm = 1;
									alex.puntuation = alex.puntuation + Integer.parseInt(lines[2]);
								} else if (lines[3].equals("T") || lines[3].equals("R") || lines[3].equals("I")) {
									if (alex.confirm == 0) {
										alex.confirm = 0;
										alex.puntuation = alex.puntuation + 20;
									}
								}
								kk = 100;
								break;
							}
						}
						if (kk == 99) {
							Node_l nod;
							if (lines[3].equals("C")) {
								nod = new Node_l(1, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
								b.add(nod);
							} else {
								nod = new Node_l(0, Integer.parseInt(lines[1]), 20);
								b.add(nod);
							}
						}

					}
				} else {

					Node_hash<Integer> tmp = new Node_hash(Integer.parseInt(lines[0]));
					Node_l nod;
					if (lines[3].equals("C")) {
						nod = new Node_l(1, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
						tmp.lista.add(nod);
					} else {
						nod = new Node_l(0, Integer.parseInt(lines[1]), 20);
						tmp.lista.add(nod);
					}
					tabla.put(Integer.parseInt(lines[0]), tmp);
				}
			}

			//

			BynaryHeap<Node_b> monticulo = new BynaryHeap<>();
			int t;
			for (int w = 1; w <= equipos; w++) {
				Node_b diego;
				int k = 0, d = 0;
				if (tabla.containsKey(w)) {

					Node_hash<Integer> tmp = tabla.get(w);
					MyLinkedList<Node_l> b = tmp.lista;
					if (b.isEmpty()) {
						diego = new Node_b(w, 0, 0);
					} else {
						for (int m = 0; m < b.size(); m++) {
							Node_l alex = b.get(m);
							if (alex.confirm == 1) {
								k++;
								d += alex.puntuation;
							}
						}
						diego = new Node_b(w, k, d);
					}
					monticulo.insert(diego);
				} else {

				}
			}
			System.out.println("Caso #" + (y + 1) + ":");

			for (int v = 0; v < equipos; v++) {
				if (!monticulo.isEmpty()) {
					Node_b pame = monticulo.deleteMin();
					System.out.println(pame.id + " " + pame.puntuacion + " " + pame.tiempo);
				}
			}
			System.out.println(correctos + " " + incorrectos + " " + runerror + " " + timelimit);

		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_hash_union;

import java.math.BigInteger;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

public class problema_b {

	public static interface MyMap {
		public void put(Object key, Object value);

		public Object get(Object key);

		public int size();

		public Set keySet();

		public Set entrySet();

		public interface MyEntry {
			public Object getKey();

			public Object getValue();
		}
	}

	public static class MySimpleMap implements MyMap {
		private ArrayList keys;
		private ArrayList values;
		private int index;

		public MySimpleMap() {
			keys = new ArrayList();
			values = new ArrayList();
			index = 0;
		}

		public void put(Object key, Object value) {
			keys.add(key);
			values.add(value);
			index++;
		}

		public void replace(int key,Object val) {
			int i = keys.indexOf(key);
				 values.set(i, val);
		}
		
		public Object get(int key) {
			int i = keys.indexOf(key);
			if (i >= 0)
				return values.get(i);
			else
				return null;
		}

		public int size() {
			return index;
		}

		public Set keySet() {
			HashSet set = new HashSet();
			set.addAll(keys);
			return set;
		}

		// Nested class starts...
		class MySimpleEntry implements MyMap.MyEntry {
			Object key;
			Object value;

			public MySimpleEntry(Object k, Object v) {
				key = k;
				value = v;
			}

			public Object getKey() {
				return key;
			}

			public Object getValue() {
				return value;
			}
		}// Nested class ends.

		public Set entrySet() {
			HashSet set = new HashSet();
			for (int i = 0; i < index; i++) {
				Object k = keys.get(i);
				Object v = values.get(i);
				MySimpleEntry temp = new MySimpleEntry(k, v);
				set.add(temp);
			}
			return set;
		}

		@Override
		public Object get(Object key) {
			// TODO Auto-generated method stub
			return null;
		}
	}

	public static void main(String[] args) throws FileNotFoundException {
		// TODO Auto-generated method stub
		File f = new File("A1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		
		int casos = 0;
		String lines[] = scan.nextLine().split(" ");
		casos = Integer.parseInt(lines[0]);
		for (int y = 0; y < casos; y++) {
			MySimpleMap mapa = new MySimpleMap();
			int cantidad = 0;
			int contador = 0;
			lines = scan.nextLine().split(" ");
			cantidad = Integer.parseInt(lines[0]);
			int arreglo[] = new int[cantidad];
			lines = scan.nextLine().split(" ");
			Object t = null;
			int n = 0;
			for (int k = 0; k < lines.length; k++) {
				t = mapa.get(Integer.parseInt(lines[k]));

				if (t == null) {
					arreglo[contador] = Integer.parseInt(lines[k]);
					mapa.put(Integer.parseInt(lines[k]), 1);
					contador++;
				} else {
					n = (int) t;
					n++;
					mapa.replace(Integer.parseInt(lines[k]), n);
					
					
				}
				
			}
			System.out.println("Caso" + " #" + (y+1) + ":");
			for (int j = 0; j < contador; j++) {
				System.out.println(arreglo[j] + " " + mapa.get(arreglo[j]));
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_heap;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;



// BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

public class problema_a {
	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    public void insert2( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }
	    
	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }
	 

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }
	    public AnyType deleteMin2( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown2( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }
	    private void buildHeap2( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown2( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    } 
	    private void percolateDown2( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }

	}

	

	public static void main(String[] args) throws Exception {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		BinaryHeap<Integer> monticulo = new BinaryHeap<>();
		int iron_man, captain_america, ant_man, vision;
		String lines[] = scan.nextLine().split(" ");

		int cantidad = Integer.parseInt(lines[0]);
		lines = scan.nextLine().split(" ");
		for (int j = 0; j < cantidad; j++) {
			if (j < 2) {
				System.out.println("-1");
				monticulo.insert(Integer.parseInt(lines[j]));
			}
			if (j >= 2) {
				monticulo.insert(Integer.parseInt(lines[j]));
				iron_man = monticulo.deleteMin();
				captain_america = monticulo.deleteMin();
				ant_man = monticulo.deleteMin();
				vision = iron_man * captain_america * ant_man;
				System.out.println(vision);
				monticulo.insert(iron_man);
				monticulo.insert(ant_man);
				monticulo.insert(captain_america);

			}
		}
	}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_heap;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

// BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

public class problema_e{
	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    public void insert2( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }
	    
	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }
	 

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }
	    public AnyType deleteMin2( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown2( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }
	    private void buildHeap2( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown2( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    } 
	    private void percolateDown2( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }

	}

	public static void main(String[] args) throws Exception {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		BinaryHeap<Integer> monticulo = new BinaryHeap<>();
		int vision = 1;
		String lines[] = scan.nextLine().split(" ");

		int cantidad = Integer.parseInt(lines[0]);
		int limite = Integer.parseInt(lines[1]);
		int arreglo[] = new int[limite];

		lines = scan.nextLine().split(" ");
		
		for (int j = 0; j < lines.length; j++) {
			System.out.println("antes de crashear  "+lines[j]);
			monticulo.insert(Integer.parseInt(lines[j]));
			if (j < (limite-1)) {
				System.out.println("-1");
			}
			if (j >= (limite-1)) {
				for(int x = 0 ; x < limite; x++){
					arreglo[x] = monticulo.deleteMin();
				}
				for(int w = 0; w < limite; w++){
					vision = vision*arreglo[w];
					monticulo.insert(arreglo[w]);
					}
				System.out.println(vision);
				vision = 1;
				}
				}
			}
		}
	
	



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_heap;

public class problema_b {

	
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_hash_union;

import java.math.BigInteger;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

public class problema_b {

	public static interface MyMap {
		public void put(Object key, Object value);

		public Object get(Object key);

		public int size();

		public Set keySet();

		public Set entrySet();

		public interface MyEntry {
			public Object getKey();

			public Object getValue();
		}
	}

	public static class MySimpleMap implements MyMap {
		private ArrayList keys;
		private ArrayList values;
		private int index;

		public MySimpleMap() {
			keys = new ArrayList();
			values = new ArrayList();
			index = 0;
		}

		public void put(Object key, Object value) {
			keys.add(key);
			values.add(value);
			index++;
		}

		public void replace(int key,Object val) {
			int i = keys.indexOf(key);
				 values.set(i, val);
		}
		
		public Object get(int key) {
			int i = keys.indexOf(key);
			if (i >= 0)
				return values.get(i);
			else
				return null;
		}

		public int size() {
			return index;
		}

		public Set keySet() {
			HashSet set = new HashSet();
			set.addAll(keys);
			return set;
		}

		// Nested class starts...
		class MySimpleEntry implements MyMap.MyEntry {
			Object key;
			Object value;

			public MySimpleEntry(Object k, Object v) {
				key = k;
				value = v;
			}

			public Object getKey() {
				return key;
			}

			public Object getValue() {
				return value;
			}
		}// Nested class ends.

		public Set entrySet() {
			HashSet set = new HashSet();
			for (int i = 0; i < index; i++) {
				Object k = keys.get(i);
				Object v = values.get(i);
				MySimpleEntry temp = new MySimpleEntry(k, v);
				set.add(temp);
			}
			return set;
		}

		@Override
		public Object get(Object key) {
			// TODO Auto-generated method stub
			return null;
		}
	}

	public static void main(String[] args) throws FileNotFoundException {
		// TODO Auto-generated method stub
		File f = new File("A1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		
		int casos = 0;
		String lines[] = scan.nextLine().split(" ");
		casos = Integer.parseInt(lines[0]);
		for (int y = 0; y < casos; y++) {
			MySimpleMap mapa = new MySimpleMap();
			int cantidad = 0;
			int contador = 0;
			lines = scan.nextLine().split(" ");
			cantidad = Integer.parseInt(lines[0]);
			int arreglo[] = new int[cantidad];
			lines = scan.nextLine().split(" ");
			Object t = null;
			int n = 0;
			for (int k = 0; k < lines.length; k++) {
				t = mapa.get(Integer.parseInt(lines[k]));

				if (t == null) {
					arreglo[contador] = Integer.parseInt(lines[k]);
					mapa.put(Integer.parseInt(lines[k]), 1);
					contador++;
				} else {
					n = (int) t;
					n++;
					mapa.replace(Integer.parseInt(lines[k]), n);
					
					
				}
				
			}
			System.out.println("Caso" + " #" + (y+1) + ":");
			for (int j = 0; j < contador; j++) {
				System.out.println(arreglo[j] + " " + mapa.get(arreglo[j]));
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.Hashtable;

public class problema_c {

		public static class QuickUnionWC{
		private int[] id;
		private int count;
		private int[] sz;
		public QuickUnionWC(int N){
			count = N;
			id = new int[N];
			sz= new int[N];
			for (int i = 0;  i < N ; i++){
				id[i] = i; 
				sz[i]=1;

			}

		}
		private int  find (int i ){
			while (i != id[i]) {
				id[i] = id[id[i]];
				i = id[i];
			}
			return i;
		}
		public boolean find (int p, int q){
			return find(p) == find(q);
		}
		public void union (int p , int q){
			int i =  find(p) , j = find(q);
			if( i == j ) return;
			/*if(i > j){
				int b = i;
				i = j;
				j = b;
			}*/
			if (sz[i] < sz[j] ){
				id[i] = j;
				sz[j] += sz[i];
			}else{
				id[j] = i;
				sz[i] += sz[j];
			}
			count--;
		}
		public void  print(){
			System.out.println("size :");
			for(int i = 0; i < sz.length; i++){

				System.out.print(sz[i] +" ");
			}
			System.out.println();
			System.out.println("id :");
			for(int i = 0; i < sz.length; i++){
				System.out.print(id[i] +" ");
			}
			System.out.println();
			System.out.println("i :" );
			for(int i = 0; i < sz.length; i++){
				System.out.print (i +" ");
			}
		}
		public int  printMin(){
			int v = count+1;
			for(int i = 0; i < sz.length; i++){
				int p = find(i);
				if(sz[p] < v && sz[p] !=1) v = sz[p] ;	
			}
			return v;
		}
		public int  printMax(){
			int v = 0;
			for(int i = 0; i < sz.length; i++){
				if(sz[i] > v ) v = sz[i];	
			}
			return v;
		}
		public void print(int ind){
			int pos=find(ind);
			System.out.println(sz[pos]);
		}
	}

		
	
	public static void main(String[] args) throws FileNotFoundException {
		 Scanner sca;
	        File archivo = new File("C_2.txt");
	        if(archivo.exists()==true){
	            sca = new Scanner (archivo);
	        }
	        else{
	            sca = new Scanner (System.in);
	        }
	        String lines[]=sca.nextLine().split(" ");
	        int casos = Integer.parseInt(lines[0]);
	        for (int u = 0; u < casos; u++){
	        	lines =sca.nextLine().split(" ");
	        	int amistades =Integer.parseInt(lines[0]);
	        	Hashtable<String,Integer> tabla = new Hashtable<String,Integer>();
	        	String comandos [] = new String [amistades*2];
	        	int y=0;
	        	for(int h = 0; h<amistades;h++){
	        		lines =sca.nextLine().split(" ");
	        		if(!tabla.containsKey(lines[0])){
	        			tabla.put(lines[0], y);
	        			y++;
	        		}
	        		if(!tabla.containsKey(lines[1])){
	        			tabla.put(lines[1], y);
	        			y++;
	        		}
	        		int pos=h*2;
	        		comandos[pos]=lines[0];
	        		pos++;
	        		comandos[pos]=lines[1];
	        	}
	        	QuickUnionWC red = new  QuickUnionWC(y);
	        	System.out.println("Caso #"+(u+1)+":");
	        	for(int h = 0; h<amistades;h++){
	        		int a,b;
	        		a=tabla.get(comandos[2*h]);
	        		b=tabla.get(comandos[((2*h)+1)]);
	        		red.union(a,b);
	        		red.union(b, a);
	        		//System.out.println("union de amista  "+(h+1));
	        		//red.print();
	        		if(a<b){
	        			red.print(a);
	        		}else{
	        			red.print(b);
	        		}
	        		
	        	}
	        	
	        }
		
	}
	

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_heap;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;



// BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

public class problema_a {
	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    public void insert2( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }
	    
	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }
	 

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }
	    public AnyType deleteMin2( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown2( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }
	    private void buildHeap2( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown2( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    } 
	    private void percolateDown2( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }

	}

	

	public static void main(String[] args) throws Exception {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		BinaryHeap<Integer> monticulo = new BinaryHeap<>();
		int iron_man, captain_america, ant_man, vision;
		String lines[] = scan.nextLine().split(" ");

		int cantidad = Integer.parseInt(lines[0]);
		lines = scan.nextLine().split(" ");
		for (int j = 0; j < cantidad; j++) {
			if (j < 2) {
				System.out.println("-1");
				monticulo.insert(Integer.parseInt(lines[j]));
			}
			if (j >= 2) {
				monticulo.insert(Integer.parseInt(lines[j]));
				iron_man = monticulo.deleteMin();
				captain_america = monticulo.deleteMin();
				ant_man = monticulo.deleteMin();
				vision = iron_man * captain_america * ant_man;
				System.out.println(vision);
				monticulo.insert(iron_man);
				monticulo.insert(ant_man);
				monticulo.insert(captain_america);

			}
		}
	}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.File;
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;

public class problema_b {
	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	// or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x ) --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( ) --> Return smallest item
	// boolean isEmpty( ) --> Return true if empty; else false
	// void makeEmpty( ) --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) > 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		public void insert2(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		public AnyType deleteMin2() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown2(1);

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		private void buildHeap2() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown2(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) > 0)
					child++;
				if (array[child].compareTo(tmp) > 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

		private void percolateDown2(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

	}

	public static class Node_b implements Comparable<Node_b> {
		public Node_b(int mine, int priority, int init) {
			mio = mine;
			prioridad = priority;
			inicio = init;
		}

		public int mio;
		public int prioridad;
		public int inicio;

		public int compareTo(Node_b o) {
			if (prioridad < o.prioridad)
				return -1;
			if (prioridad > o.prioridad)
				return 1;
			else {
				if (inicio < o.inicio)
					return -1;
				if (inicio > o.inicio)
					return 1;

			}
			return 0;
		}
	}

	//////////////////////////
	/////////////////////

	public static void main(String[] args) throws Exception {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		String lines[] = scan.nextLine().split(" ");

		int casos = Integer.parseInt(lines[0]);

		for (int a = 0; a < casos; a++) {

			lines = scan.nextLine().split(" ");

			BinaryHeap<Node_b> monticulo = new BinaryHeap<>();

			Node_b arreglo[] = new Node_b[Integer.parseInt(lines[0])];
			String[] lines_dos = scan.nextLine().split(" ");
			Queue<Node_b> cola = new LinkedList<Node_b>();

			for (int b = 0; b < arreglo.length; b++) {
				arreglo[b] = new Node_b(0, Integer.parseInt(lines_dos[b]), b);
				cola.offer(arreglo[b]);
				monticulo.insert(arreglo[b]);
			}
			arreglo[Integer.parseInt(lines[1])].mio = 1;
			int con = 0;
			Node_b nod = cola.poll();
			Node_b mon = monticulo.deleteMin();
			for (int c = 0; c < arreglo.length-1; c++) {

					if (mon.prioridad == nod.prioridad) {
						con++;
						mon = monticulo.deleteMin();
						nod = cola.poll();
					} else {
						cola.offer(nod);
						nod = cola.poll();
					}
				

			}
			System.out.println(con);
			

		}
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_heap;


import java.io.File;
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;

public class problema_b {
	public static void main(String[] args) throws Exception {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		String lines[] = scan.nextLine().split(" ");

		int casos = Integer.parseInt(lines[0]);

		for (int a = 0; a < casos; a++) {

			lines = scan.nextLine().split(" ");

			BinaryHeap<Node_b> monticulo = new BinaryHeap<>();

			Node_b arreglo[] = new Node_b[Integer.parseInt(lines[0])];
			String[] lines_dos = scan.nextLine().split(" ");
			Queue<Node_b> cola = new LinkedList<Node_b>();

			for (int b = 0; b < arreglo.length; b++) {
				arreglo[b] = new Node_b(0, Integer.parseInt(lines_dos[b]), b);
				cola.offer(arreglo[b]);
				monticulo.insert(arreglo[b]);
			}
			arreglo[Integer.parseInt(lines[1])].mio = 1;
			int con = 0;
			Node_b nod = cola.poll();
			Node_b mon = monticulo.deleteMin();
			for (int c = 0; c < arreglo.length-1; c++) {

					if (mon.prioridad == nod.prioridad) {
						con++;
						mon = monticulo.deleteMin();
						nod = cola.poll();
					} else {
						cola.offer(nod);
						nod = cola.poll();
					}
				

			}
			System.out.println(con);
			

		}
	}

	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	// or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x ) --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( ) --> Return smallest item
	// boolean isEmpty( ) --> Return true if empty; else false
	// void makeEmpty( ) --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) > 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		public void insert2(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		public AnyType deleteMin2() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown2(1);

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		private void buildHeap2() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown2(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) > 0)
					child++;
				if (array[child].compareTo(tmp) > 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

		private void percolateDown2(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

	}

	public static class Node_b implements Comparable<Node_b> {
		public Node_b(int mine, int priority, int init) {
			mio = mine;
			prioridad = priority;
			inicio = init;
		}

		public int mio;
		public int prioridad;
		public int inicio;

		public int compareTo(Node_b o) {
			if (prioridad < o.prioridad)
				return -1;
			if (prioridad > o.prioridad)
				return 1;
			else {
				if (inicio < o.inicio)
					return -1;
				if (inicio > o.inicio)
					return 1;

			}
			return 0;
		}
	}

	//////////////////////////
	/////////////////////

	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_heap;


import java.io.File;
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;

public class problema_b {
	public static void main(String[] args) throws Exception {
		File f = new File("B_1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		String lines[] = scan.nextLine().split(" ");

		int casos = Integer.parseInt(lines[0]);

		for (int a = 0; a < casos; a++) {

			lines = scan.nextLine().split(" ");

			BinaryHeap<Node_b> monticulo = new BinaryHeap<>();

			Node_b arreglo[] = new Node_b[Integer.parseInt(lines[0])];
			String[] lines_dos = scan.nextLine().split(" ");
			Queue<Node_b> cola = new LinkedList<Node_b>();

			for (int b = 0; b < arreglo.length; b++) {
				arreglo[b] = new Node_b(0, Integer.parseInt(lines_dos[b]), b);
				cola.offer(arreglo[b]);
				monticulo.insert(arreglo[b]);
			}
			if(Integer.parseInt(lines[1])<Integer.parseInt(lines[0]))
			arreglo[Integer.parseInt(lines[1])].mio = 1;
			
			int con = 0;
			Node_b nod = cola.poll();
			Node_b mon = monticulo.deleteMin();
			for (int c = 0; c < arreglo.length-1; c++) {

					if (mon.prioridad == nod.prioridad) {
						con++;
						mon = monticulo.deleteMin();
						nod = cola.poll();
					} else {
						cola.offer(nod);
						nod = cola.poll();
					}
				

			}
			System.out.println(con);
			

		}
	}

	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
	// or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x ) --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( ) --> Return smallest item
	// boolean isEmpty( ) --> Return true if empty; else false
	// void makeEmpty( ) --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the binary heap.
		 */
		public BinaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BinaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BinaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) > 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		public void insert2(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		public AnyType deleteMin2() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown2(1);

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		private void buildHeap2() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown2(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) > 0)
					child++;
				if (array[child].compareTo(tmp) > 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

		private void percolateDown2(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}

	}

	public static class Node_b implements Comparable<Node_b> {
		public Node_b(int mine, int priority, int init) {
			mio = mine;
			prioridad = priority;
			inicio = init;
		}

		public int mio;
		public int prioridad;
		public int inicio;

		public int compareTo(Node_b o) {
			if (prioridad < o.prioridad)
				return -1;
			if (prioridad > o.prioridad)
				return 1;
			else {
				if (inicio < o.inicio)
					return -1;
				if (inicio > o.inicio)
					return 1;

			}
			return 0;
		}
	}

	//////////////////////////
	/////////////////////

	
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_heap;


import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;



// BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

public class problema_a {
	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */
	// BinaryHeap class
	//
	// CONSTRUCTION: with optional capacity (that defaults to 100)
//	               or an array containing initial items
	//
	// ******************PUBLIC OPERATIONS*********************
	// void insert( x )       --> Insert x
	// Comparable deleteMin( )--> Return and remove smallest item
	// Comparable findMin( )  --> Return smallest item
	// boolean isEmpty( )     --> Return true if empty; else false
	// void makeEmpty( )      --> Remove all items
	// ******************ERRORS********************************
	// Throws UnderflowException as appropriate

	/**
	 * Implements a binary heap.
	 * Note that all "matching" is based on the compareTo method.
	 * @param <AnyType>
	 */
	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    public void insert2( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }
	    
	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }
	 

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }
	    public AnyType deleteMin2( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown2( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }
	    private void buildHeap2( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown2( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    } 
	    private void percolateDown2( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }

	}

	

	public static void main(String[] args) throws Exception {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		BinaryHeap<Integer> monticulo = new BinaryHeap<>();
		int iron_man, captain_america, ant_man, vision;
		String lines[] = scan.nextLine().split(" ");

		int cantidad = Integer.parseInt(lines[0]);
		lines = scan.nextLine().split(" ");
		for (int j = 0; j < cantidad; j++) {
			if (j < 2) {
				System.out.println("-1");
				monticulo.insert(Integer.parseInt(lines[j]));
			}
			if (j >= 2) {
				monticulo.insert(Integer.parseInt(lines[j]));
				iron_man = monticulo.deleteMin();
				captain_america = monticulo.deleteMin();
				ant_man = monticulo.deleteMin();
				vision = iron_man * captain_america * ant_man;
				System.out.println(vision);
				monticulo.insert(iron_man);
				monticulo.insert(ant_man);
				monticulo.insert(captain_america);

			}
		}
	}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_heap;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

// BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

public class problema_e{
	/**
	 * Implements a binary heap. Note that all "matching" is based on the
	 * compareTo method.
	 * 
	 * @param <AnyType>
	 */	public static class BinaryHeap<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public BinaryHeap( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public BinaryHeap( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public BinaryHeap( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    public void insert2( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }
	    
	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }
	 

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMin( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }
	    public AnyType deleteMin2( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMin( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown2( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }
	    private void buildHeap2( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown2( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    } 
	    private void percolateDown2( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; hole * 2 <= currentSize; hole = child )
	        {
	            child = hole * 2;
	            if( child != currentSize &&
	                    array[ child + 1 ].compareTo( array[ child ] ) < 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) < 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;
	    }

	}

	public static void main(String[] args) throws Exception {
		File f = new File("B1.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		BinaryHeap<Integer> monticulo = new BinaryHeap<>();
		int vision = 1;
		String lines[] = scan.nextLine().split(" ");

		int cantidad = Integer.parseInt(lines[0]);
		int limite = Integer.parseInt(lines[1]);
		int arreglo[] = new int[limite];

		lines = scan.nextLine().split(" ");
		
		for (int j = 0; j < lines.length; j++) {
			System.out.println("antes de crashear  "+lines[j]);
			monticulo.insert(Integer.parseInt(lines[j]));
			if (j < (limite-1)) {
				System.out.println("-1");
			}
			if (j >= (limite-1)) {
				for(int x = 0 ; x < limite; x++){
					arreglo[x] = monticulo.deleteMin();
				}
				for(int w = 0; w < limite; w++){
					vision = vision*arreglo[w];
					monticulo.insert(arreglo[w]);
					}
				System.out.println(vision);
				vision = 1;
				}
				}
			}
		}
	
	



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_hash_union;

import java.math.BigInteger;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;


import java.util.HashMap;

public class problema_a {

	public static class B<AnyType> {
		/**
		 * Construct the hash table.
		 */
		public B() {
			this(DEFAULT_TABLE_SIZE);
		}

		/**
		 * Construct the hash table.
		 * 
		 * @param size
		 *            approximate table size.
		 */
		public B(int size) {
			theLists = new LinkedList[nextPrime(size)];
			for (int i = 0; i < theLists.length; i++)
				theLists[i] = new LinkedList<>();
		}

		/**
		 * Insert into the hash table. If the item is already present, then do
		 * nothing.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x, Node_hash<Integer> o) {
			List<Node_hash> whichList = theLists[myhash(x)];
			if (!esta(x, o)) {
				whichList.add(o);

				// Rehash; see Section 5.5
				if (++currentSize > theLists.length)
					rehash();
			} else {
				whichList.add(o);
			}
		}

		/**
		 * Remove from the hash table.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			List<Node_hash> whichList = theLists[myhash(x)];
			if (whichList.contains(x)) {
				whichList.remove(x);
				currentSize--;
			}
		}

		/**
		 * Find an item in the hash table.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if x is found.
		 */
		public boolean contains(AnyType x) {
			List<Node_hash> whichList = theLists[myhash(x)];
			return whichList.contains(x);
		}

		public boolean esta(AnyType x, Node_hash<Integer> o) {
			List<Node_hash> whichList = theLists[myhash(x)];
			for (int u = 0; u < whichList.size(); u++) {
				if (whichList.get(u).data == o.data)
					return true;
			}
			return false;
		}

		public Node_hash get(AnyType x) {

			List<Node_hash> whichList = theLists[myhash(x)];
			// int in = whichList.indexOf(x);
			return whichList.get(0);
		}

		/**
		 * Make the hash table logically empty.
		 */
		public void makeEmpty() {
			for (int i = 0; i < theLists.length; i++)
				theLists[i].clear();
			currentSize = 0;
		}

		/**
		 * A hash routine for String objects.
		 * 
		 * @param key
		 *            the String to hash.
		 * @param tableSize
		 *            the size of the hash table.
		 * @return the hash value.
		 */
		public int hash(String key, int tableSize) {
			int hashVal = 0;

			for (int i = 0; i < key.length(); i++)
				hashVal = 37 * hashVal + key.charAt(i);

			hashVal %= tableSize;
			if (hashVal < 0)
				hashVal += tableSize;

			return hashVal;
		}

		private void rehash() {
			List<Node_hash>[] oldLists = theLists;

			// Create new double-sized, empty table
			theLists = new List[nextPrime(2 * theLists.length)];
			for (int j = 0; j < theLists.length; j++)
				theLists[j] = new LinkedList<>();

			// Copy table over
			currentSize = 0;
			for (List<Node_hash> list : oldLists)
				for (Node_hash item : list)
					insert((AnyType) item.data, item);
		}

		private int myhash(AnyType x) {
			int hashVal = x.hashCode();

			hashVal %= theLists.length;
			if (hashVal < 0)
				hashVal += theLists.length;

			return hashVal;
		}

		private static final int DEFAULT_TABLE_SIZE = 101;

		/** The array of Lists. */
		private List<Node_hash>[] theLists;
		private int currentSize;

		/**
		 * Internal method to find a prime number at least as large as n.
		 * 
		 * @param n
		 *            the starting number (must be positive).
		 * @return a prime number larger than or equal to n.
		 */
		@SuppressWarnings("empty-statement")
		private int nextPrime(int n) {
			if (n % 2 == 0)
				n++;

			for (; !isPrime(n); n += 2)
				;

			return n;
		}

		/**
		 * Internal method to test if a number is prime. Not an efficient
		 * algorithm.
		 * 
		 * @param n
		 *            the number to test.
		 * @return the result of the test.
		 */
		private boolean isPrime(int n) {
			if (n == 2 || n == 3)
				return true;

			if (n == 1 || n % 2 == 0)
				return false;

			for (int i = 3; i * i <= n; i += 2)
				if (n % i == 0)
					return false;

			return true;
		}

		/**
		 * This is the doubly-linked list node.
		 */
	}

	public static class Node_hash<AnyType> {
		public Node_hash(AnyType d) {
			data = d;
			lista = new MyLinkedList<>();
		}

		public AnyType data;
		public MyLinkedList<Node_l> lista;
	}

	/////////////////////////////////////
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;

			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static class Node_l {
		public Node_l(int c, int pr, int pu) {
			confirm = c;
			problem = pr;
			puntuation = pu;
		}

		public int confirm;
		public int problem;
		public int puntuation;
	}
	////////////////////////////////////////////////////////////////////

	public static class BynaryHeap<AnyType extends Comparable<? super AnyType>>

	{

		/**
		 * Construct the binary heap.
		 */
		public BynaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BynaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BynaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}
	}

	public static class Node_b implements Comparable<Node_b> {
		public Node_b(int d, int p, int q) {
			id = d;
			tiempo = q;
			puntuacion = p;
		}

		public int id;
		public int tiempo;
		public int puntuacion;

		public int compareTo(Node_b o) {
			if (puntuacion > o.puntuacion)
				return -1;
			if (puntuacion < o.puntuacion)
				return 1;
			else {
				if (tiempo < o.tiempo)
					return -1;
				if (tiempo > o.tiempo)
					return 1;
				else {
					if (id < o.id)
						return -1;
					if (id > o.id)
						return 1;
				}
			}

			return 0;
		}
	}

	////////////////////////////////////////////////////////////////////////////////
	public static class linkedlist<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public linkedlist() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void push(AnyType x) {
			Node<AnyType> newNode = new Node<>(x, endMarker.prev, endMarker);
			newNode.prev.next = newNode;
			endMarker.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType top() {
			return endMarker.prev.data;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType pop() {
			if (!isEmpty()) {
				AnyType popp = endMarker.prev.data;
				endMarker.prev.prev.next = endMarker;
				endMarker.prev = endMarker.prev.prev;
				theSize--;
				modCount++;

				return popp;
			} else {
				throw new ArrayIndexOutOfBoundsException("La pila esta vacia.");
			}
		}

		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public static <AnyType> void print(linkedlist<AnyType> s) {
			AnyType elem;
			if (!s.isEmpty()) {
				elem = s.pop();
				System.out.println(elem);
				linkedlist.<AnyType> print(s);
				s.push(elem);
			}
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				linkedlist.this.pop();
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		private static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;
			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub
		File f = new File("A_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		String lines[] = scan.nextLine().split(" ");
		int casos = Integer.parseInt(lines[0]);
		for (int y = 0; y < casos; y++) {

			HashMap<Integer, Node_hash> tabla = new HashMap<Integer, Node_hash>();
			lines = scan.nextLine().split(" ");
			int equipos, envios;
			equipos = Integer.parseInt(lines[0]);
			envios = Integer.parseInt(lines[1]);
			for (int ii = 0; ii < envios; ii++) {
				lines = scan.nextLine().split(" ");

				if (tabla.containsKey(Integer.parseInt(lines[0]))) {

					Node_hash<Integer> tmp = tabla.get(Integer.parseInt(lines[0]));

					if (!tmp.lista.isEmpty()) {
						int kk = 99;
						MyLinkedList<Node_l> b = tmp.lista;
						for (int g = 0; g < tmp.lista.size(); g++) {
							Node_l alex = b.get(g);
							if (alex.problem == Integer.parseInt(lines[1])) {
								if (lines[3].equals("C")) {
									alex.confirm = 1;
									alex.puntuation = alex.puntuation + Integer.parseInt(lines[2]);
								} else if (lines[3].equals("T") || lines[3].equals("R") || lines[3].equals("I")) {
									if (alex.confirm == 0) {
										alex.confirm = 0;
										alex.puntuation = alex.puntuation + 20;
									}
								}
								kk = 100;
								break;
							}
						}
						if (kk == 99) {
							Node_l nod;
							if (lines[3].equals("C")) {
								nod = new Node_l(1, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
								b.add(nod);
							} else {
								nod = new Node_l(0, Integer.parseInt(lines[1]), 20);
								b.add(nod);
							}
						}

					}
				} else {

					Node_hash<Integer> tmp = new Node_hash(Integer.parseInt(lines[0]));
					Node_l nod;
					if (lines[3].equals("C")) {
						nod = new Node_l(1, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
						tmp.lista.add(nod);
					} else {
						nod = new Node_l(0, Integer.parseInt(lines[1]), 20);
						tmp.lista.add(nod);
					}
					tabla.put(Integer.parseInt(lines[0]), tmp);
				}
			}

			//

			BynaryHeap<Node_b> monticulo = new BynaryHeap<>();
			int t;
			for (int w = 1; w <= equipos; w++) {
				Node_b diego;
				int k = 0, d = 0;
				if (tabla.containsKey(w)) {

					Node_hash<Integer> tmp = tabla.get(w);
					MyLinkedList<Node_l> b = tmp.lista;
					if (b.isEmpty()) {
						diego = new Node_b(w, 0, 0);
					} else {
						for (int m = 0; m < b.size(); m++) {
							Node_l alex = b.get(m);
							if (alex.confirm == 1) {
								k++;
								d += alex.puntuation;
							}
						}
						diego = new Node_b(w, k, d);
					}
					monticulo.insert(diego);
				} else {

				}
			}
			System.out.println("Caso #" + (y + 1) + ":");

			for (int v = 0; v < equipos; v++) {
				if (!monticulo.isEmpty()) {
					Node_b pame = monticulo.deleteMin();
					System.out.println(pame.id + " " + pame.puntuacion + " " + pame.tiempo);
				}
			}

		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_hash_union;

import java.math.BigInteger;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

public class problema_b {

	public static interface MyMap {
		public void put(Object key, Object value);

		public Object get(Object key);

		public int size();

		public Set keySet();

		public Set entrySet();

		public interface MyEntry {
			public Object getKey();

			public Object getValue();
		}
	}

	public static class MySimpleMap implements MyMap {
		private ArrayList keys;
		private ArrayList values;
		private int index;

		public MySimpleMap() {
			keys = new ArrayList();
			values = new ArrayList();
			index = 0;
		}

		public void put(Object key, Object value) {
			keys.add(key);
			values.add(value);
			index++;
		}

		public void replace(int key,Object val) {
			int i = keys.indexOf(key);
				 values.set(i, val);
		}
		
		public Object get(int key) {
			int i = keys.indexOf(key);
			if (i >= 0)
				return values.get(i);
			else
				return null;
		}

		public int size() {
			return index;
		}

		public Set keySet() {
			HashSet set = new HashSet();
			set.addAll(keys);
			return set;
		}

		// Nested class starts...
		class MySimpleEntry implements MyMap.MyEntry {
			Object key;
			Object value;

			public MySimpleEntry(Object k, Object v) {
				key = k;
				value = v;
			}

			public Object getKey() {
				return key;
			}

			public Object getValue() {
				return value;
			}
		}// Nested class ends.

		public Set entrySet() {
			HashSet set = new HashSet();
			for (int i = 0; i < index; i++) {
				Object k = keys.get(i);
				Object v = values.get(i);
				MySimpleEntry temp = new MySimpleEntry(k, v);
				set.add(temp);
			}
			return set;
		}

		@Override
		public Object get(Object key) {
			// TODO Auto-generated method stub
			return null;
		}
	}

	public static void main(String[] args) throws FileNotFoundException {
		// TODO Auto-generated method stub
		File f = new File("B_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		
		int casos = 0;
		String lines[] = scan.nextLine().split(" ");
		casos = Integer.parseInt(lines[0]);
		for (int y = 0; y < casos; y++) {
			MySimpleMap mapa = new MySimpleMap();
			int cantidad = 0;
			int contador = 0;
			lines = scan.nextLine().split(" ");
			cantidad = Integer.parseInt(lines[0]);
			int arreglo[] = new int[cantidad];
			lines = scan.nextLine().split(" ");
			Object t = null;
			int n = 0;
			for (int k = 0; k < lines.length; k++) {
				t = mapa.get(Integer.parseInt(lines[k]));

				if (t == null) {
					arreglo[contador] = Integer.parseInt(lines[k]);
					mapa.put(Integer.parseInt(lines[k]), 1);
					contador++;
				} else {
					n = (int) t;
					n++;
					mapa.replace(Integer.parseInt(lines[k]), n);
					
					
				}
				
			}
			System.out.println("Caso" + " #" + (y+1) + ":");
			for (int j = 0; j < contador; j++) {
				System.out.println(arreglo[j] + " " + mapa.get(arreglo[j]));
			}
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_hash_union;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class problema_c {

	/**
	 *  A disjoint sets ADT.  Performs union-by-rank and path compression.
	 *  Implemented using arrays.  There is no error checking whatsoever.
	 *  By adding your own error-checking, you might save yourself a lot of time
	 *  finding bugs in your application code for Project 3 and Homework 9.
	 *  Without error-checking, expect bad things to happen if you try to unite
	 *  two elements that are not roots of their respective sets, or are not
	 *  distinct.
	 *
	 *  Elements are represented by ints, numbered from zero.
	 *
	 **/

	public class DisjointSets {

	  private int[] array;

	  /**
	   *  Construct a disjoint sets object.
	   *
	   *  @param numElements the initial number of elements--also the initial
	   *  number of disjoint sets, since every element is initially in its own set.
	   **/
	  public DisjointSets(int numElements) {
	    array = new int [numElements];
	    for (int i = 0; i < array.length; i++) {
	      array[i] = -1;
	    }
	  }

	  /**
	   *  union() unites two disjoint sets into a single set.  A union-by-rank
	   *  heuristic is used to choose the new root.  This method will corrupt
	   *  the data structure if root1 and root2 are not roots of their respective
	   *  sets, or if they're identical.
	   *
	   *  @param root1 the root of the first set.
	   *  @param root2 the root of the other set.
	   **/
	  public void union(int root1, int root2) {
	    if (array[root2] < array[root1]) {
	      array[root1] = root2;             // root2 is taller; make root2 new root
	    } else {
	      if (array[root1] == array[root2]) {
	        array[root1]--;            // Both trees same height; new one is taller
	      }
	      array[root2] = root1;       // root1 equal or taller; make root1 new root
	    }
	  }

	  /**
	   *  find() finds the (int) name of the set containing a given element.
	   *  Performs path compression along the way.
	   *
	   *  @param x the element sought.
	   *  @return the set containing x.
	   **/
	  public int find(int x) {
	    if (array[x] < 0) {
	      return x;                         // x is the root of the tree; return it
	    } else {
	      // Find out who the root is; compress path by making the root x's parent.
	      array[x] = find(array[x]);
	      return array[x];                                       // Return the root
	    }
	  }

	  /**
	   *  main() is test code.  All the find()s on the same output line should be
	   *  identical.
	 * @throws FileNotFoundException 
	   **/
	  public void main(String[] args) throws FileNotFoundException {
		  
		// TODO Auto-generated method stub
			File f = new File("A_2.txt");
			Scanner scan;
			if (f.exists()) {
				scan = new Scanner(f);
			} else {
				scan = new Scanner(System.in);
			}

			String lines[] = scan.nextLine().split(" ");
			int casos = Integer.parseInt(lines[0]);
			for (int y = 0; y < casos; y++) {
				int cantidad = 0;
				lines = scan.nextLine().split(" ");
				cantidad = Integer.parseInt(lines[0]);
			    DisjointSets s = new DisjointSets(cantidad);
				lines = scan.nextLine().split(" ");
				(int w = 0; w < cantidad; w++){
					
				}
				
			}
	   
	  }
	}


}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_hash_union;

import java.math.BigInteger;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.HashMap;

public class problema_e {

	public static class B<AnyType> {
		/**
		 * Construct the hash table.
		 */
		public B() {
			this(DEFAULT_TABLE_SIZE);
		}

		/**
		 * Construct the hash table.
		 * 
		 * @param size
		 *            approximate table size.
		 */
		public B(int size) {
			theLists = new LinkedList[nextPrime(size)];
			for (int i = 0; i < theLists.length; i++)
				theLists[i] = new LinkedList<>();
		}

		/**
		 * Insert into the hash table. If the item is already present, then do
		 * nothing.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x, Node_hash<Integer> o) {
			List<Node_hash> whichList = theLists[myhash(x)];
			if (!esta(x, o)) {
				whichList.add(o);

				// Rehash; see Section 5.5
				if (++currentSize > theLists.length)
					rehash();
			} else {
				whichList.add(o);
			}
		}

		/**
		 * Remove from the hash table.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			List<Node_hash> whichList = theLists[myhash(x)];
			if (whichList.contains(x)) {
				whichList.remove(x);
				currentSize--;
			}
		}

		/**
		 * Find an item in the hash table.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if x is found.
		 */
		public boolean contains(AnyType x) {
			List<Node_hash> whichList = theLists[myhash(x)];
			return whichList.contains(x);
		}

		public boolean esta(AnyType x, Node_hash<Integer> o) {
			List<Node_hash> whichList = theLists[myhash(x)];
			for (int u = 0; u < whichList.size(); u++) {
				if (whichList.get(u).data == o.data)
					return true;
			}
			return false;
		}

		public Node_hash get(AnyType x) {

			List<Node_hash> whichList = theLists[myhash(x)];
			// int in = whichList.indexOf(x);
			return whichList.get(0);
		}

		/**
		 * Make the hash table logically empty.
		 */
		public void makeEmpty() {
			for (int i = 0; i < theLists.length; i++)
				theLists[i].clear();
			currentSize = 0;
		}

		/**
		 * A hash routine for String objects.
		 * 
		 * @param key
		 *            the String to hash.
		 * @param tableSize
		 *            the size of the hash table.
		 * @return the hash value.
		 */
		public int hash(String key, int tableSize) {
			int hashVal = 0;

			for (int i = 0; i < key.length(); i++)
				hashVal = 37 * hashVal + key.charAt(i);

			hashVal %= tableSize;
			if (hashVal < 0)
				hashVal += tableSize;

			return hashVal;
		}

		private void rehash() {
			List<Node_hash>[] oldLists = theLists;

			// Create new double-sized, empty table
			theLists = new List[nextPrime(2 * theLists.length)];
			for (int j = 0; j < theLists.length; j++)
				theLists[j] = new LinkedList<>();

			// Copy table over
			currentSize = 0;
			for (List<Node_hash> list : oldLists)
				for (Node_hash item : list)
					insert((AnyType) item.data, item);
		}

		private int myhash(AnyType x) {
			int hashVal = x.hashCode();

			hashVal %= theLists.length;
			if (hashVal < 0)
				hashVal += theLists.length;

			return hashVal;
		}

		private static final int DEFAULT_TABLE_SIZE = 101;

		/** The array of Lists. */
		private List<Node_hash>[] theLists;
		private int currentSize;

		/**
		 * Internal method to find a prime number at least as large as n.
		 * 
		 * @param n
		 *            the starting number (must be positive).
		 * @return a prime number larger than or equal to n.
		 */
		@SuppressWarnings("empty-statement")
		private int nextPrime(int n) {
			if (n % 2 == 0)
				n++;

			for (; !isPrime(n); n += 2)
				;

			return n;
		}

		/**
		 * Internal method to test if a number is prime. Not an efficient
		 * algorithm.
		 * 
		 * @param n
		 *            the number to test.
		 * @return the result of the test.
		 */
		private boolean isPrime(int n) {
			if (n == 2 || n == 3)
				return true;

			if (n == 1 || n % 2 == 0)
				return false;

			for (int i = 3; i * i <= n; i += 2)
				if (n % i == 0)
					return false;

			return true;
		}

		/**
		 * This is the doubly-linked list node.
		 */
	}

	public static class Node_hash<AnyType> {
		public Node_hash(AnyType d) {
			data = d;
			lista = new MyLinkedList<>();
		}

		public AnyType data;
		public MyLinkedList<Node_l> lista;
	}

	/////////////////////////////////////
	public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
		/**
		 * Construct an empty LinkedList.
		 */
		public MyLinkedList() {
			doClear();
		}

		private void clear() {
			doClear();
		}

		/**
		 * Change the size of this collection to zero.
		 */
		public void doClear() {
			beginMarker = new Node<>(null, null, null);
			endMarker = new Node<>(null, beginMarker, null);
			beginMarker.next = endMarker;

			theSize = 0;
			modCount++;
		}

		/**
		 * Returns the number of items in this collection.
		 * 
		 * @return the number of items in this collection.
		 */
		public int size() {
			return theSize;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		/**
		 * Adds an item to this collection, at the end.
		 * 
		 * @param x
		 *            any object.
		 * @return true.
		 */
		public boolean add(AnyType x) {

			add(size(), x);
			return true;
		}

		/**
		 * Adds an item to this collection, at specified position. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param x
		 *            any object.
		 * @param idx
		 *            position to add at.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		public void add(int idx, AnyType x) {
			addBefore(getNode(idx, 0, size()), x);
		}

		/**
		 * Adds an item to this collection, at specified position p. Items at or
		 * after that position are slid one position higher.
		 * 
		 * @param p
		 *            Node to add before.
		 * @param x
		 *            any object.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size(), inclusive.
		 */
		private void addBefore(Node<AnyType> p, AnyType x) {
			Node<AnyType> newNode = new Node<>(x, p.prev, p);
			newNode.prev.next = newNode;
			p.prev = newNode;
			theSize++;
			modCount++;
		}

		/**
		 * Returns the item at position idx.
		 * 
		 * @param idx
		 *            the index to search in.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType get(int idx) {
			return getNode(idx).data;
		}

		/**
		 * Changes the item at position idx.
		 * 
		 * @param idx
		 *            the index to change.
		 * @param newVal
		 *            the new value.
		 * @return the old value.
		 * @throws IndexOutOfBoundsException
		 *             if index is out of range.
		 */
		public AnyType set(int idx, AnyType newVal) {
			Node<AnyType> p = getNode(idx);
			AnyType oldVal = p.data;

			p.data = newVal;
			return oldVal;
		}

		/**
		 * Gets the Node at position idx, which must range from 0 to size( ) -
		 * 1.
		 * 
		 * @param idx
		 *            index to search at.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between 0 and size( ) - 1, inclusive.
		 */
		private Node<AnyType> getNode(int idx) {
			return getNode(idx, 0, size() - 1);
		}

		/**
		 * Gets the Node at position idx, which must range from lower to upper.
		 * 
		 * @param idx
		 *            index to search at.
		 * @param lower
		 *            lowest valid index.
		 * @param upper
		 *            highest valid index.
		 * @return internal node corresponding to idx.
		 * @throws IndexOutOfBoundsException
		 *             if idx is not between lower and upper, inclusive.
		 */
		private Node<AnyType> getNode(int idx, int lower, int upper) {
			Node<AnyType> p;
			if (idx < lower || idx > upper)
				throw new IndexOutOfBoundsException("getNode index: " + idx + "; size: " + size());
			if (idx < size() / 2) {
				p = beginMarker.next;
				for (int i = 0; i < idx; i++)
					p = p.next;
			} else {
				p = endMarker;
				for (int i = size(); i > idx; i--)
					p = p.prev;
			}
			return p;
		}

		/**
		 * Removes an item from this collection.
		 * 
		 * @param idx
		 *            the index of the object.
		 * @return the item was removed from the collection.
		 */
		public AnyType remove(int idx) {
			return remove(getNode(idx));
		}

		/**
		 * Removes the object contained in Node p.
		 * 
		 * @param p
		 *            the Node containing the object.
		 * @return the item was removed from the collection.
		 */
		private AnyType remove(Node<AnyType> p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			theSize--;
			modCount++;

			return p.data;
		}

		/**
		 * Returns a String representation of this collection.
		 */
		public String toString() {
			StringBuilder sb = new StringBuilder("[ ");

			for (AnyType x : this)
				sb.append(x + " ");
			sb.append("]");

			return new String(sb);
		}

		/**
		 * Obtains an Iterator object used to traverse the collection.
		 * 
		 * @return an iterator positioned prior to the first element.
		 */
		public java.util.Iterator<AnyType> iterator() {
			return new LinkedListIterator();
		}

		/**
		 * This is the implementation of the LinkedListIterator. It maintains a
		 * notion of a current position and of course the implicit reference to
		 * the MyLinkedList.
		 */
		private class LinkedListIterator implements java.util.Iterator<AnyType> {
			private Node<AnyType> current = beginMarker.next;
			private int expectedModCount = modCount;
			private boolean okToRemove = false;

			public boolean hasNext() {
				return current != endMarker;
			}

			public AnyType next() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!hasNext())
					throw new java.util.NoSuchElementException();

				AnyType nextItem = current.data;
				current = current.next;
				okToRemove = true;
				return nextItem;
			}

			public void remove() {
				if (modCount != expectedModCount)
					throw new java.util.ConcurrentModificationException();
				if (!okToRemove)
					throw new IllegalStateException();

				MyLinkedList.this.remove(current.prev);
				expectedModCount++;
				okToRemove = false;
			}
		}

		/**
		 * This is the doubly-linked list node.
		 */
		public static class Node<AnyType> {
			public Node(AnyType d, Node<AnyType> p, Node<AnyType> n) {
				data = d;
				prev = p;
				next = n;

			}

			public AnyType data;
			public Node<AnyType> prev;
			public Node<AnyType> next;
		}

		private int theSize;
		private int modCount = 0;
		private Node<AnyType> beginMarker;
		private Node<AnyType> endMarker;
	}

	public static class Node_l {
		public Node_l(int c, int pr, int pu) {
			confirm = c;
			problem = pr;
			puntuation = pu;
		}

		public int confirm;
		public int problem;
		public int puntuation;
	}
	////////////////////////////////////////////////////////////////////

	public static class BynaryHeap<AnyType extends Comparable<? super AnyType>>

	{

		/**
		 * Construct the binary heap.
		 */
		public BynaryHeap() {
			this(DEFAULT_CAPACITY);
		}

		/**
		 * Construct the binary heap.
		 * 
		 * @param capacity
		 *            the capacity of the binary heap.
		 */
		public BynaryHeap(int capacity) {
			currentSize = 0;
			array = (AnyType[]) new Comparable[capacity + 1];
		}

		/**
		 * Construct the binary heap given an array of items.
		 * 
		 * @param items
		 */
		public BynaryHeap(AnyType[] items) {
			currentSize = items.length;
			array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];

			int i = 1;
			for (AnyType item : items)
				array[i++] = item;
			buildHeap();
		}

		/**
		 * Insert into the priority queue, maintaining heap order. Duplicates
		 * are allowed.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			if (currentSize == array.length - 1)
				enlargeArray(array.length * 2 + 1);

			// Percolate up
			int hole = ++currentSize;
			for (array[0] = x; x.compareTo(array[hole / 2]) < 0; hole /= 2)
				array[hole] = array[hole / 2];
			array[hole] = x;
		}

		private void enlargeArray(int newSize) {
			AnyType[] old = array;
			array = (AnyType[]) new Comparable[newSize];
			for (int i = 0; i < old.length; i++)
				array[i] = old[i];
		}

		/**
		 * Find the smallest item in the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return array[1];
		}

		/**
		 * Remove the smallest item from the priority queue.
		 * 
		 * @return the smallest item, or throw an UnderflowException if empty.
		 * @throws java.lang.Exception
		 */
		public AnyType deleteMin() throws Exception {
			if (isEmpty())
				throw new Exception();

			AnyType minItem = findMin();
			array[1] = array[currentSize--];
			percolateDown(1);

			return minItem;
		}

		/**
		 * Establish heap order property from an arbitrary arrangement of items.
		 * Runs in linear time.
		 */
		private void buildHeap() {
			for (int i = currentSize / 2; i > 0; i--)
				percolateDown(i);
		}

		/**
		 * Test if the priority queue is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return currentSize == 0;
		}

		/**
		 * Make the priority queue logically empty.
		 */
		public void makeEmpty() {
			currentSize = 0;
		}

		private static final int DEFAULT_CAPACITY = 10;

		private int currentSize; // Number of elements in heap
		private AnyType[] array; // The heap array

		/**
		 * Internal method to percolate down in the heap.
		 * 
		 * @param hole
		 *            the index at which the percolate begins.
		 */
		private void percolateDown(int hole) {
			int child;
			AnyType tmp = array[hole];

			for (; hole * 2 <= currentSize; hole = child) {
				child = hole * 2;
				if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
				if (array[child].compareTo(tmp) < 0)
					array[hole] = array[child];
				else
					break;
			}
			array[hole] = tmp;
		}
	}

	public static class Node_b implements Comparable<Node_b> {
		public Node_b(int d, int p, int q) {
			id = d;
			tiempo = q;
			puntuacion = p;
		}

		public int id;
		public int tiempo;
		public int puntuacion;

		public int compareTo(Node_b o) {
			if (puntuacion > o.puntuacion)
				return -1;
			if (puntuacion < o.puntuacion)
				return 1;
			else {
				if (tiempo < o.tiempo)
					return -1;
				if (tiempo > o.tiempo)
					return 1;
				else {
					if (id < o.id)
						return -1;
					if (id > o.id)
						return 1;
				}
			}

			return 0;
		}
	}

	////////////////////////////////////////////////////////////////////////////////

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub
		File f = new File("A_2.txt");
		Scanner scan;
		if (f.exists()) {
			scan = new Scanner(f);
		} else {
			scan = new Scanner(System.in);
		}

		String lines[] = scan.nextLine().split(" ");
		int casos = Integer.parseInt(lines[0]);
		for (int y = 0; y < casos; y++) {

			HashMap<Integer, Node_hash> tabla = new HashMap<Integer, Node_hash>();
			lines = scan.nextLine().split(" ");
			int equipos, envios;
			int correctos = 0, incorrectos = 0, runerror = 0, timelimit = 0;
			equipos = Integer.parseInt(lines[0]);
			envios = Integer.parseInt(lines[1]);
			for (int ii = 0; ii < envios; ii++) {
				
				lines = scan.nextLine().split(" ");
				
				if(lines[3].equals("I")){
					incorrectos++;
				}else if(lines[3].equals("C")){
					correctos++;
				}else if(lines[3].equals("T")){
					timelimit++;
				}else if(lines[3].equals("R")){
					runerror++;
				}
				
				if (tabla.containsKey(Integer.parseInt(lines[0]))) {

					Node_hash<Integer> tmp = tabla.get(Integer.parseInt(lines[0]));
					if (!tmp.lista.isEmpty()) {
						int kk = 99;
						MyLinkedList<Node_l> b = tmp.lista;
						for (int g = 0; g < tmp.lista.size(); g++) {
							Node_l alex = b.get(g);
							if (alex.problem == Integer.parseInt(lines[1])) {
								if (lines[3].equals("C")) {
									alex.confirm = 1;
									alex.puntuation = alex.puntuation + Integer.parseInt(lines[2]);
								} else if (lines[3].equals("T") || lines[3].equals("R") || lines[3].equals("I")) {
									if (alex.confirm == 0) {
										alex.confirm = 0;
										alex.puntuation = alex.puntuation + 20;
									}
								}
								kk = 100;
								break;
							}
						}
						if (kk == 99) {
							Node_l nod;
							if (lines[3].equals("C")) {
								nod = new Node_l(1, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
								b.add(nod);
							} else {
								nod = new Node_l(0, Integer.parseInt(lines[1]), 20);
								b.add(nod);
							}
						}

					}
				} else {

					Node_hash<Integer> tmp = new Node_hash(Integer.parseInt(lines[0]));
					Node_l nod;
					if (lines[3].equals("C")) {
						nod = new Node_l(1, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
						tmp.lista.add(nod);
					} else {
						nod = new Node_l(0, Integer.parseInt(lines[1]), 20);
						tmp.lista.add(nod);
					}
					tabla.put(Integer.parseInt(lines[0]), tmp);
				}
			}

			//

			BynaryHeap<Node_b> monticulo = new BynaryHeap<>();
			int t;
			for (int w = 1; w <= equipos; w++) {
				Node_b diego;
				int k = 0, d = 0;
				if (tabla.containsKey(w)) {

					Node_hash<Integer> tmp = tabla.get(w);
					MyLinkedList<Node_l> b = tmp.lista;
					if (b.isEmpty()) {
						diego = new Node_b(w, 0, 0);
					} else {
						for (int m = 0; m < b.size(); m++) {
							Node_l alex = b.get(m);
							if (alex.confirm == 1) {
								k++;
								d += alex.puntuation;
							}
						}
						diego = new Node_b(w, k, d);
					}
					monticulo.insert(diego);
				} else {

				}
			}
			System.out.println("Caso #" + (y + 1) + ":");

			for (int v = 0; v < equipos; v++) {
				if (!monticulo.isEmpty()) {
					Node_b pame = monticulo.deleteMin();
					System.out.println(pame.id + " " + pame.puntuacion + " " + pame.tiempo);
				}
			}
			System.out.println(correctos + " " + incorrectos + " " + runerror + " " + timelimit);

		}

	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package proyecto_arboles;

import java.io.File;
import java.util.Scanner;

public class problema_a {

	/**
	 * Implements an unbalanced binary search tree. Note that all "matching" is
	 * based on the compareTo method.
	 * 
	 */
	public static class BinarySearchTree<AnyType extends Comparable<? super AnyType>> {
		/**
		 * Construct the tree.
		 */
		public BinarySearchTree() {
			root = null;
		}

		/**
		 * Insert into the tree; duplicates are ignored.
		 * 
		 * @param x
		 *            the item to insert.
		 */
		public void insert(AnyType x) {
			root = insert(x, root);
		}

		/**
		 * Remove from the tree. Nothing is done if x is not found.
		 * 
		 * @param x
		 *            the item to remove.
		 */
		public void remove(AnyType x) {
			root = remove(x, root);
		}

		/**
		 * Find the smallest item in the tree.
		 * 
		 * @return smallest item or null if empty.
		 */
		public AnyType findMin() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMin(root).element;
		}

		/**
		 * Find the largest item in the tree.
		 * 
		 * @return the largest item of null if empty.
		 */
		public AnyType findMax() throws Exception {
			if (isEmpty())
				throw new Exception();
			return findMax(root).element;
		}

		/**
		 * Find an item in the tree.
		 * 
		 * @param x
		 *            the item to search for.
		 * @return true if not found.
		 */
		public boolean contains(AnyType x) {
			return contains(x, root);
		}

		/**
		 * Make the tree logically empty.
		 */
		public void makeEmpty() {
			root = null;
		}

		/**
		 * Test if the tree is logically empty.
		 * 
		 * @return true if empty, false otherwise.
		 */
		public boolean isEmpty() {
			return root == null;
		}

		/**
		 * Print the tree contents in sorted order.
		 */
		public void printTree() {
			if (isEmpty())
				System.out.println("Empty tree");
			else
				printTree(root);
		}

		/**
		 * Internal method to insert into a subtree.
		 * 
		 * @param x
		 *            the item to insert.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> insert(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return new BinaryNode<>(x, null, null);

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = insert(x, t.left);
			else if (compareResult > 0)
				t.right = insert(x, t.right);
			else
				; // Duplicate; do nothing
			return t;
		}

		/**
		 * Internal method to remove from a subtree.
		 * 
		 * @param x
		 *            the item to remove.
		 * @param t
		 *            the node that roots the subtree.
		 * @return the new root of the subtree.
		 */
		private BinaryNode<AnyType> remove(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return t; // Item not found; do nothing

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				t.left = remove(x, t.left);
			else if (compareResult > 0)
				t.right = remove(x, t.right);
			else if (t.left != null && t.right != null) // Two children
			{
				t.element = findMin(t.right).element;
				t.right = remove(t.element, t.right);
			} else
				t = (t.left != null) ? t.left : t.right;
			return t;
		}

		/**
		 * Internal method to find the smallest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the smallest item.
		 */
		private BinaryNode<AnyType> findMin(BinaryNode<AnyType> t) {
			if (t == null)
				return null;
			else if (t.left == null)
				return t;
			return findMin(t.left);
		}

		/**
		 * Internal method to find the largest item in a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the largest item.
		 */
		private BinaryNode<AnyType> findMax(BinaryNode<AnyType> t) {
			if (t != null)
				while (t.right != null)
					t = t.right;

			return t;
		}

		/**
		 * Internal method to find an item in a subtree.
		 * 
		 * @param x
		 *            is item to search for.
		 * @param t
		 *            the node that roots the subtree.
		 * @return node containing the matched item.
		 */
		private boolean contains(AnyType x, BinaryNode<AnyType> t) {
			if (t == null)
				return false;

			int compareResult = x.compareTo(t.element);

			if (compareResult < 0)
				return contains(x, t.left);
			else if (compareResult > 0)
				return contains(x, t.right);
			else
				return true; // Match
		}

		/**
		 * Internal method to print a subtree in sorted order.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private void printTree(BinaryNode<AnyType> t) {
			if (t != null) {
				printTree(t.left);
				System.out.println(t.element);
				printTree(t.right);
			}
		}

		/**
		 * Internal method to compute height of a subtree.
		 * 
		 * @param t
		 *            the node that roots the subtree.
		 */
		private int height(BinaryNode<AnyType> t) {
			if (t == null)
				return -1;
			else
				return 1 + Math.max(height(t.left), height(t.right));
		}

		public synchronized void recorridoInorden() {
			ayudanteInorden(root);
		}

		// metodo recursivo para recorrido inorden
		private void ayudanteInorden(BinaryNode nodo) {
			if (nodo == null)
				return;

			ayudanteInorden(nodo.left);
			System.out.print(nodo.element + " ");
			ayudanteInorden(nodo.right);
		}

		public static int way(BinaryNode nodo1, int k) {
			if (nodo1 != null) {
				int u = 0;
				if ((Integer) nodo1.element == k) {
					return u + 1;
				} else if ((u = way(nodo1.left, k)) > 0) {
					return u + 1;
				} else if ((u = way(nodo1.right, k)) > 0) {
					return u + 1;
				}
				return 0;
			}
			return 0;
		}

		public static BinaryNode ancestro(BinaryNode nodo1, int n1, int n2) {
			int contador = 0;
			if (nodo1 != null) {
				if ((Integer) nodo1.element == n1) {
					return nodo1;
				} else if ((Integer) nodo1.element == n2) {
					return nodo1;
				}
				BinaryNode izq = ancestro(nodo1.left, n1, n2);
				contador = (Integer) nodo1.element;
				BinaryNode der = ancestro(nodo1.right, n1, n2);
				if (izq != null) {
					if (der != null) {
						contador--;
						return nodo1;
					}
				}
				if (izq != null) {
					contador += (Integer) nodo1.element;
					return izq;
				}
				if (der != null) {
					contador += (Integer) der.element;
					return der;
				}
				contador++;
			}
			contador = 0;
			return null;
		}

		// Basic node stored in unbalanced binary search trees
		public static class BinaryNode<AnyType> {
			// Constructors
			BinaryNode(AnyType theElement) {
				this(theElement, null, null);
			}

			BinaryNode(AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt) {
				element = theElement;
				left = lt;
				right = rt;
			}

			AnyType element; // The data in the node
			BinaryNode<AnyType> left; // Left child
			BinaryNode<AnyType> right; // Right child
		}

		/** The tree root. */
		private BinaryNode<AnyType> root;

		// Test program
		public static void main(String[] args) throws Exception {

			File f = new File("A1.txt");
			Scanner scan;
			if (f.exists()) {
				scan = new Scanner(f);
			} else {
				scan = new Scanner(System.in);
			}

			BinarySearchTree<Integer> tree = new BinarySearchTree<>();

			int casos = 0;
			casos = scan.nextInt();
			BinaryNode nodo = null;
			for (int y = 0; y < casos; y++) {
				int comandos = 0;
				comandos = scan.nextInt();
				for (int x = 0; x <= comandos; x++) {
					String lines[] = scan.nextLine().split(" ");
					if (lines[0].equals("agregar")) {
						tree.insert(Integer.parseInt(lines[1]));
					} else if (lines[0].equals("distancia")) {
						int p = 0, n = 0;
						int padre, perro;
						p = way(tree.root, Integer.parseInt(lines[1]));
						p--;
						n = way(tree.root, Integer.parseInt(lines[2]));
						n--;
						nodo = ancestro(tree.root, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
						if (nodo == null) {
							System.out.println("distancia: " + "-1");
						} else {
							padre = (Integer) nodo.element;
							perro = way(tree.root, padre);
							perro--;
							if (perro != -1 && p != -1 && n != -1) {
								System.out.println("distancia: " + ((p + n) - (2 * (perro))));
							} else {
								System.out.println("distancia: " + "-1");
							}
						}

					} else if (lines[0].equals("ancestro")) {

						if (Integer.parseInt(lines[1]) == Integer.parseInt(lines[2])) {
							System.out.println("ancestro: " + lines[2]);
						} else {
							nodo = ancestro(tree.root, Integer.parseInt(lines[1]), Integer.parseInt(lines[2]));
							if (nodo == null) {
								System.out.println("ancestro: -1");
							} else {
								System.out.println("ancestro: " + nodo.element);
							}
						}

					}
				}

			}
		}

	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
