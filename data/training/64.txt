package maximizaruber;

import java.util.Arrays;
import java.util.Scanner;

/**
 *
 */
public class MaximizarUber {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        Scanner in = new Scanner (System.in);
        int N, P, multPos, multNeg;
        while (in.hasNext()){
            N = in.nextInt();
            int [ ] numArray = new int [N];
            for (int i = 0; i < N; i++){
                P = in.nextInt();
                numArray[i] = P;
                //System.out.println(P);
            }
            Arrays.sort(numArray);
            //System.out.println(Arrays.toString(numArray));
            multPos = numArray[N-2] * numArray[N-1];
            multNeg = numArray[0] * numArray [1];
            if (multPos>multNeg){
                System.out.println(multPos);
            } else System.out.println(multNeg);
        }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package casillaganadora;

import java.util.Scanner;
import java.util.Arrays;

/**
 *
 */
public class CasillaGanadora {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N, caso = 0;
        while(in.hasNext()){
            N = in.nextInt();
            int a [][] = new int [N][N];
            int fila [] = new int [N];
            int columna [] = new int [N];
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++){
                    a[i][j]=in.nextInt();
                    fila[i] += a[i][j];
                    columna[j] += a[i][j];
                }
            }
            //System.out.println(Arrays.deepToString(a));
            int casillaGanadora = 0;
            for (int i = 0; i < N; i++){
                for (int j = 0; j < N; j++){
                    if (fila[i]<columna[j]) casillaGanadora++;
                }
            }
            caso ++;
            System.out.println("Case #"+caso+": "+casillaGanadora);
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package torneofutbol;

import java.util.Scanner;

/**
 *
 */
public class TorneoFutbol {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner (System.in);
        int T, N;
        while (in.hasNext()){
            T = in.nextInt();
            for (int i = 0; i < T; i++){
                int counter = 0;
                N = in.nextInt();               // equipos
                int [ ] a = new int [N];
                int [ ] b = new int [N];
                for (int j = 0; j<N; j++){
                    a[j] = in.nextInt();        // local
                    b[j] = in.nextInt();        // visitante
                }
                for (int j = 0; j<N; j++){
                    for (int k=0; k<N; k++){
                        if (j!= k){
                            if (a[j]==b[k]){
                                counter++;
                            }
                        }
                    }
                }
                System.out.println("Case #"+(i+1)+":");
                System.out.println(counter);
            }
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package maximizaruber;

import java.util.Arrays;
import java.util.Scanner;
import java.math.BigInteger;

/**
 *
 */
public class MaximizarUber {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        Scanner in = new Scanner (System.in);
        int N;
        BigInteger P, multPos, multNeg;
        while (in.hasNext()){
            N = in.nextInt();                   //tamaño lista
            BigInteger [ ] numArray = new BigInteger[N];
            for (int i = 0; i < N; i++){
                P = in.nextBigInteger();
                numArray[i] = P;
                //System.out.println(P);
            }
            Arrays.sort(numArray);
            //System.out.println(Arrays.toString(numArray));
            multPos = numArray[N-2].multiply(numArray[N-1]);
            multNeg = numArray[0].multiply(numArray[1]);
            if (multPos.compareTo(multNeg)==1){
                System.out.println("p"+multPos);
            } else System.out.println("n:"+multNeg);
        }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package maximizaruber;

import java.util.Arrays;
import java.util.Scanner;
import java.math.BigInteger;

/**
 *
 */
public class MaximizarUber {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        Scanner in = new Scanner (System.in);
        int N;
        BigInteger P, multPos, multNeg;
        while (in.hasNext()){
            N = in.nextInt();                       //tamano lista
            BigInteger [ ] numArray = new BigInteger[N];
            for (int i = 0; i < N; i++){
                P = in.nextBigInteger();
                numArray[i] = P;
                //System.out.println(P);
            }
            Arrays.sort(numArray);
            //System.out.println(Arrays.toString(numArray));
            multPos = numArray[N-2].multiply(numArray[N-1]);
            multNeg = numArray[0].multiply(numArray[1]);
            if (multPos.compareTo(multNeg)==1){
                System.out.println("p"+multPos);
            } else System.out.println("n:"+multNeg);
        }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package maximizaruber;

import java.util.Arrays;
import java.util.Scanner;
import java.math.BigInteger;

/**
 *
 */
public class MaximizarUber {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        Scanner in = new Scanner (System.in);
        int N;
        BigInteger P, multPos, multNeg;
        while (in.hasNext()){
            N = in.nextInt();                       //tamano lista
            BigInteger [ ] numArray = new BigInteger[N];
            for (int i = 0; i < N; i++){
                P = in.nextBigInteger();
                numArray[i] = P;
                //System.out.println(P);
            }
            Arrays.sort(numArray);
            //System.out.println(Arrays.toString(numArray));
            multPos = numArray[N-2].multiply(numArray[N-1]);
            multNeg = numArray[0].multiply(numArray[1]);
            if (multPos.compareTo(multNeg)==1){
                System.out.println(multPos);
            } else System.out.println(multNeg);
        }
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package casillaganadora;

import java.util.Scanner;
import java.util.Arrays;

/**
 *
 */
public class CasillaGanadora {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N, caso = 0;
        while(in.hasNext()){
            N = in.nextInt();
            int a [][] = new int [N][N];
            int fila [] = new int [N];
            int columna [] = new int [N];
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++){
                    a[i][j]=in.nextInt();
                    fila[i] += a[i][j];
                    columna[j] += a[i][j];
                }
            }
            //System.out.println(Arrays.deepToString(a));
            int casillaGanadora = 0;
            for (int i = 0; i < N; i++){
                for (int j = 0; j < N; j++){
                    if (fila[i]<columna[j]) casillaGanadora++;
                }
            }
            caso ++;
            System.out.println("Case #"+caso+": ");
            System.out.println(casillaGanadora);
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package indentificarte;

import java.util.Scanner;

/**
 *
 */
public class IndentificarTe {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        while(in.hasNext()){
            int T = in.nextInt();                   // tipo de te
            int [] N = new int [5];
            int contador = 0;
            for (int i = 0; i < 5; i++){
                N[i] = in.nextInt();
                if (N[i] == T) contador ++;
            }
            System.out.println(contador);
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package osopolar;

import java.util.Arrays;
import java.util.Scanner;

/**
 *
 */
public class OsoPolar {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int T, N;
        while(in.hasNext()){
            T = in.nextInt();                   //casos de prueba
            String cereza = "";
            for (int i = 0; i < T; i++){
                N = in.nextInt();               //tamaño barra
                int totalCerezas = 0, sumaFila = 0, sumaColumna = 0;
                int [] fila = new int [N];
                int [] columna = new int [N];
                int [][] pieza = new int [N][N];
                
                for (int j = 0; j < N; j++){
                    cereza = in.next();
                    for (int k = 0; k < N; k++){
                        if (cereza.charAt(k)==35){
                            pieza[j][k] = 1;
                            totalCerezas ++;
                            fila[j]++;
                            columna[k]++;
                        } else if (cereza.charAt(k)==46) pieza[j][k] = 0;
                    }
                }
                //System.out.println(Arrays.deepToString(pieza));
                if (totalCerezas % 2 != 0) System.out.println("NO");
                else {
                    if (fila[0] == (totalCerezas/2))System.out.println("YES");
                    else{
                        if (columna[0] == (totalCerezas/2))System.out.println("YES");
                        else{
                            sumaFila = fila[0];
                            sumaColumna = columna[0];
                            for (int j = 0; j < N; j++){
                                sumaFila += fila[j];
                                sumaColumna += columna[j];
                                if (sumaFila == (totalCerezas/2)) System.out.println("YES");
                                else if (sumaColumna == (totalCerezas/2)) System.out.println("YES");
                            }
                            if (sumaFila != (totalCerezas/2) && sumaColumna!= (totalCerezas/2)){
                                System.out.println("NO");
                            }
                        }
                    }
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package osopolar;

import java.util.Arrays;
import java.util.Scanner;

/**
 *
 */
public class OsoPolar {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int T, N;
        while(in.hasNext()){
            T = in.nextInt();                   //casos de prueba
            String cereza = "";
            for (int i = 0; i < T; i++){
                N = in.nextInt();               //tamano barra
                int totalCerezas = 0, sumaFila = 0, sumaColumna = 0;
                int [] fila = new int [N];
                int [] columna = new int [N];
                int [][] pieza = new int [N][N];
                
                for (int j = 0; j < N; j++){
                    cereza = in.next();
                    for (int k = 0; k < N; k++){
                        if (cereza.charAt(k)==35){
                            pieza[j][k] = 1;
                            totalCerezas ++;
                            fila[j]++;
                            columna[k]++;
                        } else if (cereza.charAt(k)==46) pieza[j][k] = 0;
                    }
                }
                //System.out.println(Arrays.deepToString(pieza));
                if (totalCerezas % 2 != 0) System.out.println("NO");
                else {
                    if (fila[0] == (totalCerezas/2))System.out.println("YES");
                    else{
                        if (columna[0] == (totalCerezas/2))System.out.println("YES");
                        else{
                            sumaFila = fila[0];
                            sumaColumna = columna[0];
                            for (int j = 0; j < N; j++){
                                sumaFila += fila[j];
                                sumaColumna += columna[j];
                                if (sumaFila == (totalCerezas/2)) System.out.println("YES");
                                else if (sumaColumna == (totalCerezas/2)) System.out.println("YES");
                            }
                            if (sumaFila != (totalCerezas/2) && sumaColumna!= (totalCerezas/2)){
                                System.out.println("NO");
                            }
                        }
                    }
                }
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package rummikub;

import java.util.Scanner;

/**
 *
 */
public class Rummikub {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        while (in.hasNext()){
            int T = in.nextInt();                   // Test cases
            System.out.println("t = "+T);
            int M, V;
            for (int i = 0; i < T; i++){
                M = in.nextInt();               // # of tiles
                System.out.println("m = "+M);
                String [] tile = new String [M];
                int [] value = new int [M];
                char [] color = new char [M];
                
                for (int j = 0; j < M; j++){
                    tile[j] = in.next();
                    char strValue = tile[j].charAt(0);
                    value [j] = Integer.parseInt(String.valueOf(strValue));
                    color [j] = tile[j].charAt(1);
                }
                
                int countColor = 1, countValue = 1;
                
                for (int j = 0; j < M-1; j++){
                    if (color[j] == color [j+1]){
                        countColor++;
                    } else {
                        if (value[j] == value[j+1]) countValue++;
                    }
                    System.out.println("cvalue = " + countValue + ". ccolor = "+ countColor);
                }
            }
        }
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package propuestasmatrimonio;

import java.util.Scanner;

/**
 *
 */
public class PropuestasMatrimonio {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // 
        Scanner in = new Scanner (System.in);
        int N;
        
        while (in.hasNext()){
            N = in.nextInt();                   // Cantidad de cualidades
            MyLinkedList qualities = new MyLinkedList();
            int candidateCounter = 0;
            
            for (int i = 0; i < N; i++){
                qualities.insert(in.nextInt(), i);
            }
            int M = in.nextInt();
            in.nextLine();
            for (int i = 0; i < M; i++){
                int qualityCounter = 0;
                String candidate = in.nextLine();
                String [] candidateQualities = candidate.split(" ");
                for (int j = 0; j < candidateQualities.length; j++){
                    int search = qualities.search(Integer.parseInt(candidateQualities[j]));
                    if (search >= 0) qualityCounter++;
                }
                if (qualityCounter == N) candidateCounter++;
            }
            System.out.println(candidateCounter);
        }
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(int value, int pos){
            
            if (pos > 0 && pos <= size()){
                insertNode (getNode(pos-1),value);
            } else if (pos == 0){
                insertHead(value);
            }
        }
        private Node insertHead (int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            
            listSize++;
            return newNode;
        }
        private Node insertNode (Node target, int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            
            listSize++;
            return target;
        }
        public int get (int pos){
            
            return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                return null;
            }
            Node head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            if (pos > 0 || pos < size()){
                deleteNode (getNode(0),pos);
            }
        }
        private Node deleteNode (Node head, int pos){
            
            if (pos == 0){
                beginMarker.next = head.next;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node temp;
                temp = head.next.next;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (int value){
            return searchNode(value);
        }
        private int searchNode (int value){
            
            for (int i = 0; i < size(); i++){
                if (get(i) == value){
                    return i;
                }
            }
            return -1;
        }
        
        private static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public int data;
            public Node next;
        }
        
        int listSize;
        Node beginMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package juegocartas;

import java.util.Scanner;

/**
 *
 */
public class JuegoCartas {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner in = new Scanner (System.in);
        int T, N, K, Pi;
        
        while (in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                   // Cartas en el mazo
                K = in.nextInt();                   // Número jugadores
                MyLinkedList cardStuck = new MyLinkedList();
                MyLinkedList playerList = new MyLinkedList();
                
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    Pi = in.nextInt();              // Valores de cartas
                    cardStuck.insert(Pi, j);
                }
                
                if (K > N) K = N;
                int prevCount = N/K;
                for (int j = 0; j < N; j++){
                    int count = (N-(j+1))/K;
                    
                    if (prevCount != count) {
                        for (int k = 0; k < K; k++){
                            if (!cardStuck.isEmpty()) {
                                playerList.sumeCards(cardStuck.popCards(), k);
                            }
                        }
                    }
                    
                    prevCount = count;
                }
                System.out.println(playerList.comparePlayers());
            }
        }
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            endMarker = new Node();
            endMarker.next = null;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(int value, int pos){
            
            if (pos > 0 && pos <= size()){
                insertNode (getNode(pos-1),value);
            } else if (pos == 0){
                insertHead(value);
            }
        }
        private Node insertHead (int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            if(newNode.next == null) endMarker.next = newNode;
            
            listSize++;
            return newNode;
        }
        private Node insertNode (Node target, int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            if (newNode.next == null) endMarker.next = newNode;
            
            listSize++;
            return target;
        }
        public int get (int pos){
            if (getNode(pos)==null){
                return 0;
            } else return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                return null;
            }
            Node head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            if (pos > 0 || pos < size()){
                deleteNode (getNode(0),pos);
            }
        }
        private Node deleteNode (Node head, int pos){
            
            if (pos == 0){
                beginMarker.next = head.next;
                if (head.next == null) endMarker.next = null;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node temp;
                temp = head.next.next;
                if (head.next.next == null) endMarker.next = head;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (int value){
            return searchNode(value);
        }
        private int searchNode (int value){
            
            for (int i = 0; i < size(); i++){
                if (get(i) == value){
                    return i;
                }
            }
            return -1;
        }
        public int popCards (){
            int headCard = beginMarker.next.data;
            int tailCard = endMarker.next.data;
            if (headCard > tailCard){ 
                delete(0);
                return headCard;
            } else {
                delete(size()-1);
                return tailCard;
            }
        }
        public void sumeCards (int value, int pos){
            int previousValue = get(pos);
            if (pos < size()) delete(pos);
            insert(value+previousValue, pos);
        }
        public String comparePlayers (){
            int max = 0;
            String posMax = "";
            for (int i = 0; i < size(); i++){
                if (get(i)>max) {
                    max = get(i);
                    posMax = Integer.toString(i+1);
                } else if(get(i) == max){
                    posMax = posMax+" "+Integer.toString(i+1);
                }
            }
            return posMax;
        }
        
        
        public static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public int data;
            public Node next;
        }
        
        int listSize;
        Node beginMarker;
        Node endMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package juegocartas;

import java.util.Scanner;

/**
 *
 */
public class JuegoCartas {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner in = new Scanner (System.in);
        int T, N, K, Pi;
        
        while (in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                   // Cartas en el mazo
                K = in.nextInt();                   // Numero jugadores
                MyLinkedList cardStuck = new MyLinkedList();
                MyLinkedList playerList = new MyLinkedList();
                
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    Pi = in.nextInt();              // Valores de cartas
                    cardStuck.insert(Pi, j);
                }
                
                if (K > N) K = N;
                int prevCount = N/K;
                for (int j = 0; j < N; j++){
                    int count = (N-(j+1))/K;
                    
                    if (prevCount != count) {
                        for (int k = 0; k < K; k++){
                            if (!cardStuck.isEmpty()) {
                                playerList.sumeCards(cardStuck.popCards(), k);
                            }
                        }
                    }
                    
                    prevCount = count;
                }
                System.out.println(playerList.comparePlayers());
            }
        }
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            endMarker = new Node();
            endMarker.next = null;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(int value, int pos){
            
            if (pos > 0 && pos <= size()){
                insertNode (getNode(pos-1),value);
            } else if (pos == 0){
                insertHead(value);
            }
        }
        private Node insertHead (int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            if(newNode.next == null) endMarker.next = newNode;
            
            listSize++;
            return newNode;
        }
        private Node insertNode (Node target, int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            if (newNode.next == null) endMarker.next = newNode;
            
            listSize++;
            return target;
        }
        public int get (int pos){
            if (getNode(pos)==null){
                return 0;
            } else return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                return null;
            }
            Node head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            if (pos > 0 || pos < size()){
                deleteNode (getNode(0),pos);
            }
        }
        private Node deleteNode (Node head, int pos){
            
            if (pos == 0){
                beginMarker.next = head.next;
                if (head.next == null) endMarker.next = null;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node temp;
                temp = head.next.next;
                if (head.next.next == null) endMarker.next = head;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (int value){
            return searchNode(value);
        }
        private int searchNode (int value){
            
            for (int i = 0; i < size(); i++){
                if (get(i) == value){
                    return i;
                }
            }
            return -1;
        }
        public int popCards (){
            int headCard = beginMarker.next.data;
            int tailCard = endMarker.next.data;
            if (headCard > tailCard){ 
                delete(0);
                return headCard;
            } else {
                delete(size()-1);
                return tailCard;
            }
        }
        public void sumeCards (int value, int pos){
            int previousValue = get(pos);
            if (pos < size()) delete(pos);
            insert(value+previousValue, pos);
        }
        public String comparePlayers (){
            int max = 0;
            String posMax = "";
            for (int i = 0; i < size(); i++){
                if (get(i)>max) {
                    max = get(i);
                    posMax = Integer.toString(i+1);
                } else if(get(i) == max){
                    posMax = posMax+" "+Integer.toString(i+1);
                }
            }
            return posMax;
        }
        
        
        public static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public int data;
            public Node next;
        }
        
        int listSize;
        Node beginMarker;
        Node endMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package costoasociado;


import java.util.Scanner;

/**
 *
 */
public class CostoAsociado {

    /**
     * @param args the command line arguments
     */
    
    public static void main(String[] args) {
        //
        Scanner in = new Scanner(System.in);
        int T, N, value, pos;
        String comando;
        
        while(in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                MyLinkedList linkList = new MyLinkedList();
                N = in.nextInt();                   // Cantidad de comandos
                in.nextLine();
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    comando = in.nextLine();
                    String[] cmd = new String [3];
                    cmd = comando.split(" ");
                    
                    if (cmd[0].contentEquals("insertar")){
                        value = Integer.parseInt(cmd[1]);
                        pos = Integer.parseInt(cmd[2]);
                        linkList.insert(value, pos);
                        // arrList.insert(value,pos);
                        
                    } else if (cmd[0].contentEquals("consultar")){
                        pos = Integer.parseInt(cmd[1]);
                        if (pos < 0 || pos >= linkList.size()){
                            System.out.println("consulta: no encontrado");
                        } else System.out.println("consulta: "+linkList.get(pos));
                        // arrList.consultar(pos);
                        
                    } else if (cmd[0].contentEquals("eliminar")){
                        pos = Integer.parseInt(cmd[1]);
                        linkList.delete(pos);
                        // eliminar(pos);
                        
                    } else if (cmd[0].contentEquals("buscar")){
                        value = Integer.parseInt(cmd[1]);
                        if(linkList.search(value) == -1) {
                            System.out.println("no existe numero");
                        } else System.out.println("buscar: "+linkList.search(value));
                        // arrList.buscar(value);
                        
                    } else if (cmd[0].contentEquals("costo")){
                        System.out.println("costo: "+linkList.costo());
                    } 
                }
            }
        }
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(int value, int pos){
            
            operationCost = 0;
            if (pos < 0 || pos > size()){
                operationCost += size();
                System.out.println("insertar: posicion invalida");
            } else if (pos == 0){
                insertHead(value);
            } else insertNode (getNode(pos-1),value);
        }
        private Node insertHead (int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            
            listSize++;
            System.out.println("insertar: posicion valida");
            return newNode;
        }
        private Node insertNode (Node target, int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            
            listSize++;
            System.out.println("insertar: posicion valida");
            return target;
        }
        public int get (int pos){
            
            operationCost = 0;
            return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                System.out.println("consulta: no encontrado");
                operationCost += size();
                return null;
            }
            Node head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            operationCost++;
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            operationCost = 0;
            if (pos < 0 || pos >= size()){
                operationCost += size();
                System.out.println("eliminar: posicion invalida");
            } else {
                deleteNode (getNode(0),pos);
                System.out.println("eliminar: posicion valida");
            }
        }
        private Node deleteNode (Node head, int pos){
            
            operationCost++;
            if (pos == 0){
                beginMarker.next = head.next;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node temp;
                temp = head.next.next;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (int value){
            operationCost = 0;
            return searchNode(getNode(0), value);
        }
        private int searchNode (Node head, int value){
            
            operationCost++;
            for (int i = 0; i < size(); i++){
                if (get(i) == value){
                    return i;
                }
            }
            return -1;
        }
        public int costo(){
            return operationCost;
        }
        
        private static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public int data;
            public Node next;
        }
        
        int listSize;
        int operationCost;
        Node beginMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package casilleros;

import java.util.Scanner;
import java.util.Arrays;
import static java.util.Arrays.*;

/**
 *
 */
public class Casilleros {

    /**
     * @param args the command line arguments
     */
    public static int N, maxCubiculo;
    
    public static void main(String[] args) {
        Scanner in = new Scanner (System.in);
        
        while (in.hasNext()){
            int T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                       // Numero de cubiculos
                int lockerCounter = 0;                  // # total casilleros
                int [] Ki = new int [N];                // Capacidad por cubiculo
                int [] Pos = new int [2];
                String [] Position = new String [2];
                maxCubiculo = 0;                        // Tamano cubiculo >>
                
                MyLinkedList<String> nombres = new MyLinkedList();
                MyLinkedList<Integer> cedula = new MyLinkedList();
                MyLinkedList casillero = new MyLinkedList();
                
                for (int j = 0; j < N; j++){
                    Ki[j] = in.nextInt();               // Numero de casilleros
                    lockerCounter += Ki[j];
                    if(Ki[j]>maxCubiculo) maxCubiculo = Ki[j];
                }
                
                int [][] locker = new int [N][maxCubiculo];
                
                int P = in.nextInt();                   // Numero de comandos
                in.nextLine();
                for (int j = 0; j < P; j++) {
                    String [] comando = in.nextLine().split(" ");
                    //System.out.println("cmd[0] = "+comando[0]);
                    if (comando[0].equals("ingresar")) {
                        
                        if(lockerCounter <= 0){
                            System.out.println("limite alcanzado");
                        } else {
                        
                        nombres.insert(comando[1], 0);
                        cedula.insert(Integer.parseInt(comando[3]), 0);
                        
                        String insertarCasillero = insertarCasillero(locker, Ki); 
                        System.out.println(insertarCasillero);
                        casillero.insert(insertarCasillero, 0);
                        
                        Position = insertarCasillero.split(" ");
                        Pos[0] = Integer.valueOf(Position[0])-1;
                        Pos[1] = Integer.valueOf(Position[1])-1;
                        
                        locker[Pos[0]][Pos[1]] = 1;
                        lockerCounter--;
                    }
                    } else if (comando[0].equals("salir")){
                        int position = cedula.pickPosition(Integer.parseInt(comando[1]));
                        String name = nombres.pickValue(position).toString();
                        
                        Position = casillero.pickValue(position).toString().split(" ");
                        Pos[0] = Integer.valueOf(Position[0]);
                        Pos[1] = Integer.valueOf(Position[1]);
                        
                        System.out.println("Pos 0 = "+Pos[0]+" 1 = "+Pos[1]);
                        locker[Pos[0]-1][Pos[1]-1] = 0;
                        
                        System.out.println(name);
                        lockerCounter++;
                    }
                }
            }
        }
    }
    
    public static String insertarCasillero(int [][] Array, int [] lineMax){
        int [] sumaLinea = new int [N];
        float [] carga = new float [N];         // Carga del cubiculo
        float cargaMax = 0;
        int cubiculoCargaMax = 0;
        
        for (int i = 0; i<N; i++){
            for (int j = 0; j<maxCubiculo; j++){
                System.out.print(Array[i][j]+" ");
            }
            System.out.println(" ");
        }
        
        for (int i = 0; i < N; i++) {
            if(Array[i][0]==0) {
                Array[i][0]=1;
                return (String.valueOf(i+1)+" "+String.valueOf(0+1));
            } System.out.println("No array i 0");
            for (int j = 0; j < lineMax[i]; j++){
                sumaLinea[i] += Array[i][j];
            }
        }
        for (int i = 0; i < N; i++){
            carga[i] = lineMax[i]/sumaLinea[i];
            if (carga[i]>cargaMax) {
                cargaMax = carga[i];
                cubiculoCargaMax = i;
            }
        }
        for (int j = 0; j < lineMax[cubiculoCargaMax]; j++){
            if (Array[cubiculoCargaMax][j]==0) {
                Array[cubiculoCargaMax][j]=1;
                return (String.valueOf(cubiculoCargaMax+1)+" "+String.valueOf(j+1));
            }
        }
        
        return "hola";
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(AnyType value, int pos){
            
            if (pos > 0 && pos <= size()){
                insertNode (getNode(pos-1),value);
            } else if (pos == 0){
                insertHead(value);
            }
        }
        private Node insertHead (AnyType value){
            Node<AnyType> newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            
            listSize++;
            return newNode;
        }
        private Node insertNode (Node<AnyType> target, AnyType value){
            Node<AnyType> newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            
            listSize++;
            return target;
        }
        public Object get (int pos){
            
            return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                return null;
            }
            Node<AnyType> head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            if (pos > 0 || pos < size()){
                deleteNode (getNode(0),pos);
            }
        }
        private Node deleteNode (Node head, int pos){
            
            if (pos == 0){
                beginMarker.next = head.next;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node<AnyType> temp;
                temp = head.next.next;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (AnyType value){
            System.out.println("search "+value);
            return searchNode(value);
        }
        private int searchNode (AnyType value){
            
            for (int i = 0; i < size(); i++){
                if (get(i).equals(value)){
                    return i;
                }
            }
            return -1;
        }
        public int pickPosition (AnyType value){
            int pos = search(value);
            if (pos >= 0) delete(pos);
            return pos;
        }
        public Object pickValue (int pos){
            Object value = get(pos);
            delete(pos);
            return value;
        }
        
        private static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public AnyType data;
            public Node<AnyType> next;
        }
        
        int listSize;
        Node<AnyType> beginMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package casilleros;

import java.util.Scanner;
import java.util.Arrays;
import static java.util.Arrays.*;

/**
 *
 */
public class Casilleros {

    /**
     * @param args the command line arguments
     */
    public static int N, maxCubiculo;
    
    public static void main(String[] args) {
        Scanner in = new Scanner (System.in);
        
        while (in.hasNext()){
            int T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                
                System.out.println("Caso #"+i+":");
                
                N = in.nextInt();                       // Numero de cubiculos
                int lockerCounter = 0;                  // # total casilleros
                int [] Ki = new int [N];                // Capacidad por cubiculo
                int [] Pos = new int [2];
                String [] Position = new String [2];
                maxCubiculo = 0;                        // Tamano cubiculo >>
                
                MyLinkedList<String> nombres = new MyLinkedList();
                MyLinkedList<Integer> cedula = new MyLinkedList();
                MyLinkedList casillero = new MyLinkedList();
                
                for (int j = 0; j < N; j++){
                    Ki[j] = in.nextInt();               // Numero de casilleros
                    lockerCounter += Ki[j];
                    if(Ki[j]>maxCubiculo) maxCubiculo = Ki[j];
                }
                
                int [][] locker = new int [N][maxCubiculo];
                
                int P = in.nextInt();                   // Numero de comandos
                in.nextLine();
                for (int j = 0; j < P; j++) {
                    String [] comando = in.nextLine().split(" ");
                    //System.out.println("cmd[0] = "+comando[0]);
                    if (comando[0].equals("ingresar")) {
                        
                        if(lockerCounter <= 0){
                            System.out.println("limite alcanzado");
                        } else {
                        
                        nombres.insert(comando[1], 0);
                        cedula.insert(Integer.parseInt(comando[3]), 0);
                        
                        String insertarCasillero = insertarCasillero(locker, Ki); 
                        System.out.println(insertarCasillero);
                        casillero.insert(insertarCasillero, 0);
                        
                        Position = insertarCasillero.split(" ");
                        Pos[0] = Integer.valueOf(Position[0])-1;
                        Pos[1] = Integer.valueOf(Position[1])-1;
                        
                        locker[Pos[0]][Pos[1]] = 1;
                        lockerCounter--;
                    }
                    } else if (comando[0].equals("salir")){
                        int position = cedula.pickPosition(Integer.parseInt(comando[1]));
                        String name = nombres.pickValue(position).toString();
                        
                        Position = casillero.pickValue(position).toString().split(" ");
                        Pos[0] = Integer.valueOf(Position[0]);
                        Pos[1] = Integer.valueOf(Position[1]);
                        
                        System.out.println("Pos 0 = "+Pos[0]+" 1 = "+Pos[1]);
                        locker[Pos[0]-1][Pos[1]-1] = 0;
                        
                        System.out.println(name);
                        lockerCounter++;
                    }
                }
            }
        }
    }
    
    public static String insertarCasillero(int [][] Array, int [] lineMax){
        int [] sumaLinea = new int [N];
        float [] carga = new float [N];         // Carga del cubiculo
        float cargaMax = 0;
        int cubiculoCargaMax = 0;
        
        for (int i = 0; i < N; i++) {
            if(Array[i][0]==0) {
                Array[i][0]=1;
                return (String.valueOf(i+1)+" "+String.valueOf(0+1));
            }
            for (int j = 0; j < lineMax[i]; j++){
                sumaLinea[i] += Array[i][j];
            }
        }
        for (int i = 0; i < N; i++){
            carga[i] = lineMax[i]/sumaLinea[i];
            if (carga[i]>cargaMax) {
                cargaMax = carga[i];
                cubiculoCargaMax = i;
            }
        }
        for (int j = 0; j < lineMax[cubiculoCargaMax]; j++){
            if (Array[cubiculoCargaMax][j]==0) {
                Array[cubiculoCargaMax][j]=1;
                return (String.valueOf(cubiculoCargaMax+1)+" "+String.valueOf(j+1));
            }
        }
        
        return "hola";
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(AnyType value, int pos){
            
            if (pos > 0 && pos <= size()){
                insertNode (getNode(pos-1),value);
            } else if (pos == 0){
                insertHead(value);
            }
        }
        private Node insertHead (AnyType value){
            Node<AnyType> newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            
            listSize++;
            return newNode;
        }
        private Node insertNode (Node<AnyType> target, AnyType value){
            Node<AnyType> newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            
            listSize++;
            return target;
        }
        public Object get (int pos){
            
            return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                return null;
            }
            Node<AnyType> head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            if (pos > 0 || pos < size()){
                deleteNode (getNode(0),pos);
            }
        }
        private Node deleteNode (Node head, int pos){
            
            if (pos == 0){
                beginMarker.next = head.next;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node<AnyType> temp;
                temp = head.next.next;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (AnyType value){
            System.out.println("search "+value);
            return searchNode(value);
        }
        private int searchNode (AnyType value){
            
            for (int i = 0; i < size(); i++){
                if (get(i).equals(value)){
                    return i;
                }
            }
            return -1;
        }
        public int pickPosition (AnyType value){
            int pos = search(value);
            if (pos >= 0) delete(pos);
            return pos;
        }
        public Object pickValue (int pos){
            Object value = get(pos);
            delete(pos);
            return value;
        }
        
        private static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public AnyType data;
            public Node<AnyType> next;
        }
        
        int listSize;
        Node<AnyType> beginMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package juegocartas;

import java.util.Scanner;

/**
 *
 */
public class JuegoCartas {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner in = new Scanner (System.in);
        int T, N, K, Pi;
        
        while (in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                   // Cartas en el mazo
                K = in.nextInt();                   // Numero jugadores
                MyLinkedList cardStuck = new MyLinkedList();
                MyLinkedList playerList = new MyLinkedList();
                
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    Pi = in.nextInt();              // Valores de cartas
                    cardStuck.insert(Pi, j);
                }
                
                for (int j = 0; j < N; j++){
                    System.out.println(cardStuck.get(j)+" ");
                }
                
                if (K > N) K = N;
                int prevCount = N/K;
                for (int j = 0; j < N; j++){
                    int count = (N-(j+1))/K;
                    
                    if (prevCount != count) {
                        for (int k = 0; k < K; k++){
                            if (!cardStuck.isEmpty()) {
                                playerList.sumeCards(cardStuck.popCards(), k);
                            }
                        }
                    }
                    
                    prevCount = count;
                }
                System.out.println(playerList.comparePlayers());
            }
        }
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            endMarker = new Node();
            endMarker.next = null;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(int value, int pos){
            
            if (pos > 0 && pos <= size()){
                if (pos == size()) {
                    insertTail(value);
                }else insertNode (getNode(pos-1),value);
            } else if (pos == 0){
                insertHead(value);
            }
        }
        private Node insertHead (int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            if(newNode.next == null) endMarker.next = newNode;
            
            listSize++;
            return newNode;
        }
        private Node insertNode (Node target, int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            if (newNode.next == null) endMarker.next = newNode;
            
            listSize++;
            return target;
        }
        private Node insertTail (int value){
            Node newNode = new Node();
            newNode.data = value;
            endMarker.next.next = newNode;
            endMarker.next = newNode;
            newNode.next = null;
            
            listSize++;
            return newNode;
        }
        public int get (int pos){
            if (getNode(pos)==null){
                return 0;
            } else return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                return null;
            }
            Node head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            if (pos > 0 || pos < size()){
                deleteNode (getNode(0),pos);
            }
        }
        private Node deleteNode (Node head, int pos){
            
            if (pos == 0){
                beginMarker.next = head.next;
                if (head.next == null) endMarker.next = null;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node temp;
                temp = head.next.next;
                if (head.next.next == null) endMarker.next = head;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (int value){
            return searchNode(value);
        }
        private int searchNode (int value){
            
            for (int i = 0; i < size(); i++){
                if (get(i) == value){
                    return i;
                }
            }
            return -1;
        }
        public int popCards (){
            int headCard = beginMarker.next.data;
            int tailCard = endMarker.next.data;
            if (headCard > tailCard){ 
                delete(0);
                return headCard;
            } else {
                delete(size()-1);
                return tailCard;
            }
        }
        public void sumeCards (int value, int pos){
            int previousValue = get(pos);
            if (pos < size()) delete(pos);
            insert(value+previousValue, pos);
        }
        public String comparePlayers (){
            int max = 0;
            String posMax = "";
            for (int i = 0; i < size(); i++){
                if (get(i)>max) {
                    max = get(i);
                    posMax = Integer.toString(i+1);
                } else if(get(i) == max){
                    posMax = posMax+" "+Integer.toString(i+1);
                }
            }
            return posMax;
        }
        
        
        public static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public int data;
            public Node next;
        }
        
        int listSize;
        Node beginMarker;
        Node endMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package juegocartas;

import java.util.Scanner;

/**
 *
 */
public class JuegoCartas {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner in = new Scanner (System.in);
        int T, N, K, Pi;
        
        while (in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                   // Cartas en el mazo
                K = in.nextInt();                   // Numero jugadores
                MyLinkedList cardStuck = new MyLinkedList();
                MyLinkedList playerList = new MyLinkedList();
                
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    Pi = in.nextInt();              // Valores de cartas
                    cardStuck.insert(Pi, j);
                }
                
                if (K > N) K = N;
                int prevCount = N/K;
                for (int j = 0; j < N; j++){
                    int count = (N-(j+1))/K;
                    
                    if (prevCount != count) {
                        for (int k = 0; k < K; k++){
                            if (!cardStuck.isEmpty()) {
                                playerList.sumeCards(cardStuck.popCards(), k);
                            }
                        }
                    }
                    
                    prevCount = count;
                }
                System.out.println(playerList.comparePlayers());
            }
        }
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            endMarker = new Node();
            endMarker.next = null;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(int value, int pos){
            
            if (pos > 0 && pos <= size()){
                if (pos == size()) {
                    insertTail(value);
                }else insertNode (getNode(pos-1),value);
            } else if (pos == 0){
                insertHead(value);
            }
        }
        private Node insertHead (int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            if(newNode.next == null) endMarker.next = newNode;
            
            listSize++;
            return newNode;
        }
        private Node insertNode (Node target, int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            if (newNode.next == null) endMarker.next = newNode;
            
            listSize++;
            return target;
        }
        private Node insertTail (int value){
            Node newNode = new Node();
            newNode.data = value;
            endMarker.next.next = newNode;
            endMarker.next = newNode;
            newNode.next = null;
            
            listSize++;
            return newNode;
        }
        public int get (int pos){
            if (getNode(pos)==null){
                return 0;
            } else return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                return null;
            }
            Node head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            if (pos > 0 || pos < size()){
                deleteNode (getNode(0),pos);
            }
        }
        private Node deleteNode (Node head, int pos){
            
            if (pos == 0){
                beginMarker.next = head.next;
                if (head.next == null) endMarker.next = null;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node temp;
                temp = head.next.next;
                if (head.next.next == null) endMarker.next = head;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (int value){
            return searchNode(value);
        }
        private int searchNode (int value){
            
            for (int i = 0; i < size(); i++){
                if (get(i) == value){
                    return i;
                }
            }
            return -1;
        }
        public int popCards (){
            int headCard = beginMarker.next.data;
            int tailCard = endMarker.next.data;
            if (headCard > tailCard){ 
                delete(0);
                return headCard;
            } else {
                delete(size()-1);
                return tailCard;
            }
        }
        public void sumeCards (int value, int pos){
            int previousValue = get(pos);
            if (pos < size()) delete(pos);
            insert(value+previousValue, pos);
        }
        public String comparePlayers (){
            int max = 0;
            String posMax = "";
            for (int i = 0; i < size(); i++){
                if (get(i)>max) {
                    max = get(i);
                    posMax = Integer.toString(i+1);
                } else if(get(i) == max){
                    posMax = posMax+" "+Integer.toString(i+1);
                }
            }
            return posMax;
        }
        
        
        public static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public int data;
            public Node next;
        }
        
        int listSize;
        Node beginMarker;
        Node endMarker;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package juegocartas;

import java.util.Scanner;

/**
 *
 */
public class JuegoCartas {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner in = new Scanner (System.in);
        int T, N, K, Pi;
        
        while (in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                   // Cartas en el mazo
                K = in.nextInt();                   // Numero jugadores
                MyLinkedList<Integer> cardStuck = new MyLinkedList();
                MyLinkedList<Integer> playerList = new MyLinkedList();
                
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    Pi = in.nextInt();              // Valores de cartas
                    cardStuck.add(j, Pi);
                }
                
                if (K > N) K = N;
                int prevCount = N/K;
                for (int j = 0; j < N; j++){
                    int count = (N-(j+1))/K;
                    if (prevCount != count) {
                        for (int k = 0; k < K; k++){
                            if (!cardStuck.isEmpty()) {
                                
                                if (playerList.size() >= K){
                                    int previousValue = playerList.get(k);
                                    int value = cardStuck.popCards();
                                    
                                    playerList.set(k, value+previousValue);
                                } else {
                                    playerList.add(k, cardStuck.popCards());
                                }
                            }
                        }
                    }
                    
                    prevCount = count;
                }
                System.out.println(playerList.comparePlayers());
            }
        }
    }
    
    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( ) {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( ) {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ) {
        return theSize;
    }
    
    public boolean isEmpty( ) {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( ) {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    public AnyType popCards (){
        AnyType headCard = beginMarker.next.data;
        AnyType tailCard = get(size()-1);
        
        if (Integer.parseInt(headCard.toString()) > Integer.parseInt(tailCard.toString())){
            remove(0);
            return headCard;
        } else {
            remove(getNode(size()-1));
            return tailCard;
        }
    }

    public String comparePlayers (){
        int max = 0;
        String posMax = "";
        for (int i = 0; i < size(); i++){
            if (Integer.parseInt(get(i).toString()) > max) {
                max = Integer.parseInt(get(i).toString());
                posMax = Integer.toString(i+1);
            } else if(Integer.parseInt(get(i).toString()) == max){
                posMax = posMax+" "+Integer.toString(i+1);
            }
        }
        return posMax;
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType> {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package juegocartas;

import java.util.Scanner;

/**
 *
 */
public class JuegoCartas {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner in = new Scanner (System.in);
        int T, N, K, Pi;
        
        while (in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                   // Cartas en el mazo
                K = in.nextInt();                   // Numero jugadores
                MyLinkedList<Integer> cardStuck = new MyLinkedList();
                MyLinkedList<Integer> playerList = new MyLinkedList();
                
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    Pi = in.nextInt();              // Valores de cartas
                    cardStuck.add(j, Pi);
                }
                
                if (K > N) K = N;
                int prevCount = N/K;
                for (int j = 0; j < N; j++){
                    int count = (N-(j+1))/K;
                    if (prevCount != count) {
                        for (int k = 0; k < K; k++){
                            if (!cardStuck.isEmpty()) {
                                
                                if (playerList.size() >= K){
                                    int previousValue = playerList.get(k);
                                    int value = cardStuck.popCards();
                                    
                                    playerList.set(k, value+previousValue);
                                } else {
                                    playerList.add(k, cardStuck.popCards());
                                }
                            }
                        }
                    }
                    
                    prevCount = count;
                }
                System.out.println(playerList.comparePlayers());
            }
        }
    }
    
    public static class MyLinkedList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( ) {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( ) {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ) {
        return theSize;
    }
    
    public boolean isEmpty( ) {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( ) {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    public AnyType popCards (){
        AnyType headCard = beginMarker.next.data;
        AnyType tailCard = get(size()-1);
        
        if (Integer.parseInt(headCard.toString()) > Integer.parseInt(tailCard.toString())){
            remove(0);
            return headCard;
        } else {
            remove(getNode(size()-1));
            return tailCard;
        }
    }

    public String comparePlayers (){
        int max = 0;
        String posMax = "";
        for (int i = 0; i < size(); i++){
            if (Integer.parseInt(get(i).toString()) > max) {
                max = Integer.parseInt(get(i).toString());
                posMax = Integer.toString(i+1);
            } else if(Integer.parseInt(get(i).toString()) == max){
                posMax = posMax+" "+Integer.toString(i+1);
            }
        }
        return posMax;
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType> {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package costoasociado;


import java.util.Scanner;

/**
 *
 */
public class CostoAsociado {

    /**
     * @param args the command line arguments
     */
    
    public static void main(String[] args) {
        //
        Scanner in = new Scanner(System.in);
        int T, N, value, pos;
        String comando;
        
        while(in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                MyLinkedList linkList = new MyLinkedList();
                int costoArray = 0, costoLinked = 0;
                N = in.nextInt();                   // Cantidad de comandos
                in.nextLine();
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    comando = in.nextLine();
                    String[] cmd = new String [3];
                    cmd = comando.split(" ");
                    
                    if (cmd[0].contentEquals("insertar")){
                        value = Integer.parseInt(cmd[1]);
                        pos = Integer.parseInt(cmd[2]);
                        costoArray += linkList.size() - pos;
                        costoLinked += pos;
                        linkList.insert(value, pos);
                        // arrList.insert(value,pos);
                        
                    } else if (cmd[0].contentEquals("consultar")){
                        pos = Integer.parseInt(cmd[1]);
                        if (pos < 0 || pos >= linkList.size()){
                            System.out.println("consulta: no encontrado");
                        } else {
                            System.out.println("consulta: "+linkList.get(pos));
                            costoLinked += pos;
                        }
                        // arrList.consultar(pos);
                        
                    } else if (cmd[0].contentEquals("eliminar")){
                        pos = Integer.parseInt(cmd[1]);
                        costoArray += linkList.size()-pos-1;
                        costoLinked += pos;
                        linkList.delete(pos);
                        // eliminar(pos);
                        
                    } else if (cmd[0].contentEquals("buscar")){
                        value = Integer.parseInt(cmd[1]);
                        if(linkList.search(value) == -1) {
                            costoArray += linkList.size();
                            costoLinked += linkList.size();
                            System.out.println("no existe numero");
                        } else {
                            int position = linkList.search(value);
                            costoArray += position+1;
                            costoLinked += position+1;
                            System.out.println("buscar: "+position);
                        }
                        // arrList.buscar(value);
                        
                    } else if (cmd[0].contentEquals("costo")){
                        
                        System.out.println("costo: "+costoArray+" "+costoLinked);
                        //System.out.println("Costo Lista = "+linkList.costo());
                    } 
                }
            }
        }
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            operationCost = 0;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(int value, int pos){
            
            //operationCost = 0;
            if (pos < 0 || pos > size()){
                operationCost += size();
                System.out.println("insertar: posicion invalida");
            } else if (pos == 0){
                insertHead(value);
            } else insertNode (getNode(pos-1),value);
        }
        private Node insertHead (int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            
            listSize++;
            System.out.println("insertar: posicion valida");
            return newNode;
        }
        private Node insertNode (Node target, int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            
            listSize++;
            System.out.println("insertar: posicion valida");
            return target;
        }
        public int get (int pos){
            
            //operationCost = 0;
            return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                System.out.println("consulta: no encontrado");
                operationCost += size();
                return null;
            }
            Node head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            operationCost++;
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            //operationCost = 0;
            if (pos < 0 || pos >= size()){
                operationCost += size();
                System.out.println("eliminar: posicion invalida");
            } else {
                deleteNode (getNode(0),pos);
                System.out.println("eliminar: posicion valida");
            }
        }
        private Node deleteNode (Node head, int pos){
            
            operationCost++;
            if (pos == 0){
                beginMarker.next = head.next;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node temp;
                temp = head.next.next;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (int value){
            //operationCost = 0;
            return searchNode(getNode(0), value);
        }
        private int searchNode (Node head, int value){
            
            operationCost++;
            for (int i = 0; i < size(); i++){
                if (get(i) == value){
                    return i;
                }
            }
            return -1;
        }
        public int costo(){
            return operationCost;
        }
        
        private static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public int data;
            public Node next;
        }
        
        int listSize;
        int operationCost;
        Node beginMarker;
    }
    
    public class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package costoasociado;


import java.util.Scanner;

/**
 *
 */
public class CostoAsociado {

    /**
     * @param args the command line arguments
     */
    static int costoArray, costoLinked;
    
    public static void main(String[] args) {
        //
        Scanner in = new Scanner(System.in);
        int T, N, value, pos;
        String comando;
        
        while(in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                MyLinkedList linkList = new MyLinkedList();
                costoArray = 0; costoLinked = 0;
                N = in.nextInt();                   // Cantidad de comandos
                in.nextLine();
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    comando = in.nextLine();
                    String[] cmd = new String [3];
                    cmd = comando.split(" ");
                    
                    if (cmd[0].contentEquals("insertar")){
                        value = Integer.parseInt(cmd[1]);
                        pos = Integer.parseInt(cmd[2]);
                        linkList.insert(value, pos);
                        // arrList.insert(value,pos);
                        
                    } else if (cmd[0].contentEquals("consultar")){
                        pos = Integer.parseInt(cmd[1]);
                        if (pos < 0 || pos >= linkList.size()){
                            System.out.println("consulta: no encontrado");
                        } else {
                            System.out.println("consulta: "+linkList.get(pos));
                            costoLinked += pos;
                        }
                        // arrList.consultar(pos);
                        
                    } else if (cmd[0].contentEquals("eliminar")){
                        pos = Integer.parseInt(cmd[1]);
                        linkList.delete(pos);
                        // eliminar(pos);
                        
                    } else if (cmd[0].contentEquals("buscar")){
                        value = Integer.parseInt(cmd[1]);
                        if(linkList.search(value) == -1) {
                            costoArray += linkList.size();
                            costoLinked += linkList.size();
                            System.out.println("no existe numero");
                        } else {
                            int position = linkList.search(value);
                            costoArray += position+1;
                            costoLinked += position+1;
                            System.out.println("buscar: "+position);
                        }
                        // arrList.buscar(value);
                        
                    } else if (cmd[0].contentEquals("costo")){
                        
                        System.out.println("costo: "+costoArray+" "+costoLinked);
                        //System.out.println("Costo Lista = "+linkList.costo());
                    } 
                }
            }
        }
    }
    
    public static class MyLinkedList <AnyType> {
        
        public MyLinkedList (){
            doClear();
        }
        private void clear (){
            doClear();
        }
        public void doClear (){
            beginMarker = new Node();
            beginMarker.next = null;
            operationCost = 0;
            listSize = 0;
        }
        public int size (){
            return listSize;
        }
        public boolean isEmpty (){
            return size() == 0;
        }
        public void insert(int value, int pos){
            
            //operationCost = 0;
            if (pos < 0 || pos > size()){
                operationCost += size();
                System.out.println("insertar: posicion invalida");
            } else if (pos == 0){
                costoArray += size() - pos;
                costoLinked += pos;
                insertHead(value);
            } else {
                costoArray += size() - pos;
                costoLinked += pos;
                insertNode (getNode(pos-1),value);
            }
        }
        private Node insertHead (int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = beginMarker.next;
            beginMarker.next = newNode;
            
            listSize++;
            System.out.println("insertar: posicion valida");
            return newNode;
        }
        private Node insertNode (Node target, int value){
            Node newNode = new Node();
            newNode.data = value;
            newNode.next = target.next;
            target.next = newNode;
            
            listSize++;
            System.out.println("insertar: posicion valida");
            return target;
        }
        public int get (int pos){
            
            //operationCost = 0;
            return getNode(pos).data;
        }
        private Node getNode (int pos){
            if (pos < 0 || pos > size()){
                System.out.println("consulta: no encontrado");
                operationCost += size();
                return null;
            }
            Node head = beginMarker.next;
            return getNode(head, pos);
        }
        private Node getNode (Node head, int pos){
            
            operationCost++;
            if (pos == 0){
                return head;
            }
            
            return getNode (head.next, pos-1);
        }
        public void delete (int pos){
            
            //operationCost = 0;
            if (pos < 0 || pos >= size()){
                operationCost += size();
                System.out.println("eliminar: posicion invalida");
            } else {
                costoArray += size()-pos-1;
                costoLinked += pos;
                deleteNode (getNode(0),pos);
                System.out.println("eliminar: posicion valida");
            }
        }
        private Node deleteNode (Node head, int pos){
            
            operationCost++;
            if (pos == 0){
                beginMarker.next = head.next;
                head = null;
                listSize--;
                return head;
            }
            if (pos == 1){
                Node temp;
                temp = head.next.next;
                head.next = null;
                head.next = temp;
                listSize--;
                return head;
            }
            head.next = deleteNode(head.next,pos-1);
            return head;
        }
        public int search (int value){
            //operationCost = 0;
            return searchNode(getNode(0), value);
        }
        private int searchNode (Node head, int value){
            
            operationCost++;
            for (int i = 0; i < size(); i++){
                if (get(i) == value){
                    return i;
                }
            }
            return -1;
        }
        public int costo(){
            return operationCost;
        }
        
        private static class Node <AnyType> {
            /*public Node (AnyType value, Node n){
                data = value; next = n;
            }*/
            
            public int data;
            public Node next;
        }
        
        int listSize;
        int operationCost;
        Node beginMarker;
    }
    
    public class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package MyLinkedList;

import java.util.Scanner;

/**
 *
 */
   
    public class MyLinkedList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( ) {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( ) {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ) {
        return theSize;
    }
    
    public boolean isEmpty( ) {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( ) {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    public AnyType popCards (){
        AnyType headCard = beginMarker.next.data;
        AnyType tailCard = get(size()-1);
        
        if (Integer.parseInt(headCard.toString()) > Integer.parseInt(tailCard.toString())){
            remove(0);
            return headCard;
        } else {
            remove(getNode(size()-1));
            return tailCard;
        }
    }

    public String comparePlayers (){
        int max = 0;
        String posMax = "";
        for (int i = 0; i < size(); i++){
            if (Integer.parseInt(get(i).toString()) > max) {
                max = Integer.parseInt(get(i).toString());
                posMax = Integer.toString(i+1);
            } else if(Integer.parseInt(get(i).toString()) == max){
                posMax = posMax+" "+Integer.toString(i+1);
            }
        }
        return posMax;
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType> {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
    
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner in = new Scanner (System.in);
        int T, N, K, Pi;
        
        while (in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                   // Cartas en el mazo
                K = in.nextInt();                   // Numero jugadores
                MyLinkedList<Integer> cardStuck = new MyLinkedList();
                MyLinkedList<Integer> playerList = new MyLinkedList();
                
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    Pi = in.nextInt();              // Valores de cartas
                    cardStuck.add(j, Pi);
                }
                
                if (K > N) K = N;
                int prevCount = N/K;
                for (int j = 0; j < N; j++){
                    int count = (N-(j+1))/K;
                    if (prevCount != count) {
                        for (int k = 0; k < K; k++){
                            if (!cardStuck.isEmpty()) {
                                
                                if (playerList.size() >= K){
                                    int previousValue = playerList.get(k);
                                    int value = cardStuck.popCards();
                                    
                                    playerList.set(k, value+previousValue);
                                } else {
                                    playerList.add(k, cardStuck.popCards());
                                }
                            }
                        }
                    }
                    
                    prevCount = count;
                }
                System.out.println(playerList.comparePlayers());
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.util.Scanner;

/**
 *
 */
   
    public class MyLinkedList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty LinkedList.
     */
    public MyLinkedList( )
    {
        doClear( );
    }
    
    private void clear( ) {
        doClear( );
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void doClear( ) {
        beginMarker = new Node<>( null, null, null );
        endMarker = new Node<>( null, beginMarker, null );
        beginMarker.next = endMarker;
        
        theSize = 0;
        modCount++;
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( ) {
        return theSize;
    }
    
    public boolean isEmpty( ) {
        return size( ) == 0;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        
        add( size( ), x );   
        return true;         
    }
    
    /**
     * Adds an item to this collection, at specified position.
     * Items at or after that position are slid one position higher.
     * @param x any object.
     * @param idx position to add at.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */
    public void add( int idx, AnyType x )
    {
        addBefore( getNode( idx, 0, size( ) ), x );
    }
    
    /**
     * Adds an item to this collection, at specified position p.
     * Items at or after that position are slid one position higher.
     * @param p Node to add before.
     * @param x any object.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
     */    
    private void addBefore( Node<AnyType> p, AnyType x )
    {
        Node<AnyType> newNode = new Node<>( x, p.prev, p );
        newNode.prev.next = newNode;
        p.prev = newNode;
        theSize++;
        modCount++;
    }   
    
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        return getNode( idx ).data;
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws IndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        Node<AnyType> p = getNode( idx );
        AnyType oldVal = p.data;
        
        p.data = newVal;   
        return oldVal;
    }
    
    /**
     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
     * @param idx index to search at.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
     */
    private Node<AnyType> getNode( int idx )
    {
        return getNode( idx, 0, size( ) - 1 );
    }

    /**
     * Gets the Node at position idx, which must range from lower to upper.
     * @param idx index to search at.
     * @param lower lowest valid index.
     * @param upper highest valid index.
     * @return internal node corresponding to idx.
     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
     */    
    private Node<AnyType> getNode( int idx, int lower, int upper )
    {
        Node<AnyType> p;  
        if( idx < lower || idx > upper )
            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
        if( idx < size( ) / 2 ){
            p = beginMarker.next;
            for( int i = 0; i < idx; i++ )
                p = p.next;            
        }
        else{
            p = endMarker;
            for( int i = size( ); i > idx; i-- )
                p = p.prev;
        }         
        return p;
    }
    
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public AnyType remove( int idx )
    {
        return remove( getNode( idx ) );
    }
    
    /**
     * Removes the object contained in Node p.
     * @param p the Node containing the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( Node<AnyType> p )
    {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        theSize--;
        modCount++;
        
        return p.data;
    }
    
    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
        StringBuilder sb = new StringBuilder( "[ " );

        for( AnyType x : this )
            sb.append( x + " " );
        sb.append( "]" );

        return new String( sb );
    }

    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new LinkedListIterator( );
    }

    /**
     * This is the implementation of the LinkedListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyLinkedList.
     */
    private class LinkedListIterator implements java.util.Iterator<AnyType>
    {
        private Node<AnyType> current = beginMarker.next;
        private int expectedModCount = modCount;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current != endMarker;
        }
        
        public AnyType next( )
        {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !hasNext( ) )
                throw new java.util.NoSuchElementException( ); 
                   
            AnyType nextItem = current.data;
            current = current.next;
            okToRemove = true;
            return nextItem;
        }
        
        public void remove( ) {
            if( modCount != expectedModCount )
                throw new java.util.ConcurrentModificationException( );
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyLinkedList.this.remove( current.prev );
            expectedModCount++;
            okToRemove = false;       
        }
    }
    
    public AnyType popCards (){
        AnyType headCard = beginMarker.next.data;
        AnyType tailCard = get(size()-1);
        
        if (Integer.parseInt(headCard.toString()) > Integer.parseInt(tailCard.toString())){
            remove(0);
            return headCard;
        } else {
            remove(getNode(size()-1));
            return tailCard;
        }
    }

    public String comparePlayers (){
        int max = 0;
        String posMax = "";
        for (int i = 0; i < size(); i++){
            if (Integer.parseInt(get(i).toString()) > max) {
                max = Integer.parseInt(get(i).toString());
                posMax = Integer.toString(i+1);
            } else if(Integer.parseInt(get(i).toString()) == max){
                posMax = posMax+" "+Integer.toString(i+1);
            }
        }
        return posMax;
    }
    
    /**
     * This is the doubly-linked list node.
     */
    private static class Node<AnyType> {
        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
        {
            data = d; prev = p; next = n;
        }
        
        public AnyType data;
        public Node<AnyType>   prev;
        public Node<AnyType>   next;
    }
    
    private int theSize;
    private int modCount = 0;
    private Node<AnyType> beginMarker;
    private Node<AnyType> endMarker;
    
    public static void main(String[] args) {
        // TODO code application logic here
        Scanner in = new Scanner (System.in);
        int T, N, K, Pi;
        
        while (in.hasNext()){
            T = in.nextInt();                       // Casos de prueba
            
            for (int i = 0; i < T; i++){
                N = in.nextInt();                   // Cartas en el mazo
                K = in.nextInt();                   // Numero jugadores
                MyLinkedList<Integer> cardStuck = new MyLinkedList();
                MyLinkedList<Integer> playerList = new MyLinkedList();
                
                System.out.println("Caso #"+(i+1)+":");
                
                for (int j = 0; j < N; j++){
                    Pi = in.nextInt();              // Valores de cartas
                    cardStuck.add(j, Pi);
                }
                
                if (K > N) K = N;
                int prevCount = N/K;
                for (int j = 0; j < N; j++){
                    int count = (N-(j+1))/K;
                    if (prevCount != count) {
                        for (int k = 0; k < K; k++){
                            if (!cardStuck.isEmpty()) {
                                
                                if (playerList.size() >= K){
                                    int previousValue = playerList.get(k);
                                    int value = cardStuck.popCards();
                                    
                                    playerList.set(k, value+previousValue);
                                } else {
                                    playerList.add(k, cardStuck.popCards());
                                }
                            }
                        }
                    }
                    
                    prevCount = count;
                }
                System.out.println(playerList.comparePlayers());
            }
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_a;

import java.util.*;

/**
 *
 */
public class TArboles_A {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner (System.in);
        while ( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba
            
            for (int i = 0; i < T; i++){
                System.out.println("Caso #"+(i+1)+":");
                int Q = in.nextInt();               // Numero de comandos
                BinarySearchTree <Integer> arbol = new BinarySearchTree<>();
                in.nextLine();
                
                for (int j = 0; j < Q; j++) {
                    String [] comando = in.nextLine().split(" ");
                    
                    switch (comando[0]) {
                        case "agregar":
                            arbol.insert(Integer.parseInt(comando[1]) );
                            break;
                        case "distancia":
                            int dist = arbol.distancia( Integer.parseInt(comando[1]), 
                                    Integer.parseInt(comando[2]) );
                            System.out.println("distancia: "+dist);
                            break;
                        case "ancestro":
                            int ans = arbol.ancestro( Integer.parseInt(comando[1]), 
                                    Integer.parseInt(comando[2]) );
                            System.out.println("ancestro: " + ans);
                            break;
                    }
                }
            }
        }
    }
    
    public static class BinarySearchTree<AnyType extends Comparable<? 
            super AnyType>>{
    /**
     * Construct the tree.
     */
    public BinarySearchTree( )
    {
        root = null;
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }
    
    public Integer ancestro (int u, int v) {
        BinaryNode a = ancestro((BinaryNode<Integer>) root, u, v);
        if ( a != null ) return (Integer) a.element;
        else return -1;
    }
    
    public Integer distancia (int u, int v){
        int distance = 0;
        BinaryNode node = ancestro((BinaryNode<Integer>) root, u, v);
        if ( node == null ) return -1;
        else {
            BinaryNode temp1 = node;
            
            while(temp1 != null) {
                if( u == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( u < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( u > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
            
            while ( temp1 != null ) {
                if( v == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( v < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( v > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
        } 
        return distance;
    }

    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the subtree.
     */
    private void printTree( BinaryNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    private int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return 1 + Math.max( height( t.left ), height( t.right ) );    
    }
    
    private BinaryNode ancestro (BinaryNode <Integer> root,int v1,int v2){
        Queue<String> v1path = new LinkedList<>();
        Queue<String> v2path = new LinkedList<>();
        String left = "l";
        String right = "r";
        BinaryNode <Integer> temp1;
        temp1 = root;
        BinaryNode <Integer> temp2;
        temp2 = root;
        boolean exist_v1 = false;
        boolean exist_v2 = false;
    
        while(temp1 != null)                //encuentra el camino de v1
            {
                if(v1 == temp1.element) {
                    exist_v1 = true;
                    break;
                }
                else if(v1 < temp1.element) {
                        v1path.add(left);
                        temp1 = temp1.left;
                }
                else if (v1 > temp1.element) {
                        v1path.add(right);
                        temp1 = temp1.right;
                }
        }
    
        while(temp2 != null) {          //encuentra el camino de v2
                if(v2 == temp2.element) {
                    exist_v2 = true;
                    break;
                }
                else if(v2 < temp2.element) {
                    v2path.add(left);
                    temp2 = temp2.left;
                }
                else {
                    v2path.add(right);
                    temp2 = temp2.right;
                }
        }
        
        if ( exist_v1 == false || exist_v2 == false ){
            return null;
        } else {
            temp1 = root;           // Inicia busqueda desde la raiz
            while(v1path.peek() != null && v2path.peek() != null) { //compara caminos
                if(v1path.peek() == v2path.peek()) {
                    if(v1path.peek() == "l"){   //take left
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.left;
                    } else {                    //take right
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.right;
                    }
                } else break;
            }
            return temp1;
        }
    }
    
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        BinaryNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_c;

import java.util.Arrays;
import java.util.Scanner;

/**
 *
 */
public class TArboles_C {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner ( System.in );
        int T = in.nextInt();                       // Casos de prueba
        for (int i = 0; i < T; i++) {
            System.out.println("Caso #"+(i+1));
            int n = in.nextInt();
            TreeNode [] valores = new TreeNode [n];
            int [] diferencias = new int [n];
            //System.out.println("size= "+valores.length);
            
            for (int j = 0; j < n; j++) {
                valores[j] = new TreeNode();
            }
            
            for (int j = 0; j < n; j++) {
                //System.out.println("j = "+j);
                valores[j].value = in.nextInt();
                valores[j].subTreeValue = valores[j].value;
            }
            
            for (int j = 0; j < n-1; j++) {
                int a = in.nextInt()-1;
                int b = in.nextInt()-1;
                if ( valores[a].left == null ){
                    valores[a].left = valores[b];
                    //System.out.print("l");
                } else {
                    valores[a].right = valores[b];
                    //System.out.print("r");
                }
                valores[b].up = valores[a];
                //System.out.println("");
            }
            
            for (int j = 0; j < n; j++) {
                //System.out.print("n: "+valores[j].value);
                if (valores[j].right != null ) {
                    //System.out.print(". r: "+valores[j].right.value);
                }
                if ( valores [j].left != null ){
                    //System.out.print(". l: "+valores[j].left.value);
                }
                //System.out.println("");
                TreeNode temp = valores[j];
                
                while ( temp.up != null ){
                    temp.up.subTreeValue += valores[j].value;
                    temp = temp.up;
                    //System.out.println("SubTVal = "+temp.subTreeValue+". n = "+temp.value);
                }
            }
            
            for (int j = 0; j < n; j++) {
                diferencias[j] = Math.abs(valores[0].subTreeValue - 2*valores[j].subTreeValue);
            }
            Arrays.sort(diferencias);
            System.out.println(diferencias[0]);//+" - "+diferencias[1]);
        }
    }
    
    static class TreeNode {
        TreeNode(){
            this.value = value;
            this.subTreeValue = subTreeValue;
            this.right = right;
            this.left = left;
            this.up = up;
        }
        int value;
        int subTreeValue;
        TreeNode right;
        TreeNode left;
        TreeNode up;
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_c;

import java.util.Arrays;
import java.util.Scanner;

/**
 *
 */
public class TArboles_C {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner ( System.in );
        int T = in.nextInt();                       // Casos de prueba
        for (int i = 0; i < T; i++) {
            System.out.println("Caso #"+(i+1)+":");
            int n = in.nextInt();
            TreeNode [] valores = new TreeNode [n];
            int [] diferencias = new int [n];
            //System.out.println("size= "+valores.length);
            
            for (int j = 0; j < n; j++) {
                valores[j] = new TreeNode();
            }
            
            for (int j = 0; j < n; j++) {
                //System.out.println("j = "+j);
                valores[j].value = in.nextInt();
                valores[j].subTreeValue = valores[j].value;
            }
            
            for (int j = 0; j < n-1; j++) {
                int a = in.nextInt()-1;
                int b = in.nextInt()-1;
                if ( valores[a].left == null ){
                    valores[a].left = valores[b];
                    //System.out.print("l");
                } else {
                    valores[a].right = valores[b];
                    //System.out.print("r");
                }
                valores[b].up = valores[a];
                //System.out.println("");
            }
            
            for (int j = 0; j < n; j++) {
                //System.out.print("n: "+valores[j].value);
                if (valores[j].right != null ) {
                    //System.out.print(". r: "+valores[j].right.value);
                }
                if ( valores [j].left != null ){
                    //System.out.print(". l: "+valores[j].left.value);
                }
                //System.out.println("");
                TreeNode temp = valores[j];
                
                while ( temp.up != null ){
                    temp.up.subTreeValue += valores[j].value;
                    temp = temp.up;
                    //System.out.println("SubTVal = "+temp.subTreeValue+". n = "+temp.value);
                }
            }
            
            for (int j = 0; j < n; j++) {
                diferencias[j] = Math.abs(valores[0].subTreeValue - 2*valores[j].subTreeValue);
            }
            Arrays.sort(diferencias);
            System.out.println(diferencias[0]);//+" - "+diferencias[1]);
        }
    }
    
    static class TreeNode {
        TreeNode(){
            this.value = value;
            this.subTreeValue = subTreeValue;
            this.right = right;
            this.left = left;
            this.up = up;
        }
        int value;
        int subTreeValue;
        TreeNode right;
        TreeNode left;
        TreeNode up;
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_a;

import java.util.Scanner;

/**
 *
 */
public class Heap_A {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner( System.in );
        
        while ( in.hasNext() ){
            int N = in.nextInt();           // Numeros en el arreglo
            BinaryHeap <Integer> numeros = new BinaryHeap();
            
            for (int i = 0; i < N; i++) {
                if ( numeros.currentSize < 2 ){
                    numeros.insert( -in.nextInt() );
                    System.out.println(-1);
                } else {
                    for (int j = 0; j < 3; j++) {
                        int a = numeros.deleteMin();
                        int b = numeros.deleteMin();
                        int c = 0;
                        boolean exist_c = false;
                        if ( !numeros.isEmpty() ) {
                            c = numeros.deleteMin();
                            exist_c = true;
                        }
                        int d = -in.nextInt();
                        int producto = 0;
                        if ( exist_c ){
                            if ( c > d ) {
                                producto = -a*b*d;
                                numeros.insert(d);
                            } else {
                                producto = -a*b*c;
                                numeros.insert(c);
                            }
                        } else {
                            producto = -a*b*d;
                            numeros.insert(d);
                        }
                        
                        numeros.insert(b);
                        numeros.insert(a);
                        System.out.println(producto);
                    } 
                }
            }
            
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_a;

import java.util.Scanner;

/**
 *
 */
public class Heap_A {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner( System.in );
        
        //while ( in.hasNext() ){
            int N = in.nextInt();           // Numeros en el arreglo
            BinaryHeap <Integer> numeros = new BinaryHeap();
            
            for (int i = 0; i < N; i++) {
                if ( numeros.currentSize < 2 ){
                    numeros.insert( -in.nextInt() );
                    System.out.println(-1);
                } else {
                    for (int j = 0; j < 3; j++) {
                        int a = numeros.deleteMin();
                        int b = numeros.deleteMin();
                        int c = 0;
                        boolean exist_c = false;
                        if ( !numeros.isEmpty() ) {
                            c = numeros.deleteMin();
                            exist_c = true;
                        }
                        int d = -in.nextInt();
                        int producto = 0;
                        if ( exist_c ){
                            if ( c > d ) {
                                producto = -a*b*d;
                                numeros.insert(d);
                            } else {
                                producto = -a*b*c;
                                numeros.insert(c);
                            }
                        } else {
                            producto = -a*b*d;
                            numeros.insert(d);
                        }
                        
                        numeros.insert(b);
                        numeros.insert(a);
                        System.out.println(producto);
                    } 
                }
            }
            
        //}
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_a;

import java.util.Scanner;

/**
 *
 */
public class Heap_A {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner( System.in );
        
        //while ( in.hasNext() ){
            int N = in.nextInt();           // Numeros en el arreglo
            BinaryHeap <Integer> numeros = new BinaryHeap();
            for (int i = 0; i < N; i++) {
                if ( numeros.currentSize < 2 ){
                    numeros.insert( -in.nextInt() );
                    System.out.println(-1);
                } else {
                    int a = numeros.deleteMin();
                    int b = numeros.deleteMin();
                    int c = 0;
                    boolean exist_c = false;
                    if ( !numeros.isEmpty() ) {
                        c = numeros.deleteMin();
                        exist_c = true;
                    }
                    int d = -in.nextInt();
                    int producto = 0;
                    if ( exist_c ){
                        if ( c > d ) {
                            producto = -a*b*d;
                            numeros.insert(d);
                        } else {
                            producto = -a*b*c;
                            numeros.insert(c);
                        }
                    } else {
                        producto = -a*b*d;
                        numeros.insert(d);
                    }
                        
                    numeros.insert(b);
                    numeros.insert(a);
                    System.out.println(producto);
                }
            }
            
        //}
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_a;

import java.util.Scanner;

/**
 *
 */
public class Heap_A {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner( System.in );
        
        while ( in.hasNext() ){
            int N = in.nextInt();           // Numeros en el arreglo
            BinaryHeap <Integer> numeros = new BinaryHeap();
            for (int i = 0; i < N; i++) {
                if ( numeros.currentSize < 2 ){
                    numeros.insert( -in.nextInt() );
                    System.out.println(-1);
                } else {
                    int a = numeros.deleteMin();
                    int b = numeros.deleteMin();
                    int c = 0;
                    boolean exist_c = false;
                    if ( !numeros.isEmpty() ) {
                        c = numeros.deleteMin();
                        exist_c = true;
                    }
                    int d = -in.nextInt();
                    int producto = 0;
                    if ( exist_c ){
                        if ( c > d ) {
                            producto = -a*b*d;
                            numeros.insert(d);
                        } else {
                            producto = -a*b*c;
                            numeros.insert(c);
                        }
                    } else {
                        producto = -a*b*d;
                        numeros.insert(d);
                    }
                        
                    numeros.insert(b);
                    numeros.insert(a);
                    System.out.println(producto);
                }
            }
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_d;

import java.util.Scanner;

/**
 *
 */
public class Heap_D {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner ( System.in );
        while ( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba
            
            for (int i = 0; i < T; i++) {
                System.out.println("Caso #"+(i+1)+":");
                int N = in.nextInt();               // Numero de carreras
                int [] tamanoCarrera = new int [N];
                MyArrayList <Float> promedios = new MyArrayList();
                BinaryHeap <Float> max = new BinaryHeap();
                BinaryHeap <Float> min = new BinaryHeap();
                
                in.nextLine();
                
                for (int j = 0; j < N; j++) {
                    String [] notas = in.nextLine().split(" ");
                    tamanoCarrera[j] = notas.length;
                    
                    for (int k = 0; k < tamanoCarrera[j]; k++) {
                        promedios.add(Float.parseFloat(notas[k]));
                    }
                }
                int Q = in.nextInt();
                in.nextLine();
                
                for (int j = 0; j < Q; j++) {
                    String [] comandos = in.nextLine().split(" ");
                    switch (comandos[0]) {
                        case "cambiar": {
                                int idx = Integer.parseInt(comandos[1]);
                                float x = Float.parseFloat(comandos[2]);
                                promedios.set(idx, x);
                                break;
                            }
                        case "consultar": {
                            int a = Integer.parseInt(comandos[1]);
                            int b = Integer.parseInt(comandos[2]);
                            
                            if (a!=b){
                                for (int k = a; k <= b; k++) {
                                    max.insert(-promedios.get(k));
                                    min.insert(promedios.get(k));
                                    }
                                
                                if (max.findMin() % 1 == 0) 
                                    System.out.print(Math.round(-max.findMin())+" ");
                                else System.out.print(-max.findMin()+" ");
                                if (min.findMin() % 1 == 0)
                                    System.out.println(Math.round(min.findMin()));
                                else System.out.println(min.findMin());
                                
                                max.makeEmpty();
                                min.makeEmpty();
                            } else {
                                if (promedios.get(a) % 1 == 0)
                                    System.out.println(Math.round(promedios.get(a))
                                    +" "+Math.round(promedios.get(a)));
                                else System.out.println(promedios.get(a)
                                    +" "+promedios.get(a));
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
    
    public AnyType pop (){
        return remove (size()-1);
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    public int maximum (){
        int max = 0;
        
        if(!isEmpty()){
            AnyType element = pop();
            int value = Integer.valueOf(element.toString());
            if (value > max) max = value;
            maximum();
            add(element);
        }
        
        return max;
    }
    
    private void maximum (int max){
        
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_av2;

import java.util.Scanner;

/**
 *
 */
public class Heap_Av2 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner ( System.in );
        while ( in.hasNext() ){
            int N = in.nextInt();
            MyArrayList <Integer> numeros = new MyArrayList<>();
            BinaryHeap <Integer> numOrdenados = new BinaryHeap<>();
            
            for (int i = 0; i < N; i++) {
                numeros.add(in.nextInt());
            }
            
            for (int i = 0; i < N; i++) {
                if ( i < 2 ) System.out.println("-1");
                else {
                    for (int j = 0; j <= i; j++)
                        numOrdenados.insert(-numeros.get(j));
                    int a = numOrdenados.deleteMin();
                    int b = numOrdenados.deleteMin();
                    int c = numOrdenados.deleteMin();
                    System.out.println(-a*b*c);
                }
            }
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
    
    public AnyType pop (){
        return remove (size()-1);
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    public int maximum (){
        int max = 0;
        
        if(!isEmpty()){
            AnyType element = pop();
            int value = Integer.valueOf(element.toString());
            if (value > max) max = value;
            maximum();
            add(element);
        }
        
        return max;
    }
    
    private void maximum (int max){
        
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_av2;

import java.util.Scanner;

/**
 *
 */
public class Heap_Av2 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner ( System.in );
        while ( in.hasNext() ){
            int N = in.nextInt();
            MyArrayList <Integer> numeros = new MyArrayList<>();
            BinaryHeap <Integer> numOrdenados = new BinaryHeap<>();
            
            for (int i = 0; i < N; i++) {
                numeros.add(in.nextInt());
            }
            
            for (int i = 0; i < N; i++) {
                numOrdenados.insert(-numeros.get(i));
                if ( i < 2 ) System.out.println("-1");
                else {
                    /*for (int j = 0; j <= i; j++)
                        numOrdenados.insert(-numeros.get(j));*/
                    int a = numOrdenados.deleteMin();
                    int b = numOrdenados.deleteMin();
                    int c = numOrdenados.findMin();
                    System.out.println(-a*b*c);
                    numOrdenados.insert(b);
                    numOrdenados.insert(a);
                }
            }
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
    
    public AnyType pop (){
        return remove (size()-1);
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    public int maximum (){
        int max = 0;
        
        if(!isEmpty()){
            AnyType element = pop();
            int value = Integer.valueOf(element.toString());
            if (value > max) max = value;
            maximum();
            add(element);
        }
        
        return max;
    }
    
    private void maximum (int max){
        
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_e;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

/**
 *
 */
public class TArboles_E {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner (System.in);
        while ( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba
            
            for (int i = 0; i < T; i++){
                System.out.println("Caso #"+(i+1)+":");
                int Q = in.nextInt();               // Numero de comandos
                BinarySearchTree <Integer> arbol = new BinarySearchTree<>();
                in.nextLine();
                
                for (int j = 0; j < Q; j++) {
                    String [] comando = in.nextLine().split(" ");
                    
                    switch (comando[0]) {
                        case "agregar":
                            arbol.insert(Integer.parseInt(comando[1]) );
                            break;
                        case "distancia":
                            int dist = arbol.distancia( Integer.parseInt(comando[1]), 
                                    Integer.parseInt( comando[2]) );
                            System.out.println("distancia: "+dist);
                            break;
                        case "ancestro":
                            int ans = arbol.ancestro( Integer.parseInt(comando[1]), 
                                    Integer.parseInt(comando[2]) );
                            System.out.println("ancestro: " + ans);
                            break;
                        case "contar":
                            System.out.println("contar: "+arbol.contar( 
                                    Integer.parseInt(comando[1]) ));
                            break;
                    }
                }
            }
        }
    }
    
    public static class BinarySearchTree<AnyType extends Comparable<? 
            super AnyType>>{
    /**
     * Construct the tree.
     */
    public BinarySearchTree( )
    {
        root = null;
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }
    
    public Integer ancestro (int u, int v) {
        BinaryNode a = ancestro((BinaryNode<Integer>) root, u, v);
        if ( a != null ) return (Integer) a.element;
        else return -1;
    }
    
    
    
    public Integer distancia (int u, int v){
        int distance = 0;
        BinaryNode node = ancestro((BinaryNode<Integer>) root, u, v);
        if ( node == null ) return -1;
        else {
            BinaryNode temp1 = node;
            
            while(temp1 != null) {
                if( u == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( u < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( u > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
            
            while ( temp1 != null ) {
                if( v == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( v < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( v > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
        } 
        return distance;
    }
    
    private BinaryNode find (AnyType x, BinaryNode<AnyType> temp){
        if (temp.element == null)
            return null;
        else {
            if ( temp.element == x ) 
                return temp;
            else if ( x.compareTo(temp.element) > 0 )
                return find (x,temp.right);
            else return find(x,temp.left);
        }
    }
    
    public Integer contar ( AnyType x ){
        int a = -1;
        BinaryNode node = contar (find(x, root),0);
        if (node != null) a = node.subTreeElements;
        return a;
    }
    
    private BinaryNode contar ( BinaryNode<AnyType> t, int count ){
        //System.out.println("t.element = "+t.element);
        if ( t == null ) return null;
        
        if ( t.right == null && t.left == null ){
            t.subTreeElements = 0;
            t.up.subTreeElements += 1;
            BinaryNode temp = t.up;
            while ( temp.up != null ){
                temp.up.subTreeElements += temp.subTreeElements;
                temp = temp.up;
            }
            //System.out.println("root count = "+root.subTreeElements);
            count = 1;
        } else {
            if (t.right != null )
                count ++;
                contar ( t.right, count );
            if ( t.left != null )
                count ++;
                contar ( t.left, count );
        }
        
        /*if ( t.right != null )
            t.subTreeElements += t.right.subTreeElements;
        if ( t.left != null )
            t.subTreeElements += t.left.subTreeElements;
        System.out.println("count = "+count);*/
        return t;
    }

    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 ){
            t.left = insert( x, t.left );
            t.left.up = t;
        }
        else if( compareResult > 0 ){
            t.right = insert( x, t.right );
            t.right.up = t;
        }
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the subtree.
     */
    private void printTree( BinaryNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    private int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return 1 + Math.max( height( t.left ), height( t.right ) );    
    }
    
    private BinaryNode ancestro (BinaryNode <Integer> root,int v1,int v2){
        Queue<String> v1path = new LinkedList<>();
        Queue<String> v2path = new LinkedList<>();
        String left = "l";
        String right = "r";
        BinaryNode <Integer> temp1;
        temp1 = root;
        BinaryNode <Integer> temp2;
        temp2 = root;
        boolean exist_v1 = false;
        boolean exist_v2 = false;
    
        while(temp1 != null)                //encuentra el camino de v1
            {
                if(v1 == temp1.element) {
                    exist_v1 = true;
                    break;
                }
                else if(v1 < temp1.element) {
                        v1path.add(left);
                        temp1 = temp1.left;
                }
                else if (v1 > temp1.element) {
                        v1path.add(right);
                        temp1 = temp1.right;
                }
        }
    
        while(temp2 != null) {          //encuentra el camino de v2
                if(v2 == temp2.element) {
                    exist_v2 = true;
                    break;
                }
                else if(v2 < temp2.element) {
                    v2path.add(left);
                    temp2 = temp2.left;
                }
                else {
                    v2path.add(right);
                    temp2 = temp2.right;
                }
        }
        
        if ( exist_v1 == false || exist_v2 == false ){
            return null;
        } else {
            temp1 = root;           // Inicia busqueda desde la raiz
            while(v1path.peek() != null && v2path.peek() != null) { //compara caminos
                if(v1path.peek() == v2path.peek()) {
                    if(v1path.peek() == "l"){   //take left
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.left;
                    } else {                    //take right
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.right;
                    }
                } else break;
            }
            return temp1;
        }
    }
    
    
    
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        BinaryNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            up = this.up;
            subTreeElements = this.subTreeElements;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
        BinaryNode<AnyType> up;
        int subTreeElements;
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;
    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_e;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

/**
 *
 */
public class TArboles_E {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner (System.in);
        while ( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba
            
            for (int i = 0; i < T; i++){
                System.out.println("Caso #"+(i+1)+":");
                int Q = in.nextInt();               // Numero de comandos
                BinarySearchTree <Integer> arbol = new BinarySearchTree<>();
                in.nextLine();
                
                for (int j = 0; j < Q; j++) {
                    String [] comando = in.nextLine().split(" ");
                    
                    switch (comando[0]) {
                        case "agregar":
                            arbol.insert(Integer.parseInt(comando[1]) );
                            break;
                        case "distancia":
                            int dist = arbol.distancia( Integer.parseInt(comando[1]), 
                                    Integer.parseInt( comando[2]) );
                            System.out.println("distancia: "+dist);
                            break;
                        case "ancestro":
                            int ans = arbol.ancestro( Integer.parseInt(comando[1]), 
                                    Integer.parseInt(comando[2]) );
                            System.out.println("ancestro: " + ans);
                            break;
                        case "contar":
                            System.out.println("contar: "+arbol.contar( 
                                    Integer.parseInt(comando[1]) ));
                            break;
                    }
                }
            }
        }
    }
    
    public static class BinarySearchTree<AnyType extends Comparable<? 
            super AnyType>>{
    /**
     * Construct the tree.
     */
    public BinarySearchTree( )
    {
        root = null;
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }
    
    public Integer ancestro (int u, int v) {
        BinaryNode a = ancestro((BinaryNode<Integer>) root, u, v);
        if ( a != null ) return (Integer) a.element;
        else return -1;
    }
    
    
    
    public Integer distancia (int u, int v){
        int distance = 0;
        BinaryNode node = ancestro((BinaryNode<Integer>) root, u, v);
        if ( node == null ) return -1;
        else {
            BinaryNode temp1 = node;
            
            while(temp1 != null) {
                if( u == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( u < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( u > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
            
            while ( temp1 != null ) {
                if( v == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( v < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( v > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
        } 
        return distance;
    }
    
    private BinaryNode find (AnyType x, BinaryNode<AnyType> temp){
        if (temp.element == null)
            return null;
        else {
            if ( temp.element == x ) 
                return temp;
            else if ( x.compareTo(temp.element) > 0 )
                return find (x,temp.right);
            else return find(x,temp.left);
        }
    }
    
    public Integer contar ( AnyType x ){
        int a = -1;
        BinaryNode nodeFound = find (x,root);
        if (nodeFound != null) {
            BinaryNode node = contar (nodeFound,0);
            a = node.subTreeElements;
        }
        return a;
    }
    
    private BinaryNode contar ( BinaryNode<AnyType> t, int count ){
        //System.out.println("t.element = "+t.element);
        if ( t == null ) return null;
        
        if ( t.right == null && t.left == null ){
            t.subTreeElements = 0;
            t.up.subTreeElements += 1;
            BinaryNode temp = t.up;
            while ( temp.up != null ){
                temp.up.subTreeElements += temp.subTreeElements;
                temp = temp.up;
            }
            //System.out.println("root count = "+root.subTreeElements);
            count = 1;
        } else {
            if (t.right != null )
                count ++;
                contar ( t.right, count );
            if ( t.left != null )
                count ++;
                contar ( t.left, count );
        }
        
        /*if ( t.right != null )
            t.subTreeElements += t.right.subTreeElements;
        if ( t.left != null )
            t.subTreeElements += t.left.subTreeElements;
        System.out.println("count = "+count);*/
        return t;
    }

    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 ){
            t.left = insert( x, t.left );
            t.left.up = t;
        }
        else if( compareResult > 0 ){
            t.right = insert( x, t.right );
            t.right.up = t;
        }
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the subtree.
     */
    private void printTree( BinaryNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    private int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return 1 + Math.max( height( t.left ), height( t.right ) );    
    }
    
    private BinaryNode ancestro (BinaryNode <Integer> root,int v1,int v2){
        Queue<String> v1path = new LinkedList<>();
        Queue<String> v2path = new LinkedList<>();
        String left = "l";
        String right = "r";
        BinaryNode <Integer> temp1;
        temp1 = root;
        BinaryNode <Integer> temp2;
        temp2 = root;
        boolean exist_v1 = false;
        boolean exist_v2 = false;
    
        while(temp1 != null)                //encuentra el camino de v1
            {
                if(v1 == temp1.element) {
                    exist_v1 = true;
                    break;
                }
                else if(v1 < temp1.element) {
                        v1path.add(left);
                        temp1 = temp1.left;
                }
                else if (v1 > temp1.element) {
                        v1path.add(right);
                        temp1 = temp1.right;
                }
        }
    
        while(temp2 != null) {          //encuentra el camino de v2
                if(v2 == temp2.element) {
                    exist_v2 = true;
                    break;
                }
                else if(v2 < temp2.element) {
                    v2path.add(left);
                    temp2 = temp2.left;
                }
                else {
                    v2path.add(right);
                    temp2 = temp2.right;
                }
        }
        
        if ( exist_v1 == false || exist_v2 == false ){
            return null;
        } else {
            temp1 = root;           // Inicia busqueda desde la raiz
            while(v1path.peek() != null && v2path.peek() != null) { //compara caminos
                if(v1path.peek() == v2path.peek()) {
                    if(v1path.peek() == "l"){   //take left
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.left;
                    } else {                    //take right
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.right;
                    }
                } else break;
            }
            return temp1;
        }
    }
    
    
    
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        BinaryNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            up = this.up;
            subTreeElements = this.subTreeElements;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
        BinaryNode<AnyType> up;
        int subTreeElements;
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;
    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_e;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

/**
 *
 */
public class TArboles_E {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner (System.in);
        while ( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba
            
            for (int i = 0; i < T; i++){
                System.out.println("Caso #"+(i+1)+":");
                int Q = in.nextInt();               // Numero de comandos
                BinarySearchTree <Integer> arbol = new BinarySearchTree<>();
                in.nextLine();
                
                for (int j = 0; j < Q; j++) {
                    String [] comando = in.nextLine().split(" ");
                    
                    switch (comando[0]) {
                        case "agregar":
                            arbol.insert(Integer.parseInt(comando[1]) );
                            break;
                        case "distancia":
                            int dist = arbol.distancia( Integer.parseInt(comando[1]), 
                                    Integer.parseInt( comando[2]) );
                            System.out.println("distancia: "+dist);
                            break;
                        case "ancestro":
                            int ans = arbol.ancestro( Integer.parseInt(comando[1]), 
                                    Integer.parseInt(comando[2]) );
                            System.out.println("ancestro: " + ans);
                            break;
                        case "contar":
                            System.out.println("contar: "+arbol.contar( 
                                    Integer.parseInt(comando[1]) ));
                            break;
                    }
                }
            }
        }
    }
    
    public static class BinarySearchTree<AnyType extends Comparable<? 
            super AnyType>>{
    /**
     * Construct the tree.
     */
    public BinarySearchTree( )
    {
        root = null;
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }
    
    public Integer ancestro (int u, int v) {
        BinaryNode a = ancestro((BinaryNode<Integer>) root, u, v);
        if ( a != null ) return (Integer) a.element;
        else return -1;
    }
    
    
    
    public Integer distancia (int u, int v){
        int distance = 0;
        BinaryNode node = ancestro((BinaryNode<Integer>) root, u, v);
        if ( node == null ) return -1;
        else {
            BinaryNode temp1 = node;
            
            while(temp1 != null) {
                if( u == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( u < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( u > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
            
            while ( temp1 != null ) {
                if( v == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( v < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( v > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
        } 
        return distance;
    }
    
    private BinaryNode find (AnyType x, BinaryNode<AnyType> temp){
        if (temp == null)
            return null;
        else {
            if ( temp.element == x ) 
                return temp;
            else if ( x.compareTo(temp.element) > 0 )
                return find (x,temp.right);
            else return find(x,temp.left);
        }
    }
    
    public Integer contar ( AnyType x ){
        int a = -1;
        BinaryNode<AnyType> nodeFound = find (x,root);
        if (nodeFound != null) {
            BinaryNode node = contar (nodeFound,0);
            a = node.subTreeElements;
        }
        return a;
    }
    
    private BinaryNode contar ( BinaryNode<AnyType> t, int count ){
        //System.out.println("t.element = "+t.element);
        if ( t == null ) return null;
        
        if ( t.right == null && t.left == null ){
            t.subTreeElements = 0;
            t.up.subTreeElements += 1;
            BinaryNode temp = t.up;
            while ( temp.up != null ){
                temp.up.subTreeElements += temp.subTreeElements;
                temp = temp.up;
            }
            //System.out.println("root count = "+root.subTreeElements);
            count = 1;
        } else {
            if (t.right != null )
                count ++;
                contar ( t.right, count );
            if ( t.left != null )
                count ++;
                contar ( t.left, count );
        }
        
        /*if ( t.right != null )
            t.subTreeElements += t.right.subTreeElements;
        if ( t.left != null )
            t.subTreeElements += t.left.subTreeElements;
        System.out.println("count = "+count);*/
        return t;
    }

    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 ){
            t.left = insert( x, t.left );
            t.left.up = t;
        }
        else if( compareResult > 0 ){
            t.right = insert( x, t.right );
            t.right.up = t;
        }
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the subtree.
     */
    private void printTree( BinaryNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    private int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return 1 + Math.max( height( t.left ), height( t.right ) );    
    }
    
    private BinaryNode ancestro (BinaryNode <Integer> root,int v1,int v2){
        Queue<String> v1path = new LinkedList<>();
        Queue<String> v2path = new LinkedList<>();
        String left = "l";
        String right = "r";
        BinaryNode <Integer> temp1;
        temp1 = root;
        BinaryNode <Integer> temp2;
        temp2 = root;
        boolean exist_v1 = false;
        boolean exist_v2 = false;
    
        while(temp1 != null)                //encuentra el camino de v1
            {
                if(v1 == temp1.element) {
                    exist_v1 = true;
                    break;
                }
                else if(v1 < temp1.element) {
                        v1path.add(left);
                        temp1 = temp1.left;
                }
                else if (v1 > temp1.element) {
                        v1path.add(right);
                        temp1 = temp1.right;
                }
        }
    
        while(temp2 != null) {          //encuentra el camino de v2
                if(v2 == temp2.element) {
                    exist_v2 = true;
                    break;
                }
                else if(v2 < temp2.element) {
                    v2path.add(left);
                    temp2 = temp2.left;
                }
                else {
                    v2path.add(right);
                    temp2 = temp2.right;
                }
        }
        
        if ( exist_v1 == false || exist_v2 == false ){
            return null;
        } else {
            temp1 = root;           // Inicia busqueda desde la raiz
            while(v1path.peek() != null && v2path.peek() != null) { //compara caminos
                if(v1path.peek() == v2path.peek()) {
                    if(v1path.peek() == "l"){   //take left
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.left;
                    } else {                    //take right
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.right;
                    }
                } else break;
            }
            return temp1;
        }
    }
    
    
    
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        BinaryNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
            up = this.up;
            subTreeElements = this.subTreeElements;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
        BinaryNode<AnyType> up;
        int subTreeElements;
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;
    
    }
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_d;

import java.util.*;

/**
 *
 */
public class TArboles_D {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner( System.in );
        
        while( in.hasNext() ){
            int q = in.nextInt();               // Numero de comandos
            in.nextLine();
            ArrayList <ListNode> arboles = new ArrayList();
            
            for (int i = 0; i < q; i++) {
                String [] comando = in.nextLine().split(" ");
                switch ( comando[0] ) {
                    case "insertar": {
                        int idx = Integer.parseInt(comando[1]);
                        int x = Integer.parseInt(comando[2]);
                        int j = 0;
                        if ( arboles.isEmpty() ) break;
                        while ( arboles.get(j).name != idx && arboles.get(j) != null){
                            j++;
                            if ( j == arboles.size()-1 ) break;
                        }
                        if ( arboles.get(j).name == idx )
                            arboles.get(j).arbol.insert( x, 1 );
                        break;
                    }
                    case "unir":{
                        int idx = Integer.parseInt(comando[1]);
                        int idy = Integer.parseInt(comando[2]);
                        int a = -1, b = -1;
                        boolean exista= false, existb = false;
                        
                        if ( arboles.isEmpty() ) break;
                        for (int j = 0; j < arboles.size(); j++) {
                            if ( arboles.get(j).name == idx ) {
                                a = j;
                                exista = true;
                            }
                            if ( arboles.get(j).name == idy ) {
                                b = j;
                                existb = true;
                            }
                            if ( exista && existb ) break;
                        }
                        if ( a == -1 || b == -1 ) break;
                        while (!arboles.get(b).arbol.isEmpty()){
                            int occur = arboles.get(b).arbol.ocurrenciaRoot();
                            int value = arboles.get(b).arbol.removeRoot();
                            //System.out.println("value: "+value+"main occur: "+occur);
                            arboles.get(a).arbol.insert(value, occur);
                        } arboles.remove(b);
                        
                        break;
                    }
                    case "contiene":{
                        int idx = Integer.parseInt(comando[1]);
                        int idy = Integer.parseInt(comando[2]);
                        int a = -1, b = -1;
                        boolean exista= false, existb = false;
                        if ( arboles.isEmpty() ) break;
                        
                        for (int j = 0; j < arboles.size(); j++) {
                            if ( arboles.get(j).name == idx ) {
                                a = j;
                                exista = true;
                            }
                            if ( arboles.get(j).name == idy ) {
                                b = j;
                                existb = true;
                            }
                            if ( exista && existb ) {
                                //System.out.println("existen");
                                arboles.get(a).arbol.containSubTree(arboles.get(b).arbol);
                                break;
                            }
                        }
                        if (!exista || !existb) {
                            //System.out.println("no existen");
                            break;
                        } //System.out.println("contiene: No");
                        break;
                    }
                    case "ocurrencia":{
                        int idx = Integer.parseInt(comando[1]);
                        int x = Integer.parseInt(comando[2]);
                        if ( arboles.isEmpty() ) break;
                        
                        for (int j = 0; j < arboles.size(); j++) {
                            if ( arboles.get(j).name == idx){
                                System.out.println("ocurrencia: "+
                                        arboles.get(j).arbol.ocurrencia(x) );
                            }
                        }
                        break;
                    }
                    case "crear": {
                            int idx = Integer.parseInt(comando[1]);
                            int x = Integer.parseInt(comando[2]);
                            ListNode nodo = new ListNode(idx, new AvlTree (x));
                            arboles.add(nodo);
                            break;
                        }
                }
            }
        }
    }
    
    public static class ListNode {

        public ListNode(int idx, AvlTree<Integer> tree) {
            name = idx;
            arbol = tree;
        }
        int name;
        AvlTree<Integer> arbol;
    }
    
    public static class AvlTree<AnyType extends Comparable<? super AnyType>> {
    /**
     * Construct the tree.
     */
    public AvlTree( AnyType value ) {
        root = new AvlNode(value);
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
         * @param occur
     */
    public void insert( AnyType x, int occur ) {
        AvlNode treeNode = find(x);
        //System.out.println("insrt occur: "+occur+". x: "+x);
        if ( treeNode != null ){
            treeNode.ocurrencia += occur;
        } else{
            root = insert( x, root );
            treeNode = find(x);
            treeNode.ocurrencia += (occur-1);
            //System.out.println("ocur: "+treeNode.ocurrencia+". elem: "+treeNode.element);
        }
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

       
    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.ocurrencia = findMin( t.right ).ocurrencia;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    
    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }
    
    public Integer ocurrencia ( AnyType x ){
        AvlNode <AnyType> temp = find( x );
        if ( temp == null ) return 0;
        else return temp.ocurrencia;
    }
    
    private AvlNode find ( AnyType x ){
        AvlNode <AnyType> t = root;
        if (t == null)
            return null;
        else {
            while( t.element != x ) {
                int compareResult = x.compareTo( t.element );
                
                if( compareResult < 0 ){
                    t = t.left;
                    if ( t == null ) return null;
                } else if( compareResult > 0 ){
                    t = t.right;
                    if ( t == null ) return null;
                }
            }
            return t;
        }
    }
    
    public AnyType removeRoot (){
        AvlNode <AnyType> t = root;
        AnyType value = t.element;
        remove(value);
        return value;
    }
    
    public Integer ocurrenciaRoot () {
        AvlNode <AnyType> t = root;
        //System.out.println("raiz: "+root.element+" occur: "+root.ocurrencia);
        //if ( root.right != null )System.out.print("root.right: "+root.right.element+". occur: "+root.right.ocurrencia);
        //if ( root.left != null )System.out.println(" root.left: "+root.left.element+". occur: "+root.left.ocurrencia);
        return root.ocurrencia;
    }
    
    public AnyType valorRoot () {
        AvlNode <AnyType> t = root;
        return root.element;
    }
    
    public void containSubTree ( AvlTree arbol2 ){
        AvlNode t = find((AnyType) arbol2.valorRoot());
        AvlNode temp = arbol2.root;
        AvlNode contain;
        
        if ( t == null ) System.out.println("contiene: No");
        else{
            //System.out.println("t element: "+t.element+"temp elem: "+temp.element);
            contain = containSubTree( t, temp );
            if ( contain != null )
                System.out.println("contiene: Yes");
            else System.out.println("contiene: No");
        }
    }
    
    private AvlNode containSubTree ( AvlNode mainTree, AvlNode SecondTree ){
        //System.out.println("secondNode = "+SecondTree.element);
        //System.out.println("t.right = "+mainTree.right.element);
        if ( SecondTree.right != null ){
            //System.out.println("tree.right = "+SecondTree.right.element);
            if ( mainTree.right == null ) {
                //System.out.println("right null");
                return null;
            }
            if ( mainTree.right.element == SecondTree.right.element )
                containSubTree(mainTree.right, SecondTree.right);
            else return null;
        } else return root;
        if ( SecondTree.left != null ){
            //System.out.println("tree.left = "+SecondTree.left.element);
            if ( mainTree.left == null ) {
                //System.out.println("left null");
                return null;
            }
            if ( mainTree.left.element == SecondTree.left.element )
                containSubTree(mainTree.left, SecondTree.left);
            else return null;
        } else return root;
        //System.out.println("return mainTree: "+mainTree.element);
        return root;
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    // Assume t is either balanced or within one of being balanced
    private AvlNode<AnyType> balance( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<AnyType> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    
    
    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
        
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  // Duplicate; do nothing
        return balance( t );
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the tree.
     * @return node containing the smallest item.
     */
    private AvlNode<AnyType> findMin( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the tree.
     * @return node containing the largest item.
     */
    private AvlNode<AnyType> findMax( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the tree.
     * @return true if x is found in subtree.
     */
    private boolean contains( AnyType x, AvlNode<AnyType> t )
    {
        while( t != null )
        {
            int compareResult = x.compareTo( t.element );
            
            if( compareResult < 0 )
                t = t.left;
            else if( compareResult > 0 )
                t = t.right;
            else
                return true;    // Match
        }

        return false;   // No match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the tree.
     */
    private void printTree( AvlNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Return the height of node t, or -1, if null.
     */
    private int height( AvlNode<AnyType> t )
    {
        return t == null ? -1 : t.height;
    }

    /**
     * Rotate binary tree node with left child.
     * For AVL trees, this is a single rotation for case 1.
     * Update heights, then return new root.
     */
    private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 )
    {
        AvlNode<AnyType> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }

    /**
     * Rotate binary tree node with right child.
     * For AVL trees, this is a single rotation for case 4.
     * Update heights, then return new root.
     */
    private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 )
    {
        AvlNode<AnyType> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }

    /**
     * Double rotate binary tree node: first left child
     * with its right child; then node k3 with new left child.
     * For AVL trees, this is a double rotation for case 2.
     * Update heights, then return new root.
     */
    private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }

    /**
     * Double rotate binary tree node: first right child
     * with its left child; then node k1 with new right child.
     * For AVL trees, this is a double rotation for case 3.
     * Update heights, then return new root.
     */
    private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }

    private static class AvlNode<AnyType> {
            // Constructors
        AvlNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        AvlNode( AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element    = theElement;
            left       = lt;
            right      = rt;
            height     = 0;
            ocurrencia = 1+this.ocurrencia;
        }

        AnyType           element;      // The data in the node
        AvlNode<AnyType>  left;         // Left child
        AvlNode<AnyType>  right;        // Right child
        int               height;       // Height
        int               ocurrencia;   // Ocurrencia
    }

      /** The tree root. */
    private AvlNode<AnyType> root;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_d;

import java.util.*;

/**
 *
 */
public class TArboles_D {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner( System.in );
        
        while( in.hasNext() ){
            int q = in.nextInt();               // Numero de comandos
            in.nextLine();
            ArrayList <ListNode> arboles = new ArrayList();
            
            for (int i = 0; i < q; i++) {
                String [] comando = in.nextLine().split(" ");
                switch ( comando[0] ) {
                    case "insertar": {
                        int idx = Integer.parseInt(comando[1]);
                        int x = Integer.parseInt(comando[2]);
                        int j = 0;
                        if ( arboles.isEmpty() ) break;
                        while ( arboles.get(j).name != idx && arboles.get(j) != null){
                            j++;
                            if ( j == arboles.size()-1 ) break;
                        }
                        if ( arboles.get(j).name == idx )
                            arboles.get(j).arbol.insert( x, 1 );
                        break;
                    }
                    case "unir":{
                        int idx = Integer.parseInt(comando[1]);
                        int idy = Integer.parseInt(comando[2]);
                        int a = -1, b = -1;
                        boolean exista= false, existb = false;
                        
                        if ( arboles.isEmpty() ) break;
                        for (int j = 0; j < arboles.size(); j++) {
                            if ( arboles.get(j).name == idx ) {
                                a = j;
                                exista = true;
                            }
                            if ( arboles.get(j).name == idy ) {
                                b = j;
                                existb = true;
                            }
                            if ( exista && existb ) break;
                        }
                        if ( a == -1 || b == -1 ) break;
                        while (!arboles.get(b).arbol.isEmpty()){
                            int occur = arboles.get(b).arbol.ocurrenciaRoot();
                            int value = arboles.get(b).arbol.removeRoot();
                            //System.out.println("value: "+value+"main occur: "+occur);
                            arboles.get(a).arbol.insert(value, occur);
                        } arboles.remove(b);
                        
                        break;
                    }
                    case "contiene":{
                        int idx = Integer.parseInt(comando[1]);
                        int idy = Integer.parseInt(comando[2]);
                        int a = -1, b = -1;
                        boolean exista= false, existb = false;
                        if ( arboles.isEmpty() ) break;
                        
                        for (int j = 0; j < arboles.size(); j++) {
                            if ( arboles.get(j).name == idx ) {
                                a = j;
                                exista = true;
                            }
                            if ( arboles.get(j).name == idy ) {
                                b = j;
                                existb = true;
                            }
                            if ( exista && existb ) {
                                //System.out.println("existen");
                                arboles.get(a).arbol.containSubTree(arboles.get(b).arbol);
                                break;
                            }
                        }
                        if (!exista || !existb) {
                            //System.out.println("no existen");
                            break;
                        } //System.out.println("contiene: No");
                        break;
                    }
                    case "ocurrencia":{
                        int idx = Integer.parseInt(comando[1]);
                        int x = Integer.parseInt(comando[2]);
                        if ( arboles.isEmpty() ) break;
                        
                        for (int j = 0; j < arboles.size(); j++) {
                            if ( arboles.get(j).name == idx){
                                System.out.println("ocurrencia: "+
                                        arboles.get(j).arbol.ocurrencia(x) );
                            }
                        }
                        break;
                    }
                    case "crear": {
                            int idx = Integer.parseInt(comando[1]);
                            int x = Integer.parseInt(comando[2]);
                            ListNode nodo = new ListNode(idx, new AvlTree (x));
                            arboles.add(nodo);
                            break;
                        }
                }
            }
        }
    }
    
    public static class ListNode {

        public ListNode(int idx, AvlTree<Integer> tree) {
            name = idx;
            arbol = tree;
        }
        int name;
        AvlTree<Integer> arbol;
    }
    
    public static class AvlTree<AnyType extends Comparable<? super AnyType>> {
    /**
     * Construct the tree.
     */
    public AvlTree( AnyType value ) {
        root = new AvlNode(value);
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
         * @param occur
     */
    public void insert( AnyType x, int occur ) {
        AvlNode treeNode = find(x);
        //System.out.println("insrt occur: "+occur+". x: "+x);
        if ( treeNode != null ){
            treeNode.ocurrencia += occur;
        } else{
            root = insert( x, root );
            treeNode = find(x);
            treeNode.ocurrencia += (occur-1);
            //System.out.println("ocur: "+treeNode.ocurrencia+". elem: "+treeNode.element);
        }
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

       
    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private AvlNode<AnyType> remove( AnyType x, AvlNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.ocurrencia = findMin( t.right ).ocurrencia;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return balance( t );
    }
    
    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }
    
    public Integer ocurrencia ( AnyType x ){
        AvlNode <AnyType> temp = find( x );
        if ( temp == null ) return 0;
        else return temp.ocurrencia;
    }
    
    private AvlNode find ( AnyType x ){
        AvlNode <AnyType> t = root;
        if (t == null)
            return null;
        else {
            while( t.element != x ) {
                int compareResult = x.compareTo( t.element );
                
                if( compareResult < 0 ){
                    t = t.left;
                    if ( t == null ) return null;
                } else if( compareResult > 0 ){
                    t = t.right;
                    if ( t == null ) return null;
                }
            }
            return t;
        }
    }
    
    public AnyType removeRoot (){
        AvlNode <AnyType> t = root;
        AnyType value = t.element;
        remove(value);
        return value;
    }
    
    public Integer ocurrenciaRoot () {
        AvlNode <AnyType> t = root;
        //System.out.println("raiz: "+root.element+" occur: "+root.ocurrencia);
        //if ( root.right != null )System.out.print("root.right: "+root.right.element+". occur: "+root.right.ocurrencia);
        //if ( root.left != null )System.out.println(" root.left: "+root.left.element+". occur: "+root.left.ocurrencia);
        return root.ocurrencia;
    }
    
    public AnyType valorRoot () {
        AvlNode <AnyType> t = root;
        return root.element;
    }
    
    public void containSubTree ( AvlTree arbol2 ){
        AvlNode t = find((AnyType) arbol2.valorRoot());
        AvlNode temp = arbol2.root;
        AvlNode contain;
        
        if ( t == null ) System.out.println("contiene: No");
        else{
            //System.out.println("t element: "+t.element+"temp elem: "+temp.element);
            contain = containSubTree( t, temp );
            if ( contain != null )
                System.out.println("contiene: Yes");
            else System.out.println("contiene: No");
        }
    }
    
    private AvlNode containSubTree ( AvlNode mainTree, AvlNode SecondTree ){
        //System.out.println("secondNode = "+SecondTree.element);
        //System.out.println("t.right = "+mainTree.right.element);
        if ( SecondTree.right != null ){
            //System.out.println("tree.right = "+SecondTree.right.element);
            if ( mainTree.right == null ) {
                //System.out.println("right null");
                return null;
            }
            if ( mainTree.right.element == SecondTree.right.element )
                containSubTree(mainTree.right, SecondTree.right);
            else return null;
        } else return root;
        if ( SecondTree.left != null ){
            //System.out.println("tree.left = "+SecondTree.left.element);
            if ( mainTree.left == null ) {
                //System.out.println("left null");
                return null;
            }
            if ( mainTree.left.element == SecondTree.left.element )
                containSubTree(mainTree.left, SecondTree.left);
            else return null;
        } else return root;
        //System.out.println("return mainTree: "+mainTree.element);
        return root;
    }

    private static final int ALLOWED_IMBALANCE = 1;
    
    // Assume t is either balanced or within one of being balanced
    private AvlNode<AnyType> balance( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;
        
        if( height( t.left ) - height( t.right ) > ALLOWED_IMBALANCE )
            if( height( t.left.left ) >= height( t.left.right ) )
                t = rotateWithLeftChild( t );
            else
                t = doubleWithLeftChild( t );
        else
        if( height( t.right ) - height( t.left ) > ALLOWED_IMBALANCE )
            if( height( t.right.right ) >= height( t.right.left ) )
                t = rotateWithRightChild( t );
            else
                t = doubleWithRightChild( t );

        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    public void checkBalance( )
    {
        checkBalance( root );
    }
    
    private int checkBalance( AvlNode<AnyType> t )
    {
        if( t == null )
            return -1;
        
        if( t != null )
        {
            int hl = checkBalance( t.left );
            int hr = checkBalance( t.right );
            if( Math.abs( height( t.left ) - height( t.right ) ) > 1 ||
                    height( t.left ) != hl || height( t.right ) != hr )
                System.out.println( "OOPS!!" );
        }
        
        return height( t );
    }
    
    
    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private AvlNode<AnyType> insert( AnyType x, AvlNode<AnyType> t )
    {
        if( t == null )
            return new AvlNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
        
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  // Duplicate; do nothing
        return balance( t );
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the tree.
     * @return node containing the smallest item.
     */
    private AvlNode<AnyType> findMin( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;

        while( t.left != null )
            t = t.left;
        return t;
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the tree.
     * @return node containing the largest item.
     */
    private AvlNode<AnyType> findMax( AvlNode<AnyType> t )
    {
        if( t == null )
            return t;

        while( t.right != null )
            t = t.right;
        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the tree.
     * @return true if x is found in subtree.
     */
    private boolean contains( AnyType x, AvlNode<AnyType> t )
    {
        while( t != null )
        {
            int compareResult = x.compareTo( t.element );
            
            if( compareResult < 0 )
                t = t.left;
            else if( compareResult > 0 )
                t = t.right;
            else
                return true;    // Match
        }

        return false;   // No match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the tree.
     */
    private void printTree( AvlNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Return the height of node t, or -1, if null.
     */
    private int height( AvlNode<AnyType> t )
    {
        return t == null ? -1 : t.height;
    }

    /**
     * Rotate binary tree node with left child.
     * For AVL trees, this is a single rotation for case 1.
     * Update heights, then return new root.
     */
    private AvlNode<AnyType> rotateWithLeftChild( AvlNode<AnyType> k2 )
    {
        AvlNode<AnyType> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max( height( k2.left ), height( k2.right ) ) + 1;
        k1.height = Math.max( height( k1.left ), k2.height ) + 1;
        return k1;
    }

    /**
     * Rotate binary tree node with right child.
     * For AVL trees, this is a single rotation for case 4.
     * Update heights, then return new root.
     */
    private AvlNode<AnyType> rotateWithRightChild( AvlNode<AnyType> k1 )
    {
        AvlNode<AnyType> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max( height( k1.left ), height( k1.right ) ) + 1;
        k2.height = Math.max( height( k2.right ), k1.height ) + 1;
        return k2;
    }

    /**
     * Double rotate binary tree node: first left child
     * with its right child; then node k3 with new left child.
     * For AVL trees, this is a double rotation for case 2.
     * Update heights, then return new root.
     */
    private AvlNode<AnyType> doubleWithLeftChild( AvlNode<AnyType> k3 )
    {
        k3.left = rotateWithRightChild( k3.left );
        return rotateWithLeftChild( k3 );
    }

    /**
     * Double rotate binary tree node: first right child
     * with its left child; then node k1 with new right child.
     * For AVL trees, this is a double rotation for case 3.
     * Update heights, then return new root.
     */
    private AvlNode<AnyType> doubleWithRightChild( AvlNode<AnyType> k1 )
    {
        k1.right = rotateWithLeftChild( k1.right );
        return rotateWithRightChild( k1 );
    }

    private static class AvlNode<AnyType> {
            // Constructors
        AvlNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        AvlNode( AnyType theElement, AvlNode<AnyType> lt, AvlNode<AnyType> rt )
        {
            element    = theElement;
            left       = lt;
            right      = rt;
            height     = 0;
            ocurrencia = 1+this.ocurrencia;
        }

        AnyType           element;      // The data in the node
        AvlNode<AnyType>  left;         // Left child
        AvlNode<AnyType>  right;        // Right child
        int               height;       // Height
        int               ocurrencia;   // Ocurrencia
    }

      /** The tree root. */
    private AvlNode<AnyType> root;
    }

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_b;

import java.util.*;

/**
 *
 */
public class Heap_B {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new  Scanner( System.in );
        while( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba 
            System.out.println("ok");
            
            for (int i = 0; i < T; i++) {
                int n = in.nextInt();               // Numero de trabajos en cola
                int m = in.nextInt();               // Posicion trabajo pedido
                int contador = 1;
                Queue <Node> pendientes = new LinkedList();
                BinaryHeap <Integer> prioridades = new BinaryHeap();
                
                for (int j = 0; j < n; j++) {
                    int prioridad = in.nextInt();
                    Node elemento = new Node();
                    elemento.posicion = j;
                    elemento.prioridad = prioridad;
                    prioridades.insert(-prioridad);
                    pendientes.add(elemento);
                }
                while( !prioridades.isEmpty() ){
                    Node elemento = pendientes.remove();
                    if ( elemento.prioridad == -prioridades.findMin() ){
                        if ( elemento.posicion == m ) {
                            if ( !prioridades.isEmpty() )
                                
                            System.out.println( contador );
                            break;
                        } else contador++;
                        prioridades.deleteMin();
                    } else pendientes.add(elemento);
                    //System.out.println("n: "+prioridades.deleteMin());
                }
            }
        }        
    }
    
    public static class Node {
        public Node (){
            this.posicion = posicion;
            this.prioridad = prioridad;
        }
        int posicion;
        int prioridad;
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
    
    public AnyType pop (){
        return remove (size()-1);
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    public int maximum (){
        int max = 0;
        
        if(!isEmpty()){
            AnyType element = pop();
            int value = Integer.valueOf(element.toString());
            if (value > max) max = value;
            maximum();
            add(element);
        }
        
        return max;
    }
    
    private void maximum (int max){
        
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_b;

import java.util.*;

/**
 *
 */
public class Heap_B {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new  Scanner( System.in );
        while( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba 
            //System.out.println("okokokokokokokokokokok");
            
            for (int i = 0; i < T; i++) {
                int n = in.nextInt();               // Numero de trabajos en cola
                int m = in.nextInt();               // Posicion trabajo pedido
                int contador = 1;
                Queue <Node> pendientes = new LinkedList();
                BinaryHeap <Integer> prioridades = new BinaryHeap();
                
                for (int j = 0; j < n; j++) {
                    int prioridad = in.nextInt();
                    Node elemento = new Node();
                    elemento.posicion = j;
                    elemento.prioridad = prioridad;
                    prioridades.insert(-prioridad);
                    pendientes.add(elemento);
                }
                while( !prioridades.isEmpty() ){
                    Node elemento = pendientes.remove();
                    if ( elemento.prioridad == -prioridades.findMin() ){
                        if ( elemento.posicion == m ) {
                            if ( !prioridades.isEmpty() )
                                
                            System.out.println( contador );
                            break;
                        } else contador++;
                        prioridades.deleteMin();
                    } else pendientes.add(elemento);
                    //System.out.println("n: "+prioridades.deleteMin());
                }
            }
        }        
    }
    
    public static class Node {
        public Node (){
            this.posicion = posicion;
            this.prioridad = prioridad;
        }
        int posicion;
        int prioridad;
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
    
    public AnyType pop (){
        return remove (size()-1);
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    public int maximum (){
        int max = 0;
        
        if(!isEmpty()){
            AnyType element = pop();
            int value = Integer.valueOf(element.toString());
            if (value > max) max = value;
            maximum();
            add(element);
        }
        
        return max;
    }
    
    private void maximum (int max){
        
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_e;

import java.util.*;

/**
 *
 */
public class Heap_E {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner( System.in );
        while ( in.hasNext() ){
            int N = in.nextInt();                   // Tamano arreglo
            int K = in.nextInt();                   // Numero de elementos a mult
            BinaryHeap <Integer> numProducto = new BinaryHeap<>();
            Queue <Integer> temp = new LinkedList();
            
            for (int i = 0; i < N; i++)
                numProducto.insert(in.nextInt());
            
            for (int i = 0; i < N; i++) {
                int producto = 1;
                if ( i < K-1 ) System.out.println("-1");
                else{
                    for (int j = 0; j <= i; j++) {
                        int a = numProducto.deleteMin();
                        temp.add(a);
                        producto *= a;
                    }
                    for (int j = 0; j < K; j++) {
                        numProducto.insert(temp.remove());
                    }
                    System.out.println(producto);
                }
            }
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_e;

import java.util.*;

/**
 *
 */
public class Heap_E {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner( System.in );
        //while ( in.hasNext() ){
            int N = in.nextInt();                   // Tamano arreglo
            int K = in.nextInt();                   // Numero de elementos a mult
            BinaryHeap <Integer> numProducto = new BinaryHeap<>();
            Queue <Integer> temp = new LinkedList();
            
            for (int i = 0; i < N; i++)
                numProducto.insert(in.nextInt());
            
            for (int i = 0; i < N; i++) {
                int producto = 1;
                if ( i < K-1 ) System.out.println("-1");
                else{
                    for (int j = 0; j <= i; j++) {
                        int a = numProducto.deleteMin();
                        temp.add(a);
                        producto *= a;
                    }
                    for (int j = 0; j < K; j++) {
                        numProducto.insert(temp.remove());
                    }
                    System.out.println(producto);
                }
            }
        //}
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_e;

import java.util.*;

/**
 *
 */
public class Heap_E {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner( System.in );
        //while ( in.hasNext() ){
            int N = in.nextInt();                   // Tamano arreglo
            int K = in.nextInt();                   // Numero de elementos a mult
            BinaryHeap <Integer> numProducto = new BinaryHeap<>();
            Queue <Integer> temp = new LinkedList();
            
            
            for (int i = 0; i < N; i++) {
                numProducto.insert( -in.nextInt() );
                int producto = 1;
                
                if ( i < K-1 ) System.out.println("-1");
                else{
                    for (int j = 0; j < K; j++) {
                        int a = -numProducto.deleteMin();
                        //System.out.println("a: "+a);
                        temp.add(a);
                        producto *= a;
                    }
                    for (int j = 0; j < K; j++) {
                        numProducto.insert( -temp.remove() );
                    }
                    System.out.println(producto);
                }
            }
        //}
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_e;

import java.util.*;

/**
 *
 */
public class Heap_E {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner( System.in );
        while ( in.hasNext() ){
            int N = in.nextInt();                   // Tamano arreglo
            int K = in.nextInt();                   // Numero de elementos a mult
            BinaryHeap <Integer> numProducto = new BinaryHeap<>();
            Queue <Integer> temp = new LinkedList();
            
            
            for (int i = 0; i < N; i++) {
                numProducto.insert( -in.nextInt() );
                int producto = 1;
                
                if ( i < K-1 ) System.out.println("-1");
                else{
                    for (int j = 0; j < K; j++) {
                        int a = -numProducto.deleteMin();
                        //System.out.println("a: "+a);
                        temp.add(a);
                        producto *= a;
                    }
                    for (int j = 0; j < K; j++) {
                        numProducto.insert( -temp.remove() );
                    }
                    System.out.println(producto);
                }
            }
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package hash_b;

import java.util.*;

/**
 *
 */
public class Hash_B {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner( System.in );
        while( in.hasNext() ){
            int T = in.nextInt();                       // Casos de prueba
            SeparateChainingHashTable <Integer> hash = new SeparateChainingHashTable();
            Queue <Integer> orden = new LinkedList();
            
            for (int i = 0; i < T; i++) {
                System.out.println("Caso #"+(i+1)+":");
                int N = in.nextInt();                   // Cantidad # en seq.
                int count = 0;
                
                for (int j = 0; j < N; j++) {
                    int num = in.nextInt();
                    hash.insert( num );
                    orden.add( num );
                }
                for (int j = 0; j < N; j++) {
                    //System.out.println("size: "+hash.currentSize);
                    int num = orden.remove();
                    if ( hash.contains( num ) ){
                        System.out.println(num+" "+hash.repeated( num ));
                        hash.remove(num);
                    }
                    //System.out.println("exist2: "+hash.contains(num));
                }
            }
        }
    }
    
    // SeparateChaining Hash table class
//
// CONSTRUCTION: an approximate initial size or default of 101
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// void makeEmpty( )      --> Remove all items

/**
 * Separate chaining table implementation of hash tables.
 * Note that all "matching" is based on the equals method.
 * @param <AnyType>
 */
    public static class SeparateChainingHashTable<AnyType> {
    /**
     * Construct the hash table.
     */
        public SeparateChainingHashTable( ) {
            this( DEFAULT_TABLE_SIZE );
        }

    /**
     * Construct the hash table.
     * @param size approximate table size.
     */
        public SeparateChainingHashTable( int size ) {
            theLists = new LinkedList[ nextPrime( size ) ];
            for( int i = 0; i < theLists.length; i++ )
                theLists[ i ] = new LinkedList<>( );
        }

    /**
     * Insert into the hash table. If the item is
     * already present, then do nothing.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            List<AnyType> whichList = theLists[ myhash( x ) ];
            if( !whichList.contains( x ) ) {
                whichList.add( x );
                // Rehash; see Section 5.5
                if( ++currentSize > theLists.length )
                    rehash( );
                repeated[ myhash( x ) ] = 1;
            } else
                repeated[ myhash( x ) ]++;
        }

    /**
     * Remove from the hash table.
     * @param x the item to remove.
     */
    public void remove( AnyType x ) {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        if( whichList.contains( x ) ) {
            whichList.remove( x );
            currentSize--;
        }
    }

    /**
     * Find an item in the hash table.
     * @param x the item to search for.
     * @return true if x is found.
     */
    public boolean contains( AnyType x ) {
        List<AnyType> whichList = theLists[ myhash( x ) ];
        return whichList.contains( x );
    }

    /**
     * Make the hash table logically empty.
     */
    public void makeEmpty( ) {
        for( int i = 0; i < theLists.length; i++ )
            theLists[ i ].clear( );
        currentSize = 0;  
    }

    /**
     * A hash routine for String objects.
     * @param key the String to hash.
     * @param tableSize the size of the hash table.
     * @return the hash value.
     */
    public static int hash( String key, int tableSize )
    {
        int hashVal = 0;

        for( int i = 0; i < key.length( ); i++ )
            hashVal = 37 * hashVal + key.charAt( i );

        hashVal %= tableSize;
        if( hashVal < 0 )
            hashVal += tableSize;

        return hashVal;
    }
    
    public int repeated ( AnyType x ){
        return repeated[ myhash( x ) ];
    }

    private void rehash( )
    {
        List<AnyType> [ ]  oldLists = theLists;

            // Create new double-sized, empty table
        theLists = new List[ nextPrime( 2 * theLists.length ) ];
        for( int j = 0; j < theLists.length; j++ )
            theLists[ j ] = new LinkedList<>( );

            // Copy table over
        currentSize = 0;
        for( List<AnyType> list : oldLists )
            for( AnyType item : list )
                insert( item );
    }

    private int myhash( AnyType x )
    {
        int hashVal = x.hashCode( );

        hashVal %= theLists.length;
        if( hashVal < 0 )
            hashVal += theLists.length;

        return hashVal;
    }
    
    private static final int DEFAULT_TABLE_SIZE = 101;

        /** The array of Lists. */
    private List<AnyType> [ ] theLists; 
    private int currentSize;
    private int [] repeated = new int [1000001];

    /**
     * Internal method to find a prime number at least as large as n.
     * @param n the starting number (must be positive).
     * @return a prime number larger than or equal to n.
     */
    @SuppressWarnings("empty-statement")
    private static int nextPrime( int n )
    {
        if( n % 2 == 0 )
            n++;

        for( ; !isPrime( n ); n += 2 )
            ;

        return n;
    }

    /**
     * Internal method to test if a number is prime.
     * Not an efficient algorithm.
     * @param n the number to test.
     * @return the result of the test.
     */
    private static boolean isPrime( int n )
    {
        if( n == 2 || n == 3 )
            return true;

        if( n == 1 || n % 2 == 0 )
            return false;

        for( int i = 3; i * i <= n; i += 2 )
            if( n % i == 0 )
                return false;

        return true;
    }
}
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_b;

import java.util.*;

/**
 *
 */
public class Heap_B {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new  Scanner( System.in );
        while( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba 
            //System.out.println("okokokokokokokokokokok");
            
            for (int i = 0; i < T; i++) {
                int n = in.nextInt();               // Numero de trabajos en cola
                int m = in.nextInt();               // Posicion trabajo pedido
                int contador = 1;
                Queue <Node> pendientes = new LinkedList();
                BinaryHeap <Integer> prioridades = new BinaryHeap();
                
                for (int j = 0; j < n; j++) {
                    int prioridad = in.nextInt();
                    Node elemento = new Node();
                    elemento.posicion = j;
                    elemento.prioridad = prioridad;
                    prioridades.insert(-prioridad);
                    pendientes.add(elemento);
                }
                while( !prioridades.isEmpty() ){
                    Node elemento = pendientes.remove();
                    if ( elemento.prioridad == -prioridades.findMin() ){
                        if ( elemento.posicion == m ) {
                            if ( !prioridades.isEmpty() )
                                
                            System.out.println( contador );
                            break;
                        } else contador++;
                        prioridades.deleteMin();
                    } else pendientes.add(elemento);
                    //System.out.println("n: "+prioridades.deleteMin());
                }
            }
        }        
    }
    
    public static class Node {
        public Node (){
            this.posicion = posicion;
            this.prioridad = prioridad;
        }
        int posicion;
        int prioridad;
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
    
    public AnyType pop (){
        return remove (size()-1);
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    public int maximum (){
        int max = 0;
        
        if(!isEmpty()){
            AnyType element = pop();
            int value = Integer.valueOf(element.toString());
            if (value > max) max = value;
            maximum();
            add(element);
        }
        
        return max;
    }
    
    private void maximum (int max){
        
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package heap_d;

import java.util.Scanner;

/**
 *
 */
public class Heap_D {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner ( System.in );
        while ( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba
            
            for (int i = 0; i < T; i++) {
                System.out.println("Caso #"+(i+1)+":");
                int N = in.nextInt();               // Numero de carreras
                int [] tamanoCarrera = new int [N];
                MyArrayList <Float> promedios = new MyArrayList();
                BinaryHeap <Float> max = new BinaryHeap();
                BinaryHeap <Float> min = new BinaryHeap();
                
                in.nextLine();
                
                for (int j = 0; j < N; j++) {
                    String [] notas = in.nextLine().split(" ");
                    tamanoCarrera[j] = notas.length;
                    
                    for (int k = 0; k < tamanoCarrera[j]; k++) {
                        promedios.add(Float.parseFloat(notas[k]));
                    }
                }
                int Q = in.nextInt();
                in.nextLine();
                
                for (int j = 0; j < Q; j++) {
                    String [] comandos = in.nextLine().split(" ");
                    switch (comandos[0]) {
                        case "cambiar": {
                                int idx = Integer.parseInt(comandos[1]);
                                float x = Float.parseFloat(comandos[2]);
                                promedios.set(idx, x);
                                break;
                            }
                        case "consultar": {
                            int a = Integer.parseInt(comandos[1]);
                            int b = Integer.parseInt(comandos[2]);
                            
                            if (a!=b){
                                for (int k = a; k <= b; k++) {
                                    max.insert(-promedios.get(k));
                                    min.insert(promedios.get(k));
                                    }
                                
                                if (max.findMin() % 1 == 0) 
                                    System.out.print(Math.round(-max.findMin())+" ");
                                else System.out.print(-max.findMin()+" ");
                                if (min.findMin() % 1 == 0)
                                    System.out.println(Math.round(min.findMin()));
                                else System.out.println(min.findMin());
                                
                                max.makeEmpty();
                                min.makeEmpty();
                            } else {
                                if (promedios.get(a) % 1 == 0)
                                    System.out.println(Math.round(promedios.get(a))
                                    +" "+Math.round(promedios.get(a)));
                                else System.out.println(promedios.get(a)
                                    +" "+promedios.get(a));
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
    
    public static class BinaryHeap<AnyType extends Comparable<? 
            super AnyType>> {
    /**
     * Construct the binary heap.
     */
        public BinaryHeap( ) {
            this( DEFAULT_CAPACITY );
        }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
        public BinaryHeap( int capacity ) {
            currentSize = 0;
            array = (AnyType[]) new Comparable[ capacity + 1 ];
        }
    
    /**
     * Construct the binary heap given an array of items.
     * @param items
     */
        public BinaryHeap( AnyType [ ] items ) {
            currentSize = items.length;
            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
            
            int i = 1;
            for( AnyType item : items )
                array[ i++ ] = item;
            buildHeap( );
        }

    /**
     * Insert into the priority queue, maintaining heap order.
     * Duplicates are allowed.
     * @param x the item to insert.
     */
        public void insert( AnyType x ) {
            if( currentSize == array.length - 1 )
                enlargeArray( array.length * 2 + 1 );

            // Percolate up
            int hole = ++currentSize;
            for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2 )
                array[ hole ] = array[ hole / 2 ];
            array[ hole ] = x;
        }
        
        
        private void enlargeArray( int newSize ) {
            AnyType [] old = array;
            array = (AnyType []) new Comparable[ newSize ];
            for( int i = 0; i < old.length; i++ )
                array[ i ] = old[ i ];
        }
    
    /**
     * Find the smallest item in the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType findMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            return array[ 1 ];
        }

    /**
     * Remove the smallest item from the priority queue.
     * @return the smallest item, or throw an UnderflowException if empty.
     * @throws java.lang.Exception
     */
        public AnyType deleteMin( ) throws Exception {
            if( isEmpty( ) )
                throw new Exception( );
            
            AnyType minItem = findMin( );
            array[ 1 ] = array[ currentSize-- ];
            percolateDown( 1 );
            
            return minItem;
        }

    /**
     * Establish heap order property from an arbitrary
     * arrangement of items. Runs in linear time.
     */
        private void buildHeap( ) {
            for( int i = currentSize / 2; i > 0; i-- )
                percolateDown( i );
        }

    /**
     * Test if the priority queue is logically empty.
     * @return true if empty, false otherwise.
     */
        public boolean isEmpty( ) {
            return currentSize == 0;
        }

    /**
     * Make the priority queue logically empty.
     */
        public void makeEmpty( ) {
            currentSize = 0;
        }
        
        private static final int DEFAULT_CAPACITY = 10;
        
        private int currentSize;      // Number of elements in heap
        private AnyType [ ] array; // The heap array

    /**
     * Internal method to percolate down in the heap.
     * @param hole the index at which the percolate begins.
     */
        private void percolateDown( int hole ) {
            int child;
            AnyType tmp = array[ hole ];
            
            for( ; hole * 2 <= currentSize; hole = child ) {
                child = hole * 2;
                if( child != currentSize &&
                        array[ child + 1 ].compareTo( array[ child ] ) < 0 )
                    child++;
                if( array[ child ].compareTo( tmp ) < 0 )
                    array[ hole ] = array[ child ];
                else break;
            }
            array[ hole ] = tmp;
        }
    }
    public static class MyArrayList<AnyType> implements Iterable<AnyType> {
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayList( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        if( newCapacity < theSize )
            return;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
            theItems[ i ] = old[ i ];
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x ) {
        add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
            theItems[ i ] = theItems[ i - 1 ];

        theItems[ idx ] = x;
        theSize++;  
    }
    
    public AnyType pop (){
        return remove (size()-1);
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    private AnyType remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
            theItems[ i ] = theItems[ i + 1 ];
        theSize--;    
        
        return removedItem;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    public int maximum (){
        int max = 0;
        
        if(!isEmpty()){
            AnyType element = pop();
            int value = Integer.valueOf(element.toString());
            if (value > max) max = value;
            maximum();
            add(element);
        }
        
        return max;
    }
    
    private void maximum (int max){
        
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayList.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_a;

import java.util.*;

/**
 *
 */
public class TArboles_A {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner (System.in);
        while ( in.hasNext() ){
            int T = in.nextInt();                   // Casos de prueba
            
            for (int i = 0; i < T; i++){
                System.out.println("Caso #"+(i+1)+":");
                int Q = in.nextInt();               // Numero de comandos
                BinarySearchTree <Integer> arbol = new BinarySearchTree<>();
                in.nextLine();
                
                for (int j = 0; j < Q; j++) {
                    String [] comando = in.nextLine().split(" ");
                    
                    switch (comando[0]) {
                        case "agregar":
                            arbol.insert(Integer.parseInt(comando[1]) );
                            break;
                        case "distancia":
                            int dist = arbol.distancia( Integer.parseInt(comando[1]), 
                                    Integer.parseInt(comando[2]) );
                            System.out.println("distancia: "+dist);
                            break;
                        case "ancestro":
                            int ans = arbol.ancestro( Integer.parseInt(comando[1]), 
                                    Integer.parseInt(comando[2]) );
                            System.out.println("ancestro: " + ans);
                            break;
                    }
                }
            }
        }
    }
    
    public static class BinarySearchTree<AnyType extends Comparable<? 
            super AnyType>>{
    /**
     * Construct the tree.
     */
    public BinarySearchTree( )
    {
        root = null;
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }
    
    public Integer ancestro (int u, int v) {
        BinaryNode a = ancestro((BinaryNode<Integer>) root, u, v);
        if ( a != null ) return (Integer) a.element;
        else return -1;
    }
    
    public Integer distancia (int u, int v){
        int distance = 0;
        BinaryNode node = ancestro((BinaryNode<Integer>) root, u, v);
        if ( node == null ) return -1;
        else {
            BinaryNode temp1 = node;
            
            while(temp1 != null) {
                if( u == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( u < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( u > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
            
            while ( temp1 != null ) {
                if( v == Integer.parseInt(temp1.element.toString()) ) {
                    temp1 = node;
                    break;
                }
                else if( v < Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.left; distance++;
                }
                else if ( v > Integer.parseInt(temp1.element.toString()) ) {
                        temp1 = temp1.right; distance++;
                }
            }
        } 
        return distance;
    }

    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the subtree.
     */
    private void printTree( BinaryNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    private int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return 1 + Math.max( height( t.left ), height( t.right ) );    
    }
    
    private BinaryNode ancestro (BinaryNode <Integer> root,int v1,int v2){
        Queue<String> v1path = new LinkedList<>();
        Queue<String> v2path = new LinkedList<>();
        String left = "l";
        String right = "r";
        BinaryNode <Integer> temp1;
        temp1 = root;
        BinaryNode <Integer> temp2;
        temp2 = root;
        boolean exist_v1 = false;
        boolean exist_v2 = false;
    
        while(temp1 != null)                //encuentra el camino de v1
            {
                if(v1 == temp1.element) {
                    exist_v1 = true;
                    break;
                }
                else if(v1 < temp1.element) {
                        v1path.add(left);
                        temp1 = temp1.left;
                }
                else if (v1 > temp1.element) {
                        v1path.add(right);
                        temp1 = temp1.right;
                }
        }
    
        while(temp2 != null) {          //encuentra el camino de v2
                if(v2 == temp2.element) {
                    exist_v2 = true;
                    break;
                }
                else if(v2 < temp2.element) {
                    v2path.add(left);
                    temp2 = temp2.left;
                }
                else {
                    v2path.add(right);
                    temp2 = temp2.right;
                }
        }
        
        if ( exist_v1 == false || exist_v2 == false ){
            return null;
        } else {
            temp1 = root;           // Inicia busqueda desde la raiz
            while(v1path.peek() != null && v2path.peek() != null) { //compara caminos
                if(v1path.peek() == v2path.peek()) {
                    if(v1path.peek() == "l"){   //take left
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.left;
                    } else {                    //take right
                        v1path.remove();
                        v2path.remove();
                        temp1 = temp1.right;
                    }
                } else break;
            }
            return temp1;
        }
    }
    
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        BinaryNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;
    
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package tarboles_c;

import java.util.Arrays;
import java.util.Scanner;

/**
 *
 */
public class TArboles_C {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Scanner in = new Scanner ( System.in );
        int T = in.nextInt();                       // Casos de prueba
        for (int i = 0; i < T; i++) {
            System.out.println("Caso #"+(i+1)+":");
            int n = in.nextInt();
            TreeNode [] valores = new TreeNode [n];
            int [] diferencias = new int [n];
            //System.out.println("size= "+valores.length);
            
            for (int j = 0; j < n; j++) {
                valores[j] = new TreeNode();
            }
            
            for (int j = 0; j < n; j++) {
                //System.out.println("j = "+j);
                valores[j].value = in.nextInt();
                valores[j].subTreeValue = valores[j].value;
            }
            
            for (int j = 0; j < n-1; j++) {
                int a = in.nextInt()-1;
                int b = in.nextInt()-1;
                if ( valores[a].left == null ){
                    valores[a].left = valores[b];
                    //System.out.print("l");
                } else {
                    valores[a].right = valores[b];
                    //System.out.print("r");
                }
                valores[b].up = valores[a];
                //System.out.println("");
            }
            
            for (int j = 0; j < n; j++) {
                //System.out.print("n: "+valores[j].value);
                if (valores[j].right != null ) {
                    //System.out.print(". r: "+valores[j].right.value);
                }
                if ( valores [j].left != null ){
                    //System.out.print(". l: "+valores[j].left.value);
                }
                //System.out.println("");
                TreeNode temp = valores[j];
                
                while ( temp.up != null ){
                    temp.up.subTreeValue += valores[j].value;
                    temp = temp.up;
                    //System.out.println("SubTVal = "+temp.subTreeValue+". n = "+temp.value);
                }
            }
            
            for (int j = 0; j < n; j++) {
                diferencias[j] = Math.abs(valores[0].subTreeValue - 2*valores[j].subTreeValue);
            }
            Arrays.sort(diferencias);
            System.out.println(diferencias[0]);//+" - "+diferencias[1]);
        }
    }
    
    static class TreeNode {
        TreeNode(){
            this.value = value;
            this.subTreeValue = subTreeValue;
            this.right = right;
            this.left = left;
            this.up = up;
        }
        int value;
        int subTreeValue;
        TreeNode right;
        TreeNode left;
        TreeNode up;
    }
    
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
