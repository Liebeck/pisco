package punto_a;

import java.util.*;
import java.math.*;

public class punto_a {
	public static void main(String[] args) {
		long prod = 0;
		long aux = 0;
		long[] arr;
		int tam;
		
		Scanner cin = new Scanner(System.in);

		tam = cin.nextInt();
		arr = new long[tam];

		for (int i = 0; i < tam; i++) {
			arr[i] = cin.nextLong();
			}

		for (int a = 0; a < tam; a++) {
			for (int b = 0; b < tam; b++) {
				if (a != b){
					prod = arr[a]* arr[b];
				}
				if (prod > aux){
					aux = prod;
				}
			}
		}
		System.out.println(aux);
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package punto_b;

import java.util.Scanner;
public class punto_b {
	public static void main(String[] args) {
				int tam;
				int cas=1;
				Scanner cin =new Scanner(System.in);  
				int [][] mat;
				int [] sumac;
				int [] sumaf;
				
				while(cin.hasNext()){
					tam=cin.nextInt();
					mat=new int[tam][tam];
					for(int i=0; i<tam ;i++){
						for(int j=0; j<tam;j++){
							mat[i][j]=cin.nextInt();
						}
					}
					sumaf=new int[tam];
					sumac=new int[tam];
					
					for(int k=0; k<tam ;k++){
						int sumf=0, sumc=0;
						for(int r=0; r<tam;r++){
							sumf+=mat[k][r];
							sumaf[k]=sumf;
							sumc+=mat[r][k];
							sumac[k]=sumc;
						}
					}
					int gan=0;
					for(int i=0; i<tam ;i++){
						for(int r=0; r<tam;r++){
							if(sumac[i]>sumaf[r]){
							gan++;
							}
							else{}
						}
					}
					
					System.out.println("Case #"+ cas +":" );
					System.out.println(gan);
					cas++;
					
				}
				
			}
 }

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package punto_c;

import java.util.*;

public class punto_c {

	public static void main( String[] args )
	{
		Scanner cin = new Scanner( System.in );
		int t = 0;
		
		while( t < 1 || t > 100 ){
			t = cin.nextInt( );
			}

		for( int o = 0; o < t; o++ )
		{
			ArrayList<Equipo> equipos = new ArrayList( );
			int n = 0;
			int cnt = 0;
			while( n < 1 || n > 100 ){
				n = cin.nextInt( );
			
			}
			for( int p = 0; p < n; p++ )
			{
				Equipo actual = new Equipo( cin.nextInt( ), cin.nextInt( ) );
				equipos.add( actual );
			}

			for( int i = 0; i < n; i++ )
			{
				for( int j = 1; j < n; j++ )
				{ 
					if( equipos.get( i ).visitante == equipos.get( (i + j) % n ).local )
						cnt++;
				}
			}
			System.out.println( "Case #" + ( o + 1 ) + ":" ); 
			System.out.println( cnt );
		}
	}
}

class Equipo
	{
		int local;
		int visitante;

		public Equipo( int local, int visitante )
		{
			this.local = local;
			this.visitante = visitante;
		}

		public Equipo( )
		{
			this.local = -1;
			this.visitante = -1;
		}
	} 
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package punto_d;

import java.util.*;

public class punto_d {
	public static void main(String[] args) {

		int casos;
		int certot =0;
		int tam;
		int cerfil; 
		int cercol; 
		int fila;
		int col; 
		int colaux;
		int filaux;
		char[][] arr;
		char[] toarr;
		int[] arrcercol;
		int [] arrcerfil;
		int [] sumcercol;
		int [] sumcerfil;
		int [] arrcolaux;
		int [] arrfilaux;
		String cer;
		String corte;

		Scanner cin = new Scanner(System.in);
		casos = cin.nextInt();

		for (int cas = 0; cas < casos; cas++) {
			tam = cin.nextInt();
			arr = new char[tam][tam];
			arrcerfil = new int[tam];
			arrcercol = new int[tam];
			sumcerfil = new int[tam - 1];
			sumcercol = new int[tam - 1];
			arrfilaux = new int[tam - 1];
			arrcolaux = new int[tam - 1];
			corte = "NO";

			for (int f = 0; f < tam; f++) {
				cer = cin.next();
				toarr = cer.toCharArray();
				for (int c = 0; c < toarr.length; c++) {
					arr[f][c] = toarr[c];
				}
			}
			for (int j = 0; j < tam; j++) {
				cerfil = 0;
				cercol = 0;
				for (int k = 0; k < tam; k++) {
					if (arr[j][k] == '#') {
						cerfil += 1;
						arrcerfil[j] = cerfil;
						certot += 1;
					}
					if (arr[k][j] == '#') {
						cercol += 1;
						arrcercol[j] = cercol;
					}
				}
			}
			if (certot % 2 != 0) {
				corte = "NO";
			} else {
				fila = 0;
				col = 0;
				for (int j = 0; j < tam - 1; j++) {
					fila += arrcerfil[j];
					col += arrcercol[j];
					sumcerfil[j] = fila;
					sumcercol[j] = col;
				}
				filaux = 0;
				colaux = 0;
				for (int j = tam - 1; j > 0; j--) {
					filaux += arrcerfil[j];
					colaux += arrcercol[j];
					arrfilaux[j - 1] = filaux;
					arrcolaux[j - 1] = colaux;
				}
				for (int j = 0; j < tam - 1; j++) {
					if (sumcerfil[j] == arrfilaux[j] || sumcercol[j] == arrcolaux[j]) {
						corte = "YES";
						j = tam - 1;
					}
				}
			}
			System.out.println(corte);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package punto_clase;

import java.util.Scanner;

public class punto_clase {
	public static void main(String[] args) {
		int num;
		int [] arr;
		int cont=0;
		
		Scanner cin = new Scanner(System.in);
		num = cin.nextInt();
		arr = new int [5];
				
		for (int i = 0; i < 5; i++) {
			arr[i] = cin.nextInt();
			if (num==arr[i]){
				cont++;
			}
			}
			System.out.println(cont);
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package punto_d;

import java.util.*;

public class punto_d {
	public static void main(String[] args) {

		int casos;
		int certot =0;
		int tam;
		int cerfil; 
		int cercol; 
		int fila;
		int col; 
		int colaux;
		int filaux;
		char[][] arr;
		char[] toarr;
		int[] arrcercol;
		int [] arrcerfil;
		int [] sumcercol;
		int [] sumcerfil;
		int [] arrcolaux;
		int [] arrfilaux;
		String cer;
		String corte;

		Scanner cin = new Scanner(System.in);
		casos = cin.nextInt();

		for (int cas = 0; cas < casos; cas++) {
			tam = cin.nextInt();
			arr = new char[tam][tam];
			arrcerfil = new int[tam];
			arrcercol = new int[tam];
			sumcerfil = new int[tam - 1];
			sumcercol = new int[tam - 1];
			arrfilaux = new int[tam - 1];
			arrcolaux = new int[tam - 1];
			corte = "NO";

			for (int f = 0; f < tam; f++) {
				cer = cin.next();
				toarr = cer.toCharArray();
				for (int c = 0; c < toarr.length; c++) {
					arr[f][c] = toarr[c];
				}
			}
			for (int j = 0; j < tam; j++) {
				cerfil = 0;
				cercol = 0;
				for (int k = 0; k < tam; k++) {
					if (arr[j][k] == '#') {
						cerfil += 1;
						arrcerfil[j] = cerfil;
						certot += 1;
					}
					if (arr[k][j] == '#') {
						cercol += 1;
						arrcercol[j] = cercol;
					}
				}
			}
			if (certot % 2 != 0) {
				corte = "NO";
			} else {
				fila = 0;
				col = 0;
				for (int j = 0; j < tam - 1; j++) {
					fila += arrcerfil[j];
					col += arrcercol[j];
					sumcerfil[j] = fila;
					sumcercol[j] = col;
				}
				filaux = 0;
				colaux = 0;
				for (int j = tam - 1; j > 0; j--) {
					filaux += arrcerfil[j];
					colaux += arrcercol[j];
					arrfilaux[j - 1] = filaux;
					arrcolaux[j - 1] = colaux;
				}
				for (int j = 0; j < tam - 1; j++) {
					if (sumcerfil[j] == arrfilaux[j] || sumcercol[j] == arrcolaux[j]) {
						corte = "YES";
						j = tam - 1;
					}
				}
			}
			System.out.println(corte);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package punto_d;

import java.util.*;

public class punto_d {
	public static void main(String[] args) {

		int casos;
		int certot =0;
		int tam;
		int cerfil; 
		int cercol; 
		int fila;
		int col; 
		int colaux;
		int filaux;
		char[][] arr;
		char[] toarr;
		int[] arrcercol;
		int [] arrcerfil;
		int [] sumcercol;
		int [] sumcerfil;
		int [] arrcolaux;
		int [] arrfilaux;
		String cer;
		String corte;

		Scanner cin = new Scanner(System.in);
		casos = cin.nextInt();

		for (int cas = 0; cas < casos; cas++) {
			tam = cin.nextInt();
			arr = new char[tam][tam];
			arrcerfil = new int[tam];
			arrcercol = new int[tam];
			sumcerfil = new int[tam - 1];
			sumcercol = new int[tam - 1];
			arrfilaux = new int[tam - 1];
			arrcolaux = new int[tam - 1];
			corte = "NO";

			for (int f = 0; f < tam; f++) {
				cer = cin.next();
				toarr = cer.toCharArray();
				for (int c = 0; c < toarr.length; c++) {
					arr[f][c] = toarr[c];
				}
			}
			for (int j = 0; j < tam; j++) {
				cerfil = 0;
				cercol = 0;
				for (int k = 0; k < tam; k++) {
					if (arr[j][k] == '#') {
						cerfil += 1;
						arrcerfil[j] = cerfil;
						certot += 1;
					}
					if (arr[k][j] == '#') {
						cercol += 1;
						arrcercol[j] = cercol;
					}
				}
			}
			if (certot % 2 != 0) {
				corte = "NO";
			} else {
				fila = 0;
				col = 0;
				for (int j = 0; j < tam - 1; j++) {
					fila += arrcerfil[j];
					col += arrcercol[j];
					sumcerfil[j] = fila;
					sumcercol[j] = col;
				}
				filaux = 0;
				colaux = 0;
				for (int j = tam - 1; j > 0; j--) {
					filaux += arrcerfil[j];
					colaux += arrcercol[j];
					arrfilaux[j - 1] = filaux;
					arrcolaux[j - 1] = colaux;
				}
				for (int j = 0; j < tam - 1; j++) {
					if (sumcerfil[j] == arrfilaux[j] || sumcercol[j] == arrcolaux[j]) {
						corte = "YES";
						j = tam - 1;
					}
				}
			}
			System.out.println(corte);
		}
	}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package javaapplication79.punto_d;

/**
 *
 */
import java.util.*;
public class punto_d {
   
	public static void main(String[] args) {

		char[] arrTemp;
		int[] sumac, sumaf, auxc, auxf, auxcB, auxfB;
		String temp, corte;
                char[][] arr;
                int casos, aux, cfil, ccol, fil, col, tam, colprov, filprov;
		Scanner cin = new Scanner(System.in);
		casos = cin.nextInt();

		for (int i = 0; i < casos; i++) {
			
		tam = cin.nextInt();
			arr = new char[tam][tam];
			aux = 0;
			sumaf = new int[tam];
			sumac = new int[tam];
			auxf = new int[tam - 1];
			auxc = new int[tam - 1];
			auxfB = new int[tam - 1];
			auxcB = new int[tam - 1];
                        corte = "NO";	
			for (int j = 0; j < tam; j++) {
				temp = cin.next();
				arrTemp = temp.toCharArray();
				for (int k = 0; k < arrTemp.length; k++) {
					arr[j][k] = arrTemp[k];
				}
			}
			for (int j = 0; j < tam; j++) {
				cfil = 0;
				ccol = 0;
				for (int k = 0; k < tam; k++) {
					if (arr[j][k] == '#') {
						cfil = cfil + 1;
						sumaf[j] = cfil;
						aux = aux + 1;
					}
					if (arr[k][j] == '#') {
						ccol = ccol + 1;
						sumac[j] = ccol;
					}
				}
			}
			if (aux % 2 != 0) 
                        {
			                          
                            corte = "NO";
			} else 
                        {
				                            
                            fil = 0;
				
                            col = 0;
				for (int j = 0; j < tam - 1; j++) {
					fil = fil + sumaf[j];
					col = col + sumac[j];
					auxf[j] = fil;
					auxc[j] = col;
				}
				filprov = 0;
				colprov = 0;
				for (int j = tam - 1; j > 0; j--) {
					filprov = filprov + sumaf[j];
					colprov = colprov + sumac[j];
					auxfB[j - 1] = filprov;
					auxcB[j - 1] = colprov;
				}
				for (int j = 0; j < tam - 1; j++) {
					if (auxf[j] == auxfB[j] || auxc[j] == auxcB[j]) {
						corte = "YES";
						j = tam - 1;
					}
				}
			}
			System.out.println(corte);
		}
	}
} 


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package punto_clase;

import java.util.Scanner;

public class punto_clase {
	public static void main(String[] args) {
		int num;
		int [] arr;
		int cont=0;
		
		Scanner cin = new Scanner(System.in);
		num = cin.nextInt();
		arr = new int [5];
				
		for (int i = 0; i < 5; i++) {
			arr[i] = cin.nextInt();
			if (num==arr[i]){
				cont++;
			}
			}
			System.out.println(cont);
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


class MyArrayListA<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListA( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	System.out.println("consulta: " + theItems[idx]);
    }
    
    /**
     * Return if delete
     */
    public void delete (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("eliminar: posicion invalida");
        }
    	else
    	{
    		remove(idx);
    		System.out.println("eliminar: posicion valida");
    	}	
    }
    
    /**
     * Return if insert
     */
    public void insert (int idx, AnyType x)
    {   
    	if( idx < 0 || idx > size( ) )
        {
    		System.out.println("insertar: posicion invalida");
        }
    	else
    	{
			add(idx, x);
			System.out.println("insertar: posicion valida");
    	}

    }
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public int ensureCapacity( int newCapacity )
    {
    	int costo = 0;
        if( newCapacity < theSize )
            return 0;

        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
        	costo++;
            theItems[ i ] = old[ i ];
        }
        return costo;
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
     /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  
    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {       
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;    
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListA.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    
    

    public static void main(String[] args)    {
    	Scanner scan =new Scanner(System.in);  
		
		int casos = Integer.parseInt(scan.nextLine()); 
		for (int t = 0; t < casos; t++) 
        {
			int cosarr = 0;
			int coslis = 0;
			System.out.println("Caso #"+(t+1)+":");
			MyArrayListA<Integer> lista = new MyArrayListA<>( );
			int cant = Integer.parseInt(scan.nextLine());
			for (int i = 0; i < cant; i++) 
			{
				String cadena = scan.nextLine();
				String[] parts = cadena.split(" ");
				if (parts[0].equals("insertar")) 
				{
					int idx = Integer.parseInt(parts[2]);
					int x = Integer.parseInt(parts[1]);
					
					if( idx < 0 || idx > lista.size( ) )
			        {
			    		System.out.println("insertar: posicion invalida");
			        }
			    	else
			    	{
						System.out.println("insertar: posicion valida");
						cosarr += lista.size()-idx;
						coslis += idx;
						lista.add(idx, x);
			    	}
				}
				if (parts[0].equals("costo")) 
				{
					System.out.println("costo: "+cosarr+" "+coslis);
				}
				if (parts[0].equals("buscar")) 
				{
					int idx = 0;
					boolean existe = false;
					int x = Integer.parseInt(parts[1]);
					for (int j = 0; j < lista.size(); j++) 
					{
						if (lista.get(j) == x) 
						{
							idx = j+1;
							System.out.println("buscar: " + j);
							existe = true;
							break;
						}
					}
					
					if (existe == false) 
					{
						cosarr += lista.size();
						coslis += lista.size();
						System.out.println("no existe numero" );
					}
					else
					{
						cosarr += idx;
						coslis += idx;
					}
				}
				
				if (parts[0].equals("eliminar") ) 
				{
					int x = Integer.parseInt(parts[1]);
					
					if( x < 0 || x >= lista.size( ) )
			        {
			    		System.out.println("eliminar: posicion invalida");
			        }
			    	else
			    	{
			    		cosarr += lista.size()-x-1;
			    		coslis += x;
			    		lista.remove(x);
			    		System.out.println("eliminar: posicion valida");
			    	}
				}
				if (parts[0].equals("consultar")) 
				{
					int x = Integer.parseInt(parts[1]);
					if( x < 0 || x >= lista.size( ) )
			        {
			    		System.out.println("consulta: no encontrado");
			        }
			    	else
			    	{
			    		lista.exist(x);
			    		coslis += x;
			    	}
				}
			}
        }	
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;
public class pb_2{
public static class MyArrayListB<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListB( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }
    
     
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;    

    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListB.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}
    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in);
		
		int N = Integer.parseInt(scan.nextLine()); 

		for (int t = 0; t < N; t++) 
        {
			System.out.println("Caso #"+(t+1)+":");
			MyArrayListB<Integer> listajugadores = new MyArrayListB<>( );
			MyArrayListB<Integer> listacartas = new MyArrayListB<>( );
			String cantidades = scan.nextLine();
			String[] parts = cantidades.split(" ");
			int cantcar = Integer.parseInt(parts[0]);
			int cantjug = Integer.parseInt(parts[1]);
			for (int i = 0; i < cantjug; i++){ 
				listajugadores.add(0);
        	}
			String car = scan.nextLine();
			String[] cartas = car.split(" ");
			for (int j = 0; j < cartas.length; j++){ 
				listacartas.add(Integer.parseInt(cartas[j]));
			}
			int j = 0;
			int max = 0;
			for (int i = 0; i < cantcar; i++)
			{
				if (j == listajugadores.size()) 
					j=0;
				if (listacartas.get(0)<listacartas.get(listacartas.size()-1))				{
					int val = listajugadores.get(j)+listacartas.get(listacartas.size()-1);
					listajugadores.set(j,val);
					listacartas.remove(listacartas.size()-1);
					if (max < val)
						max = val;
				}
				else
				{
					int val = listajugadores.get(j)+listacartas.get(0);
					listajugadores.set(j,val);
					listacartas.remove(0);
					if (max < val)
						max = val;
				}				
				j++;
			}
			for (int i = 0; i < listajugadores.size(); i++) 
			{
				if (listajugadores.get(i)==max) 
				{
					int n = i+1;
					System.out.print(n+" ");
				}
			}
		System.out.println();
        }	
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class pb_2al 
{
	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder();

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.setLength(sb.length() - 1);

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public static void main(String[] args)
	{
		Scanner scan =new Scanner(System.in);	
		MyArrayList<Integer> cartas = new MyArrayList<>();
		MyArrayList<Integer> jugadores = new MyArrayList<>();		
		MyArrayList<Integer> ganador = new MyArrayList<>();
		int casos = Integer.parseInt(scan.nextLine());
		for (int N = 0; N < casos; N++) 
		{
			System.out.println("Caso #" + (N + 1) + ":");
			cartas.clear();
			jugadores.clear();
			ganador.clear();
			int cards = scan.nextInt();
			int players = scan.nextInt();
			
			for (int i = 0; i < cards; i++) 
			{
				cartas.add(scan.nextInt());
			}			
			for (int i = 0; i < players; i++) 
			{
				jugadores.add(0);
			}
			int i = 0;			
			while(cartas.size() != 0)
			{		
				if (i == players)
					i = 0;
				int max = 0;				
				if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
				{
					max = cartas.get(0);
					cartas.remove(0);
				}
				else
				{
					max = cartas.get(cartas.size() - 1);
					cartas.remove(cartas.size() - 1);
				}
				
				jugadores.set(i, jugadores.get(i) + max);											
				
				i++;
			}	
			int max = 0;
			for (int j = 0; j < jugadores.size(); j++) 
			{
				if(jugadores.get(j) > max)
				{
					max = jugadores.get(j);
					ganador.clear();
				}
				if (jugadores.get(j) >= max)
					ganador.add(j + 1);
			}		
			System.out.println(ganador);
			
		}
		
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>


	import java.io.File;
	import java.io.FileNotFoundException;
	import java.io.PrintStream;
	import java.util.Scanner;

	public class p2_bb 
	{
		public static class MyArrayList<AnyType> implements Iterable<AnyType>
		{
		    /**
		     * Construct an empty ArrayList.
		     */
		    public MyArrayList( )
		    {
		        doClear( );
		    }
		    
		    /**
		     * Returns the number of items in this collection.
		     * @return the number of items in this collection.
		     */
		    public int size( )
		    {
		        return theSize;
		    }
		    
		    /**
		     * Returns true if this collection is empty.
		     * @return true if this collection is empty.
		     */ 
		    public boolean isEmpty( )
		    {
		        return size( ) == 0;
		    }
		    
		    /**
		     * Returns the item at position idx.
		     * @param idx the index to search in.
		     * @throws ArrayIndexOutOfBoundsException if index is out of range.
		     */
		    public AnyType get( int idx )
		    {
		        if( idx < 0 || idx >= size( ) )
		            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
		        return theItems[ idx ];    
		    }
		        
		    /**
		     * Changes the item at position idx.
		     * @param idx the index to change.
		     * @param newVal the new value.
		     * @return the old value.
		     * @throws ArrayIndexOutOfBoundsException if index is out of range.
		     */
		    public AnyType set( int idx, AnyType newVal )
		    {
		        if( idx < 0 || idx >= size( ) )
		            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
		        AnyType old = theItems[ idx ];    
		        theItems[ idx ] = newVal;
		        
		        return old;    
		    }

		    @SuppressWarnings("unchecked")
		    public void ensureCapacity( int newCapacity )
		    {
		        if( newCapacity < theSize )
		            return;

		        AnyType [ ] old = theItems;
		        theItems = (AnyType []) new Object[ newCapacity ];
		        for( int i = 0; i < size( ); i++ )
		            theItems[ i ] = old[ i ];
		    }
		    
		    /**
		     * Adds an item to this collection, at the end.
		     * @param x any object.
		     * @return true.
		     */
		    public boolean add( AnyType x )
		    {
		    	add( size( ), x );
		        return true;            
		    }
		    
		    /**
		     * Adds an item to this collection, at the specified index.
		     * @param x any object.
		     * @return true.
		     */
		    public void add( int idx, AnyType x )
		    {
		        if( theItems.length == size( ) )
		            ensureCapacity( size( ) * 2 + 1 );

		        for( int i = theSize; i > idx; i-- )
		            theItems[ i ] = theItems[ i - 1 ];

		        theItems[ idx ] = x;
		        theSize++;  
		    }
		      
		    /**
		     * Removes an item from this collection.
		     * @param idx the index of the object.
		     * @return the item was removed from the collection.
		     */
		    public AnyType remove( int idx )
		    {
		        AnyType removedItem = theItems[ idx ];
		        
		        for( int i = idx; i < size( ) - 1; i++ )
		            theItems[ i ] = theItems[ i + 1 ];
		        theSize--;    
		        
		        return removedItem;
		    }
		    
		    /**
		     * Change the size of this collection to zero.
		     */
		    public void clear( )
		    {
		        doClear( );
		    }
		    
		    private void doClear( )
		    {
		        theSize = 0;
		        ensureCapacity( DEFAULT_CAPACITY );
		    }
		    
		    /**
		     * Obtains an Iterator object used to traverse the collection.
		     * @return an iterator positioned prior to the first element.
		     */
		    public java.util.Iterator<AnyType> iterator( )
		    {
		        return new ArrayListIterator( );
		    }

		    /**
		     * Returns a String representation of this collection.
		     */
		    public String toString( )
		    {
		            StringBuilder sb = new StringBuilder();

		            for( AnyType x : this )
		                sb.append( x + " " );
		            sb.setLength(sb.length() - 1);

		            return new String( sb );
		    }
		    
		    /**
		     * This is the implementation of the ArrayListIterator.
		     * It maintains a notion of a current position and of
		     * course the implicit reference to the MyArrayList.
		     */
		    private class ArrayListIterator implements java.util.Iterator<AnyType>
		    {
		        private int current = 0;
		        private boolean okToRemove = false;
		        	     	      
		        public boolean hasNext( )
		        {
		            return current < size( );
		        }
		        
		        
		        public AnyType next( )
		        {
		            if( !hasNext( ) ) 
		                throw new java.util.NoSuchElementException( ); 
		                  
		            okToRemove = true;    
		            return theItems[ current++ ];
		        }
		        
		        public void remove( )
		        {
		            if( !okToRemove )
		                throw new IllegalStateException( );
		                
		            MyArrayList.this.remove( --current );
		            okToRemove = false;
		        }
		    }
		    
		    private static final int DEFAULT_CAPACITY = 10;
		    
		    private AnyType [ ] theItems;
		    private int theSize;
		}
		
		public static void main(String[] args){
			Scanner scan =new Scanner(System.in);
			MyArrayList<Integer> jugadores = new MyArrayList<>();
			MyArrayList<Integer> cartas = new MyArrayList<>();
			MyArrayList<Integer> maximo = new MyArrayList<>();
			int testCases = Integer.parseInt(scan.nextLine());
			for (int N = 0; N < testCases; N++) 
			{
				System.out.println("Caso #" + (N + 1) + ":");
				cartas.clear();
				jugadores.clear();
				maximo.clear();
				
				int numcartas = scan.nextInt();
				int numjugadores = scan.nextInt();
				scan.nextLine();
				for (int i = 0; i < numcartas; i++) 
				{
					cartas.add(scan.nextInt());
				}			
				if (scan.hasNext())
					scan.nextLine();
				for (int i = 0; i < numjugadores; i++) 
				{
					jugadores.add(0);
				}
				int i = 0;			
				while(cartas.size() != 0)
				{		
					if (i == numjugadores)
						i = 0;
					int max = 0;				
					if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
					{
						max = cartas.get(0);
						cartas.remove(0);
					}
					else
					{
						max = cartas.get(cartas.size() - 1);
						cartas.remove(cartas.size() - 1);
					}
					
					jugadores.set(i, jugadores.get(i) + max);											
					
					i++;
				}	
				int mayor = 0;
				for (int j = 0; j < jugadores.size(); j++) 
				{
					if(jugadores.get(j) > mayor)
					{
						mayor = jugadores.get(j);
						maximo.clear();
					}
					if (jugadores.get(j) >= mayor)
						maximo.add(j + 1);
				}		
				System.out.println(maximo);
				
			}
			
		}

	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class pc_2 
{
	public static class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder( "[ " );

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.append( "]" );

	            return new String( sb );
	    }	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public static void main(String[] args)
	{
		Scanner scan =new Scanner(System.in);
		
		int numcar = Integer.parseInt(scan.nextLine());
		MyArrayList<Integer> carbus = new MyArrayList<>();
		
		for (int i = 0; i < numcar; i++) 
		{
			carbus.add(scan.nextInt());
		}
		if (scan.hasNext())
			scan.nextLine();
		int numninas = Integer.parseInt(scan.nextLine());
		
		int cumplen = 0;
		for (int N = 0; N < numninas; N++) 
		{
			MyArrayList<Integer> carninas = new MyArrayList<>();
			String	car = scan.nextLine();
			String[] carni = car.split(" ");
			for (int i = 0; i < carni.length; i++) 
			{
				carninas.add(Integer.parseInt(carni[i]));
			}
			int carcum = 0;
			if (carninas.size() < carbus.size())
				continue;
						
			for (int i = 0; i < carbus.size(); i++)
			{
				for (int j = 0; j < carninas.size(); j++)
				{
					if (carbus.get(i) == carninas.get(j))
					{
						carninas.remove(j);
						carcum++;
						if (carcum == carbus.size())
							cumplen++;
						}
					
				}
			}
		}
		System.out.println(cumplen);
		
	}
}	
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
	import java.util.Scanner;

	public class p2_bb 
	{
		public static class MyArrayList<AnyType> implements Iterable<AnyType>
		{
		    /**
		     * Construct an empty ArrayList.
		     */
		    public MyArrayList( )
		    {
		        doClear( );
		    }
		    
		    /**
		     * Returns the number of items in this collection.
		     * @return the number of items in this collection.
		     */
		    public int size( )
		    {
		        return theSize;
		    }
		    
		    /**
		     * Returns true if this collection is empty.
		     * @return true if this collection is empty.
		     */ 
		    public boolean isEmpty( )
		    {
		        return size( ) == 0;
		    }
		    
		    /**
		     * Returns the item at position idx.
		     * @param idx the index to search in.
		     * @throws ArrayIndexOutOfBoundsException if index is out of range.
		     */
		    public AnyType get( int idx )
		    {
		        if( idx < 0 || idx >= size( ) )
		            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
		        return theItems[ idx ];    
		    }
		        
		    /**
		     * Changes the item at position idx.
		     * @param idx the index to change.
		     * @param newVal the new value.
		     * @return the old value.
		     * @throws ArrayIndexOutOfBoundsException if index is out of range.
		     */
		    public AnyType set( int idx, AnyType newVal )
		    {
		        if( idx < 0 || idx >= size( ) )
		            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
		        AnyType old = theItems[ idx ];    
		        theItems[ idx ] = newVal;
		        
		        return old;    
		    }

		    @SuppressWarnings("unchecked")
		    public void ensureCapacity( int newCapacity )
		    {
		        if( newCapacity < theSize )
		            return;

		        AnyType [ ] old = theItems;
		        theItems = (AnyType []) new Object[ newCapacity ];
		        for( int i = 0; i < size( ); i++ )
		            theItems[ i ] = old[ i ];
		    }
		    
		    /**
		     * Adds an item to this collection, at the end.
		     * @param x any object.
		     * @return true.
		     */
		    public boolean add( AnyType x )
		    {
		    	add( size( ), x );
		        return true;            
		    }
		    
		    /**
		     * Adds an item to this collection, at the specified index.
		     * @param x any object.
		     * @return true.
		     */
		    public void add( int idx, AnyType x )
		    {
		        if( theItems.length == size( ) )
		            ensureCapacity( size( ) * 2 + 1 );

		        for( int i = theSize; i > idx; i-- )
		            theItems[ i ] = theItems[ i - 1 ];

		        theItems[ idx ] = x;
		        theSize++;  
		    }
		      
		    /**
		     * Removes an item from this collection.
		     * @param idx the index of the object.
		     * @return the item was removed from the collection.
		     */
		    public AnyType remove( int idx )
		    {
		        AnyType removedItem = theItems[ idx ];
		        
		        for( int i = idx; i < size( ) - 1; i++ )
		            theItems[ i ] = theItems[ i + 1 ];
		        theSize--;    
		        
		        return removedItem;
		    }
		    
		    /**
		     * Change the size of this collection to zero.
		     */
		    public void clear( )
		    {
		        doClear( );
		    }
		    
		    private void doClear( )
		    {
		        theSize = 0;
		        ensureCapacity( DEFAULT_CAPACITY );
		    }
		    
		    /**
		     * Obtains an Iterator object used to traverse the collection.
		     * @return an iterator positioned prior to the first element.
		     */
		    public java.util.Iterator<AnyType> iterator( )
		    {
		        return new ArrayListIterator( );
		    }

		    /**
		     * Returns a String representation of this collection.
		     */
		    public String toString( )
		    {
		            StringBuilder sb = new StringBuilder();

		            for( AnyType x : this )
		                sb.append( x + " " );
		            sb.setLength(sb.length() - 1);

		            return new String( sb );
		    }
		    
		    /**
		     * This is the implementation of the ArrayListIterator.
		     * It maintains a notion of a current position and of
		     * course the implicit reference to the MyArrayList.
		     */
		    private class ArrayListIterator implements java.util.Iterator<AnyType>
		    {
		        private int current = 0;
		        private boolean okToRemove = false;
		        	     	      
		        public boolean hasNext( )
		        {
		            return current < size( );
		        }
		        
		        
		        public AnyType next( )
		        {
		            if( !hasNext( ) ) 
		                throw new java.util.NoSuchElementException( ); 
		                  
		            okToRemove = true;    
		            return theItems[ current++ ];
		        }
		        
		        public void remove( )
		        {
		            if( !okToRemove )
		                throw new IllegalStateException( );
		                
		            MyArrayList.this.remove( --current );
		            okToRemove = false;
		        }
		    }
		    
		    private static final int DEFAULT_CAPACITY = 10;
		    
		    private AnyType [ ] theItems;
		    private int theSize;
		}
		
		public static void main(String[] args){
			Scanner scan =new Scanner(System.in);
			MyArrayList<Integer> jugadores = new MyArrayList<>();
			MyArrayList<Integer> cartas = new MyArrayList<>();
			MyArrayList<Integer> maximo = new MyArrayList<>();
			int testCases = Integer.parseInt(scan.nextLine());
			for (int N = 0; N < testCases; N++) 
			{
				System.out.println("Caso #" + (N + 1) + ":");
				cartas.clear();
				jugadores.clear();
				maximo.clear();
				
				int numcartas = scan.nextInt();
				int numjugadores = scan.nextInt();
				scan.nextLine();
				for (int i = 0; i < numcartas; i++) 
				{
					cartas.add(scan.nextInt());
				}			
				if (scan.hasNext())
					scan.nextLine();
				for (int i = 0; i < numjugadores; i++) 
				{
					jugadores.add(0);
				}
				int i = 0;			
				while(cartas.size() != 0)
				{		
					if (i == numjugadores)
						i = 0;
					int max = 0;				
					if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
					{
						max = cartas.get(0);
						cartas.remove(0);
					}
					else
					{
						max = cartas.get(cartas.size() - 1);
						cartas.remove(cartas.size() - 1);
					}
					
					jugadores.set(i, jugadores.get(i) + max);											
					
					i++;
				}	
				int mayor = 0;
				for (int j = 0; j < jugadores.size(); j++) 
				{
					if(jugadores.get(j) > mayor)
					{
						mayor = jugadores.get(j);
						maximo.clear();
					}
					if (jugadores.get(j) >= mayor)
						maximo.add(j + 1);
				}		
				System.out.println(maximo);
				
			}
			
		}

	}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;
public class pb_2{
public static class MyArrayListB<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListB( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }
    
     
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;    

    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListB.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
}
    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in);
		
		int N = Integer.parseInt(scan.nextLine()); 

		for (int t = 0; t < N; t++) 
        {
			System.out.println("Caso #"+(t+1)+":");
			MyArrayListB<Integer> listajugadores = new MyArrayListB<>( );
			MyArrayListB<Integer> listacartas = new MyArrayListB<>( );
			String cantidades = scan.nextLine();
			String[] parts = cantidades.split(" ");
			int cantcar = Integer.parseInt(parts[0]);
			int cantjug = Integer.parseInt(parts[1]);
			for (int i = 0; i < cantjug; i++){ 
				listajugadores.add(0);
        	}
			String car = scan.nextLine();
			String[] cartas = car.split(" ");
			for (int j = 0; j < cartas.length; j++){ 
				listacartas.add(Integer.parseInt(cartas[j]));
			}
			int j = 0;
			int max = 0;
			for (int i = 0; i < cantcar; i++)
			{
				if (j == listajugadores.size()) 
					j=0;
				if (listacartas.get(0)<listacartas.get(listacartas.size()-1))				{
					int val = listajugadores.get(j)+listacartas.get(listacartas.size()-1);
					listajugadores.set(j,val);
					listacartas.remove(listacartas.size()-1);
					if (max < val)
						max = val;
				}
				else
				{
					int val = listajugadores.get(j)+listacartas.get(0);
					listajugadores.set(j,val);
					listacartas.remove(0);
					if (max < val)
						max = val;
				}				
				j++;
			}
			for (int i = 0; i < listajugadores.size(); i++) 
			{
				if (listajugadores.get(i)==max) 
				{
					int n = i+1;
					System.out.print(n+" ");
				}
			}
		System.out.println();
        }	
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Scanner;

public class p2_b 
{
	public class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder();

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.setLength(sb.length() - 1);

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public static void main(String[] args) throws FileNotFoundException 
	{
		Scanner scan;
		File f = new File("src/inProblemB");
		if (f.exists()) 
		{
			scan = new Scanner(f);
			// todo System.out.print va a ir al archivo "outProblemC"
			System.setOut(new PrintStream(new File("src/outProblemB")));
		} 
		else 
		{
			scan = new Scanner(System.in);
		}		
		p2_b pb = new p2_b();
		MyArrayList<Integer> cartas = pb.new MyArrayList<>();
		MyArrayList<Integer> jugadores = pb.new MyArrayList<>();		
		MyArrayList<Integer> maximo = pb.new MyArrayList<>();
		int testCases = Integer.parseInt(scan.nextLine());
		for (int N = 0; N < testCases; N++) 
		{
			System.out.println("Caso #" + (N + 1) + ":");
			cartas.clear();
			jugadores.clear();
			maximo.clear();
			//String read = scan.nextLine();
			int numcartas = scan.nextInt();
			int numjugadores = scan.nextInt();
			scan.nextLine();
			for (int i = 0; i < numcartas; i++) 
			{
				cartas.add(scan.nextInt());
			}			
			if (scan.hasNext())
				scan.nextLine();
			for (int i = 0; i < numjugadores; i++) 
			{
				jugadores.add(0);
			}
			int i = 0;			
			while(cartas.size() != 0)
			{		
				if (i == numjugadores)
					i = 0;
				int max = 0;				
				if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
				{
					max = cartas.get(0);
					cartas.remove(0);
				}
				else
				{
					max = cartas.get(cartas.size() - 1);
					cartas.remove(cartas.size() - 1);
				}
				
				jugadores.set(i, jugadores.get(i) + max);											
				
				i++;
			}	
			int mayor = 0;
			for (int j = 0; j < jugadores.size(); j++) 
			{
				if(jugadores.get(j) > mayor)
				{
					mayor = jugadores.get(j);
					maximo.clear();
				}
				if (jugadores.get(j) >= mayor)
					maximo.add(j + 1);
			}		
			System.out.println(maximo);
			
		}
		
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Scanner;

public class p2_b 
{
	public class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder();

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.setLength(sb.length() - 1);

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public static void main(String[] args) throws FileNotFoundException 
	{
		Scanner scan;
		File f = new File("src/inProblemB");
		if (f.exists()) 
		{
			scan = new Scanner(f);
			// todo System.out.print va a ir al archivo "outProblemC"
			System.setOut(new PrintStream(new File("src/outProblemB")));
		} 
		else 
		{
			scan = new Scanner(System.in);
		}		
		p2_b pb = new p2_b();
		MyArrayList<Integer> cartas = pb.new MyArrayList<>();
		MyArrayList<Integer> jugadores = pb.new MyArrayList<>();		
		MyArrayList<Integer> maximo = pb.new MyArrayList<>();
		int testCases = Integer.parseInt(scan.nextLine());
		for (int N = 0; N <= testCases; N++) 
		{
			
			cartas.clear();
			jugadores.clear();
			maximo.clear();
			int numcartas = scan.nextInt();
			int numjugadores = scan.nextInt();
			for (int i = 0; i < numcartas; i++) 
			{
				cartas.add(scan.nextInt());
			}			
			
			for (int i = 0; i < numjugadores; i++) 
			{
				jugadores.add(0);
			}
			int i = 0;			
			while(cartas.size() != 0)
			{		
				if (i == numjugadores)
					i = 0;
				int max = 0;				
				if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
				{
					max = cartas.get(0);
					cartas.remove(0);
				}
				else
				{
					max = cartas.get(cartas.size() - 1);
					cartas.remove(cartas.size() - 1);
				}
				
				jugadores.set(i, jugadores.get(i) + max);											
				
				i++;
			}	
			int mayor = 0;
			for (int j = 0; j < jugadores.size(); j++) 
			{
				if(jugadores.get(j) > mayor)
				{
					mayor = jugadores.get(j);
					maximo.clear();
				}
				if (jugadores.get(j) >= mayor)
					maximo.add(j + 1);
				}	
			System.out.println("Caso #" + (N + 1) + ":");
			System.out.println(maximo);
			
		}
		
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Scanner;

public class p2_b 
{
	public class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder();

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.setLength(sb.length() - 1);

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public static void main(String[] args) throws FileNotFoundException 
	{
		Scanner scan;
		File f = new File("src/inProblemB");
		if (f.exists()) 
		{
			scan = new Scanner(f);
			// todo System.out.print va a ir al archivo "outProblemC"
			System.setOut(new PrintStream(new File("src/outProblemB")));
		} 
		else 
		{
			scan = new Scanner(System.in);
		}		
		p2_b pb = new p2_b();
		MyArrayList<Integer> cartas = pb.new MyArrayList<>();
		MyArrayList<Integer> jugadores = pb.new MyArrayList<>();		
		MyArrayList<Integer> maximo = pb.new MyArrayList<>();
		int testCases = Integer.parseInt(scan.nextLine());
		for (int N = 0; N < testCases; N++) 
		{
			System.out.println("Caso #" + (N + 1) + ":");
			cartas.clear();
			jugadores.clear();
			maximo.clear();
			int numcartas = scan.nextInt();
			int numjugadores = scan.nextInt();
			for (int i = 0; i < numcartas; i++) 
			{
				cartas.add(scan.nextInt());
			}			
			
			for (int i = 0; i < numjugadores; i++) 
			{
				jugadores.add(0);
			}
			int i = 0;			
			while(cartas.size() != 0)
			{		
				if (i == numjugadores)
					i = 0;
				int max = 0;				
				if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
				{
					max = cartas.get(0);
					cartas.remove(0);
				}
				else
				{
					max = cartas.get(cartas.size() - 1);
					cartas.remove(cartas.size() - 1);
				}
				
				jugadores.set(i, jugadores.get(i) + max);											
				
				i++;
			}	
			int mayor = 0;
			for (int j = 0; j < jugadores.size(); j++) 
			{
				if(jugadores.get(j) > mayor)
				{
					mayor = jugadores.get(j);
					maximo.clear();
				}
				if (jugadores.get(j) >= mayor)
					maximo.add(j + 1);
				}		
			System.out.println(maximo);
			
		}
		
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
package pd;



import java.util.Scanner;


public class pd
{
	public class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder();

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.setLength(sb.length() - 1);

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public class estudiante
	{
		public String nombre;
		//public String apellido;
		public String cedula;
		public int casillero;
		public int cubiculo;
		
		public estudiante(String nombre, String apellido, String cedula) 
		{
			this.nombre = nombre;
			//this.apellido = apellido;
			this.cedula = cedula;
			
		}
		
		public void asignarcub(int cubiculo, int casillero) 
		{
			this.cubiculo = cubiculo;
			this.casillero = casillero;
			
		}
		public void ced() 
		{
			System.out.println(cedula);
		} 
	}
	
	public class casillero
	{
		public int numcasilleros;
		public float carga;	
		public MyArrayList<Boolean> libre = new MyArrayList<>();
			
			
		public casillero(int numcasilleros) 
		{
			this.numcasilleros = numcasilleros;
			for (int i = 0; i < numcasilleros; i++) 
			{
				libre.add(false);
			}
		}
		public void print() 
		{
			System.out.println(libre);
		} 
		
		public float vercarga()
		{
			float totalcas = 0;
			for (int i = 0; i < libre.size(); i++) 
			{
				if (libre.get(i))
					totalcas++;
			}
			return totalcas / numcasilleros;
		}
		
		public void liberar(int idx)
		{
			libre.set(idx, false);
		}
		
		public void ocupar(int idx)
		{
			libre.set(idx, true);
		}

		
			
		
	}
	
	
	public static void salir (String cedula, MyArrayList<casillero> l, MyArrayList<estudiante> s)
	{
		estudiante est = null;
		for (int i = 0; i < s.size(); i++) 
		{
			if (cedula.equalsIgnoreCase(s.get(i).cedula))
			{
				est = s.get(i);
				
			}
		}
		
		int cubiculo = est.cubiculo;
		int casillero = est.casillero;
		l.get(cubiculo).liberar(casillero);
		System.out.println(est.nombre);
	}
	
	public static String asignar(MyArrayList<casillero> cas)
	{
		String ans;
		float lower = 1;
		int room = 0;
		int locker = 0;
		for (int i = 0; i < cas.size(); i++) 
		{
			float charge = cas.get(i).vercarga();
			//System.out.println(charge);
			if (charge < lower)
			{
				lower = charge;
				room = i;
			}
		}		
		for (int i = 0; i < cas.get(room).numcasilleros; i++) 
		{ 
			if (cas.get(room).libre.get(i) == false)
			{
				locker = i;
				break;
			}
			
		}
		cas.get(room).ocupar(locker);
		
		String a = Integer.toString(room);
		String b = Integer.toString(locker);
		
		ans = a.concat(" ");
		ans = ans.concat(b);
		if(lower == 1)
			ans = "limite alcanzado";
		return ans;
	}
	
	
	public static void main(String[] args)
	{
		Scanner scan =new Scanner(System.in);		
		pd d = new pd();
	
		
		int testCases = Integer.parseInt(scan.nextLine());
		for (int k = 0; k < testCases; k++) 
		{
			MyArrayList<estudiante> students = d.new MyArrayList<>();
			MyArrayList<casillero> lockers = d.new MyArrayList<>();
			System.out.println("Caso #" + (k + 1) + ":");
			int N = Integer.parseInt(scan.nextLine());
			String read = scan.nextLine();
			String [] numcub = read.split(" ");
			for (int j = 0; j < numcub.length; j++) 
			{
				lockers.add(d.new casillero(Integer.parseInt(numcub[j])));	
			}
			int numcoman = Integer.parseInt(scan.nextLine());
			for (int i = 0; i < numcoman; i++) 
			{
				read = scan.nextLine();
				numcub = read.split(" ");
				String command = numcub[0];
				//System.out.println(command);
				if(command.equalsIgnoreCase("ingresar"))
				{
					estudiante s = d.new estudiante (numcub[1], numcub [2], numcub[3]);
					students.add(s);
					String asignado = asignar(lockers);
					//System.out.println(place);
					String [] plc = asignado.split(" ");
					if (!asignado.equals("limite alcanzado"))
					{
						s.asignarcub(Integer.parseInt(plc[0]), Integer.parseInt(plc[1]));
						System.out.println((Integer.parseInt(plc[0]) + 1) + " " + (Integer.parseInt(plc[1])+ 1));
					}
					else 
						System.out.println("limite alcanzado");
						
				}
				else if (command.equalsIgnoreCase("salir"))
				{
					//System.out.println(numb[1]);
					salir(numcub[1], lockers, students);
				}
				
			}
			
			
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;
public class puntod
{
public static class MyArrayListD<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListD( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }
    
    /**
     * Return if delete
     */
   /* public int delete (int idx)
    {
    	int costo = 0;
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("eliminar: posicion invalida");
        }
    	else
    	{
    		costo =remove(idx);
    		System.out.println("eliminar: posicion valida");
    	}	
    	
    	return costo;
    }*/
    
    /**
     * Return if insert
     */
    /*public int insert (int idx, AnyType x)
    {   
    	int costo = 0;
    	if( idx < 0 || idx > size( ) )
        {
    		System.out.println("insertar: posicion invalida");
        }
    	else
    	{
			costo =add(idx, x);
			System.out.println("insertar: posicion valida");
    	}
    	
    	return costo;
    }*/
    
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /*public Integer search( AnyType x )
    {
    	for (int i = 0; i < theSize; i++) 
    	{
    		System.out.println(i);
    		if (theItems[i]==(x)) 
			{
				System.out.println(i);
				System.out.println(theItems[i]);
				return i++;
			}
    		System.out.println("afuera del for");
    	}
		return theSize+1;
    }*/
    
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListD.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;

    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in);
		
		int N = Integer.parseInt(scan.nextLine()); 
		
		for (int i = 0; i < N; i++) 
		{
			MyArrayListD<Estudiante> lstest = new MyArrayListD<>( );
			MyArrayListD<Cubiculo> lstcub = new MyArrayListD<>( );
			int caso = i+1;
			System.out.println("Caso #"+caso+":");
			int cubiculos = Integer.parseInt(scan.nextLine());
			String casilleros = scan.nextLine();
			String[] casillero = casilleros.split(" ");
			for (int j = 0; j < cubiculos; j++) 
			{
				int cas = Integer.parseInt(casillero[j]);
				Cubiculo cub = new Cubiculo(cas);
				lstcub.add(cub);
			}
			int comandos = Integer.parseInt(scan.nextLine());
			for (int j = 0; j < comandos; j++) 
			{
				String com = scan.nextLine();
				String[] comando = com.split(" ");
				if (comando[0].equals("ingresar")) 
				{
					int menor = buscar(lstcub);
					int menor1 = menor+1;
					String n = comando[1];
					String a = comando[2];
					long c = Long.parseLong(comando[3]);
					Cubiculo cubi = lstcub.get(menor);
					int ac = cubi.actual();
					int ac1 = ac+1;
					if (cubi.carga < 1) 
					{
						Estudiante est = new Estudiante<>(n, a, c, menor, ac);
						lstest.add(est);
						cubi.ocupados++;
						cubi.actual.set(ac, 1);
						cubi.carga = car(cubi);
						System.out.println(menor1+" "+ac1);
					}
					else
					{
						System.out.println("limite alcanzado");
					}
				}
				if (comando[0].equals("salir")) 
				{
					int cero = 0;
					long ced = Long.parseLong(comando[1]);
					int idx = salir(lstest,ced);
					Estudiante est = lstest.get(idx);
					int cub = est.cubiculo;
					Cubiculo c =lstcub.get(cub);
					int idxActual = est.casillero;
					if (est.casillero == 0) 
					{
						MyArrayListD<Integer> list = c.actual;
						list.set(0, cero);
					}
					else
					{
						MyArrayListD<Integer> list = c.actual;
						list.set(idxActual, cero);
					}
					//System.out.println("actual "+c.actual.get(idx)+"en el indice "+idxActual);
					c.ocupados--;
					c.carga = car(c);
					System.out.println(est.nombre);
					lstest.remove(idx);
					
				}
			}
			
		}
	}
    public static int buscar(MyArrayListD lst)
    {
    	int idx = 0;
    	float min = 1;
    	for (int i = 0; i < lst.size(); i++) 
    	{
			Cubiculo cub = (Cubiculo) lst.get(i);
			if (cub.carga == 0)
			{
				idx = i;
				break;
			}
			else if (cub.carga < min) 
			{
				min = cub.carga;
				idx = i;
			}
		}
    	
		return idx;
    }
    
    public static float car(Cubiculo cub)
    {
    	float carg = 0;
    	if (cub.ocupados == 0) 
			carg = 0;
    	else
    	{
    		float o =cub.ocupados;
    		float c = cub.cantidad;
    		carg = o/c;
    	}
    	return carg;
    }
    public static int salir(MyArrayListD<Estudiante> lstest,long ced)
    {
    	int idx = 0;
    	for (int i = 0; i < lstest.size(); i++)
    	{
    		Estudiante e = (Estudiante) lstest.get(i);
    		long c = e.cedula;
			if (c == ced) 
			{
				idx = i;
				break;
			}
		}
    	
		return idx;
    }
    
    
    
    public static class Estudiante<AnyType>
    {
        public Estudiante( String n, String a, long c, int cub, int cas)
        {
            nombre = n; apellido = a; cedula = c; cubiculo = cub; casillero = cas;
        }
        
        public String nombre;
        public String apellido;
        public long cedula;
        public int cubiculo;
        public int casillero;
    }
    
    public static class Cubiculo<AnyType>
    {
        public Cubiculo( int c)
        {
            cantidad = c; 
            actual = new MyArrayListD<Integer> (); 
            int idx = 0;
        	for (int i = 0; i < cantidad; i++) 
        	{
        		actual.add(idx);
    		}
        }
        
        public int actual()
        {
        	int idx = 0;
        	int z = 0;
        	for (int i = 0; i < actual.size(); i++) 
        	{
        		 z =(int) actual.get(i);
        		//System.out.println("indice buscando: "+i+" z: "+z);
    			if (z == 0) 
    			{
    				idx = i;
    				break;
    			}
    		}
    		return idx;
        }

        public void print() {
        	System.out.print(cantidad+" ");
        }
       
		public int cantidad;
        public int ocupados = 0;
        public float carga = 0;
        public MyArrayListD actual;   
    }
}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class MyArrayListpd<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListpd( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }
    
      
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }

    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListpd.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;

    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in);
		
		int N = Integer.parseInt(scan.nextLine()); 
		
		for (int i = 0; i < N; i++) 
		{
			MyArrayListpd<Estudiante> lstest = new MyArrayListpd<>( );
			MyArrayListpd<Cubiculo> lstcub = new MyArrayListpd<>( );
			int caso = i+1;
			System.out.println("Caso #"+caso+":");
			int cubiculos = Integer.parseInt(scan.nextLine());
			String casilleros = scan.nextLine();
			String[] casillero = casilleros.split(" ");
			for (int j = 0; j < cubiculos; j++) 
			{
				int cas = Integer.parseInt(casillero[j]);
				Cubiculo cub = new Cubiculo(cas);
				lstcub.add(cub);
			}
			int comandos = Integer.parseInt(scan.nextLine());
			for (int j = 0; j < comandos; j++) 
			{
				String com = scan.nextLine();
				String[] comando = com.split(" ");
				if (comando[0].equals("ingresar")) 
				{
					int menor = buscar(lstcub);
					int menor1 = menor+1;
					String n = comando[1];
					String a = comando[2];
					long c = Long.parseLong(comando[3]);
					Cubiculo cubi = lstcub.get(menor);
					int ac = cubi.actual();
					int ac1 = ac+1;
					if (cubi.carga < 1) 
					{
						Estudiante est = new Estudiante<>(n, a, c, menor, ac);
						lstest.add(est);
						cubi.ocupados++;
						cubi.actual.set(ac, 1);
						cubi.carga = car(cubi);
						System.out.println(menor1+" "+ac1);
					}
					else
					{
						System.out.println("limite alcanzado");
					}
				}
				if (comando[0].equals("salir")) 
				{
					int cero = 0;
					long ced = Long.parseLong(comando[1]);
					int idx = salir(lstest,ced);
					Estudiante est = lstest.get(idx);
					int cub = est.cubiculo;
					Cubiculo c =lstcub.get(cub);
					int idxActual = est.casillero;
					if (est.casillero == 0) 
					{
						MyArrayListpd<Integer> list = c.actual;
						list.set(0, cero);
					}
					else
					{
						MyArrayListpd<Integer> list = c.actual;
						list.set(idxActual, cero);
					}
					c.ocupados--;
					c.carga = car(c);
					System.out.println(est.nombre);
					lstest.remove(idx);
					
				}
			}
			
		}
	}
    public static int buscar(MyArrayListpd lst)
    {
    	int idx = 0;
    	float min = 1;
    	for (int i = 0; i < lst.size(); i++) 
    	{
			Cubiculo cub = (Cubiculo) lst.get(i);
			if (cub.carga == 0)
			{
				idx = i;
				break;
			}
			else if (cub.carga < min) 
			{
				min = cub.carga;
				idx = i;
			}
		}
    	
		return idx;
    }
    
    public static float car(Cubiculo cub)
    {
    	float carg = 0;
    	if (cub.ocupados == 0) 
			carg = 0;
    	else
    	{
    		float o =cub.ocupados;
    		float c = cub.cantidad;
    		carg = o/c;
    	}
    	return carg;
    }
    public static int salir(MyArrayListpd<Estudiante> lstest,long ced)
    {
    	int idx = 0;
    	for (int i = 0; i < lstest.size(); i++)
    	{
    		Estudiante e = (Estudiante) lstest.get(i);
    		long c = e.cedula;
			if (c == ced) 
			{
				idx = i;
				break;
			}
		}
    	
		return idx;
    }
    
    
    
    public static class Estudiante<AnyType>
    {
        public Estudiante( String n, String a, long c, int cub, int cas)
        {
            nombre = n; apellido = a; cedula = c; cubiculo = cub; casillero = cas;
        }
        
        public String nombre;
        public String apellido;
        public long cedula;
        public int cubiculo;
        public int casillero;
    }
    
    public static class Cubiculo<AnyType>
    {
        public Cubiculo( int c)
        {
            cantidad = c; 
            actual = new MyArrayListpd<Integer> (); 
            int idx = 0;
        	for (int i = 0; i < cantidad; i++) 
        	{
        		actual.add(idx);
    		}
        }
        
        public int actual()
        {
        	int idx = 0;
        	int z = 0;
        	for (int i = 0; i < actual.size(); i++) 
        	{
        		 z =(int) actual.get(i);
        		//System.out.println("indice buscando: "+i+" z: "+z);
    			if (z == 0) 
    			{
    				idx = i;
    				break;
    			}
    		}
    		return idx;
        }

        public void print() {
        	System.out.print(cantidad+" ");
        }
       
		public int cantidad;
        public int ocupados = 0;
        public float carga = 0;
        public MyArrayListpd actual;   
    }
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Scanner;

public class p2_b 
{
	public class MyArrayList<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayList( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder();

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.setLength(sb.length() - 1);

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayList.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public static void main(String[] args) throws FileNotFoundException 
	{
		Scanner scan;
		File f = new File("src/inProblemB");
		if (f.exists()) 
		{
			scan = new Scanner(f);
			// todo System.out.print va a ir al archivo "outProblemC"
			System.setOut(new PrintStream(new File("src/outProblemB")));
		} 
		else 
		{
			scan = new Scanner(System.in);
		}		
		p2_b pb = new p2_b();
		MyArrayList<Integer> cartas = pb.new MyArrayList<>();
		MyArrayList<Integer> jugadores = pb.new MyArrayList<>();		
		MyArrayList<Integer> maximo = pb.new MyArrayList<>();
		int testCases = Integer.parseInt(scan.nextLine());
		for (int N = 0; N < testCases; N++) 
		{
			System.out.println("Caso #" + (N + 1) + ":");
			cartas.clear();
			jugadores.clear();
			maximo.clear();
			int numcartas = scan.nextInt();
			int numjugadores = scan.nextInt();
			for (int i = 0; i < numcartas; i++) 
			{
				cartas.add(scan.nextInt());
			}			
			
			for (int i = 0; i < numjugadores; i++) 
			{
				jugadores.add(0);
			}
			int i = 0;			
			while(cartas.size() != 0)
			{		
				if (i == numjugadores)
					i = 0;
				int max = 0;				
				if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
				{
					max = cartas.get(0);
					cartas.remove(0);
				}
				else
				{
					max = cartas.get(cartas.size() - 1);
					cartas.remove(cartas.size() - 1);
				}
				
				jugadores.set(i, jugadores.get(i) + max);											
				
				i++;
			}	
			int mayor = 0;
			for (int j = 0; j < jugadores.size(); j++) 
			{
				if(jugadores.get(j) > mayor)
				{
					mayor = jugadores.get(j);
					maximo.clear();
				}
				if (jugadores.get(j) >= mayor)
					maximo.add(j + 1);
				}		
			System.out.println(maximo);
			
		}
		
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class MyArrayListpd<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListpd( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }
    
      
    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }

    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListpd.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;

    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in);
		
		int N = Integer.parseInt(scan.nextLine()); 
		
		for (int i = 0; i < N; i++) 
		{
			MyArrayListpd<Estudiante> lstest = new MyArrayListpd<>( );
			MyArrayListpd<Cubiculo> lstcub = new MyArrayListpd<>( );
			int caso = i+1;
			System.out.println("Caso #"+caso+":");
			int cubiculos = Integer.parseInt(scan.nextLine());
			String casilleros = scan.nextLine();
			String[] casillero = casilleros.split(" ");
			for (int j = 0; j < cubiculos; j++) 
			{
				int cas = Integer.parseInt(casillero[j]);
				Cubiculo cub = new Cubiculo(cas);
				lstcub.add(cub);
			}
			int comandos = Integer.parseInt(scan.nextLine());
			for (int j = 0; j < comandos; j++) 
			{
				String com = scan.nextLine();
				String[] comando = com.split(" ");
				if (comando[0].equals("ingresar")) 
				{
					int menor = buscar(lstcub);
					int menor1 = menor+1;
					String n = comando[1];
					String a = comando[2];
					long c = Long.parseLong(comando[3]);
					Cubiculo cubi = lstcub.get(menor);
					int ac = cubi.actual();
					int ac1 = ac+1;
					if (cubi.carga < 1) 
					{
						Estudiante est = new Estudiante<>(n, a, c, menor, ac);
						lstest.add(est);
						cubi.ocupados++;
						cubi.actual.set(ac, 1);
						cubi.carga = car(cubi);
						System.out.println(menor1+" "+ac1);
					}
					else
					{
						System.out.println("limite alcanzado");
					}
				}
				if (comando[0].equals("salir")) 
				{
					int cero = 0;
					long ced = Long.parseLong(comando[1]);
					int idx = salir(lstest,ced);
					Estudiante est = lstest.get(idx);
					int cub = est.cubiculo;
					Cubiculo c =lstcub.get(cub);
					int idxActual = est.casillero;
					if (est.casillero == 0) 
					{
						MyArrayListpd<Integer> list = c.actual;
						list.set(0, cero);
					}
					else
					{
						MyArrayListpd<Integer> list = c.actual;
						list.set(idxActual, cero);
					}
					c.ocupados--;
					c.carga = car(c);
					System.out.println(est.nombre);
					lstest.remove(idx);
					
				}
			}
			
		}
	}
    public static int buscar(MyArrayListpd lst)
    {
    	int idx = 0;
    	float min = 1;
    	for (int i = 0; i < lst.size(); i++) 
    	{
			Cubiculo cub = (Cubiculo) lst.get(i);
			if (cub.carga == 0)
			{
				idx = i;
				break;
			}
			else if (cub.carga < min) 
			{
				min = cub.carga;
				idx = i;
			}
		}
    	
		return idx;
    }
    
    public static float car(Cubiculo cub)
    {
    	float carg = 0;
    	if (cub.ocupados == 0) 
			carg = 0;
    	else
    	{
    		float o =cub.ocupados;
    		float c = cub.cantidad;
    		carg = o/c;
    	}
    	return carg;
    }
    public static int salir(MyArrayListpd<Estudiante> lstest,long ced)
    {
    	int idx = 0;
    	for (int i = 0; i < lstest.size(); i++)
    	{
    		Estudiante e = (Estudiante) lstest.get(i);
    		long c = e.cedula;
			if (c == ced) 
			{
				idx = i;
				break;
			}
		}
    	
		return idx;
    }
    
    
    
    public static class Estudiante<AnyType>
    {
        public Estudiante( String n, String a, long c, int cub, int cas)
        {
            nombre = n; apellido = a; cedula = c; cubiculo = cub; casillero = cas;
        }
        
        public String nombre;
        public String apellido;
        public long cedula;
        public int cubiculo;
        public int casillero;
    }
    
    public static class Cubiculo<AnyType>
    {
        public Cubiculo( int c)
        {
            cantidad = c; 
            actual = new MyArrayListpd<Integer> (); 
            int idx = 0;
        	for (int i = 0; i < cantidad; i++) 
        	{
        		actual.add(idx);
    		}
        }
        
        public int actual()
        {
        	int idx = 0;
        	int z = 0;
        	for (int i = 0; i < actual.size(); i++) 
        	{
        		 z =(int) actual.get(i);
        		if (z == 0) 
    			{
    				idx = i;
    				break;
    			}
    		}
    		return idx;
        }

        public void print() {
        	System.out.print(cantidad+" ");
        }
       
		public int cantidad;
        public int ocupados = 0;
        public float carga = 0;
        public MyArrayListpd actual;   
    }
}



<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Scanner;

public class p2_b 
{
	public class MyArrayListpb<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayListpb( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder();

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.setLength(sb.length() - 1);

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayListpb.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public static void main(String[] args) throws FileNotFoundException 
	{
		Scanner scan;
		File f = new File("src/inProblemB");
		if (f.exists()) 
		{
			scan = new Scanner(f);
			// todo System.out.print va a ir al archivo "outProblemC"
			System.setOut(new PrintStream(new File("src/outProblemB")));
		} 
		else 
		{
			scan = new Scanner(System.in);
		}		
		p2_b pb = new p2_b();
		MyArrayListpb<Integer> cartas = pb.new MyArrayListpb<>();
		MyArrayListpb<Integer> jugadores = pb.new MyArrayListpb<>();		
		MyArrayListpb<Integer> maximo = pb.new MyArrayListpb<>();
		int testCases = Integer.parseInt(scan.nextLine());
		for (int N = 0; N < testCases; N++) 
		{
			System.out.println("Caso #" + (N + 1) + ":");
			cartas.clear();
			jugadores.clear();
			maximo.clear();
			int numcartas = scan.nextInt();
			int numjugadores = scan.nextInt();
			for (int i = 0; i < numcartas; i++) 
			{
				cartas.add(scan.nextInt());
			}			
			
			for (int i = 0; i < numjugadores; i++) 
			{
				jugadores.add(0);
			}
			int i = 0;			
			while(cartas.size() != 0)
			{		
				if (i == numjugadores)
					i = 0;
				int max = 0;				
				if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
				{
					max = cartas.get(0);
					cartas.remove(0);
				}
				else
				{
					max = cartas.get(cartas.size() - 1);
					cartas.remove(cartas.size() - 1);
				}
				
				jugadores.set(i, jugadores.get(i) + max);											
				
				i++;
			}	
			int mayor = 0;
			for (int j = 0; j < jugadores.size(); j++) 
			{
				if(jugadores.get(j) > mayor)
				{
					mayor = jugadores.get(j);
					maximo.clear();
				}
				if (jugadores.get(j) >= mayor)
					maximo.add(j + 1);
				}		
			System.out.println(maximo);
			
		}
		
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Scanner;

public class p2_b 
{
	public class MyArrayListpb<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty ArrayList.
	     */
	    public MyArrayListpb( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    	add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder();

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.setLength(sb.length() - 1);

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        	     	      
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyArrayListpb.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
	public static void main(String[] args) throws FileNotFoundException 
	{
		Scanner scan;
		File f = new File("src/inProblemB");
		if (f.exists()) 
		{
			scan = new Scanner(f);
			// todo System.out.print va a ir al archivo "outProblemC"
			System.setOut(new PrintStream(new File("src/outProblemB")));
		} 
		else 
		{
			scan = new Scanner(System.in);
		}		
		p2_b pb = new p2_b();
		MyArrayListpb<Integer> cartas = pb.new MyArrayListpb<>();
		MyArrayListpb<Integer> jugadores = pb.new MyArrayListpb<>();		
		MyArrayListpb<Integer> maximo = pb.new MyArrayListpb<>();
		int testCases = Integer.parseInt(scan.nextLine());
		for (int N = 0; N < testCases; N++) 
		{
			System.out.println("Caso #" + (N + 1) + ":");
			cartas.clear();
			jugadores.clear();
			maximo.clear();
			int numcartas = scan.nextInt();
			int numjugadores = scan.nextInt();
			for (int i = 0; i < numcartas; i++) 
			{
				cartas.add(scan.nextInt());
			}			
			
			for (int i = 0; i < numjugadores; i++) 
			{
				jugadores.add(0);
			}
			int i = 0;			
			while(cartas.size() != 0)
			{		
				if (i == numjugadores)
					i = 0;
				int max = 0;				
				if (cartas.get(0) >= cartas.get(cartas.size() - 1)  )
				{
					max = cartas.get(0);
					cartas.remove(0);
				}
				else
				{
					max = cartas.get(cartas.size() - 1);
					cartas.remove(cartas.size() - 1);
				}
				
				jugadores.set(i, jugadores.get(i) + max);											
				
				i++;
			}	
			int mayor = 0;
			for (int j = 0; j < jugadores.size(); j++) 
			{
				if(jugadores.get(j) > mayor)
				{
					mayor = jugadores.get(j);
					maximo.clear();
				}
				if (jugadores.get(j) >= mayor)
					maximo.add(j + 1);
				}		
			System.out.println(maximo);
			
		}
		
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;
public class p_2bdef{
public static class MyArrayListB<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListB( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }

    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }

    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;    

    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListB.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;

    
    
    
    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in); 
		
		int N = Integer.parseInt(scan.nextLine()); 

		for (int t = 0; t < N; t++) 
        {
			MyArrayListB<Integer> cararr = new MyArrayListB<>( );
			MyArrayListB<Integer> jugarr = new MyArrayListB<>( );
			String cantidades = scan.nextLine();
			String[] parts = cantidades.split(" ");
			int numcartas = Integer.parseInt(parts[0]);
			int numjugadores = Integer.parseInt(parts[1]);
			for (int i = 0; i < numjugadores; i++) 
				jugarr.add(0);
			String cartas = scan.nextLine();
			String[] carta = cartas.split(" ");
			for (int j = 0; j < carta.length; j++) 
				cararr.add(Integer.parseInt(carta[j]));
			int j = 0;
			int max = 0;
			for (int i = 0; i < numcartas; i++)
			{
				if (j == jugarr.size()) 
					j=0;
				if (cararr.get(0)<=cararr.get(cararr.size()-1)) 
				{
					int val = jugarr.get(j)+cararr.get(cararr.size()-1);
					jugarr.set(j,val);
					cararr.remove(cararr.size()-1);
					if (max < val)
						max = val;
				}
				else
				{
					int sum = jugarr.get(j)+cararr.get(0);
					jugarr.set(j,sum);
					cararr.remove(0);
					if (max < sum)
						max = sum;
				}				
				j++;
			}
			System.out.println("Caso #"+(t+1)+":");
			for (int i = 0; i < jugarr.size(); i++) 
			{
				if (jugarr.get(i)==max) 
				{
					int ganador = i+1;
					System.out.print(ganador+" ");
				}
			}
			System.out.println();
        }	
	}
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;
public class p_2bdef{
public static class MyArrayListB<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListB( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }

    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }

    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;    

    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListB.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;

    
    
    
    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in); 
		
		int N = Integer.parseInt(scan.nextLine()); 

		for (int t = 0; t < N; t++) 
        {
			MyArrayListB<Integer> cararr = new MyArrayListB<>( );
			MyArrayListB<Integer> jugarr = new MyArrayListB<>( );
			String cantidades = scan.nextLine();
			String[] parts = cantidades.split(" ");
			int numcartas = Integer.parseInt(parts[0]);
			int numjugadores = Integer.parseInt(parts[1]);
			for (int i = 0; i < numjugadores; i++) 
				jugarr.add(0);
			String cartas = scan.nextLine();
			String[] carta = cartas.split(" ");
			for (int j = 0; j < carta.length; j++) 
				cararr.add(Integer.parseInt(carta[j]));
			int j = 0;
			int max = 0;
			for (int i = 0; i < numcartas; i++)
			{
				if (j == jugarr.size()) 
					j=0;
				if (cararr.get(0)<=cararr.get(cararr.size()-1)) 
				{
					int val = jugarr.get(j)+cararr.get(cararr.size()-1);
					jugarr.set(j,val);
					cararr.remove(cararr.size()-1);
					if (max < val)
						max = val;
				}
				else
				{
					int sum = jugarr.get(j)+cararr.get(0);
					jugarr.set(j,sum);
					cararr.remove(0);
					if (max < sum)
						max = sum;
				}				
				j++;
			}
			System.out.println("Caso #"+(t+1)+":");
			for (int i = 0; i < jugarr.size(); i++) 
			{
				if (jugarr.get(i)==max) 
				{
					int ganador = i+1;
					System.out.print(ganador+" ");
				}
			}
			System.out.println();
        }	
	}
}
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class MyArrayListB<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListB( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }

    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }

    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        AnyType removedItem = theItems[ idx ];
        
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;    

    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListB.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;

    
    
    
    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in); 
		
		int N = Integer.parseInt(scan.nextLine()); 

		for (int t = 0; t < N; t++) 
        {
			MyArrayListB<Integer> cararr = new MyArrayListB<>( );
			MyArrayListB<Integer> jugarr = new MyArrayListB<>( );
			String cantidades = scan.nextLine();
			String[] parts = cantidades.split(" ");
			int numcartas = Integer.parseInt(parts[0]);
			int numjugadores = Integer.parseInt(parts[1]);
			for (int i = 0; i < numjugadores; i++) 
				jugarr.add(0);
			String cartas = scan.nextLine();
			String[] carta = cartas.split(" ");
			for (int j = 0; j < carta.length; j++) 
				cararr.add(Integer.parseInt(carta[j]));
			int j = 0;
			int max = 0;
			for (int i = 0; i < numcartas; i++)
			{
				if (j == jugarr.size()) 
					j=0;
				if (cararr.get(0)<=cararr.get(cararr.size()-1)) 
				{
					int val = jugarr.get(j)+cararr.get(cararr.size()-1);
					jugarr.set(j,val);
					cararr.remove(cararr.size()-1);
					if (max < val)
						max = val;
				}
				else
				{
					int sum = jugarr.get(j)+cararr.get(0);
					jugarr.set(j,sum);
					cararr.remove(0);
					if (max < sum)
						max = sum;
				}				
				j++;
			}
			System.out.println("Caso #"+(t+1)+":");
			for (int i = 0; i < jugarr.size(); i++) 
			{
				if (jugarr.get(i)==max) 
				{
					int ganador = i+1;
					System.out.print(ganador+" ");
				}
			}
			System.out.println();
        }	
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class MyArrayListD<AnyType> implements Iterable<AnyType>
{
    /**
     * Construct an empty ArrayList.
     */
    public MyArrayListD( )
    {
        doClear( );
    }
    
    /**
     * Returns the number of items in this collection.
     * @return the number of items in this collection.
     */
    public int size( )
    {
        return theSize;
    }
    
    /**
     * Returns true if this collection is empty.
     * @return true if this collection is empty.
     */ 
    public boolean isEmpty( )
    {
        return size( ) == 0;
    }
    /**
     * Return if exist
     */
    public void exist (int idx)
    {
    	if( idx < 0 || idx >= size( ) )
        {
    		System.out.println("consulta: no encontrado");
        }
    	else
    		System.out.println("consulta: " + theItems[idx]);
    }

    /**
     * Returns the item at position idx.
     * @param idx the index to search in.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType get( int idx )
    {
        if( idx < 0 || idx >= size( ) )
        {
        	throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        }
        return theItems[ idx ];    
    }
        
    /**
     * Changes the item at position idx.
     * @param idx the index to change.
     * @param newVal the new value.
     * @return the old value.
     * @throws ArrayIndexOutOfBoundsException if index is out of range.
     */
    public AnyType set( int idx, AnyType newVal )
    {
        if( idx < 0 || idx >= size( ) )
            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
        AnyType old = theItems[ idx ];    
        theItems[ idx ] = newVal;
        
        return old;    
    }

    @SuppressWarnings("unchecked")
    public void ensureCapacity( int newCapacity )
    {
        AnyType [ ] old = theItems;
        theItems = (AnyType []) new Object[ newCapacity ];
        for( int i = 0; i < size( ); i++ )
        {
            theItems[ i ] = old[ i ];
        }
 
    }
    
    /**
     * Adds an item to this collection, at the end.
     * @param x any object.
     * @return true.
     */
    public boolean add( AnyType x )
    {
    add( size( ), x );
        return true;            
    }
    
    /**
     * Adds an item to this collection, at the specified index.
     * @param x any object.
     * @return true.
     */
    public void add( int idx, AnyType x )
    {
        if( theItems.length == size( ) )
            ensureCapacity( size( ) * 2 + 1 );

        for( int i = theSize; i > idx; i-- )
        {
            theItems[ i ] = theItems[ i - 1 ];
        }
        theItems[ idx ] = x;
        theSize++;  

    }
      
    /**
     * Removes an item from this collection.
     * @param idx the index of the object.
     * @return the item was removed from the collection.
     */
    public void remove( int idx )
    {
        for( int i = idx; i < size( ) - 1; i++ )
        {
            theItems[ i ] = theItems[ i + 1 ];
        }
        theSize--;
    }
    
    /**
     * Change the size of this collection to zero.
     */
    public void clear( )
    {
        doClear( );
    }
    
    private void doClear( )
    {
        theSize = 0;
        ensureCapacity( DEFAULT_CAPACITY );
    }
    
    /**
     * Obtains an Iterator object used to traverse the collection.
     * @return an iterator positioned prior to the first element.
     */
    public java.util.Iterator<AnyType> iterator( )
    {
        return new ArrayListIterator( );
    }

    /**
     * Returns a String representation of this collection.
     */
    public String toString( )
    {
            StringBuilder sb = new StringBuilder( "[ " );

            for( AnyType x : this )
                sb.append( x + " " );
            sb.append( "]" );

            return new String( sb );
    }
    
    /**
     * This is the implementation of the ArrayListIterator.
     * It maintains a notion of a current position and of
     * course the implicit reference to the MyArrayList.
     */
    private class ArrayListIterator implements java.util.Iterator<AnyType>
    {
        private int current = 0;
        private boolean okToRemove = false;
        
        public boolean hasNext( )
        {
            return current < size( );
        }
        
        
        public AnyType next( )
        {
            if( !hasNext( ) ) 
                throw new java.util.NoSuchElementException( ); 
                  
            okToRemove = true;    
            return theItems[ current++ ];
        }
        
        public void remove( )
        {
            if( !okToRemove )
                throw new IllegalStateException( );
                
            MyArrayListD.this.remove( --current );
            okToRemove = false;
        }
    }
    
    private static final int DEFAULT_CAPACITY = 10;
    
    private AnyType [ ] theItems;
    private int theSize;
    
    public static int Busc(MyArrayListD lst)
    {
    	int idx = 0;
    	float min = 1;
    	for (int i = 0; i < lst.size(); i++) 
    	{
			Cub cub = (Cub) lst.get(i);
			if (cub.carga == 0)
			{
				idx = i;
				break;
			}
			else if (cub.carga < min) 
			{
				min = cub.carga;
				idx = i;
			}
		}
    	
		return idx;
    }
    
    public static float Car(Cub cub)
    {
    	float cargacub = 0;
    	if (cub.llenos == 0) 
    		cargacub = 0;
    	else
    	{
    		float llenos =cub.llenos;
    		float totalcub = cub.cantidad;
    		cargacub = llenos/totalcub;
    	}
    	return cargacub;
    }
    public static int salir(MyArrayListD<Est> lisest,long ced)
    {
    	int caslib = 0;
    	for (int i = 0; i < lisest.size(); i++)
    	{
    		Est esal = (Est) lisest.get(i);
    		long id = esal.cedula;
			if (id == ced) 
			{
				caslib = i;
				break;
			}
		}
    	
		return caslib;
    }
    
    
    
    public static class Est<AnyType>
    {
    	 public String nombre;
         public long cedula;
         public int cubiculo;
         public int casillero;
         
         public Est(String n, long c, int cub, int cas) 
 		{
 			this.nombre = n;
 			this.cedula = c;
 			this.cubiculo = cub;
 			this.casillero = cas;
 			 			
 		}
    
    }
    
    public static class Cub<AnyType>
    {
        public Cub( int c)
        {
            cantidad = c; 
            casasi = new MyArrayListD<Integer> (); 
            int idx = 0;
        	for (int i = 0; i < cantidad; i++) 
        	{
        		casasi.add(idx);
    		}
        }
        
        public int actual()
        {
        	int idx = 0;
        	int z = 0;
        	for (int i = 0; i < casasi.size(); i++) 
        	{
        		 z =(int) casasi.get(i);
        		if (z == 0) 
    			{
    				idx = i;
    				break;
    			}
    		}
    		return idx;
        }

        public void print() {
        	System.out.print(cantidad+" ");
        }
       
		public int cantidad;
        public int llenos = 0;
        public float carga = 0;
        public MyArrayListD casasi;   
    }

    public static void main(String[] args)
    {
    	Scanner scan =new Scanner(System.in); 
		
		int casos = Integer.parseInt(scan.nextLine()); 
		
		for (int i = 0; i < casos; i++) 
		{
			MyArrayListD<Est> lisest = new MyArrayListD<>( );
			MyArrayListD<Cub> liscub = new MyArrayListD<>( );
			System.out.println("Caso #"+(i+1)+":");
			int cubiculos = Integer.parseInt(scan.nextLine());
			String casilleros = scan.nextLine();
			String[] casillero = casilleros.split(" ");
			for (int j = 0; j < cubiculos; j++) 
			{
				int cas = Integer.parseInt(casillero[j]);
				Cub cub = new Cub(cas);
				liscub.add(cub);
			}
			int cantcom = Integer.parseInt(scan.nextLine());
			for (int j = 0; j < cantcom; j++) 
			{
				String camandos = scan.nextLine();
				String[] comando = camandos.split(" ");
				if (comando[0].equals("ingresar")) 
				{
					int cubmenorcar = Busc(liscub);
					String n = comando[1];
					long c = Long.parseLong(comando[3]);
					Cub cubi = liscub.get(cubmenorcar);
					int menorcas = cubi.actual();
					if (cubi.carga < 1) 
					{
						Est est = new Est<>(n, c, cubmenorcar, menorcas);
						lisest.add(est);
						cubi.llenos++;
						cubi.casasi.set(menorcas, 1);
						cubi.carga = Car(cubi);
						System.out.println((cubmenorcar+1)+" "+(menorcas+1));
					}
					else
					{
						System.out.println("limite alcanzado");
					}
				}
				if (comando[0].equals("salir")) 
				{
					
					long ced = Long.parseLong(comando[1]);
					int idx = salir(lisest,ced);
					Est est = lisest.get(idx);
					int cub = est.cubiculo;
					Cub c =liscub.get(cub);
					int casocupado = est.casillero;
					if (est.casillero == 0) 
					{
						MyArrayListD<Integer> list = c.casasi;
						list.set(0,0);
					}
					else
					{
						MyArrayListD<Integer> list = c.casasi;
						list.set(casocupado,0);
					}
					
					c.llenos--;
					c.carga = Car(c);
					System.out.println(est.nombre);
					lisest.remove(idx);
					
				}
			}
			
		}
	}

}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

import javax.sql.CommonDataSource;

// BinarySearchTree class
//
// CONSTRUCTION: with no initializer
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// Comparable findMin( )  --> Return smallest item
// Comparable findMax( )  --> Return largest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// void printTree( )      --> Print tree in sorted order
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

/**
 * Implements an unbalanced binary search tree.
 * Note that all "matching" is based on the compareTo method.
 */
public class BinarySearchTreeA<AnyType extends Comparable<? super AnyType>>
{
    /**
     * Construct the tree.
     */
    public BinarySearchTreeA( )
    {
        root = null;
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }

    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the subtree.
     */
    private void printTree( BinaryNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    private int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return 1 + Math.max( height( t.left ), height( t.right ) );    
    }
    
    public BinaryNode<AnyType> find( BinaryNode<AnyType> t, Comparable<? super AnyType> toFind ){
    	if( t == null )
            return null;
            
        int compareResult = toFind.compareTo( t.element );
            
        if( compareResult < 0 )
            return find( t.left, toFind );
        else if( compareResult > 0 )
            return find( t.right, toFind );
        else
            return t;    // Match
    }
    
    public boolean isAncestor(BinaryNode<AnyType> a, Comparable<? super AnyType> b){
    	if( b.compareTo(a.element) == 0 )
    		return true;
    	BinaryNode<AnyType> ancestor = find( root, a.element );
    	if( ancestor == null )
    		return false;
    	
    	if( find( ancestor, b ) != null )
    		return true;
    	
    	return false;
    }
    
    public BinaryNode<AnyType> commonAncestor(BinaryNode<AnyType> t, 
    											Comparable<? super AnyType> a,
    												Comparable<? super AnyType> b){
    	if( t == null )
    		return null;
    	
    	if( isAncestor(t, a) && isAncestor(t, b) ){
    		BinaryNode<AnyType> left = commonAncestor( t.left, a, b);
    		BinaryNode<AnyType> right = commonAncestor( t.right, a, b);
    		if( left != null )
    			return left;
    		else if( right != null )
    			return right;
    		else
    			return t;
    	}else
    		return null;
    }
    
    public int distanceFromAncestor( BinaryNode<AnyType> ancestor, Comparable<? super AnyType> node ){
    	if( ancestor == null )
            return 0;
            
        int compareResult = node.compareTo( ancestor.element );
            
        if( compareResult < 0 )
            return distanceFromAncestor( ancestor.left, node ) + 1 ;
        else if( compareResult > 0 )
            return distanceFromAncestor( ancestor.right, node ) + 1 ;
        else
            return 0;    // Match
    }
    
    public int distance( Comparable<? super AnyType> a, Comparable<? super AnyType> b){
    	BinaryNode<AnyType> common = commonAncestor(root, a, b);
    	return distanceFromAncestor( common, a ) + distanceFromAncestor( common, b);
    }
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        BinaryNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;


        // Test program
    public static void main( String [ ] args ) throws Exception
    {	
    	
    	BufferedReader br = new BufferedReader( new InputStreamReader(System.in) );
    	
    	int t = Integer.parseInt(br.readLine());
    	
    	for( int i = 0; i < t; i++ ){
    		System.out.println("Caso #" + (i+1) + ":");
    		BinarySearchTreeA<Integer> tree = new BinarySearchTreeA<>( );
    		int q = Integer.parseInt( br.readLine() );
    		for( int j = 0; j < q; j++ ){
    			String[] cmd = br.readLine().split(" ");
    			switch(cmd[0]){
    			case "agregar":
    				tree.insert( Integer.parseInt(cmd[1]) );
    				break;
    			case "distancia":
    				int a = Integer.parseInt( cmd[1] );
    				int b = Integer.parseInt( cmd[2] );
    				int distance = -1;
    				if( tree.root != null && tree.contains(a) && tree.contains(b) )
    					distance = tree.distance( a, b );
    				System.out.println("distancia: " + distance);
    				break;
    			case "ancestro":
    				int a1 = Integer.parseInt( cmd[1] );
    				int b2 = Integer.parseInt( cmd[2] );
    				int ancestor = -1;
    				if( tree.root != null && tree.contains(a1) && tree.contains(b2) )
    					ancestor = tree.commonAncestor( tree.root, a1, b2 ).element;
    				System.out.println("ancestro: " + ancestor);
    				break;
    			}
    			
    			
    		}
    	}
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import org.xml.sax.HandlerBase;

public class TreeB<AnyType extends Comparable<? super AnyType>>
{
	
	/** The tree root. */
    private TreeBNode<AnyType> root;
    private String ans;
    
    /**
     * Construct the tree.
     */
    public TreeB( )
    {
        root = null;
        ans = new String();
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        //root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return false;//contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    public void insert(AnyType element, TreeBNode<AnyType> t){
    	if( t == null ){
    		root = new TreeBNode<>(element);
    		return;
    	}
    	
    	ArrayList<AnyType> e = new ArrayList<AnyType>();
    	e.add(element);
    	TreeBNode<AnyType> node = BFS(t, e, "find");
    	//System.out.println("node: " + node.element);
    	if( node.element == element)
    		return;
    	node.children.add( new TreeBNode<AnyType>(element) );
    }
    
    public void insert(ArrayList<AnyType> elements, TreeBNode<AnyType> t){
    	if( t == null ){
    		return;
    	}
    	
    	ArrayList<AnyType> e = new ArrayList<>();
    	e.add( t.element );
    	TreeBNode<AnyType> node = BFS(root, e, "find");
    	for( AnyType any : elements )
    		node.children.add( new TreeBNode<AnyType>(any) );
    	//printQ(node.children);
    }
    
    public boolean execute(TreeBNode<AnyType> node, ArrayList<AnyType> toFind, String cmd){
    	switch(cmd){
    	case "print":
    		ans += node.element+ " ";
    		return false;
    	case "find":
    		for( AnyType f : toFind ){
    			if( f.compareTo(node.element) == 0 ){
    				/*System.out.println("f:" + f);
    				System.out.println("node.element:" + node.element);*/
    				return true;
    			}
    		}
    		return false;
    	default:
    		return false;
    	}
    }
    
    public void printQ(List<TreeBNode> q){
    	for( TreeBNode t : q )
    		System.out.print( t.element + " " );
    	System.out.println();
    }
    
    public TreeBNode<AnyType> BFS(TreeBNode<AnyType> subTree, ArrayList<AnyType> toFind, String cmd){
    	LinkedList<TreeBNode> qEven = new LinkedList<>();
    	LinkedList<TreeBNode> qOdd = new LinkedList<>();
    	LinkedList<TreeBNode> cQ = qEven;
    	
    	qEven.add(subTree);
    	
    	HashMap<TreeBNode, Integer> depth = new HashMap<>();
    	depth.put(subTree, 0);
    	
    	TreeBNode<AnyType> current = subTree;
    	
    	while( true ){
    		/*System.out.println("Even");
    		printQ(qEven);
    		System.out.println("Odd");
    		printQ(qOdd);*/
    		/*if( cQ == qEven ) System.out.println("even " + cQ.size());
    		else System.out.println("odd " + cQ.size());*/
    		if( cQ.size() > 0 )
    			current = cQ.remove();
    		else if( qEven.size() > 0 || qOdd.size() > 0){
    			cQ = cQ == qEven? qOdd : qEven;
    			current = cQ.remove();
    		}else
    			break;
    		//System.out.println("current: " + current.element + "\n " + cQ.size());
    		boolean found = execute(current, toFind, cmd);
    		if( found && cmd.equals("find") )
    			return current;
    		int d = depth.get(current) + 1;
    		if( d % 2 == 1 ){
    			ArrayList<TreeBNode> et = current.children;
    			for( int i = 0; i < et.size(); i++ ){
    				TreeBNode<AnyType> child = et.get(i);
    				depth.put(child, d);
    				qEven.addFirst(child);
    				//System.out.println("even " + child.element);
    			}
    		}else{
    			ArrayList<TreeBNode> et = current.children;
    			
    			for( int i = et.size()-1; i > -1; i-- ){
    				TreeBNode<AnyType> child = et.get(i);
    				depth.put(child, d);
    				qOdd.addFirst(child);
    				//System.out.println("odd " + child.element);
    			}
    		}
    		
    		
    	}
		return null;
    }
           // Basic node stored in unbalanced binary search trees
    private static class TreeBNode<AnyType>
    {
    	AnyType element;
    	ArrayList<TreeBNode> children;            // The data in the node
        // Constructors
        TreeBNode( AnyType theElement )
        {	
        	element  = theElement;
            children = new ArrayList<>();
        }        
    }


        // Test program
    public static void main( String [ ] args ) throws Exception
    {	
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	int t = Integer.parseInt( br.readLine() );
    	for (int i = 0; i < t; i++) {
    		int q = Integer.parseInt( br.readLine() );
    		System.out.println("Caso #" + (i+1) + ":");
    		TreeB<Integer> tree = new TreeB<>();
    		for (int j = 0; j < q; j++) {
				String[] in = br.readLine().split(" ");
				//System.out.println( Arrays.toString(in) );
				ArrayList<Integer> toAdd = new ArrayList<>();
				TreeBNode<Integer> node = new TreeBNode<>(Integer.parseInt(in[0]) );
				tree.insert(node.element, tree.root);
				
				for (int k = 1; k < in.length; k++) {
					toAdd.add( Integer.parseInt(in[k]) );
				}
				
				tree.insert(toAdd, node);
				
			}
    		//System.out.println("printing");
    		tree.BFS(tree.root, null, "print");
    		System.out.println( tree.ans.trim() );
		}
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;

// BinaryHeap class
//
// CONSTRUCTION: with optional capacity (that defaults to 100)
//               or an array containing initial items
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// Comparable deleteMin( )--> Return and remove smallest item
// Comparable findMin( )  --> Return smallest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

/**
 * Implements a binary heap.
 * Note that all "matching" is based on the compareTo method.
 * @param <AnyType>
 */
public class MaxHeap<AnyType extends Comparable<? super AnyType>>
{
	// fields
	   AnyType[] heap;   // array for complete binary tree
	   int size;   // number of elements in heap

	   // constructors
	   /** create a heap with the given initial capacity
	    * @throws IllegalArgumentException when
	    * initialCapacity < 1 */
	   @SuppressWarnings( "unchecked" )
	   public MaxHeap( int initialCapacity )
	   {
	      if( initialCapacity < 1 )
	         throw new IllegalArgumentException
	            ( "initialCapacity must be >= 1" );
	      heap = ( AnyType[] ) new Comparable[ initialCapacity + 1 ];
	      size = 0;
	   }

	   /** create a heap with initial capacity 10 */
	   public MaxHeap( )
	   {
	      this( 10 );
	   }

	   // methods
	   /** @return true iff the heap is empty */
	   public boolean isEmpty( )
	   {
	      return size == 0;
	   }

	   /** @return number of elements in the heap */
	   public int size( )
	   {
	      return size;
	   }

	   /** @return maximum element
	    * @return null if the heap is empty */
	   public AnyType getMax( )
	   {
	      return ( size == 0 ) ? null : heap[ 1 ];
	   }

	   /** put theElement into the heap */
	   @SuppressWarnings( "unchecked" )
	   public void put( AnyType theElement )
	   {
	      // increase array size if necessary
	      if( size == heap.length - 1 )
	      {
	         AnyType[] old = heap;
	         heap = ( AnyType[] ) new Comparable[ 2 * heap.length ];
	         for( int i = 0; i < old.length; i++ )
	            heap[ i ] = old[ i ];
	      }

	      // find place for theElement
	      // currentNode starts at new leaf and moves up tree
	      int currentNode = ++size;
	      while( currentNode != 1 &&
	             heap[ currentNode / 2 ].compareTo( theElement ) < 0 )
	      {
	         // cannot put theElement in heap[ currentNode ]
	         heap[ currentNode ] = heap[ currentNode / 2 ]; // move element down
	         currentNode /= 2; // move to parent
	      }

	      heap[ currentNode ] = theElement;
	   }

	   /** remove max element and return it */
	   public AnyType removeMax( )
	   {
	      // if heap is empty return null
	      if( size == 0 ) return null;       // heap empty

	      AnyType maxElement = heap[ 1 ];  // max element

	      // reheapify
	      AnyType lastElement = heap[ size-- ];

	      // find place for lastElement starting at root
	      int currentNode = 1,
	         child = 2;     // child of currentNode
	      while( child <= size )
	      {
	         // heap[ child ] should be larger child of currentNode
	         if( child < size &&
	             heap[ child ].compareTo( heap[ child + 1 ] ) < 0 ) child++;

	         // can we put lastElement in heap[ currentNode ]?
	         if( lastElement.compareTo( heap[ child ] ) >= 0 )
	            break;   // yes

	         // no
	         heap[ currentNode ] = heap[ child ]; // move child up
	         currentNode = child; // move down a level
	         child *= 2;
	      }
	      heap[ currentNode ] = lastElement;

	      return maxElement;
	   }

	   /** initialize max heap to element array theHeap */
	   @SuppressWarnings("unchecked")
	   public void initialize( AnyType[] theHeap )
	   {
	      int theSize = theHeap.length;
	      heap = ( AnyType[] ) new Comparable[ theSize + 1 ];
	      for( int i = 1; i< heap.length; i++ )
	         heap[ i ] = theHeap[ i - 1 ];
	      size = theSize;
	      // heapify
	      for( int root = size / 2; root >= 1; root-- )
	      {
	         AnyType rootElement = heap[ root ];

	         // find place to put rootElement
	         int child = 2 * root; // parent of child is target
	         // location for rootElement
	         while( child <= size )
	         {
	            // heap[ child ] should be larger sibling
	            if( child < size &&
	                heap[ child ].compareTo( heap[ child + 1 ] ) < 0 ) child++;

	            // can we put rootElement in heap[ child / 2 ]?
	            if( rootElement.compareTo( heap[ child ] ) >= 0 )
	               break;  // yes

	            // no
	            heap[ child / 2 ] = heap[ child ]; // move child up
	            child *= 2; // move down a level
	         }
	         heap[ child / 2 ] = rootElement;
	      }
	   }

        // Test program
    public static void main( String [ ] args )
    {
        BufferedReader br = new BufferedReader( new InputStreamReader(System.in) );
        int n;
		try {
			n = Integer.parseInt( br.readLine() );
			MaxHeap<Integer> h = new MaxHeap<>( n );
			String[] nums = br.readLine().split(" ");
			
			LinkedList<Integer> three = new LinkedList<>();
	        for( int i = 0; i < n; i++ ){
	        	h.put(Integer.parseInt(nums[i]));;
	        	if( i < 2 ){
	        		System.out.println(-1);
	        		continue;
	        	}
	        	int prod = 1;
	        	for( int j = 0; j < 3; j++ ){
	        		int max = h.removeMax();
	        		three.add(max);
	        		prod *= max;
	        	}
	        	for( Integer it : three )
	        		h.put(it);
	        	three.clear();
	        	System.out.println(prod);
	        }
		} catch (NumberFormatException | IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        
    	
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeB<AnyType extends Comparable<? super AnyType>>
{
	
	/** The tree root. */
    private TreeBNode<AnyType> root;
    private StringBuilder ans;
    
    /**
     * Construct the tree.
     */
    public TreeB( )
    {
        root = null;
        ans = new StringBuilder();
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        //root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return false;//contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    public void insert(AnyType element, TreeBNode<AnyType> t){
    	if( t == null ){
    		root = new TreeBNode<>(element);
    		return;
    	}
    	
    	ArrayList<AnyType> e = new ArrayList<AnyType>();
    	e.add(element);
    	TreeBNode<AnyType> node = BFS(t, e, "find");
    	//System.out.println("node: " + node.element);
    	if( node.element == element)
    		return;
    	node.children.add( new TreeBNode<AnyType>(element) );
    }
    
    public void insert(ArrayList<AnyType> elements, TreeBNode<AnyType> t){
    	if( t == null ){
    		return;
    	}
    	
    	ArrayList<AnyType> e = new ArrayList<>();
    	e.add( t.element );
    	TreeBNode<AnyType> node = BFS(root, e, "find");
    	for( AnyType any : elements )
    		node.children.add( new TreeBNode<AnyType>(any) );
    	//printQ(node.children);
    }
    
    public boolean execute(TreeBNode<AnyType> node, ArrayList<AnyType> toFind, String cmd){
    	switch(cmd){
    	case "print":
    		ans.append(node.element+ " ");
    		return false;
    	case "find":
    		for( AnyType f : toFind ){
    			if( f.compareTo(node.element) == 0 ){
    				/*System.out.println("f:" + f);
    				System.out.println("node.element:" + node.element);*/
    				return true;
    			}
    		}
    		return false;
    	default:
    		return false;
    	}
    }
    
    public void printQ(List<TreeBNode> q){
    	for( TreeBNode t : q )
    		System.out.print( t.element + " " );
    	System.out.println();
    }
    
    public TreeBNode<AnyType> BFS(TreeBNode<AnyType> subTree, ArrayList<AnyType> toFind, String cmd){
    	LinkedList<TreeBNode> qEven = new LinkedList<>();
    	LinkedList<TreeBNode> qOdd = new LinkedList<>();
    	LinkedList<TreeBNode> cQ = qEven;
    	
    	qEven.add(subTree);
    	
    	HashMap<TreeBNode, Integer> depth = new HashMap<>();
    	depth.put(subTree, 0);
    	
    	TreeBNode<AnyType> current = subTree;
    	
    	while( true ){
    		/*System.out.println("Even");
    		printQ(qEven);
    		System.out.println("Odd");
    		printQ(qOdd);*/
    		/*if( cQ == qEven ) System.out.println("even " + cQ.size());
    		else System.out.println("odd " + cQ.size());*/
    		if( cQ.size() > 0 )
    			current = cQ.remove();
    		else if( qEven.size() > 0 || qOdd.size() > 0){
    			cQ = cQ == qEven? qOdd : qEven;
    			current = cQ.remove();
    		}else
    			break;
    		//System.out.println("current: " + current.element + "\n " + cQ.size());
    		boolean found = execute(current, toFind, cmd);
    		if( found && cmd.equals("find") )
    			return current;
    		int d = depth.get(current) + 1;
    		if( d % 2 == 1 ){
    			ArrayList<TreeBNode> et = current.children;
    			for( int i = 0; i < et.size(); i++ ){
    				TreeBNode<AnyType> child = et.get(i);
    				depth.put(child, d);
    				qEven.addFirst(child);
    				//System.out.println("even " + child.element);
    			}
    		}else{
    			ArrayList<TreeBNode> et = current.children;
    			
    			for( int i = et.size()-1; i > -1; i-- ){
    				TreeBNode<AnyType> child = et.get(i);
    				depth.put(child, d);
    				qOdd.addFirst(child);
    				//System.out.println("odd " + child.element);
    			}
    		}
    		
    		
    	}
		return null;
    }
           // Basic node stored in unbalanced binary search trees
    private static class TreeBNode<AnyType>
    {
    	AnyType element;
    	ArrayList<TreeBNode> children;            // The data in the node
        // Constructors
        TreeBNode( AnyType theElement )
        {	
        	element  = theElement;
            children = new ArrayList<>();
        }        
    }


        // Test program
    public static void main( String [ ] args ) throws Exception
    {	
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	int t = Integer.parseInt( br.readLine() );
    	for (int i = 0; i < t; i++) {
    		int q = Integer.parseInt( br.readLine() );
    		System.out.println("Caso #" + (i+1) + ":");
    		TreeB<Integer> tree = new TreeB<>();
    		for (int j = 0; j < q; j++) {
				String[] in = br.readLine().split(" ");
				if( in.length == 1 )
				    continue;
				//System.out.println( Arrays.toString(in) );
				ArrayList<Integer> toAdd = new ArrayList<>();
				TreeBNode<Integer> node = new TreeBNode<>(Integer.parseInt(in[0]) );
				tree.insert(node.element, tree.root);
				
				for (int k = 1; k < in.length; k++) {
					toAdd.add( Integer.parseInt(in[k]) );
				}
				
				tree.insert(toAdd, node);
				
			}
    		//System.out.println("printing");
    		tree.BFS(tree.root, null, "print");
    		String an = new String(tree.ans).trim();
    		System.out.println( an );
		}
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.concurrent.PriorityBlockingQueue;

public class Problem {
	
	int time;
	int penalty;
	boolean solved;
	
	
	public Problem(int time, int penalty, boolean solved){
		this.time = time;
		this.penalty = penalty;
		this.solved = solved;
	}
	
	public Problem(){
		this(0,0,false);
	}
	
	public static void addToParticipant(HashMap<Integer,Problem> pProblems,
												int id, int problemid, int time, char result){
		//System.out.println("Participant " + id + ", " + problemid + ", " + time + ", " + result); 
		Problem p = pProblems.get(problemid);
		boolean solved = false;
		int penalty = 0;
		if( result !=  'C' ){
			penalty+=20;
		}else{
			//System.out.println("solved");
			solved = true;
		}
		if( p == null ){
			pProblems.put(problemid, new Problem(time, penalty, solved));
			return;
		}
		//System.out.println("Updating " + id + ", " + problemid + ", " + time + ", " + result);
		if( !p.solved ){
			p.time = time > p.time? time:p.time;
			p.penalty += penalty;
			p.solved = solved;
		}
		
	}
	
	public static Score calculateScore( HashMap<Integer, Problem> pProblems, int id ){
		int problems = 0;
		int penalty = 0;
		Collection<Problem> allproblems = pProblems.values();
		for( Problem p : allproblems ){
			//System.out.println("Participant " + id + ", " + p.time+ ", " + p.penalty + ", " + p.solved);
			if( p.solved ){
				problems++;
				penalty += p.time + p.penalty;
			}
		}
		return new Score(id, problems, penalty);
	}
	
	static class Score implements Comparable<Score>{
		int id;
		int problems;
		int penalty;
		
		public Score(int id, int problems, int penalty){
			this.id = id;
			this.problems = problems;
			this.penalty = penalty;
		}
		
		public String toString(){
			return "" + id + " " + problems + " " + penalty; 
		}

		@Override
		public int compareTo(Score o) {
			int proDiff = problems - o.problems;
			if( proDiff != 0 )
				return -proDiff;
			
			int penDiff = penalty - o.penalty;
			if( penDiff != 0 )
				return penDiff;
			
			int idDiff = id - o.id;
			if( idDiff != 0 )
				return idDiff;
			
			return 0;
		}
	}
	
	public static void main(String[] args) {
		
		try {
			
			BufferedReader br = new BufferedReader( new InputStreamReader(System.in) );
			int t = Integer.parseInt( br.readLine() );
			for (int i = 0; i < t; i++) {
				String[] cs = br.readLine().split(" ");
				int participants = Integer.parseInt(cs[0]);
				HashMap<Integer, HashMap<Integer,Problem>> scores = new HashMap<>();

				int submissions = Integer.parseInt(cs[1]);
				for (int j = 0; j < submissions; j++) {
					String[] submission = br.readLine().split(" ");
					int participant = Integer.parseInt(submission[0]);
					int problem = Integer.parseInt(submission[1]);
					int time = Integer.parseInt(submission[2]);
					char result = submission[3].charAt(0);
					HashMap<Integer, Problem> par = scores.get(participant);
					if( par == null ){
						par = new HashMap<>();
						scores.put(participant, par);
					}
					addToParticipant(par, participant, problem, time, result);
				}
				PriorityQueue<Score> finalScores = new PriorityQueue<>(); 
				for (int j = 0; j < participants; j++) {
					HashMap<Integer, Problem> sc = scores.get(j+1);
					if( sc == null)
						continue;
					finalScores.add( calculateScore(sc, j+1) );
				}
				
				
				System.out.println("Caso #" + (i+1) );
				int size = finalScores.size();
				for (int j = 0; j < size; j++) {
					System.out.println((Score)finalScores.poll());
				}
				
			}
		} catch (NumberFormatException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class heapA 
{
	public class MyHeap<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyHeap( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	    	System.out.println(getNode( idx , 0, size( ) ).data);
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    public void push(AnyType x )
	    {
	    	//System.out.println(getNode( 0 , 0, size( ) ).data);
	        addBefore( getNode( 0, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    public AnyType peek( )
	    {
	        return getNode( 0 ).data;
	    }
	    
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    public AnyType pop()
	    {
	        return remove( beginMarker.next );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyHeap.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	public static void main(String[] args) throws FileNotFoundException 
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		try{
		heapA a = new heapA();
		
		int tam = Integer.parseInt(br.readLine());
		String[] line = br.readLine().split(" ");
		//MyStack<Integer> st = a.new MyStack<>();
		MyHeap<Integer> max = a.new MyHeap<>();
		
		for (int i = 0; i < line.length; i++)
		{
			if(i < 2)
				System.out.println("-1");
			if (max.size() <= 3 && i <=2)
			{
				if (max.size() == 0)
					max.push(Integer.parseInt(line[i]));
				else 
				{
					int aux = max.peek();
					if (Integer.parseInt(line[i]) < aux)
					{
						aux = max.pop();
						if (max.size() == 1)
						{
							int aux2 = max.peek();
							if (Integer.parseInt(line[i]) < aux2)
							{
								aux2 = max.pop();
								max.push(Integer.parseInt(line[i]));
								max.push(aux2);
								max.push(aux);
							}
							else
							{
								max.push(Integer.parseInt(line[i]));
								max.push(aux);
							}
								
						}
						else
						{
							max.push(Integer.parseInt(line[i]));
							max.push(aux);
						}
						
					}
					else
					{
						max.push(Integer.parseInt(line[i]));
					}
						
				}
				if (max.size() >= 3)
				{
					int n1 = max.pop();
					int n2 = max.pop();
					int n3 = max.pop();
					System.out.println(n1 * n2 * n3);
					max.push(n3);
					max.push(n2);
					max.push(n1);
				}
			}
			else
			{
				int n1 = max.pop();
				int n2 = max.pop();
				int n3 = max.pop();
				int next = Integer.parseInt(line[i]);
				if (next >= n1)
				{
					n3 = n2;
					n2 = n1;
					n1 = next;
				}
				else if (next >= n2)
				{
					n3 = n2;
					n2 = next;
				}
				else if (next >= n3)
					n3 = next;
				System.out.println(n1 * n2 * n3);
				max.push(n3);
				max.push(n2);
				max.push(n1);
			}
		}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
	}
}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;


public class hashA 
{
	public class HashA
	{
	    public <K, V extends Comparable<? super V>> HashMap<K, V> 
	        sortByValue( HashMap<K, V> map )
	    {
	        LinkedList<HashMap.Entry<K, V>> list =
	            new LinkedList<HashMap.Entry<K, V>>( map.entrySet() );
	        Collections.sort( list, new Comparator<HashMap.Entry<K, V>>()
	        {
	            public int compare( HashMap.Entry<K, V> o1, HashMap.Entry<K, V> o2 )
	            {
	                return (o2.getValue()).compareTo( o1.getValue() );
	            }
	        } );

	        HashMap<K, V> result = new LinkedHashMap<K, V>();
	        for (HashMap.Entry<K, V> entry : list)
	        {
	            result.put( entry.getKey(), entry.getValue() );
	        }
	        return result;
	    }
	}
	
	public class Score implements Comparable<Score>
	{
		int team;
		HashMap<Integer, Integer> map = new HashMap<>();
		int minutes = 0;
		int penalty;
		int correctProblems = 0;

		public Score(int team) 
		{
			super();
			this.team = team;
		}
		
		public void addProblem (int problem)
		{
			if(map.containsKey(problem))
				this.map.put(problem, map.get(problem)+1);
			else
				this.map.put(problem, 0);
		}
		
		public void correctProblem (int problem, int minutes)
		{
			int tries = this.map.get(problem);
			this.penalty += 20 * tries + minutes;
			this.correctProblems++;
		}
		
		@Override
		public int compareTo(Score other) 
		{
			if(this.correctProblems > other.correctProblems)
				return 1;
			else if(this.correctProblems < other.correctProblems)
				return -1;
			else if(this.penalty < other.penalty)
				return 1;
			else if(this.penalty > other.penalty)
				return -1;
			else if(this.team < other.team)
				return 1;
			else if(this.team > other.team)
				return -1;
			return 0;
		}

		
	}
	public static void main(String[] args)
	{
        Scanner cin = new Scanner (System.in);
		hashA a = new hashA();
		
		int numberCases = Integer.parseInt(cin.nextLine());
		
		for (int i = 0; i < numberCases; i++) 
		{
			System.out.println("Caso #" + (i+1) + ":");
			int n = cin.nextInt();
			int k = cin.nextInt();
			cin.nextLine();
			HashMap<Integer, Score> map = new HashMap<>(n);
			for (int j = 0; j < k; j++) 
			{
				int team = cin.nextInt();
				int problem = cin.nextInt();
				int time = cin.nextInt();
				char status = cin.next().charAt(0);
				
				if(map.containsKey(team))
				{
					Score s = map.get(team);
					if (status == 'C')
					{
						s.addProblem(problem);
						s.correctProblem(problem, time);
					}
					else
						s.addProblem(problem);
					map.put(team, s);
				}
				else
				{
					Score s = a.new Score(team);
					if (status == 'C')
					{
						s.addProblem(problem);
						s.correctProblem(problem, time);
					}
					else
						s.addProblem(problem);
					map.put(team, s);
				}
				
				
				if (j != k - 1)
					cin.nextLine();
			}
			
			HashA order = a.new HashA();
			map = order.sortByValue(map);
			for (Score score: map.values()) 
			{
				System.out.println(score.team + " " + score.correctProblems + " " + score.penalty);
			}
		}
		cin.close();
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.HashMap;
import java.util.Scanner;


public class hashB 
{
	public static void main(String[] args)
	{
        Scanner cin = new Scanner (System.in);
		int numberCases = Integer.parseInt(cin.nextLine());
		
		for (int i = 0; i < numberCases; i++) 
		{
			System.out.println("Caso #" + (i+1) + ":");
			int N = Integer.parseInt(cin.nextLine());
			int [] numbers = new int [N];
			HashMap<Integer, Integer> map = new HashMap<>();
			int idx = 0;
			for (int j = 0; j < N; j++) 
			{
				int a = cin.nextInt();
				if(map.containsKey(a))
				{
					map.put(a, map.get(a)+1);
				}
				else
				{
					numbers[idx++] = a;
					map.put(a, 1);
				}
				
			}
			if (i != numberCases-1)
				cin.nextLine();
			
			for (int j = 0; j < map.keySet().size(); j++)  
			{
				System.out.println(numbers[j] + " " + map.get(numbers[j]));
			}
		}
		
		cin.close();
		
		
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class heapD 
{
	public class heapNotes 
	{
		 int start;
		 int end;
		 heapNotes leftTree;
		 heapNotes rightTree;
		 float maxNote;
		 float minNote;
		 
		 public heapNotes(int start, int end) 
		 {
			 this.start = start;
			 this.end = end;
			 if(start == end) 
			 {
				 leftTree = rightTree = null;
				 return;
			 }
			 int mid = (start + end) / 2;
			 leftTree = new heapNotes(start, mid);
			 rightTree = new heapNotes(mid + 1, end);
		 }

		 public void set(int pos, float value) 
		 {
			 if(start == end)
			 {
				 minNote = value;
				 maxNote = value;
				 return;
			 }
			 
			 int mid = (start + end) / 2;
			 
			 if(pos <= mid)
				 leftTree.set(pos, value);
			 else
				 rightTree.set(pos, value);

			 minNote = Math.min(leftTree.minNote, rightTree.minNote);
			 maxNote = Math.max(leftTree.maxNote, rightTree.maxNote);
		 }
		 public float[] getData(int low, int high) 
		 {
			 float data [] = new float[2];
			 if(start == low && end == high)
			 {
				 data[0] = maxNote;
				 data[1] = minNote;
				 return data;
			 }
			 
			 int mid = (start + end) / 2;

			 if(high <= mid) 
				 return leftTree.getData(low, high);

			 if(low > mid)
				 return rightTree.getData(low, high);

			 float[] dataLeft = leftTree.getData(low, mid);
			 float[] dataRight = rightTree.getData(mid+1, high);
			 
			 data[0] = Math.max(dataLeft[0], dataRight[0]);
			 data[1] = Math.min(dataLeft[1], dataRight[1]);
			 
			 return data;
		 }
	}
	public static void main(String[] args)
	{
        Scanner cin = new Scanner (System.in);
		heapD d = new heapD();
		int numberCases = Integer.parseInt(cin.nextLine());
		
		for (int nc = 0; nc < numberCases; nc++) 
		{
			System.out.println("Caso #" + (nc+1) + ":");
			int numberCareers = Integer.parseInt(cin.nextLine());
			String averages = "";
			for (int i = 0; i < numberCareers; i++) 
			{
				averages = averages.concat(cin.nextLine());
				averages = averages.concat(" ");
			}
			String [] notes = averages.split(" ");	
			heapNotes tree = d.new heapNotes(0, notes.length-1);
			for (int i = 0; i < notes.length; i++) 
			{
				tree.set(i,Float.parseFloat(notes[i]));
			}
			int numberQueries = Integer.parseInt(cin.nextLine());
			for (int i = 0; i < numberQueries; i++) 
			{
				String [] queries = cin.nextLine().split(" ");
				if (queries[0].equalsIgnoreCase("cambiar"))
				{
					int idx = Integer.parseInt(queries[1]);
					float x = Float.parseFloat(queries[2]);
					tree.set(idx, x);
				}
				else 
				{
					int a = Integer.parseInt(queries[1]);
					int b = Integer.parseInt(queries[2]);
					float max = tree.getData(a, b)[0];
					float min = tree.getData(a, b)[1];
					if (max*10 % 10 == 0 && min*10 % 10 == 0)
					{
						int m = (int) max;
						int n = (int) min;
						System.out.println(m + " " + n);
					}
					else if (max*10 % 10 == 0)
					{
						int m = (int) max;
						System.out.println(m + " " + min);
					}
					else if (min*10 % 10 == 0)
					{
						int n = (int) min;
						System.out.println(max + " " + n);
					}
					else 
						System.out.println(max + " " + min);
				}
			}
				
		}
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


public class heapB 
{
	public class HeapB<AnyType extends Comparable<? super AnyType>>
	{
	    /**
	     * Construct the binary heap.
	     */
	    public HeapB( )
	    {
	        this( DEFAULT_CAPACITY );
	    }

	    /**
	     * Construct the binary heap.
	     * @param capacity the capacity of the binary heap.
	     */
	    public HeapB( int capacity )
	    {
	        currentSize = 0;
	        array = (AnyType[]) new Comparable[ capacity + 1 ];
	    }
	    
	    /**
	     * Construct the binary heap given an array of items.
	     * @param items
	     */
	    public HeapB( AnyType [ ] items )
	    {
	            currentSize = items.length;
	            array = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];
	            int i = 1;
	            for( AnyType item : items )
	                array[ i++ ] = item;
	            buildHeap( );
	    }

	    /**
	     * Insert into the priority queue, maintaining heap order.
	     * Duplicates are allowed.
	     * @param x the item to insert.
	     */
	    public void insert( AnyType x )
	    {
	        if( currentSize == array.length - 1 )
	            enlargeArray( array.length * 2 + 1 );

	            // Percolate up
	        int hole = ++currentSize;
	        for( array[ 0 ] = x; x.compareTo( array[ hole / 2 ] ) > 0; hole /= 2 )
	            array[ hole ] = array[ hole / 2 ];
	        array[ hole ] = x;
	    }


	    private void enlargeArray( int newSize )
	    {
	            AnyType [] old = array;
	            array = (AnyType []) new Comparable[ newSize ];
	            for( int i = 0; i < old.length; i++ )
	                array[ i ] = old[ i ];        
	    }
	    
	    /**
	     * Find the smallest item in the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType findMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );
	        return array[ 1 ];
	    }

	    /**
	     * Remove the smallest item from the priority queue.
	     * @return the smallest item, or throw an UnderflowException if empty.
	     * @throws java.lang.Exception
	     */
	    public AnyType deleteMax( ) throws Exception
	    {
	        if( isEmpty( ) )
	            throw new Exception( );

	        AnyType minItem = findMax( );
	        array[ 1 ] = array[ currentSize-- ];
	        percolateDown( 1 );

	        return minItem;
	    }

	    /**
	     * Establish heap order property from an arbitrary
	     * arrangement of items. Runs in linear time.
	     */
	    private void buildHeap( )
	    {
	        for( int i = currentSize / 2; i > 0; i-- )
	            percolateDown( i );
	    }

	    /**
	     * Test if the priority queue is logically empty.
	     * @return true if empty, false otherwise.
	     */
	    public boolean isEmpty( )
	    {
	        return currentSize == 0;
	    }

	    /**
	     * Make the priority queue logically empty.
	     */
	    public void makeEmpty( )
	    {
	        currentSize = 0;
	    }

	    private static final int DEFAULT_CAPACITY = 10;

	    private int currentSize;      // Number of elements in heap
	    private AnyType [ ] array; // The heap array

	    /**
	     * Internal method to percolate down in the heap.
	     * @param hole the index at which the percolate begins.
	     */
	    private void percolateDown( int hole )
	    {
	        int child;
	        AnyType tmp = array[ hole ];

	        for( ; (hole * 2) <= currentSize; hole = child )
	        {
	            child = (hole * 2);
	            if( child != currentSize &&
	                    array[ child + 1].compareTo( array[ child ] ) > 0 )
	                child++;
	            if( array[ child ].compareTo( tmp ) > 0 )
	                array[ hole ] = array[ child ];
	            else
	                break;
	        }
	        array[ hole ] = tmp;	        
	    }
	}
	
	public class MyQueue<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyQueue( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	    	//System.out.println(getNode( idx , 0, size( ) ).data);
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    public void push(AnyType x )
	    {
	    	//System.out.println(getNode( 0 , 0, size( ) ).data);
	        addBefore( getNode( 0, 0, size( ) ), x );
	    }
	    
	    public void enqueue(AnyType x )
	    {
	    	//System.out.println(getNode( 0 , 0, size( ) ).data);
	    	add( size( ), x );
	    }
	    
	    public void dequeue()
	    {
	    	//System.out.println(getNode( 0 , 0, size( ) ).data);
	    	remove( beginMarker.next );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	    
	    public AnyType peek( )
	    {
	        return getNode( 0 ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    public AnyType pop()
	    {
	        return remove( beginMarker.next );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }
	    
	    public void getNeedys ()
	    {
	    	Node <AnyType> a = beginMarker.next;
	    	while (a.data != null)
	    	{
	    		System.out.print(a.needy + " ");
	    		a = a.next;
	    	}
	    	System.out.println();
	    }
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyQueue.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n; needy = false;
	        }
	        
	        public void setNeedy ()
	        {
	        	needy = true;
	        }
	        
	        public AnyType data;
	        public boolean needy;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	public class MyStack<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyStack( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	    	System.out.println(getNode( idx , 0, size( ) ).data);
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    public void push(AnyType x )
	    {
	    	//System.out.println(getNode( 0 , 0, size( ) ).data);
	        addBefore( getNode( 0, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	     
	    public AnyType peek( )
	    {
	        return getNode( 0 ).data;
	    }
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    public AnyType pop()
	    {
	        return remove( beginMarker.next );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyStack.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	public static void main(String[] args) throws Exception 
	{
        Scanner cin = new Scanner (System.in);
		heapB b = new heapB();
		int numberCases = Integer.parseInt(cin.nextLine());
		
		for (int p = 0; p < numberCases; p++) 
		{
			int n = cin.nextInt();
			int m = cin.nextInt();
			int time = 0;
			int needyValue = 0;
			cin.nextLine();
			Integer[] toPrint = new Integer [n];
			MyQueue<Integer> queue = b.new MyQueue<>();
			for (int i = 0; i < n; i++)
			{
				int next = cin.nextInt();
				queue.enqueue(next);
				if (i == m)
				{
					queue.getNode(queue.size()-1).setNeedy();
					needyValue = next;
				}
				toPrint[i] = next;
			}
			if(p != numberCases - 1)
				cin.nextLine();
			HeapB<Integer> heap = b.new HeapB<>(toPrint);
			boolean temp = true;
			while (temp && !heap.isEmpty())
			{
				int max = heap.findMax();
				while (queue.peek() != max)
				{
					if (queue.getNode(0).needy == true)
					{
						queue.enqueue(queue.peek());
						queue.getNode(queue.size()-1).setNeedy();
						queue.dequeue();
					}
					else
					{
						queue.enqueue(queue.peek());
						queue.dequeue();
					}
				}
				if (queue.getNode(0).needy == true)
					temp = false;
				queue.dequeue();
				heap.deleteMax();
				time++;
			}

			System.out.println(time);

		}
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.HashMap;
import java.util.Scanner;

public class hashC 
{
	public static class UnionFind 
	{
		private int id[];
		private int sz[];
		private int cont;

		public int getCont() 
		{
			return cont;
		}
		
		public int getSize(int x) 
		{
			return sz[x];
		}

		public UnionFind(int n) 
		{
			id = new int[n];
			sz = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) 
			{
				id[i] = i;
				sz[i] = 1;
			}
		}

		public int find(int x) 
		{
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) 
		{
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if (sz[a] < sz[b]) 
			{
				id[a] = b;
				sz[b] += sz[a];
			} 
			else 
			{
				id[b] = a;
				sz[a] += sz[b];
			}
			cont--;
		}
	}

	public static void main(String[] args)
	{
        Scanner cin = new Scanner (System.in);
		int numberCases = Integer.parseInt(cin.nextLine());
		
		for (int i = 0; i < numberCases; i++) 
		{
			System.out.println("Caso #" + (i+1) + ":");
			int isFriend = Integer.parseInt(cin.nextLine());
			HashMap<String, Integer> map = new HashMap<>();
			UnionFind unionFind = new UnionFind(2*isFriend);
			int temp = 0;
			for (int j = 0; j < isFriend; j++) 
			{
				String Aperson = cin.next();
				String Bperson = cin.next();
				int Atemp = 0, Btemp = 0;
				if(!map.containsKey(Aperson) && !map.containsKey(Bperson))
				{
					Atemp = temp;
					map.put(Aperson, temp++);
					Btemp = temp;
					map.put(Bperson, temp++);
				}
				else if(map.containsKey(Aperson) && !map.containsKey(Bperson))
				{
					Atemp = map.get(Aperson);
					Btemp = temp;
					map.put(Bperson, temp++);
				}
				else if(map.containsKey(Bperson) && !map.containsKey(Aperson))
				{
					Atemp = map.get(Bperson);
					Btemp = temp;
					map.put(Aperson, temp++);
				}
				else
				{
					Atemp = map.get(Aperson);
					Btemp = map.get(Bperson);
				}
				unionFind.union(Atemp, Btemp);
				System.out.println(unionFind.getSize(unionFind.find(Atemp)));
				
				if(i != numberCases-1)
					cin.nextLine();
			}
		}
		cin.close();
	}

}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


public class hashD 
{
	public static class MyUFd 
	{
		private int id[];
		private int rank[];
		private int cont;

		public int getCont() 
		{
			return cont;
		}

		public MyUFd(int n) 
		{
			id = new int[n];
			rank = new int[n];
			cont = n;
			for (int i = 0; i < n; i++) 
			{
				id[i] = i;
				rank[i] = 1;
			}
		}

		public int find(int x) 
		{
			if (id[x] != x)
				return id[x] = find(id[x]);
			return x;
		}

		public void union(int x, int y) 
		{
			int a = find(x);
			int b = find(y);
			if (a == b)
				return;
			if (rank[a] < rank[b]) 
			{
				id[a] = b;
			} 
			else 
			{
				id[b] = a;
				if (rank[a] == rank[b])
					rank[b]++;
			}
			cont--;
		}
		
		public boolean getEnm(int x, int y)
		{
			return find(2*x+1) == find(2*y);
		}
		
		public boolean getFr(int x, int y)
		{
			return find(2*x) == find(2*y);
		}
		
		public void setEnm(int x, int y)
		{
			union(2*x+1, 2*y);
			union(2*x, 2*y+1);
		}
		public void setFr(int x, int y)
		{
			union(2*x+1, 2*y+1);
			union(2*x, 2*y);
		}
		
		
		
		
	}
	public static void main(String[] args)
	{
        Scanner cin = new Scanner (System.in);
		int numberCases = Integer.parseInt(cin.nextLine());
		for (int i = 0; i < numberCases; i++) 
		{
			System.out.println("Caso #" + (i+1) + ":");
			int n = cin.nextInt();
			int k = cin.nextInt();
			MyUFd unionFind = new MyUFd(2*n);
			for (int j = 0; j < k; j++) 
			{
				int operation = cin.nextInt();
				int person1 = cin.nextInt();
				int person2 = cin.nextInt();
			
				switch(operation)
				{
					case 1:
					{
						if(unionFind.getEnm(person1, person2))
							System.out.println("-1");
						else
						{
							unionFind.setFr(person1, person2);
						}
						break;
					}
					case 2:
					{
						if(person1 == person2 || unionFind.getFr(person1, person2))
							System.out.println("-1");
						else
						{
							unionFind.setEnm(person1, person2);
						}
						break;
					}
					case 3:
					{
						if(unionFind.getFr(person1, person2))
							System.out.println("1");
							
						else
							System.out.println("0");
							
						break;
					}
					case 4:
					{
						if(unionFind.getEnm(person1, person2))
							System.out.println("1");
							
						else
							System.out.println("0");
							
						break;
					}
				}
			}
			if(i != numberCases-1)
				cin.nextLine();
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.io.BufferedReader;
import java.io.InputStreamReader;

import javax.sql.CommonDataSource;

// BinarySearchTree class
//
// CONSTRUCTION: with no initializer
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// boolean contains( x )  --> Return true if x is present
// Comparable findMin( )  --> Return smallest item
// Comparable findMax( )  --> Return largest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// void printTree( )      --> Print tree in sorted order
// ******************ERRORS********************************
// Throws UnderflowException as appropriate

/**
 * Implements an unbalanced binary search tree.
 * Note that all "matching" is based on the compareTo method.
 */
public class BinarySearchTreeA<AnyType extends Comparable<? super AnyType>>
{
    /**
     * Construct the tree.
     */
    public BinarySearchTreeA( )
    {
        root = null;
    }

    /**
     * Insert into the tree; duplicates are ignored.
     * @param x the item to insert.
     */
    public void insert( AnyType x )
    {
        root = insert( x, root );
    }

    /**
     * Remove from the tree. Nothing is done if x is not found.
     * @param x the item to remove.
     */
    public void remove( AnyType x )
    {
        root = remove( x, root );
    }

    /**
     * Find the smallest item in the tree.
     * @return smallest item or null if empty.
     */
    public AnyType findMin( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMin( root ).element;
    }

    /**
     * Find the largest item in the tree.
     * @return the largest item of null if empty.
     */
    public AnyType findMax( ) throws Exception
    {
        if( isEmpty( ) )
            throw new Exception( );
        return findMax( root ).element;
    }

    /**
     * Find an item in the tree.
     * @param x the item to search for.
     * @return true if not found.
     */
    public boolean contains( AnyType x )
    {
        return contains( x, root );
    }

    /**
     * Make the tree logically empty.
     */
    public void makeEmpty( )
    {
        root = null;
    }

    /**
     * Test if the tree is logically empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty( )
    {
        return root == null;
    }

    /**
     * Print the tree contents in sorted order.
     */
    public void printTree( )
    {
        if( isEmpty( ) )
            System.out.println( "Empty tree" );
        else
            printTree( root );
    }

    /**
     * Internal method to insert into a subtree.
     * @param x the item to insert.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> insert( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return new BinaryNode<>( x, null, null );
        
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = insert( x, t.left );
        else if( compareResult > 0 )
            t.right = insert( x, t.right );
        else
            ;  // Duplicate; do nothing
        return t;
    }

    /**
     * Internal method to remove from a subtree.
     * @param x the item to remove.
     * @param t the node that roots the subtree.
     * @return the new root of the subtree.
     */
    private BinaryNode<AnyType> remove( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return t;   // Item not found; do nothing
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            t.left = remove( x, t.left );
        else if( compareResult > 0 )
            t.right = remove( x, t.right );
        else if( t.left != null && t.right != null ) // Two children
        {
            t.element = findMin( t.right ).element;
            t.right = remove( t.element, t.right );
        }
        else
            t = ( t.left != null ) ? t.left : t.right;
        return t;
    }

    /**
     * Internal method to find the smallest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the smallest item.
     */
    private BinaryNode<AnyType> findMin( BinaryNode<AnyType> t )
    {
        if( t == null )
            return null;
        else if( t.left == null )
            return t;
        return findMin( t.left );
    }

    /**
     * Internal method to find the largest item in a subtree.
     * @param t the node that roots the subtree.
     * @return node containing the largest item.
     */
    private BinaryNode<AnyType> findMax( BinaryNode<AnyType> t )
    {
        if( t != null )
            while( t.right != null )
                t = t.right;

        return t;
    }

    /**
     * Internal method to find an item in a subtree.
     * @param x is item to search for.
     * @param t the node that roots the subtree.
     * @return node containing the matched item.
     */
    private boolean contains( AnyType x, BinaryNode<AnyType> t )
    {
        if( t == null )
            return false;
            
        int compareResult = x.compareTo( t.element );
            
        if( compareResult < 0 )
            return contains( x, t.left );
        else if( compareResult > 0 )
            return contains( x, t.right );
        else
            return true;    // Match
    }

    /**
     * Internal method to print a subtree in sorted order.
     * @param t the node that roots the subtree.
     */
    private void printTree( BinaryNode<AnyType> t )
    {
        if( t != null )
        {
            printTree( t.left );
            System.out.println( t.element );
            printTree( t.right );
        }
    }

    /**
     * Internal method to compute height of a subtree.
     * @param t the node that roots the subtree.
     */
    private int height( BinaryNode<AnyType> t )
    {
        if( t == null )
            return -1;
        else
            return 1 + Math.max( height( t.left ), height( t.right ) );    
    }
    
    public BinaryNode<AnyType> find( BinaryNode<AnyType> t, Comparable<? super AnyType> toFind ){
    	if( t == null )
            return null;
            
        int compareResult = toFind.compareTo( t.element );
            
        if( compareResult < 0 )
            return find( t.left, toFind );
        else if( compareResult > 0 )
            return find( t.right, toFind );
        else
            return t;    // Match
    }
    
    public boolean isAncestor(BinaryNode<AnyType> a, Comparable<? super AnyType> b){
    	if( b.compareTo(a.element) == 0 )
    		return true;
    	BinaryNode<AnyType> ancestor = find( root, a.element );
    	if( ancestor == null )
    		return false;
    	
    	if( find( ancestor, b ) != null )
    		return true;
    	
    	return false;
    }
    
    public BinaryNode<AnyType> commonAncestor(BinaryNode<AnyType> t, 
    											Comparable<? super AnyType> a,
    												Comparable<? super AnyType> b){
    	if( t == null )
    		return null;
    	
    	if( isAncestor(t, a) && isAncestor(t, b) ){
    		BinaryNode<AnyType> left = commonAncestor( t.left, a, b);
    		BinaryNode<AnyType> right = commonAncestor( t.right, a, b);
    		if( left != null )
    			return left;
    		else if( right != null )
    			return right;
    		else
    			return t;
    	}else
    		return null;
    }
    
    public int distanceFromAncestor( BinaryNode<AnyType> ancestor, Comparable<? super AnyType> node ){
    	if( ancestor == null )
            return 0;
            
        int compareResult = node.compareTo( ancestor.element );
            
        if( compareResult < 0 )
            return distanceFromAncestor( ancestor.left, node ) + 1 ;
        else if( compareResult > 0 )
            return distanceFromAncestor( ancestor.right, node ) + 1 ;
        else
            return 0;    // Match
    }
    
    public int distance( Comparable<? super AnyType> a, Comparable<? super AnyType> b){
    	BinaryNode<AnyType> common = commonAncestor(root, a, b);
    	return distanceFromAncestor( common, a ) + distanceFromAncestor( common, b);
    }
    // Basic node stored in unbalanced binary search trees
    private static class BinaryNode<AnyType>
    {
            // Constructors
        BinaryNode( AnyType theElement )
        {
            this( theElement, null, null );
        }

        BinaryNode( AnyType theElement, BinaryNode<AnyType> lt, BinaryNode<AnyType> rt )
        {
            element  = theElement;
            left     = lt;
            right    = rt;
        }

        AnyType element;            // The data in the node
        BinaryNode<AnyType> left;   // Left child
        BinaryNode<AnyType> right;  // Right child
    }


      /** The tree root. */
    private BinaryNode<AnyType> root;


        // Test program
    public static void main( String [ ] args ) throws Exception
    {	
    	
    	BufferedReader br = new BufferedReader( new InputStreamReader(System.in) );
    	
    	int t = Integer.parseInt(br.readLine());
    	
    	for( int i = 0; i < t; i++ ){
    		System.out.println("Caso #" + (i+1) + ":");
    		BinarySearchTreeA<Integer> tree = new BinarySearchTreeA<>( );
    		int q = Integer.parseInt( br.readLine() );
    		for( int j = 0; j < q; j++ ){
    			String[] cmd = br.readLine().split(" ");
    			switch(cmd[0]){
    			case "agregar":
    				tree.insert( Integer.parseInt(cmd[1]) );
    				break;
    			case "distancia":
    				int a = Integer.parseInt( cmd[1] );
    				int b = Integer.parseInt( cmd[2] );
    				int distance = -1;
    				if( tree.root != null && tree.contains(a) && tree.contains(b) )
    					distance = tree.distance( a, b );
    				System.out.println("distancia: " + distance);
    				break;
    			case "ancestro":
    				int a1 = Integer.parseInt( cmd[1] );
    				int b2 = Integer.parseInt( cmd[2] );
    				int ancestor = -1;
    				if( tree.root != null && tree.contains(a1) && tree.contains(b2) )
    					ancestor = tree.commonAncestor( tree.root, a1, b2 ).element;
    				System.out.println("ancestro: " + ancestor);
    				break;
    			}
    			
    			
    		}
    	}
        
    }
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;


public class hashA 
{
	public class HashA
	{
	    public <K, V extends Comparable<? super V>> HashMap<K, V> 
	        sortByValue( HashMap<K, V> map )
	    {
	        LinkedList<HashMap.Entry<K, V>> list =
	            new LinkedList<HashMap.Entry<K, V>>( map.entrySet() );
	        Collections.sort( list, new Comparator<HashMap.Entry<K, V>>()
	        {
	            public int compare( HashMap.Entry<K, V> o1, HashMap.Entry<K, V> o2 )
	            {
	                return (o2.getValue()).compareTo( o1.getValue() );
	            }
	        } );

	        HashMap<K, V> result = new LinkedHashMap<K, V>();
	        for (HashMap.Entry<K, V> entry : list)
	        {
	            result.put( entry.getKey(), entry.getValue() );
	        }
	        return result;
	    }
	}
	
	public class Score implements Comparable<Score>
	{
		int team;
		HashMap<Integer, Integer> map = new HashMap<>();
		int minutes = 0;
		int penalty;
		int correctProblems = 0;

		public Score(int team) 
		{
			super();
			this.team = team;
		}
		
		public void addProblem (int problem)
		{
			if(map.containsKey(problem))
				this.map.put(problem, map.get(problem)+1);
			else
				this.map.put(problem, 0);
		}
		
		public void correctProblem (int problem, int minutes)
		{
			int tries = this.map.get(problem);
			this.penalty += 20 * tries + minutes;
			this.correctProblems++;
		}
		
		@Override
		public int compareTo(Score other) 
		{
			if(this.correctProblems > other.correctProblems)
				return 1;
			else if(this.correctProblems < other.correctProblems)
				return -1;
			else if(this.penalty < other.penalty)
				return 1;
			else if(this.penalty > other.penalty)
				return -1;
			else if(this.team < other.team)
				return 1;
			else if(this.team > other.team)
				return -1;
			return 0;
		}

		
	}
	public static void main(String[] args)
	{
        Scanner cin = new Scanner (System.in);
		hashA a = new hashA();
		
		int numberCases = Integer.parseInt(cin.nextLine());
		
		for (int i = 0; i < numberCases; i++) 
		{
			System.out.println("Caso #" + (i+1) + ":");
			int n = cin.nextInt();
			int k = cin.nextInt();
			cin.nextLine();
			HashMap<Integer, Score> map = new HashMap<>(n);
			for (int j = 0; j < k; j++) 
			{
				int team = cin.nextInt();
				int problem = cin.nextInt();
				int time = cin.nextInt();
				char status = cin.next().charAt(0);
				
				if(map.containsKey(team))
				{
					Score s = map.get(team);
					if (status == 'C')
					{
						s.addProblem(problem);
						s.correctProblem(problem, time);
					}
					else
						s.addProblem(problem);
					map.put(team, s);
				}
				else
				{
					Score s = a.new Score(team);
					if (status == 'C')
					{
						s.addProblem(problem);
						s.correctProblem(problem, time);
					}
					else
						s.addProblem(problem);
					map.put(team, s);
				}
				
				
				if (j != k - 1)
					cin.nextLine();
			}
			
			HashA order = a.new HashA();
			map = order.sortByValue(map);
			for (Score score: map.values()) 
			{
				System.out.println(score.team + " " + score.correctProblems + " " + score.penalty);
			}
		}
		cin.close();
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Scanner;


public class hashA 
{
	public class MyHashA
	{
	    public <K, V extends Comparable<? super V>> HashMap<K, V> 
	        sortByValue( HashMap<K, V> map )
	    {
	        LinkedList<HashMap.Entry<K, V>> list =
	            new LinkedList<HashMap.Entry<K, V>>( map.entrySet() );
	        Collections.sort( list, new Comparator<HashMap.Entry<K, V>>()
	        {
	            public int compare( HashMap.Entry<K, V> o1, HashMap.Entry<K, V> o2 )
	            {
	                return (o2.getValue()).compareTo( o1.getValue() );
	            }
	        } );

	        HashMap<K, V> result = new LinkedHashMap<K, V>();
	        for (HashMap.Entry<K, V> entry : list)
	        {
	            result.put( entry.getKey(), entry.getValue() );
	        }
	        return result;
	    }
	}
	
	public class Score implements Comparable<Score>
	{
		int team;
		HashMap<Integer, Integer> map = new HashMap<>();
		int minutes = 0;
		int penalty;
		int correctProblems = 0;

		public Score(int team) 
		{
			super();
			this.team = team;
		}
		
		public void addProblem (int problem)
		{
			if(map.containsKey(problem))
				this.map.put(problem, map.get(problem)+1);
			else
				this.map.put(problem, 0);
		}
		
		public void correctProblem (int problem, int minutes)
		{
			int tries = this.map.get(problem);
			this.penalty += 20 * tries + minutes;
			this.correctProblems++;
		}
		
		@Override
		public int compareTo(Score other) 
		{
			if(this.correctProblems > other.correctProblems)
				return 1;
			else if(this.correctProblems < other.correctProblems)
				return -1;
			else if(this.penalty < other.penalty)
				return 1;
			else if(this.penalty > other.penalty)
				return -1;
			else if(this.team < other.team)
				return 1;
			else if(this.team > other.team)
				return -1;
			return 0;
		}

		
	}
	public static void main(String[] args){ 

    	Scanner cin = new Scanner (System.in);
		hashA a = new hashA();
		
		int testCases = Integer.parseInt(cin.nextLine());
		
		for (int i = 0; i < testCases; i++) 
		{
			System.out.println("Caso #" + (i+1) + ":");
			int teams = cin.nextInt();
			int sendings = cin.nextInt();
			cin.nextLine();
			HashMap<Integer, Score> map = new HashMap<>(teams);
			for (int j = 0; j < sendings; j++) 
			{
				int team = cin.nextInt();
				int problem = cin.nextInt();
				int time = cin.nextInt();
				char status = cin.next().charAt(0);
				
				if(map.containsKey(team))
				{
					Score s = map.get(team);
					if (status == 'C')
					{
						s.addProblem(problem);
						s.correctProblem(problem, time);
					}
					else
						s.addProblem(problem);
					map.put(team, s);
				}
				else
				{
					Score s = a.new Score(team);
					if (status == 'C')
					{
						s.addProblem(problem);
						s.correctProblem(problem, time);
					}
					else
						s.addProblem(problem);
					map.put(team, s);
				}
				
				
				if (j != sendings - 1)
					cin.nextLine();
			}
			
			MyHashA order = a.new MyHashA();
			map = order.sortByValue(map);
			for (Score score: map.values()) 
			{
				System.out.println(score.team + " " + score.correctProblems + " " + score.penalty);
			}
		}
		cin.close();
	}
}


<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;


public class heapA 
{
	public class MyHeapA<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public MyHeapA( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	    	System.out.println(getNode( idx , 0, size( ) ).data);
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    public void push(AnyType x )
	    {
	    	//System.out.println(getNode( 0 , 0, size( ) ).data);
	        addBefore( getNode( 0, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    public AnyType peek( )
	    {
	        return getNode( 0 ).data;
	    }
	    
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    public AnyType pop()
	    {
	        return remove( beginMarker.next );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            MyHeapA.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}
	
	public static void main(String[] args)
	{
		Scanner cin = new Scanner (System.in);
		heapA a = new heapA();
		
		int size = Integer.parseInt(cin.nextLine());
		String[] line = cin.nextLine().split(" ");
		MyHeapA<Integer> max = a.new MyHeapA<>();
		
		for (int i = 0; i < line.length; i++)
		{
			if(i < 2)
				System.out.println("-1");
			if (max.size() <= 3 && i <=2)
			{
				if (max.size() == 0)
					max.push(Integer.parseInt(line[i]));
				else 
				{
					int aux = max.peek();
					if (Integer.parseInt(line[i]) < aux)
					{
						aux = max.pop();
						if (max.size() == 1)
						{
							int aux2 = max.peek();
							if (Integer.parseInt(line[i]) < aux2)
							{
								aux2 = max.pop();
								max.push(Integer.parseInt(line[i]));
								max.push(aux2);
								max.push(aux);
							}
							else
							{
								max.push(Integer.parseInt(line[i]));
								max.push(aux);
							}
								
						}
						else
						{
							max.push(Integer.parseInt(line[i]));
							max.push(aux);
						}
						
					}
					else
					{
						max.push(Integer.parseInt(line[i]));
					}
						
				}
				if (max.size() >= 3)
				{
					int n1 = max.pop();
					int n2 = max.pop();
					int n3 = max.pop();
					System.out.println(n1 * n2 * n3);
					max.push(n3);
					max.push(n2);
					max.push(n1);
				}
			}
			else
			{
				int n1 = max.pop();
				int n2 = max.pop();
				int n3 = max.pop();
				int next = Integer.parseInt(line[i]);
				if (next >= n1)
				{
					n3 = n2;
					n2 = n1;
					n1 = next;
				}
				else if (next >= n2)
				{
					n3 = n2;
					n2 = next;
				}
				else if (next >= n3)
					n3 = next;
				System.out.println(n1 * n2 * n3);
				max.push(n3);
				max.push(n2);
				max.push(n1);
			}
		}
	}
}

<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
import java.util.Scanner;

public class treeB {

	public static class ArrayTreeB<AnyType> implements Iterable<AnyType>
	{
	    
		
		/**
	     * Construct an empty ArrayList.
	     */
	    public ArrayTreeB( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    /**
	     * Returns true if this collection is empty.
	     * @return true if this collection is empty.
	     */ 
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        return theItems[ idx ];    
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws ArrayIndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType addinidx( int idx, AnyType newVal )
	    {
	        if( idx < 0 || idx >= size( ) )
	            throw new ArrayIndexOutOfBoundsException( "Index " + idx + "; size " + size( ) );
	        AnyType old = theItems[ idx ];    
	        theItems[ idx ] = newVal;
	        
	        return old;    
	    }

	    @SuppressWarnings("unchecked")
	    public void ensureCapacity( int newCapacity )
	    {
	        if( newCapacity < theSize )
	            return;

	        AnyType [ ] old = theItems;
	        theItems = (AnyType []) new Object[ newCapacity ];
	        for( int i = 0; i < size( ); i++ )
	            theItems[ i ] = old[ i ];
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	    add( size( ), x );
	        return true;            
	    }
	    
	    /**
	     * Adds an item to this collection, at the specified index.
	     * @param x any object.
	     * @return true.
	     */
	    public void add( int idx, AnyType x )
	    {
	        if( theItems.length == size( ) )
	            ensureCapacity( size( ) * 2 + 1 );

	        for( int i = theSize; i > idx; i-- )
	            theItems[ i ] = theItems[ i - 1 ];

	        theItems[ idx ] = x;
	        theSize++;  
	    }
	      
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        AnyType removedItem = theItems[ idx ];
	        
	        for( int i = idx; i < size( ) - 1; i++ )
	            theItems[ i ] = theItems[ i + 1 ];
	        theSize--;    
	        
	        return removedItem;
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void clear( )
	    {
	        doClear( );
	    }
	    
	    private void doClear( )
	    {
	        theSize = 0;
	        ensureCapacity( DEFAULT_CAPACITY );
	    }
	    
	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new ArrayListIterator( );
	    }

	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	            StringBuilder sb = new StringBuilder( "[ " );

	            for( AnyType x : this )
	                sb.append( x + " " );
	            sb.append( "]" );

	            return new String( sb );
	    }
	    
	    /**
	     * This is the implementation of the ArrayListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyArrayList.
	     */
	    private class ArrayListIterator implements java.util.Iterator<AnyType>
	    {
	        private int current = 0;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current < size( );
	        }
	        
	        
	        public AnyType next( )
	        {
	            if( !hasNext( ) ) 
	                throw new java.util.NoSuchElementException( ); 
	                  
	            okToRemove = true;    
	            return theItems[ current++ ];
	        }
	        
	        public void remove( )
	        {
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            ArrayTreeB.this.remove( --current );
	            okToRemove = false;
	        }
	    }
	    
	    private static final int DEFAULT_CAPACITY = 10;
	    private static final int tamano = 10001;
	    private AnyType [ ] theItems;
	    private int theSize;
	}
	
public static class ListTreeB<AnyType> implements Iterable<AnyType>
	{
	    /**
	     * Construct an empty LinkedList.
	     */
	    public ListTreeB( )
	    {
	        doClear( );
	    }
	    
	    private void clear( )
	    {
	        doClear( );
	    }
	    
	    /**
	     * Change the size of this collection to zero.
	     */
	    public void doClear( )
	    {
	        beginMarker = new Node<>( null, null, null );
	        endMarker = new Node<>( null, beginMarker, null );
	        beginMarker.next = endMarker;
	        
	        theSize = 0;
	        modCount++;
	    }
	    
	    /**
	     * Returns the number of items in this collection.
	     * @return the number of items in this collection.
	     */
	    public int size( )
	    {
	        return theSize;
	    }
	    
	    public boolean isEmpty( )
	    {
	        return size( ) == 0;
	    }
	    
	    /**
	     * Adds an item to this collection, at the end.
	     * @param x any object.
	     * @return true.
	     */
	    public boolean add( AnyType x )
	    {
	        
	        add( size( ), x );   
	        return true;         
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position.
	     * Items at or after that position are slid one position higher.
	     * @param x any object.
	     * @param idx position to add at.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */
	    public void add( int idx, AnyType x )
	    {
	        addBefore( getNode( idx, 0, size( ) ), x );
	    }
	    
	    /**
	     * Adds an item to this collection, at specified position p.
	     * Items at or after that position are slid one position higher.
	     * @param p Node to add before.
	     * @param x any object.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size(), inclusive.
	     */    
	    private void addBefore( Node<AnyType> p, AnyType x )
	    {
	        Node<AnyType> newNode = new Node<>( x, p.prev, p );
	        newNode.prev.next = newNode;
	        p.prev = newNode;         
	        theSize++;
	        modCount++;
	    }   
	    
	    
	    /**
	     * Returns the item at position idx.
	     * @param idx the index to search in.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType get( int idx )
	    {
	        return getNode( idx ).data;
	    }
	        
	    /**
	     * Changes the item at position idx.
	     * @param idx the index to change.
	     * @param newVal the new value.
	     * @return the old value.
	     * @throws IndexOutOfBoundsException if index is out of range.
	     */
	    public AnyType set( int idx, AnyType newVal )
	    {
	        Node<AnyType> p = getNode( idx );
	        AnyType oldVal = p.data;
	        
	        p.data = newVal;   
	        return oldVal;
	    }
	    
	    /**
	     * Gets the Node at position idx, which must range from 0 to size( ) - 1.
	     * @param idx index to search at.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between 0 and size( ) - 1, inclusive.
	     */
	    private Node<AnyType> getNode( int idx )
	    {
	        return getNode( idx, 0, size( ) - 1 );
	    }

	    /**
	     * Gets the Node at position idx, which must range from lower to upper.
	     * @param idx index to search at.
	     * @param lower lowest valid index.
	     * @param upper highest valid index.
	     * @return internal node corresponding to idx.
	     * @throws IndexOutOfBoundsException if idx is not between lower and upper, inclusive.
	     */    
	    private Node<AnyType> getNode( int idx, int lower, int upper )
	    {
	        Node<AnyType> p;  
	        if( idx < lower || idx > upper )
	            throw new IndexOutOfBoundsException( "getNode index: " + idx + "; size: " + size( ) );
	        if( idx < size( ) / 2 ){
	            p = beginMarker.next;
	            for( int i = 0; i < idx; i++ )
	                p = p.next;            
	        }
	        else{
	            p = endMarker;
	            for( int i = size( ); i > idx; i-- )
	                p = p.prev;
	        }         
	        return p;
	    }
	    
	    /**
	     * Removes an item from this collection.
	     * @param idx the index of the object.
	     * @return the item was removed from the collection.
	     */
	    public AnyType remove( int idx )
	    {
	        return remove( getNode( idx ) );
	    }
	    
	    /**
	     * Removes the object contained in Node p.
	     * @param p the Node containing the object.
	     * @return the item was removed from the collection.
	     */
	    private AnyType remove( Node<AnyType> p )
	    {
	        p.next.prev = p.prev;
	        p.prev.next = p.next;
	        theSize--;
	        modCount++;
	        
	        return p.data;
	    }
	    
	    /**
	     * Returns a String representation of this collection.
	     */
	    public String toString( )
	    {
	        StringBuilder sb = new StringBuilder( "[ " );

	        for( AnyType x : this )
	            sb.append( x + " " );
	        sb.append( "]" );

	        return new String( sb );
	    }
	    
	    
	   public void enqueue(AnyType x){
		   
		   add(x);
	   }
	   
	   
	   public void pushQueue (AnyType x){
		   add(0,x);
		   
	   }
	    
	   public AnyType dequeue(){
		   
		  return remove(0);
	   } 
	   
	   public AnyType deleteLast(){
		   
		  return remove(theSize-1);
	   } 
	    
	    
	   public AnyType peek(){
		   
		  return get(0);
	   }       
	    

	    /**
	     * Obtains an Iterator object used to traverse the collection.
	     * @return an iterator positioned prior to the first element.
	     */
	    public java.util.Iterator<AnyType> iterator( )
	    {
	        return new LinkedListIterator( );
	    }

	    /**
	     * This is the implementation of the LinkedListIterator.
	     * It maintains a notion of a current position and of
	     * course the implicit reference to the MyLinkedList.
	     */
	    private class LinkedListIterator implements java.util.Iterator<AnyType>
	    {
	        private Node<AnyType> current = beginMarker.next;
	        private int expectedModCount = modCount;
	        private boolean okToRemove = false;
	        
	        public boolean hasNext( )
	        {
	            return current != endMarker;
	        }
	        
	        public AnyType next( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !hasNext( ) )
	                throw new java.util.NoSuchElementException( ); 
	                   
	            AnyType nextItem = current.data;
	            current = current.next;
	            okToRemove = true;
	            return nextItem;
	        }
	        
	        public void remove( )
	        {
	            if( modCount != expectedModCount )
	                throw new java.util.ConcurrentModificationException( );
	            if( !okToRemove )
	                throw new IllegalStateException( );
	                
	            ListTreeB.this.remove( current.prev );
	            expectedModCount++;
	            okToRemove = false;       
	        }
	    }
	    
	    /**
	     * This is the doubly-linked list node.
	     */
	    private static class Node<AnyType>
	    {
	        public Node( AnyType d, Node<AnyType> p, Node<AnyType> n )
	        {
	            data = d; prev = p; next = n;
	        }
	        
	        public AnyType data;
	        public Node<AnyType>   prev;
	        public Node<AnyType>   next;
	    }
	    
	    private int theSize;
	    private int modCount = 0;
	    private Node<AnyType> beginMarker;
	    private Node<AnyType> endMarker;
	}


	
	public static void main(String[] args){
		
		int init = 0;
		ArrayTreeB<ArrayTreeB> Tree;
		ArrayTreeB<Integer> Array;
		
		
        ListTreeB<Integer> ListTreeB;
        ListTreeB<Integer> QueueTreeB;
        
        
        Scanner cin = new Scanner (System.in);
		
		StringBuilder path = new StringBuilder();
		StringBuilder Aux;
		
		String line;
		String line_node;
	
		
		int numberCases = Integer.parseInt(cin.nextLine());
		
		for (int c=1; c<=numberCases; c++){
			
			Tree = new ArrayTreeB<>( );
			Array = new ArrayTreeB<>( );			 
			ListTreeB = new ListTreeB<>();
			QueueTreeB = new ListTreeB<>();
			 
			
			for (int i=1; i<=100001; i++){
				Tree.add(Array);
			}		

			
			int numberCommands = Integer.parseInt(cin.nextLine());	
			path.append("Caso #"+c+":" + System.lineSeparator());


				
			for (int p =1; p <= numberCommands; p++){
				
				line_node = cin.nextLine();
				
				String[] split = line_node.split(" ");
		    	int idx_array =  Integer.parseInt(split[0]); 
				int values =0;
		    	
		    	
		    	if(p==1){
		    	    init = idx_array;
		    	}
                 
		    	
			    for (int i=1; i<split.length;i++ ){
					
			    	values = Integer.parseInt(split[i]);
			    	Array.add(values);		    	
			    }
			    
		    	Tree.addinidx(idx_array, Array);
		        Array = new ArrayTreeB<>( );
		    	
			}
				
			

			int index = init;
			int values=0;
			path.append(init+" ");

			

        	for(int i= (Tree.get(index).size()-1); i>=0; i-- ){

	        		values = (int) Tree.get(index).get(i);
	        		ListTreeB.pushQueue(values);
	        		path.append(values+" ");

        		
        	}			
			
        	int counter = 1;


        	
            while(counter <= numberCommands){
            	
            	int size_Queue = ListTreeB.size();
            	
            	for(int i=0; i<size_Queue; i++){
	
            		if(ListTreeB.size()==0){
            			break;
            		}
            		
            		index = ListTreeB.dequeue();

            		for (int j=0; j<Tree.get(index).size(); j++){
            			
            			values =  (int) Tree.get(index).get(j);
            			QueueTreeB.pushQueue(values);
            			path.append(values+ " " );

            		}
            	}
            	
            	int size_Queue_Aux = QueueTreeB.size();
            	
            	for(int j=0; j<size_Queue_Aux; j++){  
	
            		if(QueueTreeB.size()==0){
            			break;
            		}
            		
	            	index = QueueTreeB.dequeue();
	            	
	            	for(int i=(Tree.get(index).size()-1); i>=0; i-- ){
	            		
	            		values = (int) (Tree.get(index).get(i));
	            		ListTreeB.pushQueue(values);
	            		path.append(values+" " );
         	           		
	            	}	
            	}
            	
            	counter++;
            }
			
			
            path.append(System.lineSeparator());
	}
System.out.println(path);
//System.out.println(path);
//System.out.println(path);
}

	
}
<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>
